<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="felix.20190922171916.2"><vh>Introduction</vh></v>
<v t="felix.20200717222352.1"><vh>@clean package.json</vh>
<v t="felix.20200717222716.1"><vh>configuration</vh>
<v t="felix.20200717223431.1"><vh>External Files Change Detection</vh></v>
<v t="felix.20200717223454.1"><vh>Interface Behavior</vh></v>
<v t="felix.20200717223513.1"><vh>Statusbar Indicator</vh></v>
<v t="felix.20200717223828.1"><vh>Interface Appearance</vh></v>
<v t="felix.20200717223852.1"><vh>Leo Bridge Options</vh></v>
</v>
<v t="felix.20200717222850.1"><vh>viewsContainers</vh></v>
<v t="felix.20200717222918.1"><vh>views</vh></v>
<v t="felix.20200717222938.1"><vh>languages</vh></v>
<v t="felix.20200717222946.1"><vh>grammars</vh></v>
<v t="felix.20200717223012.1"><vh>commands</vh>
<v t="felix.20200717224224.1"><vh>Tests</vh></v>
<v t="felix.20200717224216.1"><vh>Show Webviews</vh></v>
<v t="felix.20200717224258.1"><vh>Server</vh></v>
<v t="felix.20200717231121.1"><vh>Scripting &amp; @buttons</vh></v>
<v t="felix.20200717224519.1"><vh>Show UI Panes</vh></v>
<v t="felix.20200717224549.1"><vh>Leo File Documents</vh></v>
<v t="felix.20200717230237.1"><vh>Tree View</vh></v>
<v t="felix.20200717230331.1"><vh>Node Edition</vh></v>
<v t="felix.20200717230350.1"><vh>Move Nodes</vh></v>
<v t="felix.20200717230620.1"><vh>Outline Edition</vh></v>
<v t="felix.20200717230807.1"><vh>Goto Nodes</vh></v>
<v t="felix.20200717230820.1"><vh>Hoist/Dehoist</vh></v>
<v t="felix.20200717230830.1"><vh>Undo/Redo</vh></v>
<v t="felix.20200717231448.1"><vh>TODO</vh></v>
</v>
<v t="felix.20200717223038.1"><vh>viewsWelcome</vh>
<v t="felix.20200717232644.1"><vh>Leo Integration Panel</vh>
<v t="felix.20200717231719.1"><vh>Not Ready: [start], [connect] and settings</vh></v>
<v t="felix.20200717231753.1"><vh>Not Ready Auto Start: [connect] and settings</vh></v>
<v t="felix.20200717231742.1"><vh>Not Ready Server Started: [connect] and settings</vh></v>
<v t="felix.20200717231803.1"><vh>Not Ready: Connecting</vh></v>
<v t="felix.20200717231844.1"><vh>Ready: [open] and settings</vh></v>
</v>
<v t="felix.20200717232009.1"><vh>Leo Documents</vh>
<v t="felix.20200717233055.1"><vh>Not Ready</vh></v>
<v t="felix.20200717233118.1"><vh>Ready: Empty</vh></v>
</v>
<v t="felix.20200717232019.1"><vh>leoButtons</vh>
<v t="felix.20200717233230.1"><vh>Not Ready</vh></v>
<v t="felix.20200717233257.1"><vh>Ready: No Opened Files</vh></v>
<v t="felix.20200717233318.1"><vh>Ready: No Buttons</vh></v>
</v>
</v>
<v t="felix.20200717223100.1"><vh>menus</vh>
<v t="felix.20200718001246.1"><vh>commandPalette</vh>
<v t="felix.20200718001643.1"><vh>Server</vh></v>
<v t="felix.20200718001834.1"><vh>Scripting &amp; @buttons</vh></v>
<v t="felix.20200718001744.1"><vh>Show UI Panes</vh></v>
<v t="felix.20200718001726.1"><vh>Leo File Documents</vh></v>
<v t="felix.20200718001920.1"><vh>Tree View</vh></v>
<v t="felix.20200718001925.1"><vh>Node Edition</vh></v>
<v t="felix.20200718001929.1"><vh>Move Nodes</vh></v>
<v t="felix.20200718001935.1"><vh>Outline Edition</vh></v>
<v t="felix.20200718001940.1"><vh>Goto Nodes</vh></v>
<v t="felix.20200718001958.1"><vh>Hoist/Dehoist</vh></v>
<v t="felix.20200718002007.1"><vh>Undo/Redo</vh></v>
<v t="felix.20200718002528.1"><vh>TODO</vh></v>
<v t="felix.20200718002013.1"><vh>Hidden Commands</vh>
<v t="felix.20200718003128.1"><vh>Tests</vh></v>
<v t="felix.20200718003207.1"><vh>Show UI Panes</vh></v>
<v t="felix.20200718003215.1"><vh>Leo File Documents</vh></v>
<v t="felix.20200718003223.1"><vh>Tree View</vh></v>
<v t="felix.20200718003227.1"><vh>Node Edition</vh></v>
<v t="felix.20200718003236.1"><vh>Move Nodes</vh></v>
<v t="felix.20200718003239.1"><vh>Outline Edition</vh></v>
<v t="felix.20200718003243.1"><vh>Goto Nodes</vh></v>
<v t="felix.20200718003251.1"><vh>Hoist/Dehoist</vh></v>
<v t="felix.20200718003259.1"><vh>Undo/Redo</vh></v>
</v>
</v>
<v t="felix.20200718001311.1"><vh>explorer/context</vh></v>
<v t="felix.20200718001319.1"><vh>view/title</vh></v>
<v t="felix.20200718001334.1"><vh>view/item/context</vh></v>
</v>
<v t="felix.20200717223116.1"><vh>keybindings</vh>
<v t="felix.20200718005357.1"><vh>Scripting</vh></v>
<v t="felix.20200718005412.1"><vh>Show UI Panes</vh></v>
<v t="felix.20200718005425.1"><vh>Leo File Documents</vh></v>
<v t="felix.20200718005440.1"><vh>Tree View</vh></v>
<v t="felix.20200718005444.1"><vh>Node Edition</vh></v>
<v t="felix.20200718005448.1"><vh>Move Nodes</vh></v>
<v t="felix.20200718005453.1"><vh>Outline Edition</vh></v>
<v t="felix.20200718005458.1"><vh>Goto Nodes</vh></v>
</v>
<v t="felix.20200717223127.1"><vh>resourceLabelFormatters</vh></v>
</v>
<v t="felix.20191126232434.2"><vh>@clean leobridgeserver.py</vh>
<v t="felix.20191128002414.1"><vh>Imports</vh></v>
<v t="felix.20191128002417.1"><vh>Constants</vh></v>
<v t="felix.20200302204251.1"><vh>class IdleTimeManager</vh>
<v t="felix.20200302204251.2"><vh>itm.add_callback</vh></v>
<v t="felix.20200302204251.3"><vh>itm.on_idle</vh></v>
<v t="felix.20200302204251.4"><vh>itm.start</vh></v>
</v>
<v t="felix.20200302205810.1"><vh>class ExternalFilesController</vh>
<v t="felix.20200302205810.2"><vh>efc.ctor</vh></v>
<v t="felix.20200302205810.7"><vh>efc.on_idle</vh></v>
<v t="felix.20200302205810.8"><vh>efc.idle_check_commander</vh></v>
<v t="felix.20200302205810.9"><vh>efc.idle_check_at_file_node</vh></v>
<v t="felix.20200304221925.1"><vh>efc.integResult</vh></v>
<v t="felix.20200302205810.21"><vh>efc.utilities</vh>
<v t="felix.20200302205810.22"><vh>efc.ask</vh></v>
<v t="felix.20200302205810.23"><vh>efc.checksum</vh></v>
<v t="felix.20200302205810.25"><vh>efc.get_mtime</vh></v>
<v t="felix.20200302205810.26"><vh>efc.get_time</vh></v>
<v t="felix.20200302205810.27"><vh>efc.has_changed</vh></v>
<v t="felix.20200302205810.28"><vh>efc.is_enabled</vh></v>
<v t="felix.20200302205810.29"><vh>efc.join</vh></v>
<v t="felix.20200302205810.30"><vh>efc.set_time</vh></v>
<v t="felix.20200302205810.31"><vh>efc.warn</vh></v>
</v>
<v t="felix.20200308145948.1"><vh>other called methods</vh>
<v t="felix.20200308150856.1"><vh>open_with</vh></v>
<v t="felix.20200308150848.1"><vh>check_overwrite</vh></v>
<v t="felix.20200308150821.1"><vh>shut_down</vh></v>
<v t="felix.20200308150842.1"><vh>destroy_frame</vh></v>
</v>
</v>
<v t="felix.20191126232434.4"><vh>class LeoBridgeIntegController</vh>
<v t="felix.20191126232434.5"><vh>__init__</vh></v>
<v t="felix.20200303214235.1"><vh>_asyncIdleLoop</vh></v>
<v t="felix.20200626012709.1"><vh>_returnNo</vh></v>
<v t="felix.20200626030820.1"><vh>_returnYes</vh></v>
<v t="felix.20200303214255.1"><vh>_idleTime</vh></v>
<v t="felix.20200623201853.1"><vh>_getTotalOpened</vh></v>
<v t="felix.20200623215904.1"><vh>_getFirstOpenedCommander</vh></v>
<v t="felix.20200304224909.1"><vh>sendAsyncOutput</vh></v>
<v t="felix.20200304220844.1"><vh>askResult</vh></v>
<v t="felix.20200312231358.1"><vh>applyConfig</vh></v>
<v t="felix.20200219224515.1"><vh>logSignon</vh></v>
<v t="felix.20200219222712.1"><vh>es</vh></v>
<v t="felix.20200211202929.1"><vh>initConnection</vh></v>
<v t="felix.20200622230608.1"><vh>getOpenedFiles</vh></v>
<v t="felix.20200624172552.1"><vh>setOpenedFile</vh></v>
<v t="felix.20191126232434.13"><vh>openFile</vh></v>
<v t="felix.20191126232434.14"><vh>closeFile</vh></v>
<v t="felix.20200216160305.1"><vh>saveFile</vh></v>
<v t="felix.20200619165641.1"><vh>getStates</vh></v>
<v t="felix.20200710014747.1"><vh>getButtons</vh></v>
<v t="felix.20200710030614.1"><vh>clickButton</vh></v>
<v t="felix.20200711182907.1"><vh>removeButton</vh></v>
<v t="felix.20191128003151.1"><vh>JSON Output Functions</vh>
<v t="felix.20191128004456.1"><vh>setActionId</vh></v>
<v t="felix.20200213195413.1"><vh>asyncOutput</vh></v>
<v t="felix.20191126232434.7"><vh>sendLeoBridgePackage</vh></v>
<v t="felix.20191126232434.8"><vh>outputError</vh></v>
<v t="felix.20191126232434.9"><vh>outputBodyData</vh></v>
<v t="felix.20191126232434.10"><vh>outputPNode</vh></v>
<v t="felix.20191126232434.11"><vh>outputPNodes</vh></v>
</v>
<v t="felix.20200705193918.1"><vh>Outline Goto Commands</vh>
<v t="felix.20200705193927.1"><vh>pageUp</vh></v>
<v t="felix.20200711210205.1"><vh>pageDown</vh></v>
<v t="felix.20200711210205.2"><vh>gotoFirstVisible</vh></v>
<v t="felix.20200705233325.1"><vh>gotoLastVisible</vh></v>
<v t="felix.20200705201100.1"><vh>gotoLastSibling</vh></v>
<v t="felix.20200705223536.1"><vh>gotoNextVisible</vh></v>
<v t="felix.20200705223541.1"><vh>gotoPrevVisible</vh></v>
<v t="felix.20200706030410.1"><vh>gotoNextMarked</vh></v>
<v t="felix.20200706202247.1"><vh>gotoNextClone</vh></v>
<v t="felix.20200705223430.1"><vh>contractOrGoLeft</vh></v>
<v t="felix.20200705223521.1"><vh>expandAndGoRight</vh></v>
</v>
<v t="felix.20191128000818.1"><vh>Outline Editing Commands</vh>
<v t="felix.20191127004621.1"><vh>markPNode</vh></v>
<v t="felix.20191127235913.1"><vh>unmarkPNode</vh></v>
<v t="felix.20191231203545.1"><vh>clonePNode</vh></v>
<v t="felix.20191127004619.1"><vh>copyPNode</vh></v>
<v t="felix.20191127004620.1"><vh>cutPNode</vh></v>
<v t="felix.20191130211048.1"><vh>pastePNode</vh></v>
<v t="felix.20191130211048.2"><vh>pasteAsClonePNode</vh></v>
<v t="felix.20191127002548.1"><vh>deletePNode</vh></v>
<v t="felix.20191127000344.1"><vh>movePNodeDown</vh></v>
<v t="felix.20191127000419.1"><vh>movePNodeLeft</vh></v>
<v t="felix.20191127000420.1"><vh>movePNodeRight</vh></v>
<v t="felix.20191127000420.2"><vh>movePNodeUp</vh></v>
<v t="felix.20191127001506.1"><vh>insertPNode</vh></v>
<v t="felix.20200120224033.1"><vh>insertNamedPNode</vh></v>
<v t="felix.20191127001506.2"><vh>promotePNode</vh></v>
<v t="felix.20191127001506.3"><vh>demotePNode</vh></v>
<v t="felix.20191231184412.1"><vh>sortChildrenPNode</vh></v>
<v t="felix.20191231184412.2"><vh>sortSiblingsPNode</vh></v>
<v t="felix.20191231201748.1"><vh>hoistPNode</vh></v>
<v t="felix.20191231201749.1"><vh>deHoist</vh></v>
</v>
<v t="felix.20191128001054.1"><vh>Outline and Body Interaction</vh>
<v t="felix.20200105173826.1"><vh>outlineCommand</vh></v>
<v t="felix.20191231203711.1"><vh>undo</vh></v>
<v t="felix.20200103204811.1"><vh>redo</vh></v>
<v t="felix.20200301235235.1"><vh>refreshFromDiskPNode</vh></v>
<v t="felix.20191231214801.1"><vh>executeScript</vh></v>
<v t="felix.20191126232434.15"><vh>getPNode</vh></v>
<v t="felix.20191126232434.16"><vh>getChildren</vh></v>
<v t="felix.20191126232434.17"><vh>getParent</vh></v>
<v t="felix.20191126232434.18"><vh>getSelectedNode</vh></v>
<v t="felix.20191201194046.1"><vh>getAllGnx</vh></v>
<v t="felix.20191126232434.19"><vh>getBody</vh></v>
<v t="felix.20191126232434.20"><vh>getBodyLength</vh></v>
<v t="felix.20191126232434.21"><vh>setNewBody</vh></v>
<v t="felix.20191126232434.22"><vh>setBody</vh></v>
<v t="felix.20191126232434.23"><vh>setNewHeadline</vh></v>
<v t="felix.20191126232434.24"><vh>setSelectedNode</vh></v>
<v t="felix.20191126232434.25"><vh>expandNode</vh></v>
<v t="felix.20191126232434.26"><vh>collapseNode</vh></v>
<v t="felix.20200329000454.1"><vh>contractAll</vh></v>
<v t="felix.20191126232434.29"><vh>yieldAllRootChildren</vh></v>
<v t="felix.20191216195906.1"><vh>findPNodeFromGnx</vh></v>
</v>
<v t="felix.20191128003648.1"><vh>leoFlexx Conversion Functions</vh>
<v t="felix.20191126232434.27"><vh>create_gnx_to_vnode</vh></v>
<v t="felix.20191126232434.28"><vh>test_round_trip_positions</vh></v>
<v t="felix.20191126232434.30"><vh>ap_to_p</vh></v>
<v t="felix.20191126232434.31"><vh>p_to_ap</vh></v>
</v>
</v>
<v t="felix.20191126232435.1"><vh>main</vh></v>
</v>
<v t="felix.20200718024635.1"><vh>@clean src/commandStack.ts</vh>
<v t="felix.20200718024635.2"><vh>class CommandStack</vh>
<v t="felix.20200718024635.3"><vh>CommandStack.size</vh></v>
<v t="felix.20200718024635.4"><vh>CommandStack.newSelection</vh></v>
<v t="felix.20200718024635.5"><vh>CommandStack.add</vh></v>
<v t="felix.20200718024635.6"><vh>CommandStack._tryStart</vh></v>
<v t="felix.20200718024635.7"><vh>CommandStack._runStackCommand</vh></v>
<v t="felix.20200718024635.8"><vh>CommandStack._resolveResult</vh></v>
</v>
</v>
<v t="felix.20200718030926.1"><vh>@clean src/config.ts</vh>
<v t="felix.20200718030926.2"><vh>class Config</vh>
<v t="felix.20200718030926.3"><vh>Config.getConfig</vh></v>
<v t="felix.20200718030926.4"><vh>Config.setLeoIntegSettings</vh></v>
<v t="felix.20200718030926.5"><vh>Config.buildFromSavedSettings</vh></v>
</v>
</v>
<v t="felix.20200718020912.1"><vh>@clean src/constants.ts</vh>
<v t="felix.20200718020912.2"><vh>class Constants</vh>
<v t="felix.20200718020912.3"><vh>general constants</vh></v>
<v t="felix.20200718020912.4"><vh>language id's</vh></v>
<v t="felix.20200718020912.5"><vh>workbench interface panels</vh></v>
<v t="felix.20200718020912.6"><vh>user messages</vh></v>
<v t="felix.20200718020912.7"><vh>ask/save buttons</vh></v>
<v t="felix.20200718020912.8"><vh>configuration keys</vh></v>
<v t="felix.20200718020912.9"><vh>context flags</vh></v>
<v t="felix.20200718020912.14"><vh>vscode executeCommand strings</vh></v>
<v t="felix.20200718020912.10"><vh>async actions</vh></v>
<v t="felix.20200718020912.11"><vh>async info messages codes</vh></v>
<v t="felix.20200718020912.12"><vh>async ask return codes</vh></v>
<v t="felix.20200718020912.13"><vh>leoBridge action strings</vh></v>
<v t="felix.20200718020912.15"><vh>commands strings</vh></v>
</v>
</v>
<v t="felix.20200718031424.1"><vh>@clean src/extension.ts</vh>
<v t="felix.20200718031424.2"><vh>activate</vh>
<v t="felix.20200718031424.3"><vh>&lt;&lt; define constants &gt;&gt;</vh></v>
<v t="felix.20200718031424.4"><vh> not implemented commands</vh></v>
<v t="felix.20200718031424.5"><vh>button commands</vh></v>
<v t="felix.20200718031424.6"><vh>file commands</vh></v>
<v t="felix.20200718031424.7"><vh>edit headline commands</vh></v>
<v t="felix.20200718031424.8"><vh>node commands...</vh>
<v t="felix.20200718031424.9"><vh>cut/copy/paste commands</vh></v>
<v t="felix.20200718031424.10"><vh>expand/contract commands</vh></v>
<v t="felix.20200718031424.11"><vh>git-diff (new, activate)</vh></v>
<v t="felix.20200718031424.12"><vh>goto commands</vh></v>
<v t="felix.20200718031424.13"><vh>hoist/dehoist commands</vh></v>
<v t="felix.20200718031424.14"><vh>insert/clone commands</vh></v>
<v t="felix.20200718031424.15"><vh>mark/unmark commands</vh></v>
<v t="felix.20200718031424.16"><vh>move commands</vh></v>
<v t="felix.20200718031424.17"><vh>page up/down commands</vh></v>
<v t="felix.20200718031424.18"><vh>promote/demote commands</vh></v>
<v t="felix.20200718031424.19"><vh>sort commands</vh></v>
<v t="felix.20200718031424.20"><vh>undo/redo commands</vh></v>
</v>
<v t="felix.20200718031424.21"><vh>server commands</vh></v>
<v t="felix.20200718031424.22"><vh>select/show commands</vh></v>
<v t="felix.20200718031424.23"><vh>&lt;&lt; show welcome screen &gt;&gt;</vh></v>
</v>
<v t="felix.20200718031424.24"><vh>deactivate</vh></v>
<v t="felix.20200718031424.25"><vh>showWelcomeIfNewer</vh></v>
<v t="felix.20200718031424.26"><vh>getDurationMilliseconds</vh></v>
</v>
<v t="felix.20200718035737.1"><vh>@clean src/leoAsync.ts</vh>
<v t="felix.20200718035737.2"><vh>class LeoAsync</vh>
<v t="felix.20200718035737.3"><vh>LeoAsync.log</vh></v>
<v t="felix.20200718035737.4"><vh>LeoAsync.showSaveAsDialog</vh></v>
<v t="felix.20200718035737.5"><vh>LeoAsync.showAskModalDialog</vh></v>
<v t="felix.20200718035737.6"><vh>LeoAsync.showWarnModalMessage</vh></v>
<v t="felix.20200718035737.7"><vh>LeoAsync.showChangesDetectedInfoMessage</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="felix.20190922171916.2">@doc

This Leo file contains all of the source for the Visual Studio Code 'Leo Integration' Extension

To contribute, see the official issues page for current list of 'TODO's at https://github.com/boltex/leointeg/issues

Coding Standards
================

All non-trivial structure types should be defined in the types.d.ts file. Any other symbol should have its type properly defined at declaration.

Avoid hardcoded data in code. Immutable constants and objects structures should be in the constants.ts source file.

Generic, re-usable utility functions are kept in the utils.ts source file.



Symbols Decorators prefixes
---------------------------

w_symbol : A 'work' variable, to work with.

p_symbol : This was passed as parameter into the scope you're in.

i_symbol : This in index for a loop or an iteration of some kind.

UPPERCASE : An immutable constant from the constants.ts source file.


</t>
<t tx="felix.20191126232434.10">def outputPNode(self, p_node=False):
    if p_node:
        return self.sendLeoBridgePackage("node", self.p_to_ap(p_node))  # Single node, singular
    else:
        return self.sendLeoBridgePackage("node", None)

</t>
<t tx="felix.20191126232434.11">def outputPNodes(self, p_pList):
    w_apList = []
    for p in p_pList:
        w_apList.append(self.p_to_ap(p))
    return self.sendLeoBridgePackage("nodes", w_apList)  # Multiple nodes, plural

</t>
<t tx="felix.20191126232434.13">def openFile(self, p_file):
    """
    Open a leo file via leoBridge controller, or create a new document if empty string.
    Returns an object that contains a 'opened' member.
    """
    w_found = False

    # If not empty string (asking for New file) then check if already opened
    if p_file:
        for w_commander in self.g.app.commanders():
            if w_commander.fileName() == p_file:
                w_found = True
                self.commander = w_commander

    if not w_found:
        self.commander = self.bridge.openLeoFile(p_file)  # create self.commander

    # Leo at this point has done this too: g.app.windowList.append(c.frame)
    # and so this now app.commanders() yields this: return [f.c for f in g.app.windowList]

    # did this add to existing array of g.app.commanders() ?
    # print(*self.g.app.commanders(), sep='\n')

    if self.commander:
        self.commander.closed = False
        self.create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self.p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage("opened", w_result)
    else:
        return self.outputError('Error in openFile')

</t>
<t tx="felix.20191126232434.14">def closeFile(self, p_package):
    """
    Closes a leo file. A file can then be opened with "openFile"
    Returns an object that contains a 'closed' member
    """
    # TODO : Specify which file to support multiple opened files
    if self.commander:
        if p_package["forced"] and self.commander.changed:
            # return "no" g.app.gui.runAskYesNoDialog  and g.app.gui.runAskYesNoCancelDialog
            self.commander.revert()
        if p_package["forced"] or not self.commander.changed:
            self.commander.closed = True
            self.commander.close()
        else:
            return self.sendLeoBridgePackage('closed', False)  # Cannot close, ask to save, ignore or cancel

    # Switch commanders to first available
    w_total = self._getTotalOpened()
    if w_total:
        self.commander = self._getFirstOpenedCommander()
    else:
        self.commander = None

    if self.commander:
        self.create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self.p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage("closed", w_result)
    else:
        w_result = {"total": 0}
        return self.sendLeoBridgePackage("closed", w_result)

</t>
<t tx="felix.20191126232434.15">def getPNode(self, p_ap):
    '''EMIT OUT a node, don't select it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            return self.outputPNode(w_p)
        else:
            return self.outputError("Error in getPNode no w_p node found")
    else:
        return self.outputError("Error in getPNode no param p_ap")

</t>
<t tx="felix.20191126232434.16">def getChildren(self, p_ap):
    '''EMIT OUT list of children of a node'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p and w_p.hasChildren():
            return self.outputPNodes(w_p.children())
        else:
            return self.outputPNodes([])  # default empty array
    else:
        if self.commander.hoistStack:
            return self.outputPNodes([self.commander.hoistStack[-1].p])
        else:
            return self.outputPNodes(self.yieldAllRootChildren())  # this outputs all Root Children

</t>
<t tx="felix.20191126232434.17">def getParent(self, p_ap):
    '''EMIT OUT the parent of a node, as an array, even if unique or empty'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p and w_p.hasParent():
            return self.outputPNode(w_p.getParent())
        else:
            return self.outputPNode()  # default empty for root
    else:
        return self.outputPNode()

</t>
<t tx="felix.20191126232434.18">def getSelectedNode(self, p_paramUnused):
    '''EMIT OUT Selected Position as an array, even if unique'''
    if self.commander.p:
        return self.outputPNode(self.commander.p)
    else:
        return self.outputPNode()

</t>
<t tx="felix.20191126232434.19">def getBody(self, p_gnx):
    '''EMIT OUT body of a node'''
    if p_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(p_gnx)  # vitalije
        if w_v:
            if w_v.b:
                return self.outputBodyData(w_v.b)
            else:
                return self.outputBodyData()  # default "" empty string
        else:
            return self.sendLeoBridgePackage()  # empty as inexistent
    else:
        return self.sendLeoBridgePackage()  # empty as inexistent

</t>
<t tx="felix.20191126232434.2">#! python3
@language python
@tabwidth -4
@others
if __name__ == '__main__':
    # Startup
    try:
        main()
    except KeyboardInterrupt:
        print("\nKeyboard Interupt: Stopping leobridge server", flush=True)
        sys.exit()
</t>
<t tx="felix.20191126232434.20">def getBodyLength(self, p_gnx):
    '''EMIT OUT body string length of a node'''
    if p_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(p_gnx)  # vitalije
        if w_v and len(w_v.b):
            return self.sendLeoBridgePackage("bodyLength", len(w_v.b))
        else:
            return self.sendLeoBridgePackage("bodyLength", 0)
    else:
        # TODO : May need to signal inexistent by self.sendLeoBridgePackage()  # empty as inexistent
        return self.sendLeoBridgePackage("bodyLength", 0)

</t>
<t tx="felix.20191126232434.21">def setNewBody(self, p_body):
    '''Change Body of selected node'''
    # TODO : This method is unused for now? Remove if unnecessary.
    # TODO : Does this support 'Undo'?
    if self.commander.p:
        self.commander.p.b = p_body['body']
        return self.outputPNode(self.commander.p)
    else:
        return self.outputError("Error in setNewBody")

</t>
<t tx="felix.20191126232434.22">def setBody(self, p_package):
    '''Change Body text of a node'''
    for w_p in self.commander.all_positions():
        if w_p.v.gnx == p_package['gnx']:  # found
            # TODO : Before setting undo and trying to set body, first check if different than existing body
            w_bunch = self.commander.undoer.beforeChangeNodeContents(w_p)  # setup undoable operation
            w_p.v.setBodyString(p_package['body'])
            self.commander.undoer.afterChangeNodeContents(w_p, "Body Text", w_bunch)
            if not self.commander.isChanged():
                self.commander.setChanged()
            if not w_p.v.isDirty():
                w_p.setDirty()
            break
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.23">def setNewHeadline(self, p_package):
    '''Change Headline of a node'''
    w_newHeadline = p_package['text']
    w_ap = p_package['node']
    if w_ap:
        w_p = self.ap_to_p(w_ap)
        if w_p:
            # set this node's new headline
            w_bunch = self.commander.undoer.beforeChangeNodeContents(w_p)
            w_p.h = w_newHeadline
            self.commander.undoer.afterChangeNodeContents(w_p, 'Change Headline', w_bunch)
            return self.outputPNode(w_p)
    else:
        return self.outputError("Error in setNewHeadline")

</t>
<t tx="felix.20191126232434.24">def setSelectedNode(self, p_ap):
    '''Select a node, or the first one found with its GNX'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            if self.commander.positionExists(w_p):
                # set this node as selection
                self.commander.selectPosition(w_p)
            else:
                w_foundPNode = self.findPNodeFromGnx(p_ap['gnx'])
                if w_foundPNode:
                    self.commander.selectPosition(w_foundPNode)
                else:
                    print("Set Selection node does not exist! ap was:" + json.dumps(p_ap))
    # * return the finally selected node
    if self.commander.p:
        return self.outputPNode(self.commander.p)
    else:
        return self.outputPNode()

</t>
<t tx="felix.20191126232434.25">def expandNode(self, p_ap):
    '''Expand a node'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_p.expand()
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.26">def collapseNode(self, p_ap):
    '''Collapse a node'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_p.contract()
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.27">def create_gnx_to_vnode(self):
    '''Make the first gnx_to_vnode array with all unique nodes'''
    t1 = time.process_time()
    self.gnx_to_vnode = {v.gnx: v for v in self.commander.all_unique_nodes()}
    # This is likely the only data that ever will be needed.
    if 0:
        print('app.create_all_data: %5.3f sec. %s entries' % (
            (time.process_time()-t1), len(list(self.gnx_to_vnode.keys()))))
    self.test_round_trip_positions()

</t>
<t tx="felix.20191126232434.28">def test_round_trip_positions(self):
    '''(From Leo plugin leoflexx.py) Test the round tripping of p_to_ap and ap_to_p.'''
    # Bug fix: p_to_ap updates app.gnx_to_vnode. Save and restore it.
    old_d = self.gnx_to_vnode.copy()
    old_len = len(list(self.gnx_to_vnode.keys()))
    t1 = time.process_time()
    qtyAllPositions = 0
    for p in self.commander.all_positions():
        qtyAllPositions += 1
        ap = self.p_to_ap(p)
        p2 = self.ap_to_p(ap)
        assert p == p2, (repr(p), repr(p2), repr(ap))
    gnx_to_vnode = old_d
    new_len = len(list(gnx_to_vnode.keys()))
    assert old_len == new_len, (old_len, new_len)
    print('Leo file opened. Its outline contains ' + str(qtyAllPositions) + " nodes positions.")
    print(('Testing app.test_round_trip_positions for all nodes: Total time: %5.3f sec.' % (time.process_time()-t1)))

</t>
<t tx="felix.20191126232434.29">def yieldAllRootChildren(self):
    '''Return all root children P nodes'''
    p = self.commander.rootPosition()
    while p:
        yield p
        p.moveToNext()

</t>
<t tx="felix.20191126232434.30">def ap_to_p(self, ap):
    '''(From Leo plugin leoflexx.py) Convert an archived position to a true Leo position.'''
    childIndex = ap['childIndex']
    v = self.gnx_to_vnode[ap['gnx']]
    stack = [
        (self.gnx_to_vnode[d['gnx']], d['childIndex'])
        for d in ap['stack']
    ]
    return leoNodes.position(v, childIndex, stack)

</t>
<t tx="felix.20191126232434.31">def p_to_ap(self, p):
    '''(From Leo plugin leoflexx.py) Converts Leo position to a serializable archived position.'''
    if not p.v:
        print('app.p_to_ap: no p.v: %r %s' % (p))
        assert False
    p_gnx = p.v.gnx
    if p_gnx not in self.gnx_to_vnode:
        self.gnx_to_vnode[p_gnx] = p.v
    # * necessary properties for outline
    w_ap = {
        'childIndex': p._childIndex,
        'gnx': p.v.gnx,
        'level': p.level(),
        'headline': p.h,
        'stack': [{
            'gnx': stack_v.gnx,
            'childIndex': stack_childIndex,
            'headline': stack_v.h,
        } for (stack_v, stack_childIndex) in p.stack],
    }
    # TODO : Convert all those booleans into an 8 bit integer 'status' flag
    if p.v.u:
        w_ap['u'] = p.v.u
    if bool(p.b):
        w_ap['hasBody'] = True
    if p.hasChildren():
        w_ap['hasChildren'] = True
    if p.isCloned():
        w_ap['cloned'] = True
    if p.isDirty():
        w_ap['dirty'] = True
    if p.isExpanded():
        w_ap['expanded'] = True
    if p.isMarked():
        w_ap['marked'] = True
    if p.isAnyAtFileNode():
        w_ap['atFile'] = True
    if p == self.commander.p:
        w_ap['selected'] = True
    return w_ap


</t>
<t tx="felix.20191126232434.4">class LeoBridgeIntegController:
    '''Leo Bridge Controller'''

    @others
</t>
<t tx="felix.20191126232434.5">def __init__(self):
    # TODO : @boltex #74 need gnx_to_vnode for each opened file/commander
    self.gnx_to_vnode = []  # utility array - see leoflexx.py in leoPluginsRef.leo
    self.bridge = leoBridge.controller(gui='nullGui',
                                       loadPlugins=True,  # True: attempt to load plugins.
                                       readSettings=True,  # True: read standard settings files.
                                       silent=True,      # True: don't print signon messages.
                                       verbose=False)     # True: prints messages that would be sent to the log pane.
    self.g = self.bridge.globals()

    # * Trace outputs to pythons stdout, also prints the function call stack
    # self.g.trace('test trace')

    # * Intercept Log Pane output: Sends to vsCode's log pane
    self.g.es = self.es  # pointer - not a function call

    # print(dir(self.g))
    self.currentActionId = 1  # Id of action being processed, STARTS AT 1 = Initial 'ready'

    # * Currently Selected Commander (opened from leo.core.leoBridge or chosen via the g.app.windowList frame list)
    self.commander = None

    self.leoIntegConfig = None
    self.webSocket = None
    self.loop = None

    # * Replacement instances to Leo's codebase : IdleTime, idleTimeManager and externalFilesController
    self.g.IdleTime = self._idleTime
    self.g.app.idleTimeManager = IdleTimeManager(self.g)
    # attach instance to g.app for calls to set_time, etc.
    self.g.app.externalFilesController = ExternalFilesController(self)
    # TODO : Maybe use those yes/no replacement right before actual usage instead of in init. (to allow re-use/switching)
    self.g.app.gui.runAskYesNoDialog = self._returnYes  # override for "revert to file" operation

    # * setup leoBackground to get messages from leo
    try:
        self.g.app.idleTimeManager.start()  # To catch derived file changes
    except:
        print('ERROR with idleTimeManager')

</t>
<t tx="felix.20191126232434.7">def sendLeoBridgePackage(self, p_key=False, p_any=None):
    w_package = {"id": self.currentActionId}
    if p_key:
        w_package[p_key] = p_any  # add [key]?:any
    return(json.dumps(w_package, separators=(',', ':')))  # send as json
    # await self.webSocket.send(json.dumps(w_package, separators=(',', ':')))  # send as json

</t>
<t tx="felix.20191126232434.8">def outputError(self, p_message="Unknown Error"):
    print("ERROR: " + p_message)  # Output to this server's running console
    w_package = {"id": self.currentActionId}
    w_package["error"] = p_message
    return p_message

</t>
<t tx="felix.20191126232434.9">def outputBodyData(self, p_bodyText=""):
    return self.sendLeoBridgePackage("bodyData", p_bodyText)

</t>
<t tx="felix.20191126232435.1">def main():
    '''python script for leo integration via leoBridge'''
    global wsHost, wsPort
    print("Starting LeoBridge... (Launch with -h for help)", flush=True)
    # replace default host address and port if provided as arguments

    try:
        opts, args = getopt.getopt(sys.argv[1:], "ha:p:", ["help", "address=", "port="])
    except getopt.GetoptError:
        print('leobridgeserver.py -a &lt;address&gt; -p &lt;port&gt;')
        print('defaults to localhost on port 32125', flush=True)
        if args:
            print("unused args: " + str(args), flush=True)
        sys.exit(2)
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            print('leobridgeserver.py -a &lt;address&gt; -p &lt;port&gt;')
            print('defaults to localhost on port 32125', flush=True)
            sys.exit()
        elif opt in ("-a", "--address"):
            wsHost = arg
        elif opt in ("-p", "--port"):
            wsPort = arg

    # * start Server
    integController = LeoBridgeIntegController()

    # * This is a basic example loop
    # async def asyncInterval(timeout):
    #     dummyCounter = 0
    #     strTimeout = str(timeout) + ' sec interval'
    #     while True:
    #         await asyncio.sleep(timeout)
    #         dummyCounter = dummyCounter+1
    #         await integController.asyncOutput("{\"interval\":" + str(timeout+dummyCounter) + "}")  # as number
    #         print(strTimeout)

    async def leoBridgeServer(websocket, path):
        try:
            integController.initConnection(websocket)
            await websocket.send(integController.sendLeoBridgePackage())  # * Start by sending empty as 'ok'
            integController.logSignon()
            async for w_message in websocket:
                w_param = json.loads(w_message)
                if w_param and w_param['action']:
                    # print("action:" + w_param['action'])
                    # * Storing id of action in global var instead of passing as parameter
                    integController.setActionId(w_param['id'])
                    # ! functions called this way need to accept at least a parameter other than 'self'
                    # ! See : getSelectedNode and getAllGnx
                    # TODO : Block attempts to call functions starting with underscore or reserved
                    answer = getattr(integController, w_param['action'])(w_param['param'])  # Crux
                else:
                    answer = "Error in processCommand"
                    print(answer, flush=True)
                await websocket.send(answer)
        except:
            print("Caught Websocket Disconnect Event", flush=True)
        finally:
            asyncio.get_event_loop().stop()

    localLoop = asyncio.get_event_loop()
    start_server = websockets.serve(leoBridgeServer, wsHost, wsPort)
    # localLoop.create_task(asyncInterval(5)) # Starts a test loop of async communication
    localLoop.run_until_complete(start_server)
    print("LeoBridge started at " + wsHost + " on port: " + str(wsPort) + " [ctrl+c] to break", flush=True)
    localLoop.run_forever()
    print("Stopping leobridge server", flush=True)


</t>
<t tx="felix.20191127000344.1">def movePNodeDown(self, p_ap):
    '''Move a node DOWN, don't select it if possible'''
    return self.outlineCommand("moveOutlineDown", p_ap, True)

</t>
<t tx="felix.20191127000419.1">def movePNodeLeft(self, p_ap):
    '''Move a node LEFT, don't select it if possible'''
    return self.outlineCommand("moveOutlineLeft", p_ap, True)

</t>
<t tx="felix.20191127000420.1">def movePNodeRight(self, p_ap):
    '''Move a node RIGHT, don't select it if possible'''
    return self.outlineCommand("moveOutlineRight", p_ap, True)

</t>
<t tx="felix.20191127000420.2">def movePNodeUp(self, p_ap):
    '''Move a node UP, don't select it if possible'''
    return self.outlineCommand("moveOutlineUp", p_ap, True)

</t>
<t tx="felix.20191127001506.1">def insertPNode(self, p_ap):
    '''Insert a node at given node, then select it once created, and finally return it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_bunch = self.commander.undoer.beforeInsertNode(w_p)
            w_newNode = w_p.insertAfter()
            w_newNode.setDirty()
            self.commander.undoer.afterInsertNode(w_newNode, 'Insert Node', w_bunch)
            self.commander.selectPosition(w_newNode)
            return self.outputPNode(self.commander.p)  # in both cases, return selected node
        else:
            return self.outputError("Error in insertPNode no w_p node found")  # default empty
    else:
        return self.outputError("Error in insertPNode no param p_ap")

</t>
<t tx="felix.20191127001506.2">def promotePNode(self, p_ap):
    '''Promote a node, don't select it if possible'''
    return self.outlineCommand("promote", p_ap, True)

</t>
<t tx="felix.20191127001506.3">def demotePNode(self, p_ap):
    '''Demote a node, don't select it if possible'''
    return self.outlineCommand("demote", p_ap, True)

</t>
<t tx="felix.20191127002548.1">def deletePNode(self, p_ap):
    '''Delete a node, don't select it. Try to keep selection, then return the selected node that remains'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            if w_p == self.commander.p:
                self.commander.deleteOutline()  # already on this node, so delete it
            else:
                oldPosition = self.commander.p  # not same node, save position to possibly return to
                self.commander.selectPosition(w_p)
                self.commander.deleteOutline()
                if self.commander.positionExists(oldPosition):
                    self.commander.selectPosition(oldPosition)  # select if old position still valid
                else:
                    oldPosition._childIndex = oldPosition._childIndex-1
                    # Try again with childIndex
                    if self.commander.positionExists(oldPosition):
                        self.commander.selectPosition(oldPosition)  # additional try with lowered childIndex
            return self.outputPNode(self.commander.p)  # in both cases, return selected node
        else:
            return self.outputError("Error in deletePNode no w_p node found")  # default empty
    else:
        return self.outputError("Error in deletePNode no param p_ap")

</t>
<t tx="felix.20191127004619.1">def copyPNode(self, p_ap):
    '''Copy a node, don't select it'''
    return self.outlineCommand("copyOutline", p_ap, True)

</t>
<t tx="felix.20191127004620.1">def cutPNode(self, p_ap):
    '''Cut a node, don't select it'''
    return self.outlineCommand("cutOutline", p_ap, True)

</t>
<t tx="felix.20191127004621.1">def markPNode(self, p_ap):
    '''Mark a node, don't select it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_p.setMarked()
            return self.outputPNode(self.commander.p)  # return selected node when done (not w_p)
        else:
            return self.outputError("Error in markPNode no w_p node found")
    else:
        return self.outputError("Error in markPNode no param p_ap")

</t>
<t tx="felix.20191127235913.1">def unmarkPNode(self, p_ap):
    '''Unmark a node, don't select it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_p.clearMarked()
            return self.outputPNode(self.commander.p)  # return selected node when done (not w_p)
        else:
            return self.outputError("Error in unmarkPNode no w_p node found")
    else:
        return self.outputError("Error in unmarkPNode no param p_ap")

</t>
<t tx="felix.20191128000818.1"></t>
<t tx="felix.20191128001054.1"></t>
<t tx="felix.20191128002414.1">import leo.core.leoBridge as leoBridge
import leo.core.leoNodes as leoNodes
import asyncio
import websockets
import sys
import getopt
import time
import json

</t>
<t tx="felix.20191128002417.1"># server defaults
wsHost = "localhost"
wsPort = 32125


</t>
<t tx="felix.20191128003151.1"></t>
<t tx="felix.20191128003648.1"></t>
<t tx="felix.20191128004456.1">def setActionId(self, p_id):
    self.currentActionId = p_id

</t>
<t tx="felix.20191130211048.1">def pastePNode(self, p_ap):
    '''Paste a node, don't select it if possible'''
    return self.outlineCommand("pasteOutline", p_ap, True)

</t>
<t tx="felix.20191130211048.2">def pasteAsClonePNode(self, p_ap):
    '''Paste as clone, don't select it if possible'''
    return self.outlineCommand("pasteOutlineRetainingClones", p_ap, True)

</t>
<t tx="felix.20191201194046.1">def getAllGnx(self, p_paramUnused):
    '''Get gnx array from all unique nodes'''
    w_all_gnx = [p.v.gnx for p in self.commander.all_unique_positions(copy=False)]
    return self.sendLeoBridgePackage("allGnx", w_all_gnx)

</t>
<t tx="felix.20191216195906.1">def findPNodeFromGnx(self, p_gnx):
    '''Return first p node with this gnx or false'''
    for p in self.commander.all_unique_positions():
        if p.v.gnx == p_gnx:
            return p
    return False

</t>
<t tx="felix.20191231184412.1">def sortChildrenPNode(self, p_ap):
    '''Sort children of a node, don't select it if possible'''
    return self.outlineCommand("sortChildren", p_ap, True)

</t>
<t tx="felix.20191231184412.2">def sortSiblingsPNode(self, p_ap):
    '''Sort siblings of a node, don't select it if possible'''
    return self.outlineCommand("sortSiblings", p_ap, True)

</t>
<t tx="felix.20191231201748.1">def hoistPNode(self, p_ap):
    '''Select and Hoist a node'''
    return self.outlineCommand("hoist", p_ap)  # Don't try to re-select node

</t>
<t tx="felix.20191231201749.1">def deHoist(self, p_paramUnused):
    '''De-Hoist'''
    self.commander.dehoist()
    return self.outputPNode(self.commander.p)  # in any case, return selected node

</t>
<t tx="felix.20191231203545.1">def clonePNode(self, p_ap):
    '''Clone a node, return it if it was also the current selection, otherwise try not to select it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            if w_p == self.commander.p:
                return self.outlineCommand("clone", p_ap, False)
            else:
                return self.outlineCommand("clone", p_ap, True)
        else:
            return self.outputError("Error in clonePNode function, no w_p node found")  # default empty
    else:
        return self.outputError("Error in clonePNode function, no param p_ap")

</t>
<t tx="felix.20191231203711.1">def undo(self, p_paramUnused):
    '''Undo last un-doable operation'''
    if self.commander.undoer.canUndo():
        self.commander.undoer.undo()
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="felix.20191231214801.1">def executeScript(self, p_package):
    '''Select a node and run its script'''
    if 'node' in p_package:
        w_ap = p_package['node']
        w_p = self.ap_to_p(w_ap)
        if w_p:
            self.commander.selectPosition(w_p)
            w_script = ""
            if 'text' in p_package:
                w_script = str(p_package['text'])
            if w_script and not w_script.isspace():
                # * Mimic getScript !!
                try:
                    # Remove extra leading whitespace so the user may execute indented code.
                    w_script = self.g.removeExtraLws(w_script, self.commander.tab_width)
                    w_script = self.g.extractExecutableString(self.commander, w_p, w_script)
                    w_validScript = self.g.composeScript(self.commander, w_p, w_script,
                                                         forcePythonSentinels=True,
                                                         useSentinels=True)
                    self.commander.executeScript(script=w_validScript)
                except Exception as e:
                    self.g.trace('Error while executing script')
                    print('Error while executing script')
                    print(str(e))
            else:
                self.commander.executeScript()
            return self.outputPNode(self.commander.p)  # in both cases, return selected node
        else:
            return self.outputError("Error in run no w_p node found")  # default empty
    else:
        return self.outputError("Error in run no param p_ap")

</t>
<t tx="felix.20200103204811.1">def redo(self, p_paramUnused):
    '''Undo last un-doable operation'''
    if self.commander.undoer.canRedo():
        self.commander.undoer.redo()
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="felix.20200105173826.1">def outlineCommand(self, p_command, p_ap, p_keepSelection=False):
    '''Generic call to an outline operation (p_command) for specific p-node (p_ap), with possibility of trying to preserve the current selection (p_keepSelection)'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_func = getattr(self.commander, p_command)
            if w_p == self.commander.p:
                w_func()
            else:
                oldPosition = self.commander.p  # not same node, save position to possibly return to
                self.commander.selectPosition(w_p)
                w_func()
                if p_keepSelection and self.commander.positionExists(oldPosition):
                    self.commander.selectPosition(oldPosition)  # select if old position still valid
            return self.outputPNode(self.commander.p)  # in both cases, return selected node
        else:
            return self.outputError("Error in " + p_command + " no w_p node found")  # default empty
    else:
        return self.outputError("Error in " + p_command + " no param p_ap")

</t>
<t tx="felix.20200120224033.1">def insertNamedPNode(self, p_package):
    '''Insert a node at given node, set its headline, select it and finally return it'''
    w_newHeadline = p_package['text']
    w_ap = p_package['node']
    if w_ap:
        w_p = self.ap_to_p(w_ap)
        if w_p:
            w_u = self.commander.undoer.beforeInsertNode(w_p)
            w_newNode = w_p.insertAfter()
            # set this node's new headline
            w_newNode.h = w_newHeadline
            w_newNode.setDirty()
            self.commander.undoer.afterInsertNode(w_newNode, 'Insert Node', w_u)
            self.commander.selectPosition(w_newNode)
            return self.outputPNode(self.commander.p)  # in any case, return selected node
        else:
            return self.outputError("Error in insertNamedPNode no w_p node found")  # default empty
    else:
        return self.outputError("Error in insertNamedPNode no param w_ap")

</t>
<t tx="felix.20200211202929.1">def initConnection(self, p_webSocket):
    self.webSocket = p_webSocket
    self.loop = asyncio.get_event_loop()

</t>
<t tx="felix.20200213195413.1">async def asyncOutput(self, p_json):
    '''Output json string to the websocket'''
    if self.webSocket:
        await self.webSocket.send(p_json)
    else:
        print("websocket not ready yet")

</t>
<t tx="felix.20200216160305.1">def saveFile(self, p_package):
    '''Saves the leo file. New or dirty derived files are rewritten'''
    if self.commander:
        try:
            if "text" in p_package:
                self.commander.save(fileName=p_package['text'])
            else:
                self.commander.save()
        except Exception as e:
            self.g.trace('Error while saving')
            print("Error while saving")
            print(str(e))

    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200219222712.1">def es(self, * args, **keys):
    '''Output to the Log Pane'''
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
        'nodeLink': None,
    }
    d = self.g.doKeywordArgs(keys, d)
    s = self.g.translateArgs(args, d)
    w_package = {"async": "log", "log": s}
    self.sendAsyncOutput(w_package)

</t>
<t tx="felix.20200219224515.1">def logSignon(self):
    '''Simulate the Initial Leo Log Entry'''
    if self.loop:
        self.g.app.computeSignon()
        self.g.es(str(self.g.app.signon))
        self.g.es(str(self.g.app.signon1))
    else:
        print('no loop in logSignon')

</t>
<t tx="felix.20200301235235.1">def refreshFromDiskPNode(self, p_ap):
    '''Refresh from Disk, don't select it if possible'''
    return self.outlineCommand("refreshFromDisk", p_ap, True)

</t>
<t tx="felix.20200302204251.1">class IdleTimeManager:
    """
    A singleton class to manage idle-time handling. This class handles all
    details of running code at idle time, including running 'idle' hooks.

    Any code can call g.app.idleTimeManager.add_callback(callback) to cause
    the callback to be called at idle time forever.
    """
    # TODO : REVISE/REPLACE WITH OWN SYSTEM

    def __init__(self, g):
        """Ctor for IdleTimeManager class."""
        self.g = g
        self.callback_list = []
        self.timer = None
        self.on_idle_count = 0

    @others

</t>
<t tx="felix.20200302204251.2">def add_callback(self, callback):
    """Add a callback to be called at every idle time."""
    self.callback_list.append(callback)

</t>
<t tx="felix.20200302204251.3">def on_idle(self, timer):
    """IdleTimeManager: Run all idle-time callbacks."""
    if not self.g.app:
        return
    if self.g.app.killed:
        return
    if not self.g.app.pluginsController:
        self.g.trace('No g.app.pluginsController', self.g.callers())
        timer.stop()
        return  # For debugger.
    self.on_idle_count += 1
    # Handle the registered callbacks.
    # print("list length : ", len(self.callback_list))
    for callback in self.callback_list:
        try:
            callback()
        except Exception:
            self.g.es_exception()
            self.g.es_print(f"removing callback: {callback}")
            self.callback_list.remove(callback)
    # Handle idle-time hooks.
    self.g.app.pluginsController.on_idle()

</t>
<t tx="felix.20200302204251.4">def start(self):
    """Start the idle-time timer."""
    self.timer = self.g.IdleTime(
        self.on_idle,
        delay=500,  # Milliseconds
        tag='IdleTimeManager.on_idle')
    if self.timer:
        self.timer.start()

</t>
<t tx="felix.20200302205810.1">class ExternalFilesController:
    '''EFC Modified from Leo's sources'''

    @others

</t>
<t tx="felix.20200302205810.2">def __init__(self, integController):
    '''Ctor for ExternalFiles class.'''
    self.on_idle_count = 0
    self.integController = integController
    self.checksum_d = {}
    # Keys are full paths, values are file checksums.
    self.enabled_d = {}
    # For efc.on_idle.
    # Keys are commanders.
    # Values are cached @bool check-for-changed-external-file settings.
    self.has_changed_d = {}
    # Keys are commanders. Values are boolean.
    # Used only to limit traces.
    self.unchecked_commanders = []
    # Copy of g.app.commanders()
    self.unchecked_files = []
    # Copy of self file. Only one files is checked at idle time.
    self._time_d = {}
    # Keys are full paths, values are modification times.
    # DO NOT alter directly, use set_time(path) and
    # get_time(path), see set_time() for notes.
    self.yesno_all_time = 0  # previous yes/no to all answer, time of answer
    self.yesno_all_answer = None  # answer, 'yes-all', or 'no-all'

    self.infoMessage = None  # if yesAll/noAll forced, then just show info message after idle_check_commander
    # False or "detected", "refreshed" or "ignored"

    self.integController.g.app.idleTimeManager.add_callback(self.on_idle)

    self.waitingForAnswer = False
    self.lastPNode = None  # last p node that was asked for if not set to "AllYes\AllNo"
    self.lastCommander = None

</t>
<t tx="felix.20200302205810.21"></t>
<t tx="felix.20200302205810.22">def ask(self, c, path, p=None):
    '''
    Ask user whether to overwrite an @&lt;file&gt; tree.
    Return True if the user agrees.
    '''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["defaultReloadIgnore"].lower()
        if not bool('none' in w_check_config):
            if bool('yes' in w_check_config):
                self.infoMessage = "refreshed"
                return True
            else:
                self.infoMessage = "ignored"
                return False
    # let original function resolve

    if self.yesno_all_time + 3 &gt;= time.time() and self.yesno_all_answer:
        self.yesno_all_time = time.time()  # Still reloading?  Extend time.
        # if yesAll/noAll forced, then just show info message
        w_yesno_all_bool = bool('yes' in self.yesno_all_answer.lower())

        return w_yesno_all_bool
    if not p:
        where = 'the outline node'
    else:
        where = p.h

    _is_leo = path.endswith(('.leo', '.db'))

    if _is_leo:
        s = '\n'.join([
            f'{self.integController.g.splitLongFileName(path)} has changed outside Leo.',
            'Overwrite it?'
        ])
    else:
        s = '\n'.join([
            f'{self.integController.g.splitLongFileName(path)} has changed outside Leo.',
            f"Reload {where} in Leo?",
        ])

    w_package = {"async": "ask", "ask": 'Overwrite the version in Leo?',
                 "message": s, "yes_all": not _is_leo, "no_all": not _is_leo}

    self.integController.sendAsyncOutput(w_package)
    self.waitingForAnswer = True
    return False
    # result = self.integController.g.app.gui.runAskYesNoDialog(c, 'Overwrite the version in Leo?', s,
    # yes_all=not _is_leo, no_all=not _is_leo)

    # if result and "-all" in result.lower():
    # self.yesno_all_time = time.time()
    # self.yesno_all_answer = result.lower()

    # return bool(result and 'yes' in result.lower())

</t>
<t tx="felix.20200302205810.23">def checksum(self, path):
    '''Return the checksum of the file at the given path.'''
    import hashlib
    return hashlib.md5(open(path, 'rb').read()).hexdigest()

</t>
<t tx="felix.20200302205810.25">def get_mtime(self, path):
    '''Return the modification time for the path.'''
    return self.integController.g.os_path_getmtime(self.integController.g.os_path_realpath(path))

</t>
<t tx="felix.20200302205810.26">def get_time(self, path):
    '''
    return timestamp for path

    see set_time() for notes
    '''
    return self._time_d.get(self.integController.g.os_path_realpath(path))

</t>
<t tx="felix.20200302205810.27">def has_changed(self, c, path):
    '''Return True if p's external file has changed outside of Leo.'''
    if not self.integController.g.os_path_exists(path):
        return False
    if self.integController.g.os_path_isdir(path):
        return False
    #
    # First, check the modification times.
    old_time = self.get_time(path)
    new_time = self.get_mtime(path)
    if not old_time:
        # Initialize.
        self.set_time(path, new_time)
        self.checksum_d[path] = self.checksum(path)
        return False
    if old_time == new_time:
        return False
    #
    # Check the checksums *only* if the mod times don't match.
    old_sum = self.checksum_d.get(path)
    new_sum = self.checksum(path)
    if new_sum == old_sum:
        # The modtime changed, but it's contents didn't.
        # Update the time, so we don't keep checking the checksums.
        # Return False so we don't prompt the user for an update.
        self.set_time(path, new_time)
        return False
    # The file has really changed.
    assert old_time, path
    # #208: external change overwrite protection only works once.
    # If the Leo version is changed (dirtied) again,
    # overwrite will occur without warning.
    # self.set_time(path, new_time)
    # self.checksum_d[path] = new_sum
    return True

</t>
<t tx="felix.20200302205810.28">def is_enabled(self, c):
    '''Return the cached @bool check_for_changed_external_file setting.'''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["checkForChangeExternalFiles"].lower()
        if bool('check' in w_check_config):
            return True
        if bool('ignore' in w_check_config):
            return False
    # let original function resolve
    d = self.enabled_d
    val = d.get(c)
    if val is None:
        val = c.config.getBool('check-for-changed-external-files', default=False)
        d[c] = val
    return val

</t>
<t tx="felix.20200302205810.29">def join(self, s1, s2):
    '''Return s1 + ' ' + s2'''
    return f"{s1} {s2}"

</t>
<t tx="felix.20200302205810.30">def set_time(self, path, new_time=None):
    '''
    Implements c.setTimeStamp.

    Update the timestamp for path.

    NOTE: file paths with symbolic links occur with and without those links
    resolved depending on the code call path.  This inconsistency is
    probably not Leo's fault but an underlying Python issue.
    Hence the need to call realpath() here.
    '''

    # print("called set_time for " + str(path))

    t = new_time or self.get_mtime(path)
    self._time_d[self.integController.g.os_path_realpath(path)] = t

</t>
<t tx="felix.20200302205810.31">def warn(self, c, path, p):
    '''
    Warn that an @asis or @nosent node has been changed externally.

    There is *no way* to update the tree automatically.
    '''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["defaultReloadIgnore"].lower()

        if w_check_config != "none":
            # if not 'none' then do not warn, just infoMessage 'warn' at most
            if not self.infoMessage:
                self.infoMessage = "warn"
            return

    # let original function resolve
    if self.integController.g.unitTesting or c not in self.integController.g.app.commanders():
        return
    if not p:
        self.integController.g.trace('NO P')
        return

    s = '\n'.join([
        '%s has changed outside Leo.\n' % self.integController.g.splitLongFileName(path),
        'Leo can not update this file automatically.\n',
        'This file was created from %s.\n' % p.h,
        'Warning: refresh-from-disk will destroy all children.'
    ])

    w_package = {"async": "warn", "warn": 'External file changed', "message": s}

    self.integController.sendAsyncOutput(w_package)
    self.waitingForAnswer = True

</t>
<t tx="felix.20200302205810.7">def on_idle(self):
    '''
    Check for changed open-with files and all external files in commanders
    for which @bool check_for_changed_external_file is True.
    '''
    # Fix for flushing the terminal console to traverse
    # python through node.js when using start server in leoInteg
    sys.stdout.flush()

    if not self.integController.g.app or self.integController.g.app.killed:
        return
    if self.waitingForAnswer:
        return

    self.on_idle_count += 1

    if self.unchecked_commanders:
        # Check the next commander for which
        # @bool check_for_changed_external_file is True.
        c = self.unchecked_commanders.pop()
        self.lastCommander = c
        self.idle_check_commander(c)
    else:
        # Add all commanders for which
        # @bool check_for_changed_external_file is True.
        self.unchecked_commanders = [
            z for z in self.integController.g.app.commanders() if self.is_enabled(z)
        ]

</t>
<t tx="felix.20200302205810.8">def idle_check_commander(self, c):
    '''
    Check all external files corresponding to @&lt;file&gt; nodes in c for
    changes.
    '''
    # #1100: always scan the entire file for @&lt;file&gt; nodes.
    # #1134: Nested @&lt;file&gt; nodes are no longer valid, but this will do no harm.

    self.infoMessage = None  # reset infoMessage
    # False or "detected", "refreshed" or "ignored"

    for p in c.all_unique_positions():
        if self.waitingForAnswer:
            break
        if p.isAnyAtFileNode():
            self.idle_check_at_file_node(c, p)

    # if yesAll/noAll forced, then just show info message
    if self.infoMessage:
        w_package = {"async": "info", "message": self.infoMessage}
        self.integController.sendAsyncOutput(w_package)

</t>
<t tx="felix.20200302205810.9">def idle_check_at_file_node(self, c, p):
    '''Check the @&lt;file&gt; node at p for external changes.'''
    trace = False
    # Matt, set this to True, but only for the file that interests you.\
    # trace = p.h == '@file unregister-leo.leox'
    path = self.integController.g.fullPath(c, p)
    has_changed = self.has_changed(c, path)
    if trace:
        self.integController.g.trace('changed', has_changed, p.h)
    if has_changed:
        self.lastPNode = p  # can be set here because its the same process for ask/warn
        if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
            # Fix #1081: issue a warning.
            self.warn(c, path, p=p)
        elif self.ask(c, path, p=p):
            self.lastCommander.selectPosition(self.lastPNode)
            c.refreshFromDisk()

        # Always update the path &amp; time to prevent future warnings.
        self.set_time(path)
        self.checksum_d[path] = self.checksum(path)

</t>
<t tx="felix.20200303214235.1">async def _asyncIdleLoop(self, p_seconds, p_fn):
    while True:
        await asyncio.sleep(p_seconds)
        p_fn(self)

</t>
<t tx="felix.20200303214255.1">def _idleTime(self, fn, delay, tag):
    # TODO : REVISE/REPLACE WITH OWN SYSTEM
    asyncio.get_event_loop().create_task(self._asyncIdleLoop(delay/1000, fn))

</t>
<t tx="felix.20200304220844.1">def askResult(self, p_result):
    '''Got the result to an asked question/warning from vscode'''
    self.g.app.externalFilesController.integResult(p_result)
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200304221925.1">def integResult(self, p_result):
    '''Received result from vsCode'''
    # Got the result to an asked question/warning from vscode
    if not self.waitingForAnswer:
        print("ERROR: Received Result but no Asked Dialog")
        return
    # check if p_resultwas from a warn (ok) or an ask ('yes','yes-all','no','no-all')
    # act accordingly

    path = self.integController.g.fullPath(self.lastCommander, self.lastPNode)

    # 1- if ok, unblock 'warn'
    # 2- if no, unblock 'ask'
    # ------------------------------------------ Nothing special to do

    # 3- if noAll, set noAll, and unblock 'ask'
    if p_result and "-all" in p_result.lower():
        self.yesno_all_time = time.time()
        self.yesno_all_answer = p_result.lower()
    # ------------------------------------------ Also covers setting yesAll in #5

    # 4- if yes, REFRESH self.lastPNode, and unblock 'ask'
    # 5- if yesAll,REFRESH self.lastPNode, set yesAll, and unblock 'ask'
    if bool(p_result and 'yes' in p_result.lower()):
        self.lastCommander.selectPosition(self.lastPNode)
        self.lastCommander.refreshFromDisk()

    # Always update the path &amp; time to prevent future warnings for this PNode.
    self.set_time(path)
    self.checksum_d[path] = self.checksum(path)

    self.waitingForAnswer = False  # unblock
    self.idle_check_commander(self.lastCommander)  # unblock: run the loop as if timer had hit

</t>
<t tx="felix.20200304224909.1">def sendAsyncOutput(self, p_package):
    if "async" not in p_package:
        print('[sendAsyncOutput] Error async member missing in package parameter' + json.dumps(p_package, separators=(',', ':')))
        return
    if self.loop:
        self.loop.create_task(self.asyncOutput(json.dumps(p_package, separators=(',', ':'))))
    else:
        print('[sendAsyncOutput] Error loop not ready' + json.dumps(p_package, separators=(',', ':')))

</t>
<t tx="felix.20200308145948.1"># Some methods are called in the usual (non-leoBridge without 'efc') save process.
# Those may called by the 'save' function, like check_overwrite,
# or by any other functions from the instance of leo.core.leoBridge that's running.

</t>
<t tx="felix.20200308150821.1">def shut_down(self):
    return

</t>
<t tx="felix.20200308150842.1">def destroy_frame(self, f):
    return

</t>
<t tx="felix.20200308150848.1">def check_overwrite(self, c, fn):
    # print("check_overwrite!! ")
    return True

</t>
<t tx="felix.20200308150856.1">def open_with(self, c, d):
    return

</t>
<t tx="felix.20200312231358.1">def applyConfig(self, p_config):
    '''Got leoInteg's config from vscode'''
    self.leoIntegConfig = p_config
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200329000454.1">def contractAll(self, p_paramUnused):
    '''(Collapse) Contract All'''
    self.commander.contractAllHeadlines()
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="felix.20200619165641.1">def getStates(self, p_package):
    """
    Gets the currently opened file's general states for UI enabled/disabled states
    such as undo available, file changed/unchanged
    """
    w_states = {}
    if self.commander:
        try:
            w_states["changed"] = self.commander.changed   # 'dirty/changed' member
            w_states["canUndo"] = self.commander.canUndo()
            w_states["canRedo"] = self.commander.canRedo()
            w_states["canDemote"] = self.commander.canDemote()
            w_states["canPromote"] = self.commander.canPromote()
            w_states["canDehoist"] = self.commander.canDehoist()

        except Exception as e:
            self.g.trace('Error while getting states')
            print("Error while getting states")
            print(str(e))
    else:
        w_states["changed"] = False
        w_states["canUndo"] = False
        w_states["canRedo"] = False
        w_states["canDemote"] = False
        w_states["canPromote"] = False
        w_states["canDehoist"] = False

    return self.sendLeoBridgePackage("states", w_states)

</t>
<t tx="felix.20200622230608.1">def getOpenedFiles(self, p_package):
    '''Return array of opened file path/names to be used as openFile parameters to switch files'''
    w_files = []
    w_index = 0
    w_indexFound = 0
    for w_commander in self.g.app.commanders():
        if w_commander.closed == False:
            w_isSelected = False
            w_isChanged = w_commander.changed
            if self.commander == w_commander:
                w_indexFound = w_index
                w_isSelected = True
            w_entry = {"name": w_commander.mFileName, "index": w_index,
                       "changed": w_isChanged, "selected": w_isSelected}
            w_files.append(w_entry)
            w_index = w_index + 1

    w_openedFiles = {"files": w_files, "index": w_indexFound}

    return self.sendLeoBridgePackage("openedFiles", w_openedFiles)

</t>
<t tx="felix.20200623201853.1">def _getTotalOpened(self):
    '''Get total of opened commander (who have closed == false)'''
    w_total = 0
    for w_commander in self.g.app.commanders():
        if w_commander.closed == False:
            w_total = w_total + 1
    return w_total

</t>
<t tx="felix.20200623215904.1">def _getFirstOpenedCommander(self):
    '''Get first opened commander, or False if there are none.'''
    for w_commander in self.g.app.commanders():
        if w_commander.closed == False:
            return w_commander
    return False

</t>
<t tx="felix.20200624172552.1">def setOpenedFile(self, p_package):
    '''Choose the new active commander from array of opened file path/names by numeric index'''
    w_openedCommanders = []

    for w_commander in self.g.app.commanders():
        if w_commander.closed == False:
            w_openedCommanders.append(w_commander)

    w_index = p_package['index']

    if w_openedCommanders[w_index]:
        self.commander = w_openedCommanders[w_index]

    if self.commander:
        self.commander.closed = False
        self.create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self.p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage("setOpened", w_result)
    else:
        return self.outputError('Error in setOpenedFile')

</t>
<t tx="felix.20200626012709.1">def _returnNo(self, *arguments):
    '''Used to override g.app.gui.ask[XXX] dialogs answers'''
    return "no"

</t>
<t tx="felix.20200626030820.1">def _returnYes(self, *arguments):
    '''Used to override g.app.gui.ask[XXX] dialogs answers'''
    return "yes"

</t>
<t tx="felix.20200705193918.1"></t>
<t tx="felix.20200705193927.1">def pageUp(self, p_ap):
    """Selects a node a couple of steps up in the tree to simulate page up"""
    self.commander.selectVisBack()
    self.commander.selectVisBack()
    self.commander.selectVisBack()
    return self.outputPNode(self.commander.p)

</t>
<t tx="felix.20200705201100.1">def gotoLastSibling(self, p_ap):
    """Select the last sibling of the selected node."""
    return self.outlineCommand("goToLastSibling", p_ap)

</t>
<t tx="felix.20200705223430.1">def contractOrGoLeft(self, p_ap):
    """Simulate the left Arrow Key in folder of Windows Explorer."""
    return self.outlineCommand("contractNodeOrGoToParent", p_ap)

</t>
<t tx="felix.20200705223521.1">def expandAndGoRight(self, p_ap):
    """If a node has children, expand it if needed and go to the first child."""
    return self.outlineCommand("expandNodeAndGoToFirstChild", p_ap)

</t>
<t tx="felix.20200705223536.1">def gotoNextVisible(self, p_ap):
    """Select the visible node following the presently selected node."""
    return self.outlineCommand("selectVisNext", p_ap)

</t>
<t tx="felix.20200705223541.1">def gotoPrevVisible(self, p_ap):
    """Select the visible node preceding the presently selected node."""
    return self.outlineCommand("selectVisBack", p_ap)

</t>
<t tx="felix.20200705233325.1">def gotoLastVisible(self, p_ap):
    """Select the last visible node of selected chapter or hoist."""
    return self.outlineCommand("goToLastVisibleNode", p_ap)

</t>
<t tx="felix.20200706030410.1">def gotoNextMarked(self, p_ap):
    """Select the next marked node."""
    return self.outlineCommand("goToNextMarkedHeadline", p_ap)

</t>
<t tx="felix.20200706202247.1">def gotoNextClone(self, p_ap):
    """
    Select the next node that is a clone of the selected node.
    If the selected node is not a clone, do find-next-clone.
    """
    return self.outlineCommand("goToNextClone", p_ap)

</t>
<t tx="felix.20200710014747.1">def getButtons(self, p_package):
    '''Gets the currently opened file's @buttons list'''
    w_buttons = []
    if self.commander.theScriptingController and self.commander.theScriptingController.buttonsDict:
        w_dict = self.commander.theScriptingController.buttonsDict
        for w_key in w_dict:
            w_entry = {"name": w_dict[w_key], "index": str(w_key)}
            w_buttons.append(w_entry)
    return self.sendLeoBridgePackage("buttons", w_buttons)

def removeButton(self, p_package):
    '''Removes an entry from the buttonsDict by index string'''
    w_index = p_package['index']
    w_dict = self.commander.theScriptingController.buttonsDict
    w_key = None
    for i_key in w_dict:
        if(str(i_key) == w_index):
            w_key = i_key
    if w_key:
        del(w_dict[w_key])  # delete object member
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="felix.20200710030614.1">def clickButton(self, p_package):
    '''Handles buttons clicked in vscode from the '@button' panel'''
    w_index = p_package['index']
    w_dict = self.commander.theScriptingController.buttonsDict
    w_button = None
    for i_key in w_dict:
        if(str(i_key) == w_index):
            w_button = i_key
    if w_button:
        w_button.command()  # run clicked button command
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="felix.20200711182907.1">def getCommands(self, p_package):
    pass

    print("get command list for string: ")

    if "text" in p_package:
        print(p_package['text'])
    else:
        print("no string given")

    w_commands = []
    w_commands.append("one")
    w_commands.append("two")
    w_commands.append("three")

    return self.sendLeoBridgePackage("commands", w_commands)

def runByName(self, p_package):
    pass

    print("runByName for string:")

    if "text" in p_package:
        print(p_package['text'])
    else:
        print("no string given")

    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="felix.20200711210205.1">def pageDown(self, p_ap):
    """Selects a node a couple of steps down in the tree to simulate page down"""
    self.commander.selectVisNext()
    self.commander.selectVisNext()
    self.commander.selectVisNext()
    return self.outputPNode(self.commander.p)

</t>
<t tx="felix.20200711210205.2">def gotoFirstVisible(self, p_ap):
    """Select the first visible node of the selected chapter or hoist."""
    return self.outlineCommand("goToFirstVisibleNode", p_ap)

</t>
<t tx="felix.20200717222352.1">@language json
@tabwidth -2
{
  "name": "leointeg",
  "displayName": "Leo Editor Integration with Visual Studio Code",
  "description": "Use Leo, the literate editor with outline, directly in vscode.",
  "version": "0.1.13",
  "author": {
    "name": "Flix"
  },
  "publisher": "boltex",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/boltex/leointeg"
  },
  "engines": {
    "vscode": "^1.47.0"
  },
  "keywords": [
    "leo",
    "literate",
    "editor",
    "outline",
    "programming"
  ],
  "categories": [
    "Other"
  ],
  "activationEvents": [
    "onView:leoIntegration",
    "workspaceContains:**/*.leo"
  ],
  "main": "./dist/extension",
  "icon": "resources/leoapp128px.png",
  "galleryBanner": {
    "color": "#fffbdc",
    "theme": "light"
  },
  "contributes": {
    @others
  },
  "scripts": {
    "vscode:prepublish": "webpack --mode production",
    "webpack": "webpack --mode development",
    "webpack-dev": "webpack --mode development --watch",
    "test-compile": "tsc -p ./",
    "lint": "tslint -p ./"
  },
  "devDependencies": {
    "@types/glob": "^7.1.1",
    "@types/mocha": "^7.0.2",
    "@types/node": "^14.0.5",
    "@types/vscode": "^1.45.1",
    "@types/ws": "^7.2.4",
    "clean-webpack-plugin": "^3.0.0",
    "csp-html-webpack-plugin": "^4.0.0",
    "css-loader": "^3.5.3",
    "eslint": "^7.1.0",
    "fork-ts-checker-webpack-plugin": "^4.1.6",
    "glob": "^7.1.6",
    "html-loader": "^1.1.0",
    "html-webpack-exclude-assets-plugin": "0.0.7",
    "html-webpack-plugin": "^3.2.0",
    "imagemin-webpack-plugin": "^2.4.2",
    "mini-css-extract-plugin": "^0.9.0",
    "mocha": "^7.2.0",
    "node-sass": "^4.14.1",
    "sass-loader": "^8.0.2",
    "ts-loader": "^7.0.5",
    "tslint": "^6.1.2",
    "typescript": "^3.9.3",
    "vscode-test": "^1.4.0",
    "webpack": "^4.43.0",
    "webpack-cli": "^3.3.11"
  },
  "dependencies": {
    "@types/debounce": "^1.2.0",
    "bufferutil": "^4.0.1",
    "debounce": "^1.2.0",
    "hasbin": "^1.2.3",
    "ws": "^7.3.0"
  }
}
</t>
<t tx="felix.20200717222716.1">"configuration": {
  "title": "Leo Integration",
  "properties": {
    @others
  }
},
</t>
<t tx="felix.20200717222850.1">"viewsContainers": {
  "activitybar": [
    {
      "id": "leoIntegrationView",
      "title": "Leo",
      "icon": "resources/icon.svg"
    }
  ]
},
</t>
<t tx="felix.20200717222918.1">"views": {
  "explorer": [
    {
      "id": "leoIntegrationExplorer",
      "name": "Leo Integration",
      "contextualTitle": "Leo",
      "when": "treeInExplorer"
    },
    {
      "id": "leoDocumentsExplorer",
      "name": "Leo Documents",
      "contextualTitle": "Leo",
      "when": "treeInExplorer"
    },
    {
      "id": "leoButtonsExplorer",
      "name": "Leo Buttons",
      "contextualTitle": "Leo",
      "when": "treeInExplorer"
    }
  ],
  "leoIntegrationView": [
    {
      "id": "leoIntegration",
      "contextualTitle": "Leo",
      "name": "Integration"
    },
    {
      "id": "leoDocuments",
      "contextualTitle": "Leo",
      "name": "Documents"
    },
    {
      "id": "leoButtons",
      "contextualTitle": "Leo",
      "name": "Buttons"
    }
  ]
},
</t>
<t tx="felix.20200717222938.1">"languages": [
  {
    "id": "leobody",
    "aliases": [
      "Leo Body",
      "leobody"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configuration.json"
  }
],
</t>
<t tx="felix.20200717222946.1">"grammars": [
  {
    "language": "leobody",
    "scopeName": "source.leobody",
    "path": "./syntaxes/leobody.tmLanguage.json"
  }
],
</t>
<t tx="felix.20200717223012.1">"commands": [
  @others
],
</t>
<t tx="felix.20200717223038.1">"viewsWelcome": [
  @others
],
</t>
<t tx="felix.20200717223100.1">"menus": {
  @others
},
</t>
<t tx="felix.20200717223116.1">"keybindings": [
  @others
],
</t>
<t tx="felix.20200717223127.1">"resourceLabelFormatters": [
  {
    "scheme": "leo",
    "formatting": {
      "label": "LEO: BODY",
      "separator": "/",
      "workspaceSuffix": ""
    }
  }
]
</t>
<t tx="felix.20200717223431.1">"leoIntegration.checkForChangeExternalFiles": {
  "scope": "application",
  "default": "none",
  "type": "string",
  "description": "Set default for checking changes to external files",
  "enum": [
    "none",
    "force-check",
    "force-ignore"
  ],
  "enumDescriptions": [
    "Default from Leo's config",
    "Check for changes",
    "Ignore all changes"
  ]
},
"leoIntegration.defaultReloadIgnore": {
  "scope": "application",
  "default": "none",
  "type": "string",
  "description": "Set default for derived files to always reload, or always ignore, when changes are detected",
  "enum": [
    "none",
    "yes-all",
    "no-all"
  ],
  "enumDescriptions": [
    "Choose each time",
    "Reload All",
    "Ignore All"
  ]
},
</t>
<t tx="felix.20200717223454.1">"leoIntegration.leoTreeBrowse": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Specifies whether to use Leo's style of tree browsing with the arrow keys"
},
"leoIntegration.treeKeepFocus": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Specifies whether to keep focus in the outline when selecting a node - overridden by \"leoTreeBrowse\""
},
"leoIntegration.treeKeepFocusWhenAside": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Specifies whether to keep focus in the outline when opening a body pane on the side"
},
</t>
<t tx="felix.20200717223513.1">"leoIntegration.statusBarString": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Sets the message string of the Status Bar Indicator"
},
"leoIntegration.statusBarColor": {
  "scope": "application",
  "default": "fb7c47",
  "type": "string",
  "description": "Specifies the hexadecimal color string for the Status Bar Indicator"
},
</t>
<t tx="felix.20200717223828.1">"leoIntegration.treeInExplorer": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Show the outline tree in the explorer view"
},
"leoIntegration.showOpenAside": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Offer 'Open to the Side' in nodes context menu"
},
"leoIntegration.showEditOnNodes": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Edit Headline' button on tree nodes"
},
"leoIntegration.showArrowsOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Move Node' arrow buttons on tree nodes"
},
"leoIntegration.showAddOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Insert' button on tree nodes"
},
"leoIntegration.showMarkOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Mark/Unmark' buttons on tree nodes"
},
"leoIntegration.showCloneOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Clone' button on tree nodes"
},
"leoIntegration.showCopyOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Copy' button on tree nodes"
},
"leoIntegration.invertNodeContrast": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Inverts the contrast of the dirty/clean border aspect of tree nodes"
},
</t>
<t tx="felix.20200717223852.1">"leoIntegration.leoPythonCommand": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Specifies the command to start python (Defaults to 'py' on windows and 'python3' otherwise)"
},
"leoIntegration.startServerAutomatically": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Starts a LeoBridge server automatically, by running the leobridgeserver.py python script"
},
"leoIntegration.connectToServerAutomatically": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Connect automatically to a Leo server on specified 'Connection Port' upon activation of this extension"
},
"leoIntegration.connectionAddress": {
  "default": "localhost",
  "scope": "application",
  "type": "string",
  "description": "Connection host"
},
"leoIntegration.connectionPort": {
  "default": 32125,
  "scope": "application",
  "minimum": 0,
  "maximum": 65535,
  "type": "number",
  "description": "Connection port"
}
</t>
<t tx="felix.20200717224216.1">{
  "command": "leointeg.showSettingsPage",
  "title": "Open Settings",
  "category": "Leo",
  "icon": {
    "light": "resources/light/gear.svg",
    "dark": "resources/dark/gear.svg"
  }
},
{
  "command": "leointeg.showWelcomePage",
  "title": "Welcome",
  "category": "Leo"
},
</t>
<t tx="felix.20200717224224.1">{
  "command": "leointeg.test",
  "category": "Leo",
  "title": "Test Leo Integration"
},
</t>
<t tx="felix.20200717224258.1">{
  "command": "leointeg.startServer",
  "category": "Leo",
  "title": "Start Leo Bridge Server"
},
{
  "command": "leointeg.connectToServer",
  "title": "Connect to Leo Bridge Server",
  "category": "Leo",
  "icon": {
    "light": "resources/light/connect.svg",
    "dark": "resources/dark/connect.svg"
  }
},
</t>
<t tx="felix.20200717224519.1">{
  "command": "leointeg.showBody",
  "category": "Leo",
  "title": "Focus to Body"
},
{
  "command": "leointeg.showOutline",
  "category": "Leo",
  "title": "Focus to Tree"
},
{
  "command": "leointeg.showLogPane",
  "category": "Leo",
  "title": "Show Log Pane"
},
</t>
<t tx="felix.20200717224549.1">{
  "command": "leointeg.openLeoFile",
  "title": "Open Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/folder.svg",
    "dark": "resources/dark/folder.svg"
  }
},
{
  "command": "leointeg.switchLeoFile",
  "title": "Switch Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/switch.svg",
    "dark": "resources/dark/switch.svg"
  }
},
{
  "command": "leointeg.newLeoFile",
  "title": "New Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/new-file.svg",
    "dark": "resources/dark/new-file.svg"
  }
},
{
  "command": "leointeg.closeLeoFile",
  "title": "Close Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leointeg.saveLeoFile",
  "category": "Leo",
  "title": "Save Leo File",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leointeg.saveLeoFileFromOutline",
  "category": "Leo",
  "title": "Save Leo File",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leointeg.saveAsLeoFile",
  "category": "Leo",
  "title": "Save Leo File as...",
  "icon": {
    "light": "resources/light/save-as.svg",
    "dark": "resources/dark/save-as.svg"
  }
},
{
  "command": "leointeg.refreshFromDisk",
  "category": "Leo",
  "title": "Refresh from Disk"
},
{
  "command": "leointeg.refreshFromDiskSelection",
  "category": "Leo",
  "title": "Refresh from Disk"
},
{
  "command": "leointeg.refreshFromDiskSelectionFromOutline",
  "category": "Leo",
  "title": "Refresh from Disk"
},
</t>
<t tx="felix.20200717230237.1">{
  "command": "leointeg.selectTreeNode",
  "category": "Leo",
  "title": "Select Node"
},
{
  "command": "leointeg.openAside",
  "category": "Leo",
  "title": "Open to the Side"
},
{
  "command": "leointeg.contractAll",
  "category": "Leo",
  "title": "Contract All",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
{
  "command": "leointeg.contractAllFromOutline",
  "category": "Leo",
  "title": "Contract All",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
</t>
<t tx="felix.20200717230331.1">{
  "command": "leointeg.editHeadline",
  "category": "Leo",
  "title": "Edit Headline",
  "icon": {
    "light": "resources/light/edit.svg",
    "dark": "resources/dark/edit.svg"
  }
},
{
  "command": "leointeg.editSelectedHeadline",
  "category": "Leo",
  "title": "Edit Headline"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "category": "Leo",
  "title": "Edit Headline"
},
{
  "command": "leointeg.mark",
  "category": "Leo",
  "title": "Mark",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leointeg.markSelection",
  "category": "Leo",
  "title": "Mark"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "category": "Leo",
  "title": "Mark"
},
{
  "command": "leointeg.unmark",
  "category": "Leo",
  "title": "Unmark",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leointeg.unmarkSelection",
  "category": "Leo",
  "title": "Unmark"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "category": "Leo",
  "title": "Unmark"
},
{
  "command": "leointeg.copyNode",
  "category": "Leo",
  "title": "Copy Node",
  "icon": {
    "light": "resources/light/clipboard.svg",
    "dark": "resources/dark/clipboard.svg"
  }
},
{
  "command": "leointeg.copyNodeSelection",
  "category": "Leo",
  "title": "Copy Node"
},
{
  "command": "leointeg.cutNode",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.cutNodeSelection",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.pasteNode",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAsClone",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelection",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.delete",
  "category": "Leo",
  "title": "Delete",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leointeg.deleteSelection",
  "category": "Leo",
  "title": "Delete Node"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "category": "Leo",
  "title": "Delete Node"
},
</t>
<t tx="felix.20200717230350.1">{
  "command": "leointeg.moveOutlineDown",
  "category": "Leo",
  "title": "Move Outline Down",
  "icon": {
    "light": "resources/light/arrow-down.svg",
    "dark": "resources/dark/arrow-down.svg"
  }
},
{
  "command": "leointeg.moveOutlineDownSelection",
  "category": "Leo",
  "title": "Move Outline Down"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Down"
},
{
  "command": "leointeg.moveOutlineLeft",
  "category": "Leo",
  "title": "Move Outline Left",
  "icon": {
    "light": "resources/light/arrow-left.svg",
    "dark": "resources/dark/arrow-left.svg"
  }
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "category": "Leo",
  "title": "Move Outline Left"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Left"
},
{
  "command": "leointeg.moveOutlineRight",
  "category": "Leo",
  "title": "Move Outline Right",
  "icon": {
    "light": "resources/light/arrow-right.svg",
    "dark": "resources/dark/arrow-right.svg"
  }
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "category": "Leo",
  "title": "Move Outline Right"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Right"
},
{
  "command": "leointeg.moveOutlineUp",
  "category": "Leo",
  "title": "Move Outline Up",
  "icon": {
    "light": "resources/light/arrow-up.svg",
    "dark": "resources/dark/arrow-up.svg"
  }
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "category": "Leo",
  "title": "Move Outline Up"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Up"
},
</t>
<t tx="felix.20200717230620.1">{
  "command": "leointeg.insertNode",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.insertNodeSelection",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.cloneNode",
  "category": "Leo",
  "title": "Clone Node",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leointeg.cloneNodeSelection",
  "category": "Leo",
  "title": "Clone Node"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Clone Node"
},
{
  "command": "leointeg.promote",
  "category": "Leo",
  "title": "Promote"
},
{
  "command": "leointeg.promoteSelection",
  "category": "Leo",
  "title": "Promote"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "category": "Leo",
  "title": "Promote"
},
{
  "command": "leointeg.demote",
  "category": "Leo",
  "title": "Demote"
},
{
  "command": "leointeg.demoteSelection",
  "category": "Leo",
  "title": "Demote"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "category": "Leo",
  "title": "Demote"
},
{
  "command": "leointeg.sortChildrenSelection",
  "category": "Leo",
  "title": "Sort Children"
},
{
  "command": "leointeg.sortSiblingsSelection",
  "category": "Leo",
  "title": "Sort Siblings"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "category": "Leo",
  "title": "Sort Siblings"
},
</t>
<t tx="felix.20200717230807.1">{
  "command": "leointeg.gotoFirstVisible",
  "category": "Leo",
  "title": "Goto First Visible"
},
{
  "command": "leointeg.gotoLastVisible",
  "category": "Leo",
  "title": "Goto Last Visible"
},
{
  "command": "leointeg.pageUp",
  "category": "Leo",
  "title": "Page Up"
},
{
  "command": "leointeg.pageDown",
  "category": "Leo",
  "title": "Page Down"
},
{
  "command": "leointeg.gotoLastSibling",
  "category": "Leo",
  "title": "Goto Last Sibling"
},
{
  "command": "leointeg.gotoNextVisible",
  "category": "Leo",
  "title": "Goto Next Visible"
},
{
  "command": "leointeg.gotoPrevVisible",
  "category": "Leo",
  "title": "Goto Prev Visible"
},
{
  "command": "leointeg.contractOrGoLeft",
  "category": "Leo",
  "title": "Contract Or Go Left"
},
{
  "command": "leointeg.expandAndGoRight",
  "category": "Leo",
  "title": "Expand And Go Right"
},
</t>
<t tx="felix.20200717230820.1">{
  "command": "leointeg.hoistNode",
  "category": "Leo",
  "title": "Hoist"
},
{
  "command": "leointeg.hoistSelection",
  "category": "Leo",
  "title": "Hoist"
},
{
  "command": "leointeg.hoistSelectionFromOutline",
  "category": "Leo",
  "title": "Hoist"
},
{
  "command": "leointeg.deHoist",
  "category": "Leo",
  "title": "De-Hoist",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
{
  "command": "leointeg.deHoistFromOutline",
  "category": "Leo",
  "title": "De-Hoist",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
</t>
<t tx="felix.20200717230830.1">{
  "command": "leointeg.undo",
  "category": "Leo",
  "title": "Undo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leointeg.undoFromOutline",
  "category": "Leo",
  "title": "Undo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leointeg.redo",
  "category": "Leo",
  "title": "Redo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
{
  "command": "leointeg.redoFromOutline",
  "category": "Leo",
  "title": "Redo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
</t>
<t tx="felix.20200717231121.1">{
  "command": "leointeg.executeScriptSelection",
  "category": "Leo",
  "title": "Execute Script"
},
{
  "command": "leointeg.minibuffer",
  "category": "Leo",
  "title": "Minibuffer"
},
{
  "command": "leointeg.removeButton",
  "category": "Leo",
  "title": "Remove Button"
},
</t>
<t tx="felix.20200717231448.1">{
  "command": "leointeg.cloneFindAll",
  "category": "Leo",
  "title": "Clone Find All"
},
{
  "command": "leointeg.cloneFindAllFlattened",
  "category": "Leo",
  "title": "Clone Find All Flattened"
},
{
  "command": "leointeg.cloneFindMarked",
  "category": "Leo",
  "title": "Clone Find Marked"
},
{
  "command": "leointeg.cloneFindFlattenedMarked",
  "category": "Leo",
  "title": "cffm - Clone Find Flattened Marked"
},
{
  "command": "leointeg.extract",
  "category": "Leo",
  "title": "Extract"
},
{
  "command": "leointeg.extractNames",
  "category": "Leo",
  "title": "Extract Names"
},
{
  "command": "leointeg.copyMarked",
  "category": "Leo",
  "title": "Copy Marked"
},
{
  "command": "leointeg.diffMarkedNodes",
  "category": "Leo",
  "title": "Diff Marked Nodes"
},
{
  "command": "leointeg.gotoNextMarked",
  "category": "Leo",
  "title": "Goto Next Marked"
},
{
  "command": "leointeg.gotoNextClone",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.markChangedItems",
  "category": "Leo",
  "title": "Mark Changed Items"
},
{
  "command": "leointeg.markSubheads",
  "category": "Leo",
  "title": "Mark Subheads"
},
{
  "command": "leointeg.unmarkAll",
  "category": "Leo",
  "title": "Unmark All"
},
{
  "command": "leointeg.cloneMarkedNodes",
  "category": "Leo",
  "title": "Clone Marked Nodes"
},
{
  "command": "leointeg.deleteMarkedNodes",
  "category": "Leo",
  "title": "Delete Marked Nodes"
},
{
  "command": "leointeg.moveMarkedNodes",
  "category": "Leo",
  "title": "Move Marked Nodes"
}
</t>
<t tx="felix.20200717231719.1">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nStart a local server\n[Start Server](command:leointeg.startServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nStart a local server\n[Start Server](command:leointeg.startServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="felix.20200717231742.1">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="felix.20200717231753.1">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="felix.20200717231803.1">{
  "view": "leoIntegration",
  "contents": "Connecting...",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Connecting...",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; connectToServerAutomatically"
},
</t>
<t tx="felix.20200717231844.1">{
  "view": "leoIntegration",
  "contents": "leoBridge Connected\n[Open Leo File](command:leointeg.openLeoFile)\nView LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "leoBridge Connected\n[Open Leo File](command:leointeg.openLeoFile)\nView LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="felix.20200717232009.1"></t>
<t tx="felix.20200717232019.1"></t>
<t tx="felix.20200717232644.1"></t>
<t tx="felix.20200717233055.1">{
  "view": "leoDocuments",
  "contents": "LeoInteg is not connected",
  "when": "!leoBridgeReady"
},
{
  "view": "leoDocumentsExplorer",
  "contents": "LeoInteg is not connected",
  "when": "!leoBridgeReady"
},
</t>
<t tx="felix.20200717233118.1">{
  "view": "leoDocuments",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoDocumentsExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="felix.20200717233230.1">{
  "view": "leoButtons",
  "contents": "LeoInteg is not connected",
  "when": "!leoBridgeReady"
},
{
  "view": "leoButtonsExplorer",
  "contents": "LeoInteg is not connected",
  "when": "!leoBridgeReady"
},
</t>
<t tx="felix.20200717233257.1">{
  "view": "leoButtons",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoButtonsExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="felix.20200717233318.1">{
  "view": "leoButtons",
  "contents": "There are no @buttons in this outline",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "view": "leoButtonsExplorer",
  "contents": "There are no @buttons in this outline",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
}
</t>
<t tx="felix.20200718001246.1">"commandPalette": [
  @others
],
</t>
<t tx="felix.20200718001311.1">"explorer/context": [
  {
    "command": "leointeg.openLeoFile",
    "when": "resourceScheme == file &amp;&amp; resourceExtname == .leo",
    "group": "navigation@1"
  }
],
</t>
<t tx="felix.20200718001319.1">"view/title": [
  {
    "command": "leointeg.openLeoFile",
    "when": "view =~ /leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "view =~ /leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.showSettingsPage",
    "when": "view =~ /leoIntegration/ &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.connectToServer",
    "when": "view =~ /leoIntegration/ &amp;&amp; !leoBridgeReady &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.openLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoTreeTitled &amp;&amp; leoChanged",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.undoFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanUndo",
    "group": "navigation@3"
  },
  {
    "command": "leointeg.redoFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanRedo",
    "group": "navigation@4"
  },
  {
    "command": "leointeg.deHoistFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanDehoist",
    "group": "navigation@5"
  },
  {
    "command": "leointeg.contractAllFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened",
    "group": "navigation@6"
  }
],
</t>
<t tx="felix.20200718001334.1">"view/item/context": [
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "viewItem =~ /leoDocumentSelectedTitled/ &amp;&amp; leoChanged",
    "group": "inline@1"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "viewItem =~ /leoDocumentSelectedUntitled/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.closeLeoFile",
    "when": "viewItem =~ /leoDocumentSelected/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.editHeadline",
    "when": "showEditOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.insertNode",
    "when": "showAddOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.moveOutlineDown",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineLeft",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineRight",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineUp",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.copyNode",
    "when": "showCopyOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "showCloneOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.mark",
    "when": "showMarkOnNodes &amp;&amp; viewItem =~ /leoNodeUnmarked/",
    "group": "inline@5"
  },
  {
    "command": "leointeg.unmark",
    "when": "showMarkOnNodes &amp;&amp; viewItem =~ /leoNodeMarked/",
    "group": "inline@5"
  },
  {
    "command": "leointeg.openAside",
    "when": "showOpenAside &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext1@1"
  },
  {
    "command": "leointeg.hoistNode",
    "when": "viewItem =~ /leoNodeNotRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.deHoist",
    "when": "leoCanDehoist &amp;&amp; viewItem =~ /leoNodeRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.refreshFromDisk",
    "when": "viewItem =~ /leoNodeAtFile/",
    "group": "leoNodeContext1@3"
  },
  {
    "command": "leointeg.mark",
    "when": "viewItem =~ /leoNodeUnmarked/",
    "group": "leoNodeContext2@1"
  },
  {
    "command": "leointeg.unmark",
    "when": "viewItem =~ /leoNodeMarked/",
    "group": "leoNodeContext2@2"
  },
  {
    "command": "leointeg.copyNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@3"
  },
  {
    "command": "leointeg.cutNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@4"
  },
  {
    "command": "leointeg.pasteNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@5"
  },
  {
    "command": "leointeg.pasteNodeAsClone",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@6"
  },
  {
    "command": "leointeg.delete",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@7"
  },
  {
    "command": "leointeg.insertNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext3@1"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext3@2"
  },
  {
    "command": "leointeg.gotoNextClone",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNodeCloned/",
    "group": "leoNodeContext3@3"
  },
  {
    "command": "leointeg.removeButton",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoButtonNode/",
    "group": "leoButtonContext1@1"
  }
]
</t>
<t tx="felix.20200718001643.1">{
  "command": "leointeg.startServer",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; !leoServerStarted"
},
{
  "command": "leointeg.connectToServer",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="felix.20200718001726.1">{
  "command": "leointeg.openLeoFile",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.switchLeoFile",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "command": "leointeg.newLeoFile",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.closeLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.saveLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.saveAsLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.refreshFromDiskSelection",
  "when": "leoTreeOpened &amp;&amp; leoAtFile"
},
</t>
<t tx="felix.20200718001744.1">{
  "command": "leointeg.showLogPane",
  "when": "leoBridgeReady"
},
</t>
<t tx="felix.20200718001834.1">{
  "command": "leointeg.executeScriptSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.minibuffer",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718001920.1">{
  "command": "leointeg.contractAll",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718001925.1">{
  "command": "leointeg.editSelectedHeadline",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markSelection",
  "when": "leoTreeOpened &amp;&amp; !leoMarked"
},
{
  "command": "leointeg.unmarkSelection",
  "when": "leoTreeOpened &amp;&amp; leoMarked"
},
{
  "command": "leointeg.copyNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cutNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.deleteSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718001929.1">{
  "command": "leointeg.moveOutlineDownSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718001935.1">{
  "command": "leointeg.insertNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.promoteSelection",
  "when": "leoTreeOpened &amp;&amp; leoCanPromote"
},
{
  "command": "leointeg.demoteSelection",
  "when": "leoTreeOpened &amp;&amp; leoCanDemote"
},
{
  "command": "leointeg.sortChildrenSelection",
  "when": "leoTreeOpened &amp;&amp; leoChild"
},
{
  "command": "leointeg.sortSiblingsSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718001940.1">{
  "command": "leointeg.gotoNextMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "when": "leoTreeOpened &amp;&amp; leoCloned"
},
</t>
<t tx="felix.20200718001958.1">{
  "command": "leointeg.hoistSelection",
  "when": "leoTreeOpened &amp;&amp; !leoRoot"
},
{
  "command": "leointeg.deHoist",
  "when": "leoTreeOpened &amp;&amp; leoCanDehoist"
},
</t>
<t tx="felix.20200718002007.1">{
  "command": "leointeg.undo",
  "when": "leoTreeOpened &amp;&amp; leoCanUndo"
},
{
  "command": "leointeg.redo",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718002013.1"></t>
<t tx="felix.20200718002528.1">{
  "command": "leointeg.cloneFindAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindAllFlattened",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindFlattenedMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.extract",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.extractNames",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.copyMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.diffMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markChangedItems",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markSubheads",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.unmarkAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.deleteMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveMarkedNodes",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718003128.1">{
  "command": "leointeg.test",
  "when": "false"
},
</t>
<t tx="felix.20200718003207.1">{
  "command": "leointeg.showBody",
  "when": "false"
},
{
  "command": "leointeg.showOutline",
  "when": "false"
},
</t>
<t tx="felix.20200718003215.1">{
  "command": "leointeg.saveLeoFileFromOutline",
  "when": "false"
},
{
  "command": "leointeg.refreshFromDisk",
  "when": "false"
},
{
  "command": "leointeg.refreshFromDiskSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20200718003223.1">{
  "command": "leointeg.selectTreeNode",
  "when": "false"
},
{
  "command": "leointeg.openAside",
  "when": "false"
},
{
  "command": "leointeg.contractAllFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20200718003227.1">{
  "command": "leointeg.editHeadline",
  "when": "false"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "when": "false"
},
{
  "command": "leointeg.mark",
  "when": "false"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.unmark",
  "when": "false"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.copyNode",
  "when": "false"
},
{
  "command": "leointeg.cutNode",
  "when": "false"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.pasteNode",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAsClone",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.delete",
  "when": "false"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20200718003236.1">{
  "command": "leointeg.moveOutlineDown",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineLeft",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineRight",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineUp",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20200718003239.1">{
  "command": "leointeg.insertNode",
  "when": "false"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "when": "false"
},
{
  "command": "leointeg.cloneNode",
  "when": "false"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.promote",
  "when": "false"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.demote",
  "when": "false"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20200718003243.1">{
  "command": "leointeg.gotoNextClone",
  "when": "false"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.gotoFirstVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoLastVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoLastSibling",
  "when": "false"
},
{
  "command": "leointeg.gotoNextVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoPrevVisible",
  "when": "false"
},
{
  "command": "leointeg.contractOrGoLeft",
  "when": "false"
},
{
  "command": "leointeg.expandAndGoRight",
  "when": "false"
},
</t>
<t tx="felix.20200718003251.1">{
  "command": "leointeg.hoistNode",
  "when": "false"
},
{
  "command": "leointeg.hoistSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.deHoistFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20200718003259.1">{
  "command": "leointeg.undoFromOutline",
  "when": "false"
},
{
  "command": "leointeg.redoFromOutline",
  "when": "false"
}
</t>
<t tx="felix.20200718005357.1">{
  "command": "leointeg.executeScriptSelection",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.executeScriptSelection",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.minibuffer",
  "key": "alt+x",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718005412.1">{
  "command": "leointeg.showOutline",
  "key": "alt+t",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.showOutline",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.showBody",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "alt+d",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "tab",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "enter",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="felix.20200718005425.1">{
  "command": "leointeg.saveLeoFileFromOutline",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments/"
},
{
  "command": "leointeg.saveLeoFile",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
</t>
<t tx="felix.20200718005440.1">{
  "command": "leointeg.contractAll",
  "key": "alt+-",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.contractAllFromOutline",
  "key": "alt+-",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
</t>
<t tx="felix.20200718005444.1">{
"command": "leointeg.editSelectedHeadline",
"key": "ctrl+h",
"mac": "cmd+h",
"when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
"command": "leointeg.editSelectedHeadlineFromOutline",
"key": "ctrl+h",
"mac": "cmd+h",
"when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
"command": "leointeg.markSelection",
"key": "ctrl+m",
"mac": "cmd+m",
"when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
"command": "leointeg.markSelectionFromOutline",
"key": "ctrl+m",
"mac": "cmd+m",
"when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
"command": "leointeg.unmarkSelection",
"key": "ctrl+m",
"mac": "cmd+m",
"when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
"command": "leointeg.unmarkSelectionFromOutline",
"key": "ctrl+m",
"mac": "cmd+m",
"when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="felix.20200718005448.1">{
  "command": "leointeg.moveOutlineDownSelection",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineDownSelection",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="felix.20200718005453.1">{
  "command": "leointeg.sortSiblingsSelection",
  "key": "alt+a",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "key": "alt+a",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.promoteSelection",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.demoteSelection",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelection",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; !sideBarFocus &amp;&amp; !editorTextFocus"
},
{
  "command": "leointeg.cloneNodeSelection",
  "key": "ctrl+[Backquote]",
  "win": "ctrl+oem_7",
  "linux": "ctrl+'",
  "mac": "cmd+[Backquote]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "key": "ctrl+[Backquote]",
  "win": "ctrl+oem_7",
  "linux": "ctrl+'",
  "mac": "cmd+[Backquote]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.cutNodeSelection",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.deleteSelection",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="felix.20200718005458.1">{
  "command": "leointeg.gotoFirstVisible",
  "key": "alt+home",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoLastSibling",
  "key": "alt+end",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoFirstVisible",
  "key": "home",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoLastVisible",
  "key": "end",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.pageUp",
  "key": "pageup",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.pageDown",
  "key": "pagedown",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "key": "alt+n",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "key": "alt+n",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "down",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "alt+down",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "up",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "alt+up",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection  &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "left",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "alt+left",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "right",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "alt+right",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
}
</t>
<t tx="felix.20200718020912.1">import * as vscode from "vscode";

@others
@language typescript
@tabwidth -4
</t>
<t tx="felix.20200718020912.10">/**
 * * Actions that can be invoked by Leo through leobridge
 */
public static ASYNC_ACTIONS = {
    ASYNC_LOG: "log",
    ASYNC_ASK: "ask",
    ASYNC_WARN: "warn",
    ASYNC_INFO: "info",
    ASYNC_INTERVAL: "interval"
};

</t>
<t tx="felix.20200718020912.11">/**
 * * When async action was ASYNC_INFO
 */
public static ASYNC_INFO_MESSAGE_CODES = {
    ASYNC_REFRESHED: "refreshed",
    ASYNC_IGNORED: "ignored"
};

</t>
<t tx="felix.20200718020912.12">/**
 * * runAskYesNoDialog or runAskOkDialog result codes, used when async action requires a response
 */
public static ASYNC_ASK_RETURN_CODES = {
    YES: "yes",
    NO: "no",
    YES_ALL: "yes-all",
    NO_ALL: "no-all",
    OK: '"ok"' // Quotes in string as a 'JSON parameter'
};

</t>
<t tx="felix.20200718020912.13">/**
 * * Commands for leobridgeserver.py
 */
public static LEOBRIDGE = {
    APPLY_CONFIG: "applyConfig",
    ASK_RESULT: "askResult",
    GET_ALL_GNX: "getAllGnx",
    GET_BODY_LENGTH: "getBodyLength",
    GET_BODY: "getBody",
    GET_PNODE: "getPNode",
    GET_PARENT: "getParent",
    GET_CHILDREN: "getChildren",
    GET_SELECTED_NODE: "getSelectedNode",
    SET_SELECTED_NODE: "setSelectedNode",
    SET_BODY: "setBody",
    SET_HEADLINE: "setNewHeadline",
    EXPAND_NODE: "expandNode",
    COLLAPSE_NODE: "collapseNode",
    CONTRACT_ALL: "contractAll",
    GET_OPENED_FILES: "getOpenedFiles",
    SET_OPENED_FILE: "setOpenedFile", // Pass index ? name to validate / error check, only index when stable
    OPEN_FILE: "openFile",
    CLOSE_FILE: "closeFile",
    SAVE_FILE: "saveFile",
    SAVE_CLOSE_FILE: "saveCloseFile", // Save and close current document
    GET_BUTTONS: "getButtons",
    REMOVE_BUTTON: "removeButton",
    CLICK_BUTTON: "clickButton",
    GET_COMMANDS: "getCommands", // ask leoBridge for the list of known commands
    RUN_BY_NAME: "runByName", // Run a command by its string name like in minibuffer
    // * Goto operations
    PAGE_UP: "pageUp",
    PAGE_DOWN: "pageDown",
    GOTO_FIRST_VISIBLE: "gotoFirstVisible",
    GOTO_LAST_VISIBLE: "gotoLastVisible",
    GOTO_LAST_SIBLING: "gotoLastSibling",
    GOTO_NEXT_VISIBLE: "gotoNextVisible",
    GOTO_PREV_VISIBLE: "gotoPrevVisible",
    GOTO_NEXT_MARKED: "gotoNextMarked",
    GOTO_NEXT_CLONE: "gotoNextClone",
    CONTRACT_OR_GO_LEFT: "contractOrGoLeft",
    EXPAND_AND_GO_RIGHT: "expandAndGoRight",
    // * Leo Operations
    MARK_PNODE: "markPNode",
    UNMARK_PNODE: "unmarkPNode",
    COPY_PNODE: "copyPNode",
    CUT_PNODE: "cutPNode",
    PASTE_PNODE: "pastePNode",
    PASTE_CLONE_PNODE: "pasteAsClonePNode",
    DELETE_PNODE: "deletePNode",
    MOVE_PNODE_DOWN: "movePNodeDown",
    MOVE_PNODE_LEFT: "movePNodeLeft",
    MOVE_PNODE_RIGHT: "movePNodeRight",
    MOVE_PNODE_UP: "movePNodeUp",
    INSERT_PNODE: "insertPNode",
    INSERT_NAMED_PNODE: "insertNamedPNode",
    CLONE_PNODE: "clonePNode",
    PROMOTE_PNODE: "promotePNode",
    DEMOTE_PNODE: "demotePNode",
    REFRESH_FROM_DISK_PNODE: "refreshFromDiskPNode",
    SORT_CHILDREN: "sortChildrenPNode",
    SORT_SIBLINGS: "sortSiblingsPNode",
    UNDO: "undo",
    REDO: "redo",
    EXECUTE_SCRIPT: "executeScript",
    GET_STATES: "getStates",
    HOIST_PNODE: "hoistPNode",
    DEHOIST: "deHoist",
    // TODO : @boltex More commands to implement #15, #23, #24
    CLONE_FIND_ALL: "cloneFindAll", // #24 @boltex
    CLONE_FIND_ALL_FLATTENED: "cloneFindAllFlattened", // #24 @boltex
    CLONE_FIND_MARKED: "cloneFindMarked", // #24 @boltex
    CLONE_FIND_FLATTENED_MARKED: "cloneFindFlattenedMarked", // #24 @boltex
    EXTRACT: "extract", // #15 @boltex
    EXTRACT_NAMES: "extractNames", // #15 @boltex
    COPY_MARKED: "copyMarked", // #23 @boltex
    DIFF_MARKED_NODES: "diffMarkedNodes", // #23 @boltex
    MARK_CHANGED_ITEMS: "markChangedItems", // #23 @boltex
    MARK_SUBHEADS: "markSubheads", // #23 @boltex
    UNMARK_ALL: "unmarkAll", // #23 @boltex
    CLONE_MARKED_NODES: "cloneMarkedNodes", // #23 @boltex
    DELETE_MARKED_NODES: "deleteMarkedNodes", // #23 @boltex
    MOVE_MARKED_NODES: "moveMarkedNodes" // #23 @boltex
};

</t>
<t tx="felix.20200718020912.14">/**
 * * Command strings to be used with vscode.commands.executeCommand
 * See https://code.visualstudio.com/api/extension-guides/command#programmatically-executing-a-command
 */
public static VSCODE_COMMANDS = {
    SET_CONTEXT: "setContext",
    CLOSE_ACTIVE_EDITOR: "workbench.action.closeActiveEditor",
    QUICK_OPEN: "workbench.action.quickOpen"
};

</t>
<t tx="felix.20200718020912.15">/**
 * * All commands this expansion exposes (in package.json, contributes &gt; commands)
 */
public static COMMANDS = {
    SHOW_WELCOME: Constants.NAME + ".showWelcomePage", // Always available: not in the commandPalette section of package.json
    SHOW_SETTINGS: Constants.NAME + ".showSettingsPage", // Always available: not in the commandPalette section of package.json
    // * LeoBridge
    START_SERVER: Constants.NAME + ".startServer",
    CONNECT: Constants.NAME + ".connectToServer",
    SET_OPENED_FILE: Constants.NAME + ".setOpenedFile",
    OPEN_FILE: Constants.NAME + ".openLeoFile", // sets focus on BODY
    SWITCH_FILE: Constants.NAME + ".switchLeoFile",
    NEW_FILE: Constants.NAME + ".newLeoFile",
    SAVE_FILE: Constants.NAME + ".saveLeoFile", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
    SAVE_FILE_FO: Constants.NAME + ".saveLeoFileFromOutline", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
    SAVE_AS_FILE: Constants.NAME + ".saveAsLeoFile",
    CLOSE_FILE: Constants.NAME + ".closeLeoFile",
    CLICK_BUTTON: Constants.NAME + ".clickButton",
    REMOVE_BUTTON: Constants.NAME + ".removeButton",
    MINIBUFFER: Constants.NAME + ".minibuffer",
    // * Outline selection
    SELECT_NODE: Constants.NAME + ".selectTreeNode",
    OPEN_ASIDE: Constants.NAME + ".openAside",
    // * Goto operations that always finish with focus in outline
    PAGE_UP: Constants.NAME + ".pageUp",
    PAGE_DOWN: Constants.NAME + ".pageDown",
    GOTO_FIRST_VISIBLE: Constants.NAME + ".gotoFirstVisible",
    GOTO_LAST_VISIBLE: Constants.NAME + ".gotoLastVisible",
    GOTO_LAST_SIBLING: Constants.NAME + ".gotoLastSibling",
    GOTO_NEXT_VISIBLE: Constants.NAME + ".gotoNextVisible",
    GOTO_PREV_VISIBLE: Constants.NAME + ".gotoPrevVisible",
    GOTO_NEXT_MARKED: Constants.NAME + ".gotoNextMarked",
    GOTO_NEXT_CLONE: Constants.NAME + ".gotoNextClone",
    GOTO_NEXT_CLONE_SELECTION: Constants.NAME + ".gotoNextCloneSelection",
    GOTO_NEXT_CLONE_SELECTION_FO: Constants.NAME + ".gotoNextCloneSelectionFromOutline",
    CONTRACT_OR_GO_LEFT: Constants.NAME + ".contractOrGoLeft",
    EXPAND_AND_GO_RIGHT: Constants.NAME + ".expandAndGoRight",
    // * Leo Operations
    UNDO: Constants.NAME + ".undo", // From command Palette
    UNDO_FO: Constants.NAME + ".undoFromOutline", // from button, return focus on OUTLINE
    REDO: Constants.NAME + ".redo", // From command Palette
    REDO_FO: Constants.NAME + ".redoFromOutline", // from button, return focus on OUTLINE
    EXECUTE: Constants.NAME + ".executeScriptSelection", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
    SHOW_BODY: Constants.NAME + ".showBody",
    SHOW_OUTLINE: Constants.NAME + ".showOutline",
    SHOW_LOG: Constants.NAME + ".showLogPane",
    SORT_CHILDREN: Constants.NAME + ".sortChildrenSelection", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
    SORT_SIBLING: Constants.NAME + ".sortSiblingsSelection",
    SORT_SIBLING_FO: Constants.NAME + ".sortSiblingsSelectionFromOutline",
    CONTRACT_ALL: Constants.NAME + ".contractAll", // From command Palette
    CONTRACT_ALL_FO: Constants.NAME + ".contractAllFromOutline", // from button, return focus on OUTLINE
    // * Commands from tree panel buttons or context: focus on OUTLINE
    MARK: Constants.NAME + ".mark",
    UNMARK: Constants.NAME + ".unmark",
    COPY: Constants.NAME + ".copyNode",
    CUT: Constants.NAME + ".cutNode",
    PASTE: Constants.NAME + ".pasteNode",
    PASTE_CLONE: Constants.NAME + ".pasteNodeAsClone",
    DELETE: Constants.NAME + ".delete",
    HEADLINE: Constants.NAME + ".editHeadline",
    MOVE_DOWN: Constants.NAME + ".moveOutlineDown",
    MOVE_LEFT: Constants.NAME + ".moveOutlineLeft",
    MOVE_RIGHT: Constants.NAME + ".moveOutlineRight",
    MOVE_UP: Constants.NAME + ".moveOutlineUp",
    INSERT: Constants.NAME + ".insertNode",
    CLONE: Constants.NAME + ".cloneNode",
    PROMOTE: Constants.NAME + ".promote",
    DEMOTE: Constants.NAME + ".demote",
    REFRESH_FROM_DISK: Constants.NAME + ".refreshFromDisk",
    // * Commands from keyboard, while focus on BODY (command-palette returns to BODY for now)
    MARK_SELECTION: Constants.NAME + ".markSelection",
    UNMARK_SELECTION: Constants.NAME + ".unmarkSelection",
    COPY_SELECTION: Constants.NAME + ".copyNodeSelection", // Nothing to refresh/focus so no "FO" version
    CUT_SELECTION: Constants.NAME + ".cutNodeSelection",
    PASTE_SELECTION: Constants.NAME + ".pasteNodeAtSelection",
    PASTE_CLONE_SELECTION: Constants.NAME + ".pasteNodeAsCloneAtSelection",
    DELETE_SELECTION: Constants.NAME + ".deleteSelection",
    HEADLINE_SELECTION: Constants.NAME + ".editSelectedHeadline",
    MOVE_DOWN_SELECTION: Constants.NAME + ".moveOutlineDownSelection",
    MOVE_LEFT_SELECTION: Constants.NAME + ".moveOutlineLeftSelection",
    MOVE_RIGHT_SELECTION: Constants.NAME + ".moveOutlineRightSelection",
    MOVE_UP_SELECTION: Constants.NAME + ".moveOutlineUpSelection",
    INSERT_SELECTION: Constants.NAME + ".insertNodeSelection",
    INSERT_SELECTION_INTERRUPT: Constants.NAME + ".insertNodeSelectionInterrupt", // Headline input box can be interrupted with another insert
    CLONE_SELECTION: Constants.NAME + ".cloneNodeSelection",
    PROMOTE_SELECTION: Constants.NAME + ".promoteSelection",
    DEMOTE_SELECTION: Constants.NAME + ".demoteSelection",
    REFRESH_FROM_DISK_SELECTION: Constants.NAME + ".refreshFromDiskSelection",
    // * Commands from keyboard, while focus on OUTLINE
    MARK_SELECTION_FO: Constants.NAME + ".markSelectionFromOutline",
    UNMARK_SELECTION_FO: Constants.NAME + ".unmarkSelectionFromOutline",
    // COPY_SELECTION Nothing to refresh/focus for "copy a node" so no entry here
    CUT_SELECTION_FO: Constants.NAME + ".cutNodeSelectionFromOutline",
    PASTE_SELECTION_FO: Constants.NAME + ".pasteNodeAtSelectionFromOutline",
    PASTE_CLONE_SELECTION_FO: Constants.NAME + ".pasteNodeAsCloneAtSelectionFromOutline",
    DELETE_SELECTION_FO: Constants.NAME + ".deleteSelectionFromOutline",
    HEADLINE_SELECTION_FO: Constants.NAME + ".editSelectedHeadlineFromOutline",
    MOVE_DOWN_SELECTION_FO: Constants.NAME + ".moveOutlineDownSelectionFromOutline",
    MOVE_LEFT_SELECTION_FO: Constants.NAME + ".moveOutlineLeftSelectionFromOutline",
    MOVE_RIGHT_SELECTION_FO: Constants.NAME + ".moveOutlineRightSelectionFromOutline",
    MOVE_UP_SELECTION_FO: Constants.NAME + ".moveOutlineUpSelectionFromOutline",
    INSERT_SELECTION_FO: Constants.NAME + ".insertNodeSelectionFromOutline",
    CLONE_SELECTION_FO: Constants.NAME + ".cloneNodeSelectionFromOutline",
    PROMOTE_SELECTION_FO: Constants.NAME + ".promoteSelectionFromOutline",
    DEMOTE_SELECTION_FO: Constants.NAME + ".demoteSelectionFromOutline",
    REFRESH_FROM_DISK_SELECTION_FO: Constants.NAME + ".refreshFromDiskSelectionFromOutline",
    HOIST: Constants.NAME + ".hoistNode",
    HOIST_SELECTION: Constants.NAME + ".hoistSelection",
    HOIST_SELECTION_FO: Constants.NAME + ".hoistSelectionFromOutline",
    DEHOIST: Constants.NAME + ".deHoist",
    DEHOIST_FO: Constants.NAME + ".deHoistFromOutline",
    // * - - - - - - - - - - - - - - - not implemented yet
    CLONE_FIND_ALL: Constants.NAME + ".cloneFindAll",
    CLONE_FIND_ALL_FLATTENED: Constants.NAME + ".cloneFindAllFlattened",
    CLONE_FIND_MARKED: Constants.NAME + ".cloneFindMarked",
    CLONE_FIND_FLATTENED_MARKED: Constants.NAME + ".cloneFindFlattenedMarked",
    EXTRACT: Constants.NAME + ".extract",
    EXTRACT_NAMES: Constants.NAME + ".extractNames",
    COPY_MARKED: Constants.NAME + ".copyMarked",
    DIFF_MARKED_NODES: Constants.NAME + ".diffMarkedNodes",
    MARK_CHANGED_ITEMS: Constants.NAME + ".markChangedItems",
    MARK_SUBHEADS: Constants.NAME + ".markSubheads",
    UNMARK_ALL: Constants.NAME + ".unmarkAll",
    CLONE_MARKED_NODES: Constants.NAME + ".cloneMarkedNodes",
    DELETE_MARKED_NODES: Constants.NAME + ".deleteMarkedNodes",
    MOVE_MARKED_NODES: Constants.NAME + ".moveMarkedNodes"
};
</t>
<t tx="felix.20200718020912.2">/**
 * * Text and numeric constants used throughout leoInteg
 */
export class Constants {

    @others
}
</t>
<t tx="felix.20200718020912.3">public static PUBLISHER: string = "boltex";
public static NAME: string = "leointeg";
public static CONFIG_NAME: string = "leoIntegration";
public static CONFIG_REFRESH_MATCH: string = "OnNodes"; // substring to distinguish 'on-hover' icon commands

public static TREEVIEW_ID: string = Constants.CONFIG_NAME;
public static TREEVIEW_EXPLORER_ID: string = Constants.CONFIG_NAME + "Explorer";

public static DOCUMENTS_ID: string = "leoDocuments";
public static DOCUMENTS_EXPLORER_ID: string = "leoDocumentsExplorer";

public static BUTTONS_ID: string = "leoButtons";
public static BUTTONS_EXPLORER_ID: string = "leoButtonsExplorer";

public static VERSION_STATE_KEY: string = "leoIntegVersion";

public static FILE_EXTENSION: string = "leo";
public static URI_LEO_SCHEME: string = "leo";
public static URI_FILE_SCHEME: string = "file";
public static URI_SCHEME_HEADER: string = "leo:/";
public static FILE_OPEN_FILTER_MESSAGE: string = "Leo Files";
public static UNTITLED_FILE_NAME: string = "untitled";
public static RECENT_FILES_KEY: string = "leoFiles";

public static DEFAULT_PYTHON: string = "python3.7";
public static WIN32_PYTHON: string = "py";
public static SERVER_PATH: string = "/leobridgeserver.py";
public static SERVER_STARTED_TOKEN: string = "LeoBridge started";

public static TCPIP_DEFAULT_PORT: number = 32125;
public static TCPIP_DEFAULT_PROTOCOL: string = "ws://";
public static TCPIP_DEFAULT_ADDRESS: string = "localhost";

public static ERROR_PACKAGE_ID: number = 0;
public static STARTING_PACKAGE_ID: number = 1;
public static STATUSBAR_DEBOUNCE_DELAY: number = 50;
public static STATES_DEBOUNCE_DELAY: number = 200; // a fifth of a second after command stack completion

</t>
<t tx="felix.20200718020912.4">/**
 * * Strings used as language id (default is "leobody")
 * TODO : #56 @boltex Add more languages strings for when directives such as @language are used throughout body panes
 */
public static BODY_LANGUAGES = {
    default: "leobody"
};

</t>
<t tx="felix.20200718020912.5">/**
 * * Strings used in the workbench interface panels (not for messages or dialogs)
 */
public static GUI = {
    ICON_LIGHT_DOCUMENT: "resources/light/document.svg",
    ICON_DARK_DOCUMENT: "resources/dark/document.svg",
    ICON_LIGHT_DOCUMENT_DIRTY: "resources/light/document-dirty.svg",
    ICON_DARK_DOCUMENT_DIRTY: "resources/dark/document-dirty.svg",
    ICON_LIGHT_BUTTON: "resources/light/button.svg",
    ICON_DARK_BUTTON: "resources/dark/button.svg",
    ICON_LIGHT_BUTTON_ADD: "resources/light/button-add.svg",
    ICON_DARK_BUTTON_ADD: "resources/dark/button-add.svg",
    ICON_LIGHT_PATH: "resources/light/box",
    ICON_DARK_PATH: "resources/dark/box",
    ICON_FILE_EXT: ".svg",
    STATUSBAR_DEFAULT_COLOR: "fb7c47",
    STATUSBAR_DEFAULT_STRING: "", // Strings like "Literate", "Leo", UTF-8 also supported: 
    STATUSBAR_INDICATOR: "$(keyboard) ",
    QUICK_OPEN_LEO_COMMANDS: "&gt;leo: ",
    EXPLORER_TREEVIEW_PREFIX: "LEO ",
    TREEVIEW_TITLE: "OUTLINE",
    TREEVIEW_TITLE_NOT_CONNECTED: "NOT CONNECTED",
    TREEVIEW_TITLE_CONNECTED: "CONNECTED",
    TREEVIEW_TITLE_INTEGRATION: "INTEGRATION",
    BODY_TITLE: "LEO BODY",
    LOG_PANE_TITLE: "Leo Log Window",
    TERMINAL_PANE_TITLE: "LeoBridge Server",
    THEME_STATUSBAR: "statusBar.foreground"
};

</t>
<t tx="felix.20200718020912.6">/**
 * * Basic user messages strings for messages and dialogs
 */
public static USER_MESSAGES = {
    SCRIPT_BUTTON: "Creates a button from selected node's script",
    SCRIPT_BUTTON_TOOLTIP:
        "The 'Script Button' button creates a new button.\n" +
        "Its name will be the headline of the presently selected node\n" +
        "Hitting this newly created button executes the button's script.\n" +
        "\n" +
        "For example, to run a script on any part of an outline:\n" +
        "\n" +
        "1.  Select the node containing the script.\n" +
        "2.  Press 'Script Button'. This will create a new button.\n" +
        "3.  Select the node on which you want to run the script.\n" +
        "4.  Press the *new* button.",
    SAVE_CHANGES: "Save changes to",
    BEFORE_CLOSING: "before closing?",
    CANCEL: "Cancel",
    OPEN_WITH_LEOINTEG: "Open this Leo file with LeoInteg?",
    FILE_ALREADY_OPENED: "Leo file already opened",
    CHOOSE_OPENED_FILE: "Select an opened Leo File",
    FILE_NOT_OPENED: "No files opened.",
    STATUSBAR_TOOLTIP_ON: "Leo Key Bindings are in effect", // TODO : Add description of what happens if clicked
    STATUSBAR_TOOLTIP_OFF: "Leo Key Bindings off", // TODO : Add description of what happens if clicked
    PROMPT_EDIT_HEADLINE: "Edit Headline",
    PROMPT_INSERT_NODE: "Insert Node",
    DEFAULT_HEADLINE: "New Headline",
    START_SERVER_ERROR: "Error - Cannot start server: ",
    CONNECT_FAILED: "Leo Bridge Connection Failed",
    CONNECT_ERROR: "Leo Bridge Connection Error: Incorrect id",
    CONNECTED: "Connected",
    ALREADY_CONNECTED: "Already connected",
    DISCONNECTED: "Disconnected",
    CLOSE_ERROR: "Cannot close: No files opened.",
    YES: "Yes",
    NO: "No",
    YES_ALL: "Yes to all",
    NO_ALL: "No to all",
    CHANGES_DETECTED: "Changes to external files were detected.",
    REFRESHED: " Nodes were refreshed from file.", // with voluntary leading space
    IGNORED: " They were ignored.", // with voluntary leading space
    TOO_FAST: "leoInteg is busy! " // with voluntary trailing space
};

</t>
<t tx="felix.20200718020912.7">/**
 * * Choices offered when about to lose current changes to a Leo Document
 */
public static ASK_SAVE_CHANGES_BUTTONS: vscode.MessageItem[] = [
    {
        title: Constants.USER_MESSAGES.YES,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.NO,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.CANCEL,
        isCloseAffordance: true
    }
];

</t>
<t tx="felix.20200718020912.8">/**
 * * String for JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public static CONFIG = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "checkForChangeExternalFiles",
    DEFAULT_RELOAD_IGNORE: "defaultReloadIgnore",
    LEO_TREE_BROWSE: "leoTreeBrowse",
    TREE_KEEP_FOCUS: "treeKeepFocus",
    TREE_KEEP_FOCUS_WHEN_ASIDE: "treeKeepFocusWhenAside",
    STATUSBAR_STRING: "statusBarString",
    STATUSBAR_COLOR: "statusBarColor",
    TREE_IN_EXPLORER: "treeInExplorer",
    SHOW_OPEN_ASIDE: "showOpenAside",
    SHOW_EDIT: "showEditOnNodes",
    SHOW_ARROWS: "showArrowsOnNodes",
    SHOW_ADD: "showAddOnNodes",
    SHOW_MARK: "showMarkOnNodes",
    SHOW_CLONE: "showCloneOnNodes",
    SHOW_COPY: "showCopyOnNodes",
    INVERT_NODES: "invertNodeContrast",
    LEO_PYTHON_COMMAND: "leoPythonCommand",
    AUTO_START_SERVER: "startServerAutomatically",
    AUTO_CONNECT: "connectToServerAutomatically",
    IP_ADDRESS: "connectionAddress",
    IP_PORT: "connectionPort",
};

</t>
<t tx="felix.20200718020912.9">/**
 * * Used in 'when' clauses, set with vscode.commands.executeCommand("setContext",...)
 */
public static CONTEXT_FLAGS = {
    // Main flags for connection and opened file
    BRIDGE_READY: "leoBridgeReady", // Connected to leoBridge
    TREE_OPENED: "leoTreeOpened", // At least one Leo file opened
    TREE_TITLED: "leoTreeTitled", // Tree is a Leo file and not a new untitled document
    SERVER_STARTED: "leoServerStarted", // Auto-start or manually started
    // 'states' flags for currently opened tree view
    LEO_CHANGED: "leoChanged",
    LEO_CAN_UNDO: "leoCanUndo",
    LEO_CAN_REDO: "leoCanRedo",
    LEO_CAN_DEMOTE: "leoCanDemote",
    LEO_CAN_PROMOTE: "leoCanPromote",
    LEO_CAN_DEHOIST: "leoCanDehoist",
    // 'states' flags about current selection, for visibility and commands availability
    SELECTED_MARKED: "leoMarked", // no need for unmarked here, use !leoMarked
    SELECTED_CLONE: "leoCloned",
    SELECTED_DIRTY: "leoDirty",
    SELECTED_EMPTY: "leoEmpty",
    SELECTED_CHILD: "leoChild", // Has children
    SELECTED_ATFILE: "LeoAtFile", // Can be refreshed
    SELECTED_ROOT: "leoRoot", // ! Not given by Leo: Computed by leoInteg/vscode instead
    // Statusbar Flag 'keybindings in effect'
    LEO_SELECTED: "leoObjectSelected", // keybindings "On": Outline or body has focus
    // Context Flags for 'when' clauses, used concatenated, for each outline node
    NODE_MARKED: "leoNodeMarked",  // Selected node is marked
    NODE_UNMARKED: "leoNodeUnmarked", // Selected node is unmarked (Needed for regexp)
    NODE_ATFILE: "leoNodeAtFile", // Selected node is an @file or @clean, etc...
    NODE_CLONED: "leoNodeCloned",
    NODE_ROOT: "leoNodeRoot",
    NODE_NOT_ROOT: "leoNodeNotRoot",
    // Flags for Leo documents tree view icons and hover node command buttons
    DOCUMENT_SELECTED_TITLED: "leoDocumentSelectedTitled",
    DOCUMENT_TITLED: "leoDocumentTitled",
    DOCUMENT_SELECTED_UNTITLED: "leoDocumentSelectedUntitled",
    DOCUMENT_UNTITLED: "leoDocumentUntitled",
    // Flags that match specific LeoInteg config settings
    LEO_TREE_BROWSE: Constants.CONFIG.LEO_TREE_BROWSE, // Leo outline also in the explorer view
    TREE_IN_EXPLORER: Constants.CONFIG.TREE_IN_EXPLORER, // Leo outline also in the explorer view
    SHOW_OPEN_ASIDE: Constants.CONFIG.SHOW_OPEN_ASIDE,   // Show 'open aside' in context menu
    SHOW_EDIT: Constants.CONFIG.SHOW_EDIT,              // Hover Icons on outline nodes
    SHOW_ARROWS: Constants.CONFIG.SHOW_ARROWS,           // Hover Icons on outline nodes
    SHOW_ADD: Constants.CONFIG.SHOW_ADD,                 // Hover Icons on outline nodes
    SHOW_MARK: Constants.CONFIG.SHOW_MARK,               // Hover Icons on outline nodes
    SHOW_CLONE: Constants.CONFIG.SHOW_CLONE,             // Hover Icons on outline nodes
    SHOW_COPY: Constants.CONFIG.SHOW_COPY,               // Hover Icons on outline nodes
    AUTO_START_SERVER: Constants.CONFIG.AUTO_START_SERVER,   // Used at startup
    AUTO_CONNECT: Constants.CONFIG.AUTO_CONNECT              // Used at startup
};

</t>
<t tx="felix.20200718024635.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { UserCommand, RefreshType, LeoBridgePackage } from "./types";
import { LeoIntegration } from "./leoIntegration";

@others
@language typescript
@tabwidth -4
</t>
<t tx="felix.20200718024635.2">/**
 * * Front-facing, user command stack of actions. 
 * Actions can also be added once started resolving.
 */
export class CommandStack {

    private _stack: UserCommand[] = [];
    private _busy: boolean = false;

    // Refresh type, for after the last command is done. (From highest so far)
    private _finalRefreshType: RefreshType = RefreshType.NoRefresh; 
    
    // Flag indicating to set focus on outline when all done, instead of body. (From last one pushed)
    private _finalFromOutline: boolean = false; 

    // * Received selection from the last command that finished.
    // * Note: JSON string representation of a node, will be re-sent as node to leo instead of lastSelectedNode
    private _receivedSelection: string = ""; // Selected node that was received from last command from a running stack. Empty string is used as 'false'.

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._busy = false;
    }

    @others
}
</t>
<t tx="felix.20200718024635.3">/**
 * * Get command stack size
 * @returns the number of actions on the command stack
 */
public size(): number {
    return this._stack.length;
}

</t>
<t tx="felix.20200718024635.4">/**
 * * Signal to the command stack that a new selected node was received. 
 * This command stacks needs to know when to clear its own '_receivedSelection'
 */
public newSelection(): void {
    if (!this._busy) {
        this._receivedSelection = "";
    }
}

</t>
<t tx="felix.20200718024635.5">/**
 * * Adds on top and try to execute the bottom command if not already running
 * @param p_command is an object that has the action, node, refresh type and 'fromOutline' flag
 * @returns true if added, false if it could not due to stack 'rules':
 *  - Targeted command (for a specific node) can only be added on an empty stack
 */
public add(p_command: UserCommand): boolean {
    if (this.size() &amp;&amp; p_command.node) {
        // If already started we only if if action requires generic selected node as param
        return false;
    } else {
        this._stack.push(p_command);
        // This flag is set on command entered, not when finally executed because a rapid type in editor can override focus
        this._finalFromOutline = p_command.fromOutline; // use the last _finalFromOutline regardless of previous so change now
        this._tryStart();
        return true;
    }
}

</t>
<t tx="felix.20200718024635.6">/**
 * * Try to launch commands that were added on the stack, if any.
 */
private _tryStart(): void {
    if (this.size() &amp;&amp; !this._busy) {

        // actions have beed added and command stack instance is not busy, so set the busy flag and start from the bottom
        this._busy = true; // Cleared when the last command has returned (and the stack is empty)

        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}

</t>
<t tx="felix.20200718024635.7">/**
 * * Run the command at index 0: The bottom of the stack.
 */
private _runStackCommand(): Promise&lt;LeoBridgePackage&gt; {
    // console.log('Running from a stack of', this._stack.length);

    const w_command = this._stack[0]; // Reference from bottom of stack, don't remove yet

    // Build parameter's json here - use providedHeadline if needed
    let w_nodeJson: string = ""; // ap json used in building w_jsonParam
    let w_jsonParam: string = ""; // Finished parameter that is sent

    // First one uses given node or last selected node, other subsequent on stack will use _receivedSelection
    // (Commands such as 'collapse all' will just ignore passed on node parameter)
    const w_providedHeadline = w_command.providedHeadline; // Can be undefined
    if (w_command.node) {
        // console.log('USING SPECIFIC Node');

        w_nodeJson = w_command.node.apJson; // Was node specific, so we are starting from a new stack of commands
    } else {
        // Use received "selected node" unless first, then use last selected node
        // console.log(`NOT SPECIFIC node, busy is ${this._busy}`);

        if (this._receivedSelection) {
            // console.log('USING LAST _receivedSelection, SHOULD SEE NEXT ABOVE!');

            w_nodeJson = this._receivedSelection;
        } else {
            // console.log('USING LAST lastSelectedNode');

            w_nodeJson = this._leoIntegration.lastSelectedNode!.apJson;
        }
        if (!w_nodeJson) {
            console.log('ERROR NO ARCHIVED POSITION JSON');
        }
    }
    if (w_providedHeadline) {
        w_jsonParam = utils.buildNodeAndTextJson(w_nodeJson, w_providedHeadline); // 'Insert Named Node' or 'Edit Headline'
    } else {
        w_jsonParam = w_nodeJson; // 'Insert Unnamed Node' or regular command
    }

    // Setup _finalRefreshType, if higher than the one setup so far
    this._finalRefreshType = w_command.refreshType &gt; this._finalRefreshType ? w_command.refreshType : this._finalRefreshType;

    // Submit this action to Leo and return a promise of its packaged answer
    return this._leoIntegration.sendAction(w_command.action, w_jsonParam);
}

</t>
<t tx="felix.20200718024635.8">/**
 * * Handle the result from the command that has finished: either launch the next one, or refresh accordingly.
 * @param p_package is the json return 'package' that was just received back from Leo
 */
private _resolveResult(p_package: LeoBridgePackage): void {
    this._stack.shift();
    // If last is done then do refresh outline and focus on outline, or body
    // console.log('p_package :', p_package);

    // TODO : p_package members names should be made into constants

    this._receivedSelection = JSON.stringify(p_package.node); // ! Maybe set this._receivedSelection to the last one anyways ?
    if (!this.size()) {
        // Reset 'received' selected node so that lastSelectedNode is used instead
        // this._receivedSelection = ""; // ! Maybe not clear this here at this point!

        this._busy = false; // We're not busy anymore // ! maybe keep using _receivedSelection instead of clearing it?
        // console.log(`busy NOW FALSE :  ${this._busy}`);

        if (this._finalRefreshType) {
            // At least some type of refresh
            this._leoIntegration.launchRefresh(this._finalRefreshType, this._finalFromOutline);
        }
        // Reset refresh type and focus flag nonetheless
        this._finalRefreshType = RefreshType.NoRefresh;
        this._finalFromOutline = false;

    } else {
        // size &gt; 0, so call _runStackCommand again, keep _busy set to true
        // console.log('Next!');
        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}
</t>
<t tx="felix.20200718030926.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { ConfigMembers, RefreshType } from "./types";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

@others
@language typescript
@tabwidth -4
</t>
<t tx="felix.20200718030926.2">/**
 * * Configuration Settings Service
 */
export class Config implements ConfigMembers {
    // Some config settings are used in leobridgeserver.py such as defaultReloadIgnore and checkForChangeExternalFiles
    // TODO : Should use default values in a centralized way
    public checkForChangeExternalFiles: string = "none";  // Used in leoBridge script
    public defaultReloadIgnore: string = "none"; // Used in leoBridge script
    public leoTreeBrowse: boolean = true;
    public treeKeepFocus: boolean = true;
    public treeKeepFocusWhenAside: boolean = false;
    public treeInExplorer: boolean = true;
    public showOpenAside: boolean = true;
    public statusBarString: string = "";
    public statusBarColor: string = "";
    public showEditOnNodes: boolean = true;
    public showArrowsOnNodes: boolean = false;
    public showAddOnNodes: boolean = false;
    public showMarkOnNodes: boolean = false;
    public showCloneOnNodes: boolean = false;
    public showCopyOnNodes: boolean = false;
    public invertNodeContrast: boolean = false;
    public leoPythonCommand: string = "";
    public startServerAutomatically: boolean = false; // Now set this configuration option default to 'false' to showcase treeViews 'welcome content'
    public connectToServerAutomatically: boolean = false; // Now set this configuration option default to 'false'
    public connectionAddress: string = Constants.TCPIP_DEFAULT_ADDRESS;
    public connectionPort: number = Constants.TCPIP_DEFAULT_PORT;

    private _isSettingConfig: boolean = false;
    private _needsTreeRefresh: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20200718030926.3">/**
 * * Get Leointeg Configuration
 * @returns An object with live config settings members such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public getConfig(): ConfigMembers {
    return {
        checkForChangeExternalFiles: this.checkForChangeExternalFiles,  // Used in leoBridge script
        defaultReloadIgnore: this.defaultReloadIgnore,  // Used in leoBridge script

        leoTreeBrowse: this.leoTreeBrowse,
        treeKeepFocus: this.treeKeepFocus,
        treeKeepFocusWhenAside: this.treeKeepFocusWhenAside,
        treeInExplorer: this.treeInExplorer,
        showOpenAside: this.showOpenAside,
        statusBarString: this.statusBarString,
        statusBarColor: this.statusBarColor,
        showEditOnNodes: this.showEditOnNodes,
        showArrowsOnNodes: this.showArrowsOnNodes,
        showAddOnNodes: this.showAddOnNodes,
        showMarkOnNodes: this.showMarkOnNodes,
        showCloneOnNodes: this.showCloneOnNodes,
        showCopyOnNodes: this.showCopyOnNodes,
        invertNodeContrast: this.invertNodeContrast,
        leoPythonCommand: this.leoPythonCommand,
        startServerAutomatically: this.startServerAutomatically,
        connectToServerAutomatically: this.connectToServerAutomatically,
        connectionAddress: this.connectionAddress,
        connectionPort: this.connectionPort,
    };
}

</t>
<t tx="felix.20200718030926.4">/**
 * * Apply changes to the expansion config settings, those configuration values are persisted
 * @param p_changes is an array of key/values to change in the expansion settings
 * @returns a promise, in case additional procedures need to be run upon completion
 */
public setLeoIntegSettings(p_changes: { code: string, value: any }[]): Promise&lt;void&gt; {
    this._isSettingConfig = true;
    const w_promises: Thenable&lt;void&gt;[] = [];
    const w_vscodeConfig = vscode.workspace.getConfiguration(Constants.CONFIG_NAME);
    p_changes.forEach(i_change =&gt; {
        if (i_change &amp;&amp; i_change.code.includes(Constants.CONFIG_REFRESH_MATCH)) {
            // Check if tree refresh is required for hover-icons to be displayed or hidden accordingly
            this._needsTreeRefresh = true;
        }
        if (w_vscodeConfig.inspect(i_change.code)!.defaultValue === i_change.value) {
            // set as undefined - same as default
            w_promises.push(w_vscodeConfig.update(i_change.code, undefined, true));
            // console.log("clearing ", change.code, "to undefined");
        } else {
            // set as value which is not default
            w_promises.push(w_vscodeConfig.update(i_change.code, i_change.value, true));
            // console.log("setting ", change.code, "to ", change.value);
        }
    });
    return Promise.all(w_promises).then(() =&gt; {
        if (this._needsTreeRefresh) {
            this._needsTreeRefresh = false;
            setTimeout(() =&gt; {
                this._leoIntegration.configTreeRefresh();
            }, 200);
        }
        this._isSettingConfig = false;
        this.buildFromSavedSettings();
    });
}

</t>
<t tx="felix.20200718030926.5">/**
 * * Build config from settings from vscode's saved config settings
 */
public buildFromSavedSettings(): void {
    if (this._isSettingConfig) {
        // * Currently setting config, wait until its done all, and this will be called automatically
        return;
    } else {
        // * Graphic and theme settings
        this.invertNodeContrast = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.INVERT_NODES, false);
        this.statusBarString = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.STATUSBAR_STRING, Constants.GUI.STATUSBAR_DEFAULT_STRING);
        if (this.statusBarString.length &gt; 8) {
            this.statusBarString = Constants.GUI.STATUSBAR_DEFAULT_STRING;
        }
        this.statusBarColor = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.STATUSBAR_COLOR, Constants.GUI.STATUSBAR_DEFAULT_COLOR);
        if (!utils.isHexColor(this.statusBarColor)) {
            this.statusBarColor = Constants.GUI.STATUSBAR_DEFAULT_COLOR;
        }
        // * Interface elements visibility defaults
        // TODO : Should use default values in a centralized way
        this.checkForChangeExternalFiles = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.CHECK_FOR_CHANGE_EXTERNAL_FILES, "none");
        this.defaultReloadIgnore = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.DEFAULT_RELOAD_IGNORE, "none");
        this.treeInExplorer = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.TREE_IN_EXPLORER, true);
        this.showOpenAside = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_OPEN_ASIDE, true);
        this.showEditOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_EDIT, false);
        this.showArrowsOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_ARROWS, false);
        this.showAddOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_ADD, false);
        this.showMarkOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_MARK, false);
        this.showCloneOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_CLONE, false);
        this.showCopyOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_COPY, false);
        // * Interface settings
        this.leoTreeBrowse = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.LEO_TREE_BROWSE, true);
        this.treeKeepFocus = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.TREE_KEEP_FOCUS, true);
        this.treeKeepFocusWhenAside = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.TREE_KEEP_FOCUS_WHEN_ASIDE, false);
        // * Server and connection automation
        this.leoPythonCommand = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.LEO_PYTHON_COMMAND, "");
        this.startServerAutomatically = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.AUTO_START_SERVER, false);
        this.connectToServerAutomatically = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.AUTO_CONNECT, false);
        this.connectionAddress = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.IP_ADDRESS, Constants.TCPIP_DEFAULT_ADDRESS); // 'ws://'
        this.connectionPort = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.IP_PORT, Constants.TCPIP_DEFAULT_PORT); // 32125
        // * Set context for tree items visibility that are based on config options
        this._leoIntegration.sendConfigToServer(this.getConfig());
        utils.setContext(Constants.CONTEXT_FLAGS.LEO_TREE_BROWSE, this.leoTreeBrowse);
        utils.setContext(Constants.CONTEXT_FLAGS.TREE_IN_EXPLORER, this.treeInExplorer);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_OPEN_ASIDE, this.showOpenAside);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_EDIT, this.showEditOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_ARROWS, this.showArrowsOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_ADD, this.showAddOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_MARK, this.showMarkOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_CLONE, this.showCloneOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_COPY, this.showCopyOnNodes);
    }
}
</t>
<t tx="felix.20200718031424.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { RefreshType } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { LeoSettingsWebview } from "./webviews/leoSettingsWebview";
import { LeoButtonNode } from "./leoButtonNode";

@others
@language typescript
@tabwidth -4
</t>
<t tx="felix.20200718031424.10">[CMD.CONTRACT_ALL, () =&gt; w_leo.nodeCommand(BRIDGE.CONTRACT_ALL, U, REFRESH_TREE, false)],
[CMD.CONTRACT_ALL_FO, () =&gt; w_leo.nodeCommand(BRIDGE.CONTRACT_ALL, U, REFRESH_TREE, true)],
[CMD.CONTRACT_OR_GO_LEFT, () =&gt; w_leo.nodeCommand(BRIDGE.CONTRACT_OR_GO_LEFT, U, REFRESH_BOTH, true)],

[CMD.EXPAND_AND_GO_RIGHT, () =&gt; w_leo.nodeCommand(BRIDGE.EXPAND_AND_GO_RIGHT, U, REFRESH_BOTH, true)],
</t>
<t tx="felix.20200718031424.11">// [cmd.GIT_DIFF, () =&gt; leo.nodeCommand(bridge.GIT_DIFF, u, refreshBoth, true)],
</t>
<t tx="felix.20200718031424.12">[CMD.GOTO_NEXT_CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.GOTO_NEXT_CLONE, p_node, REFRESH_BOTH, true)],
[CMD.GOTO_NEXT_CLONE_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_NEXT_CLONE, U, REFRESH_BOTH, false)],
[CMD.GOTO_NEXT_CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_NEXT_CLONE, U, REFRESH_BOTH, true)],

[CMD.GOTO_NEXT_MARKED, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_NEXT_MARKED, U, REFRESH_BOTH, true)],

[CMD.GOTO_FIRST_VISIBLE, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_FIRST_VISIBLE, U, REFRESH_BOTH, true)],
[CMD.GOTO_LAST_SIBLING, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_LAST_SIBLING, U, REFRESH_BOTH, true)],
[CMD.GOTO_LAST_VISIBLE, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_LAST_VISIBLE, U, REFRESH_BOTH, true)],
[CMD.GOTO_NEXT_VISIBLE, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_NEXT_VISIBLE, U, REFRESH_BOTH, true)],
[CMD.GOTO_PREV_VISIBLE, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_PREV_VISIBLE, U, REFRESH_BOTH, true)],

</t>
<t tx="felix.20200718031424.13">[CMD.DEHOIST, () =&gt; w_leo.nodeCommand(BRIDGE.DEHOIST, U, REFRESH_BOTH, false)],
[CMD.DEHOIST_FO, () =&gt; w_leo.nodeCommand(BRIDGE.DEHOIST, U, REFRESH_BOTH, true)],

[CMD.HOIST, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.HOIST_PNODE, p_node, REFRESH_BOTH, true)],
[CMD.HOIST_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.HOIST_PNODE, U, REFRESH_BOTH, false)],
[CMD.HOIST_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.HOIST_PNODE, U, REFRESH_BOTH, true)],
</t>
<t tx="felix.20200718031424.14">[CMD.CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.CLONE_PNODE, p_node, REFRESH_TREE, false)],
[CMD.CLONE_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.CLONE_PNODE, U, REFRESH_TREE, false)],
[CMD.CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.CLONE_PNODE, U, REFRESH_TREE, true)],

[CMD.INSERT, (p_node: LeoNode) =&gt; w_leo.insertNode(p_node, false)],
[CMD.INSERT_SELECTION, () =&gt; w_leo.insertNode(U, false)],
[CMD.INSERT_SELECTION_FO, () =&gt; w_leo.insertNode(U, true)],

// * Special command for when inserting rapidly more than one node without even specifying a headline label,
// such as spamming CTRL+I rapidly.
[CMD.INSERT_SELECTION_INTERRUPT, () =&gt; w_leo.insertNode(U, U, true)],
</t>
<t tx="felix.20200718031424.15">[CMD.MARK, (p_node: LeoNode) =&gt; w_leo.changeMark(true, p_node, false)],
[CMD.MARK_SELECTION, () =&gt; w_leo.changeMark(true, U, false)],
[CMD.MARK_SELECTION_FO, () =&gt; w_leo.changeMark(true, U, true)],

[CMD.UNMARK, (p_node: LeoNode) =&gt; w_leo.changeMark(false, p_node, false)],
[CMD.UNMARK_SELECTION, () =&gt; w_leo.changeMark(false, U, false)],
[CMD.UNMARK_SELECTION_FO, () =&gt; w_leo.changeMark(false, U, true)],
</t>
<t tx="felix.20200718031424.16">[CMD.MOVE_DOWN, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_DOWN, p_node, REFRESH_TREE, false)],
[CMD.MOVE_DOWN_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_DOWN, U, REFRESH_TREE, false)],
[CMD.MOVE_DOWN_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_DOWN, U, REFRESH_TREE, true)],

[CMD.MOVE_LEFT, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_LEFT, p_node, REFRESH_TREE, false)],
[CMD.MOVE_LEFT_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_LEFT, U, REFRESH_TREE, false)],
[CMD.MOVE_LEFT_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_LEFT, U, REFRESH_TREE, true)],

[CMD.MOVE_RIGHT, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_RIGHT, p_node, REFRESH_TREE, false)],
[CMD.MOVE_RIGHT_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_RIGHT, U, REFRESH_TREE, false)],
[CMD.MOVE_RIGHT_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_RIGHT, U, REFRESH_TREE, true)],

[CMD.MOVE_UP, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_UP, p_node, REFRESH_TREE, false)],
[CMD.MOVE_UP_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_UP, U, REFRESH_TREE, false)],
[CMD.MOVE_UP_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_UP, U, REFRESH_TREE, true)],
</t>
<t tx="felix.20200718031424.17">[CMD.PAGE_UP, () =&gt; w_leo.nodeCommand(BRIDGE.PAGE_UP, U, REFRESH_BOTH, true)],
[CMD.PAGE_DOWN, () =&gt; w_leo.nodeCommand(BRIDGE.PAGE_DOWN, U, REFRESH_BOTH, true)],
</t>
<t tx="felix.20200718031424.18">[CMD.DEMOTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.DEMOTE_PNODE, p_node, REFRESH_TREE, false)],
[CMD.DEMOTE_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.DEMOTE_PNODE, U, REFRESH_TREE, false)],
[CMD.DEMOTE_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.DEMOTE_PNODE, U, REFRESH_TREE, true)],

[CMD.PROMOTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.PROMOTE_PNODE, p_node, REFRESH_TREE, false)],
[CMD.PROMOTE_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.PROMOTE_PNODE, U, REFRESH_TREE, false)],
[CMD.PROMOTE_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.PROMOTE_PNODE, U, REFRESH_TREE, true)],
</t>
<t tx="felix.20200718031424.19">[CMD.SORT_CHILDREN, () =&gt; w_leo.nodeCommand(BRIDGE.SORT_CHILDREN, U, REFRESH_TREE, false)],
[CMD.SORT_SIBLING, () =&gt; w_leo.nodeCommand(BRIDGE.SORT_SIBLINGS, U, REFRESH_TREE, false)],
[CMD.SORT_SIBLING_FO, () =&gt; w_leo.nodeCommand(BRIDGE.SORT_SIBLINGS, U, REFRESH_TREE, true)],
</t>
<t tx="felix.20200718031424.2">@language typescript
/**
 * * Called when extension is activated.
 * It creates the leoIntegration and the 'welcome/Settings' webview instances.
 */
export function activate(p_context: vscode.ExtensionContext) {

    &lt;&lt; define constants &gt;&gt;

    const w_commands: [string, (...args: any[]) =&gt; any][] = [

        // ! REMOVE TESTS ENTRIES FROM PACKAGE.JSON FOR MASTER BRANCH RELEASES !
        ["test", () =&gt; w_leo.test()], // Test function useful when debugging
        ["testFromOutline", () =&gt; w_leo.test(true)], // Test function useful when debugging.

        // Define entries for all commands
        [CMD.EXECUTE, () =&gt; w_leo.executeScript()],
        @others
    ];

    w_commands.map(function (p_command) {
        p_context.subscriptions.push(vscode.commands.registerCommand(...p_command));
    });
    &lt;&lt; show welcome screen &gt;&gt;
}

</t>
<t tx="felix.20200718031424.20">[CMD.REDO, () =&gt; w_leo.nodeCommand(BRIDGE.REDO, U, REFRESH_BOTH, false)],
[CMD.REDO_FO, () =&gt; w_leo.nodeCommand(BRIDGE.REDO, U, REFRESH_BOTH, true)],

[CMD.UNDO, () =&gt; w_leo.nodeCommand(BRIDGE.UNDO, U, REFRESH_BOTH, false)],
[CMD.UNDO_FO, () =&gt; w_leo.nodeCommand(BRIDGE.UNDO, U, REFRESH_BOTH, true)],
</t>
<t tx="felix.20200718031424.21">[CMD.CONNECT, () =&gt; w_leo.connect()],
[CMD.START_SERVER, () =&gt; w_leo.startServer()],
</t>
<t tx="felix.20200718031424.22">[CMD.SELECT_NODE, (p_node: LeoNode) =&gt; w_leo.selectTreeNode(p_node, false, false)],
// Called by nodes in tree when selected
[CMD.OPEN_ASIDE, (p_node: LeoNode) =&gt; w_leo.selectTreeNode(p_node, false, true)],

[CMD.SHOW_OUTLINE, () =&gt; w_leo.showOutline(true)],
// Also focuses on outline

[CMD.SHOW_LOG, () =&gt; w_leo.showLogPane()],
[CMD.SHOW_BODY, () =&gt; w_leo.showBody(false)],
// Also focuses on body

[CMD.SHOW_WELCOME, () =&gt; w_leoSettingsWebview.openWebview()],
[CMD.SHOW_SETTINGS, () =&gt; w_leoSettingsWebview.openWebview()],
// Same as 'show welcome screen'

</t>
<t tx="felix.20200718031424.23">// If the version is newer than last time, then start automatic server and connection
showWelcomeIfNewer(w_leoIntegVersion, w_previousVersion).then(() =&gt; {
    // * Start server and / or connect to it (as specified in settings)
    w_leo.startNetworkServices();
    p_context.globalState.update(Constants.VERSION_STATE_KEY, w_leoIntegVersion);
    console.log('leoInteg startup launched in ', getDurationMilliseconds(w_start), 'ms');
});
</t>
<t tx="felix.20200718031424.24">/**
 * * Called when extension is deactivated
 */
export function deactivate() {
    console.log('deactivate called for extension "leointeg"');
}

</t>
<t tx="felix.20200718031424.25">/**
 * * Show welcome screen if needed, based on last version executed
 * @param p_version Current version, as a string, from packageJSON.version
 * @param p_previousVersion Previous version, as a string, from context.globalState.get service
 * @returns a promise that triggers when command to show the welcome screen is finished, or immediately if not needed
 */
async function showWelcomeIfNewer(p_version: string, p_previousVersion: string | undefined): Promise&lt;unknown&gt; {
    let w_showWelcomeScreen: boolean = false;
    if (p_previousVersion === undefined) {
        console.log('leoInteg first-time install');
        w_showWelcomeScreen = true;
    } else {
        if (p_previousVersion !== p_version) {
            console.log(`leoInteg upgraded from v${p_previousVersion} to v${p_version}`);
        }
        const [w_major, w_minor] = p_version.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        const [w_prevMajor, w_prevMinor] = p_previousVersion.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        if (
            (w_major === w_prevMajor &amp;&amp; w_minor === w_prevMinor) ||
            // Don't notify on downgrades
            (w_major &lt; w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &lt; w_prevMinor))
        ) {
            w_showWelcomeScreen = false;
        } else if (w_major !== w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &gt; w_prevMinor)) {
            // Will show on major or minor upgrade (Formatted as 'Major.Minor.Revision' eg. 1.2.3)
            w_showWelcomeScreen = true;
        }
    }
    if (w_showWelcomeScreen) {
        return vscode.commands.executeCommand(Constants.COMMANDS.SHOW_WELCOME);
    } else {
        return Promise.resolve();
    }
}

</t>
<t tx="felix.20200718031424.26">/**
 * * Returns the milliseconds between a given starting process.hrtime tuple and the current call to process.hrtime
 * @param p_start starting process.hrtime to subtract from current immediate time
 * @returns number of milliseconds passed since the given start hrtime
 */
function getDurationMilliseconds(p_start: [number, number]): number {
    const [secs, nanosecs] = process.hrtime(p_start);
    return secs * 1000 + Math.floor(nanosecs / 1000000);
}
</t>
<t tx="felix.20200718031424.3">const w_leoIntegExtension = vscode.extensions.getExtension(Constants.PUBLISHER + '.' + Constants.NAME)!;
const w_leoIntegVersion = w_leoIntegExtension.packageJSON.version;
const w_leo: LeoIntegration = new LeoIntegration(p_context);
const w_leoSettingsWebview: LeoSettingsWebview = new LeoSettingsWebview(p_context, w_leo);
const w_previousVersion = p_context.globalState.get&lt;string&gt;(Constants.VERSION_STATE_KEY);
const w_start = process.hrtime(); // For calculating total startup time duration

// Shortcut pointers for readability
const U = undefined;
const BRIDGE = Constants.LEOBRIDGE;
const CMD = Constants.COMMANDS;
const NO_REFRESH = RefreshType.NoRefresh;
const REFRESH_TREE = RefreshType.RefreshTree;
const REFRESH_BOTH = RefreshType.RefreshTreeAndBody;
const showInfo = vscode.window.showInformationMessage;

// * Reset Extension context flags (used in 'when' clauses in package.json)
utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, false); // Connected to a leobridge server?
utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, false); // Having a Leo file opened on that server?
</t>
<t tx="felix.20200718031424.4">// TODO : @boltex More commands to implement #15, #23, #24
[CMD.CLONE_FIND_ALL, () =&gt; showInfo("TODO: cloneFindAll command")],
[CMD.CLONE_FIND_ALL_FLATTENED, () =&gt; showInfo("TODO: cloneFindAllFlattened command")],
[CMD.CLONE_FIND_MARKED, () =&gt; showInfo("TODO: cloneFindMarked command")],
[CMD.CLONE_FIND_FLATTENED_MARKED, () =&gt; showInfo("TODO: cloneFindFlattenedMarked command")],
[CMD.EXTRACT, () =&gt; showInfo("TODO: extract command")],
[CMD.EXTRACT_NAMES, () =&gt; showInfo("TODO: extractNames command")],
[CMD.COPY_MARKED, () =&gt; showInfo("TODO: copyMarked command")],
[CMD.DIFF_MARKED_NODES, () =&gt; showInfo("TODO: diffMarkedNodes command")],
[CMD.MARK_CHANGED_ITEMS, () =&gt; showInfo("TODO: markChangedItems command")],
[CMD.MARK_SUBHEADS, () =&gt; showInfo("TODO: markSubheads command")],
[CMD.UNMARK_ALL, () =&gt; showInfo("TODO: unmarkAll command")],
[CMD.CLONE_MARKED_NODES, () =&gt; showInfo("TODO: cloneMarkedNodes command")],
[CMD.DELETE_MARKED_NODES, () =&gt; showInfo("TODO: deleteMarkedNodes command")],
[CMD.MOVE_MARKED_NODES, () =&gt; showInfo("TODO: moveMarkedNode command")],
</t>
<t tx="felix.20200718031424.5">// Test for undeclared commands VERDICT IT WORKS!
[CMD.CLICK_BUTTON, (p_node: LeoButtonNode) =&gt; w_leo.clickButton(p_node)],

// Cannot be undeclared because its referenced in package.json
[CMD.REMOVE_BUTTON, (p_node: LeoButtonNode) =&gt; w_leo.removeButton(p_node)],
</t>
<t tx="felix.20200718031424.6">[CMD.CLOSE_FILE, () =&gt; w_leo.closeLeoFile()],
[CMD.NEW_FILE, () =&gt; w_leo.newLeoFile()],
[CMD.OPEN_FILE, () =&gt; w_leo.openLeoFile()],
[CMD.SAVE_AS_FILE, () =&gt; w_leo.saveAsLeoFile()],
[CMD.SAVE_FILE, () =&gt; w_leo.saveLeoFile()],
[CMD.SAVE_FILE_FO, () =&gt; w_leo.saveLeoFile(true)],
[CMD.SWITCH_FILE, () =&gt; w_leo.switchLeoFile()],

// Test for undeclared commands VERDICT IT WORKS!
[CMD.SET_OPENED_FILE, (p_index: number) =&gt; w_leo.selectOpenedLeoDocument(p_index)],

[CMD.REFRESH_FROM_DISK, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.REFRESH_FROM_DISK_PNODE, p_node, REFRESH_BOTH, false)],
[CMD.REFRESH_FROM_DISK_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.REFRESH_FROM_DISK_PNODE, U, REFRESH_BOTH, false)],
[CMD.REFRESH_FROM_DISK_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.REFRESH_FROM_DISK_PNODE, U, REFRESH_BOTH, true)],
</t>
<t tx="felix.20200718031424.7">[CMD.HEADLINE, (p_node: LeoNode) =&gt; w_leo.editHeadline(p_node, false)],
[CMD.HEADLINE_SELECTION, () =&gt; w_leo.editHeadline(U, false)],
[CMD.HEADLINE_SELECTION_FO, () =&gt; w_leo.editHeadline(U, true)],
</t>
<t tx="felix.20200718031424.8"></t>
<t tx="felix.20200718031424.9">// cut/copy/paste/delete given node.
[CMD.COPY, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.COPY_PNODE, p_node, NO_REFRESH, false)],
[CMD.CUT, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.CUT_PNODE, p_node, REFRESH_TREE, false)],
[CMD.DELETE, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.DELETE_PNODE, p_node, REFRESH_TREE, false)],
[CMD.PASTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.PASTE_PNODE, p_node, REFRESH_TREE, false)],
[CMD.PASTE_CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.PASTE_CLONE_PNODE, p_node, REFRESH_TREE, false)],

// cut/copy/paste/delete c.p..
[CMD.COPY_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.COPY_PNODE, U, NO_REFRESH, false)],
[CMD.CUT_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.CUT_PNODE, U, REFRESH_TREE, false)],
[CMD.CUT_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.CUT_PNODE, U, REFRESH_TREE, true)],
[CMD.DELETE_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.DELETE_PNODE, U, REFRESH_TREE, false)],
[CMD.DELETE_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.DELETE_PNODE, U, REFRESH_TREE, true)],
[CMD.PASTE_CLONE_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.PASTE_CLONE_PNODE, U, REFRESH_TREE, false)],
[CMD.PASTE_CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.PASTE_CLONE_PNODE, U, REFRESH_TREE, true)],
[CMD.PASTE_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.PASTE_PNODE, U, REFRESH_TREE, false)],
[CMD.PASTE_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.PASTE_PNODE, U, REFRESH_TREE, true)],
</t>
<t tx="felix.20200718035737.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import {
    AskMessageItem, RefreshType, runAskYesNoDialogParameters,
    runWarnMessageDialogParameters, runInfoMessageDialogParameters,
    showSaveAsDialogParameters
} from "./types";
import { LeoIntegration } from "./leoIntegration";

/*
    TODO : Should Reproduce those interactive controls that may be asked by Leo and redo a true UI bridge

def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    return self.simulateDialog("aboutLeoDialog", None)

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog", None)

def runAskOkDialog(self, c, title, message=None, text="Ok"):
    return self.simulateDialog("okDialog", "Ok")

def runAskOkCancelNumberDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
):
    return self.simulateDialog("numberDialog", -1)

def runAskOkCancelStringDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
    default="",
    wide=False,
):
    return self.simulateDialog("stringDialog", '')

def runCompareDialog(self, c):
    return self.simulateDialog("compareDialog", '')

def runOpenFileDialog(self, c, title, filetypes, defaultextension,
    multiple=False,
    startpath=None,
):
    return self.simulateDialog("openFileDialog", None)

def runSaveFileDialog(self, c, initialfile, title, filetypes, defaultextension):
    return self.simulateDialog("saveFileDialog", None)

def runAskYesNoDialog(self, c, title,
    message=None,
    yes_all=False,
    no_all=False,
):
    return self.simulateDialog("yesNoDialog", "no")

def runAskYesNoCancelDialog(self, c, title,
    message=None,
    yesMessage="Yes",
    noMessage="No",
    yesToAllMessage=None,
    defaultButton="Yes",
    cancelMessage=None,
):
    return self.simulateDialog("yesNoCancelDialog", "cancel")

def simulateDialog(self, key, defaultVal):
    return defaultVal

*/
@others
@language typescript
@tabwidth -4
</t>
<t tx="felix.20200718035737.2">
/**
 * * Handles the functions called by Leo through leoBridge such as adding a log pane entry, runAskYesNoDialog for file changes, etc.
 * * Some config settings affect this behavior, such as defaultReloadIgnore and checkForChangeExternalFiles
 */
export class LeoAsync {

    private _askResult: string = "";

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20200718035737.3">/**
 * * Adds message string to leoInteg's log pane, used when leoBridge gets an async 'log' command
 */
public log(p_message: string): void {
    this._leoIntegration.addLogPaneEntry(p_message);
}

</t>
<t tx="felix.20200718035737.4">/**
 * * Equivalent to runSaveFileDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * @param p_saveAsArg
 */
public showSaveAsDialog(p_saveAsArg: showSaveAsDialogParameters): void {
    console.log('TODO: SHOW SAVE AS DIALOG!');

}

</t>
<t tx="felix.20200718035737.5">/**
 * * Equivalent to runAskYesNoDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * * Opens a modal dialog to return one of 'yes', 'yes-all', 'no' or 'no-all' to be sent back with the leoBridge 'ASK_RESULT' action
 * @param p_askArg an async package object {"ask": title, "message": message, "yes_all": yes_all, "no_all": no_all}
 */
public showAskModalDialog(p_askArg: runAskYesNoDialogParameters): void {
    this._askResult = "no"; // defaults to not doing anything, matches isCloseAffordance just to be safe
    // Note: "last line" could be eventually used in the message
    // const w_lastLine = p_askArg.message.substr(p_askArg.message.lastIndexOf("\n") + 1);
    const w_items: AskMessageItem[] = [
        {
            title: Constants.USER_MESSAGES.YES,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES,
            isCloseAffordance: false
        },
        {
            title: Constants.USER_MESSAGES.NO,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO,
            isCloseAffordance: true
        }
    ];
    if (p_askArg.yes_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.YES_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES_ALL,
            isCloseAffordance: false
        });
    }
    if (p_askArg.no_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.NO_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO_ALL,
            isCloseAffordance: false
        });
    }
    const w_askRefreshInfoMessage: Thenable&lt;AskMessageItem | undefined&gt; = vscode.window.showInformationMessage(
        p_askArg.message,
        { modal: true },
        ...w_items
    );
    w_askRefreshInfoMessage.then((p_result: AskMessageItem | undefined) =&gt; {
        if (p_result) {
            this._askResult = p_result.value;
        }
        const w_sendResultPromise = this._leoIntegration.sendAction(Constants.LEOBRIDGE.ASK_RESULT, '"' + this._askResult + '"'); // Quotes in string as a 'JSON parameter'
        if (this._askResult.includes(Constants.ASYNC_ASK_RETURN_CODES.YES)) {
            w_sendResultPromise.then(() =&gt; {
                // Might have answered 'yes/yesAll' and refreshed and changed the body text
                this._leoIntegration.launchRefresh(RefreshType.RefreshTreeAndBody, false); // TODO : #34 @boltex Deal with focus placement
            });
        }
    });
}

</t>
<t tx="felix.20200718035737.6">/**
 * * Equivalent to runAskOkDialog from Leo's qt_gui.py, used when leoBridge gets an async 'warn' command
 * @param p_waitArg an async package object {"warn": "", "message": ""}
 */
public showWarnModalMessage(p_waitArg: runWarnMessageDialogParameters): void {
    vscode.window.showInformationMessage(
        p_waitArg.message,
        { modal: true }
    ).then(() =&gt; {
        this._leoIntegration.sendAction(Constants.LEOBRIDGE.ASK_RESULT, Constants.ASYNC_ASK_RETURN_CODES.OK); // Quotes in string as a 'JSON parameter'
    });
}

</t>
<t tx="felix.20200718035737.7">/**
 * * Show non-blocking info message about detected file changes, used when leoBridge gets an async 'info' command
 * @param p_infoArg an async package object { "message": string; }
 */
public showChangesDetectedInfoMessage(p_infoArg: runInfoMessageDialogParameters): void {
    let w_message = Constants.USER_MESSAGES.CHANGES_DETECTED;
    switch (p_infoArg.message) {
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_REFRESHED:
            w_message += Constants.USER_MESSAGES.REFRESHED;
            this._leoIntegration.launchRefresh(RefreshType.RefreshTreeAndBody, false); // TODO : #34 @boltex Deal with focus placement
            break;
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_IGNORED:
            w_message += Constants.USER_MESSAGES.IGNORED;
            break;
        default:
            break;
    }
    vscode.window.showInformationMessage(w_message);
}
</t>
</tnodes>
</leo_file>
