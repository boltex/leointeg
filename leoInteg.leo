<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20200722190504.1"><vh>Startup</vh>
<v t="ekr.20200724052304.1"><vh>@button backup</vh></v>
<v t="ekr.20200808100711.1"><vh>@settings</vh>
<v t="ekr.20200808100717.1"><vh>@string target-language = plain</vh></v>
</v>
<v t="ekr.20200722125546.1"><vh>script: Print all command names</vh></v>
<v t="ekr.20200815113508.1"><vh>script: Find empty nodes that have no children</vh></v>
</v>
<v t="felix.20200718220811.1"><vh>Documentation</vh>
<v t="felix.20200718220818.1"><vh>@clean README.md</vh>
<v t="felix.20200718221645.1"><vh>Requirements</vh></v>
<v t="felix.20200718222026.1"><vh>Development version installation</vh></v>
<v t="felix.20200718222035.1"><vh>Features</vh></v>
<v t="felix.20200718222043.1"><vh>Keybindings</vh></v>
<v t="felix.20200718222048.1"><vh>Derive External Files</vh></v>
<v t="felix.20200718222053.1"><vh>Automate Synchronization</vh></v>
<v t="felix.20200718222058.1"><vh>Status Bar Indicator</vh></v>
<v t="felix.20200718222102.1"><vh>Extension Settings</vh></v>
<v t="felix.20200718222108.1"><vh>Issues</vh></v>
<v t="felix.20200718222113.1"><vh>How it works</vh></v>
<v t="felix.20200718222118.1"><vh>Acknowledgments</vh></v>
</v>
<v t="felix.20200718220833.1"><vh>@clean CHANGELOG.md</vh>
<v t="felix.20210612000127.1"><vh>0.1.14</vh></v>
<v t="felix.20210509210502.1"><vh>0.1.13</vh></v>
<v t="felix.20200718222417.1"><vh>0.1.12</vh></v>
<v t="felix.20200718222419.1"><vh>0.1.11</vh></v>
<v t="felix.20200718222422.1"><vh>0.1.10</vh></v>
<v t="felix.20200718222425.1"><vh>0.1.9</vh></v>
<v t="felix.20200718222427.1"><vh>0.1.8</vh></v>
<v t="felix.20200718222429.1"><vh>0.1.7</vh></v>
<v t="felix.20200718222433.1"><vh>0.1.6</vh></v>
<v t="felix.20200718222435.1"><vh>0.1.5</vh></v>
<v t="felix.20200718222437.1"><vh>0.1.4</vh></v>
<v t="felix.20200718222439.1"><vh>0.1.3</vh></v>
<v t="felix.20200718222440.1"><vh>0.1.2</vh></v>
<v t="felix.20200718222442.1"><vh>0.1.1</vh></v>
<v t="felix.20200718222445.1"><vh>0.0.1</vh></v>
</v>
<v t="felix.20200718220833.2"><vh>@clean CONTRIBUTING.md</vh>
<v t="felix.20200718222731.1"><vh>Introduction</vh></v>
<v t="felix.20200718222739.1"><vh>Development requirements</vh></v>
<v t="felix.20200718222741.1"><vh>Getting the source</vh></v>
<v t="felix.20200718222745.1"><vh>Choosing a debug profile</vh></v>
<v t="felix.20200718222748.1"><vh>Starting the extension</vh></v>
<v t="felix.20200718222754.1"><vh>The python server script</vh></v>
<v t="felix.20200718222757.1"><vh>Issues</vh></v>
</v>
</v>
<v t="ekr.20200722190517.1"><vh>Files: Other</vh>
<v t="felix.20191126232434.2"><vh>@clean backup-leobridgeserver.py</vh>
<v t="felix.20191128002414.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="felix.20191128002417.1"><vh>&lt;&lt; constants &gt;&gt;</vh></v>
<v t="felix.20200302204251.1"><vh>class IdleTimeManager</vh>
<v t="felix.20200302204251.2"><vh>itm.add_callback</vh></v>
<v t="felix.20200302204251.3"><vh>itm.on_idle</vh></v>
<v t="felix.20200302204251.4"><vh>itm.start</vh></v>
</v>
<v t="felix.20200302205810.1"><vh>class ExternalFilesController</vh>
<v t="felix.20200302205810.2"><vh>efc.ctor</vh></v>
<v t="felix.20200302205810.7"><vh>efc.on_idle</vh></v>
<v t="felix.20200302205810.8"><vh>efc.idle_check_commander</vh></v>
<v t="felix.20200302205810.9"><vh>efc.idle_check_at_file_node</vh></v>
<v t="felix.20200304221925.1"><vh>efc.integResult</vh></v>
<v t="felix.20200302205810.21"><vh>efc.utilities</vh>
<v t="felix.20200302205810.22"><vh>efc.ask</vh></v>
<v t="felix.20200302205810.23"><vh>efc.checksum</vh></v>
<v t="felix.20200302205810.25"><vh>efc.get_mtime</vh></v>
<v t="felix.20200302205810.26"><vh>efc.get_time</vh></v>
<v t="felix.20200302205810.27"><vh>efc.has_changed</vh></v>
<v t="felix.20200302205810.28"><vh>efc.is_enabled</vh></v>
<v t="felix.20200302205810.29"><vh>efc.join</vh></v>
<v t="felix.20200302205810.30"><vh>efc.set_time</vh></v>
<v t="felix.20200302205810.31"><vh>efc.warn</vh></v>
</v>
<v t="felix.20200308145948.1"><vh>other called methods</vh>
<v t="felix.20200308150856.1"><vh>open_with</vh></v>
<v t="felix.20200308150848.1"><vh>check_overwrite</vh></v>
<v t="felix.20200308150821.1"><vh>shut_down</vh></v>
<v t="felix.20200308150842.1"><vh>destroy_frame</vh></v>
</v>
</v>
<v t="felix.20200928174406.1"><vh>class IntegTextWrapper</vh>
<v t="felix.20200928174406.2"><vh>stw.ctor</vh></v>
<v t="felix.20200928174406.3"><vh>stw.Clipboard</vh></v>
<v t="felix.20200928174406.4"><vh>stw.Do-nothings</vh></v>
<v t="felix.20200928174406.5"><vh>stw.Text</vh>
<v t="felix.20200928174406.6"><vh>stw.appendText</vh></v>
<v t="felix.20200928174406.7"><vh>stw.delete</vh></v>
<v t="felix.20200928174406.8"><vh>stw.deleteTextSelection</vh></v>
<v t="felix.20200928174406.9"><vh>stw.get</vh></v>
<v t="felix.20200928174406.10"><vh>stw.getAllText</vh></v>
<v t="felix.20200928174406.11"><vh>stw.getInsertPoint</vh></v>
<v t="felix.20200928174406.12"><vh>stw.getSelectedText</vh></v>
<v t="felix.20200928174406.13"><vh>stw.getSelectionRange</vh></v>
<v t="felix.20201028223533.1"><vh>stw.getXScrollPosition</vh></v>
<v t="felix.20201102223052.1"><vh>stw.getYScrollPosition</vh></v>
<v t="felix.20200928174406.14"><vh>stw.hasSelection</vh></v>
<v t="felix.20200928174406.15"><vh>stw.insert</vh></v>
<v t="felix.20200928174406.16"><vh>stw.selectAllText</vh></v>
<v t="felix.20200928174406.17"><vh>stw.setAllText</vh></v>
<v t="felix.20200928174406.18"><vh>stw.setInsertPoint</vh></v>
<v t="felix.20201028223434.1"><vh>stw.setXScrollPosition</vh></v>
<v t="felix.20201102223046.1"><vh>stw.setYScrollPosition</vh></v>
<v t="felix.20200928174406.19"><vh>stw.setSelectionRange</vh></v>
<v t="felix.20200928174406.20"><vh>stw.toPythonIndex</vh></v>
<v t="felix.20200928174406.21"><vh>stw.toPythonIndexRowCol</vh></v>
</v>
</v>
<v t="felix.20191126232434.4"><vh>class LeoBridgeIntegController</vh>
<v t="felix.20191126232434.5"><vh>__init__</vh></v>
<v t="felix.20200303214235.1"><vh>_asyncIdleLoop</vh></v>
<v t="felix.20200626012709.1"><vh>_returnNo</vh></v>
<v t="felix.20200626030820.1"><vh>_returnYes</vh></v>
<v t="felix.20200927213534.1"><vh>_getScript</vh></v>
<v t="felix.20200303214255.1"><vh>_idleTime</vh></v>
<v t="felix.20200623201853.1"><vh>_getTotalOpened</vh></v>
<v t="felix.20200623215904.1"><vh>_getFirstOpenedCommander</vh></v>
<v t="felix.20210528000603.1"><vh>_show_find_success</vh></v>
<v t="felix.20200304224909.1"><vh>sendAsyncOutput</vh></v>
<v t="felix.20200304220844.1"><vh>set_ask_result</vh></v>
<v t="felix.20200312231358.1"><vh>set_config</vh></v>
<v t="felix.20200219224515.1"><vh>logSignon</vh></v>
<v t="felix.20200924224017.1"><vh>JSON Output Functions</vh>
<v t="felix.20200924211032.1"><vh>setActionId</vh></v>
<v t="felix.20200924211034.1"><vh>asyncOutput</vh></v>
<v t="felix.20200924211037.1"><vh>sendLeoBridgePackage</vh></v>
<v t="felix.20200924211041.1"><vh>_outputError</vh></v>
<v t="felix.20200924211048.1"><vh>_outputBodyData</vh></v>
<v t="felix.20200927224639.1"><vh>_outputSelectionData</vh></v>
<v t="felix.20200924211051.1"><vh>_outputPNode</vh></v>
<v t="felix.20200924211054.1"><vh>_outputPNodes</vh></v>
</v>
<v t="felix.20200219222712.1"><vh>es</vh></v>
<v t="felix.20200211202929.1"><vh>initConnection</vh></v>
<v t="felix.20200924205439.1"><vh>_get_commander_method</vh></v>
<v t="felix.20200924205503.1"><vh>leoCommand</vh></v>
<v t="felix.20200924223845.1"><vh>Leo Documents</vh>
<v t="felix.20200622230608.1"><vh>get_all_open_commanders</vh></v>
<v t="felix.20210523154200.1"><vh>get_ui_states</vh></v>
<v t="felix.20200624172552.1"><vh>set_opened_file</vh></v>
<v t="felix.20191126232434.13"><vh>open_file</vh></v>
<v t="felix.20200924205915.1"><vh>open_files</vh></v>
<v t="felix.20191126232434.14"><vh>close_file</vh></v>
<v t="felix.20200216160305.1"><vh>save_file</vh></v>
<v t="felix.20210602203830.1"><vh>import_any_file</vh></v>
</v>
<v t="felix.20210523154320.1"><vh>Search</vh>
<v t="felix.20210523154326.1"><vh>get_search_settings</vh></v>
<v t="felix.20210523154352.1"><vh>set_search_settings</vh></v>
<v t="felix.20210601005209.1"><vh>find_all</vh></v>
<v t="felix.20210527225925.1"><vh>find_next</vh></v>
<v t="felix.20210527225930.1"><vh>find_previous</vh></v>
<v t="felix.20210531011702.1"><vh>replace</vh></v>
<v t="felix.20210531011713.1"><vh>replace_then_find</vh></v>
<v t="felix.20210531011822.1"><vh>replace_all</vh></v>
<v t="felix.20210531214057.1"><vh>clone_find_all</vh></v>
<v t="felix.20210531214103.1"><vh>clone_find_all_flattened</vh></v>
<v t="felix.20210601151758.1"><vh>find_var</vh></v>
<v t="felix.20210601151804.1"><vh>find_def</vh></v>
<v t="felix.20210601152841.1"><vh>goto_global_line</vh></v>
</v>
<v t="felix.20200924223910.1"><vh>At Buttons</vh>
<v t="felix.20200924210020.1"><vh>get_buttons</vh></v>
<v t="felix.20200924210024.1"><vh>remove_button</vh></v>
<v t="felix.20200924210029.1"><vh>click_button</vh></v>
</v>
<v t="felix.20200924223945.1"><vh>Minibuffer</vh>
<v t="felix.20200924210036.1"><vh>get_all_leo_commands</vh></v>
<v t="felix.20200924210058.1"><vh>_bad_commands</vh></v>
<v t="felix.20200924210112.1"><vh>_good_commands</vh></v>
<v t="felix.20200924210952.1"><vh>_getDocstringForCommand</vh></v>
</v>
<v t="felix.20200924224100.1"><vh>Overriden Leo Commands</vh>
<v t="felix.20200924211057.1"><vh>mark_node</vh></v>
<v t="felix.20200924211100.1"><vh>unmark_node</vh></v>
<v t="felix.20200924211104.1"><vh>clone_node</vh></v>
<v t="felix.20200924211121.1"><vh>cut_node</vh></v>
<v t="felix.20200924211125.1"><vh>delete_node</vh></v>
<v t="felix.20200924211127.1"><vh>insert_node</vh></v>
<v t="felix.20200924211132.1"><vh>insert_named_node</vh></v>
<v t="felix.20200924211135.1"><vh>undo</vh></v>
<v t="felix.20200924211138.1"><vh>redo</vh></v>
<v t="felix.20201025144113.1"><vh>test</vh></v>
</v>
<v t="felix.20191128001054.1"><vh>Outline and Body Interaction</vh>
<v t="felix.20200929215102.3"><vh>page_up</vh></v>
<v t="felix.20200929215102.4"><vh>page_down</vh></v>
<v t="felix.20200929215102.5"><vh>get_body_states</vh></v>
<v t="felix.20191126232434.16"><vh>get_children &amp; helper</vh>
<v t="felix.20191126232434.29"><vh>_yieldAllRootChildren</vh></v>
</v>
<v t="felix.20191126232434.17"><vh>get_parent</vh></v>
<v t="felix.20191201194046.1"><vh>get_all_gnx</vh></v>
<v t="felix.20191126232434.19"><vh>get_body</vh></v>
<v t="felix.20191126232434.20"><vh>get_body_length</vh></v>
<v t="felix.20191126232434.22"><vh>set_body</vh></v>
<v t="felix.20210512000301.1"><vh>get_focus</vh></v>
<v t="felix.20200929230231.1"><vh>set_selection</vh></v>
<v t="felix.20191126232434.23"><vh>set_headline</vh></v>
<v t="felix.20191126232434.24"><vh>set_current_position &amp; helper</vh>
<v t="felix.20191216195906.1"><vh>_findPNodeFromGnx</vh></v>
</v>
<v t="felix.20191126232434.25"><vh>expand_node</vh></v>
<v t="felix.20191126232434.26"><vh>contract_node</vh></v>
</v>
<v t="felix.20191128003648.1"><vh>leoFlexx Conversion Functions</vh>
<v t="felix.20191126232434.27"><vh>_create_gnx_to_vnode</vh></v>
<v t="felix.20191126232434.28"><vh>_test_round_trip_positions</vh></v>
<v t="felix.20191126232434.30"><vh>_ap_to_p</vh></v>
<v t="felix.20191126232434.31"><vh>_p_to_ap</vh></v>
</v>
</v>
<v t="felix.20201129184357.1"><vh>printAction</vh></v>
<v t="felix.20191126232435.1"><vh>main leoBridgeServer loop</vh></v>
</v>
<v t="ekr.20200815123601.1"><vh>@clean package.json</vh>
<v t="ekr.20200815123601.2"><vh>configuration</vh>
<v t="ekr.20200815123601.3"><vh>External Files Change Detection</vh></v>
<v t="ekr.20200815123601.4"><vh>Interface Behavior</vh></v>
<v t="ekr.20200815123601.5"><vh>Statusbar Indicator</vh></v>
<v t="ekr.20200815123601.6"><vh>Interface Appearance</vh></v>
<v t="ekr.20200815123601.7"><vh>Leo Bridge Options</vh></v>
</v>
<v t="ekr.20200815123601.8"><vh>viewsContainers</vh></v>
<v t="ekr.20200815123601.9"><vh>views</vh></v>
<v t="ekr.20200815123601.10"><vh>languages</vh></v>
<v t="ekr.20200815123601.11"><vh>grammars</vh></v>
<v t="ekr.20200815123601.12"><vh>snippets</vh></v>
<v t="ekr.20200815123601.13"><vh>commands</vh>
<v t="ekr.20200815123601.14"><vh>Tests</vh></v>
<v t="ekr.20200815123601.15"><vh>Show Webviews</vh></v>
<v t="ekr.20200815123601.16"><vh>Server</vh></v>
<v t="ekr.20200815123601.17"><vh>Scripting &amp; @buttons</vh></v>
<v t="ekr.20200815123601.18"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.19"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.20"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.21"><vh>Node Editing</vh></v>
<v t="felix.20201105010614.1"><vh>Text Editing</vh></v>
<v t="ekr.20200815123601.22"><vh>Move Nodes</vh></v>
<v t="ekr.20200815123601.23"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.24"><vh>Goto Nodes</vh></v>
<v t="ekr.20200815123601.25"><vh>Hoist/Dehoist</vh></v>
<v t="ekr.20200815123601.26"><vh>Undo/Redo</vh></v>
<v t="felix.20210517001143.1"><vh>Search</vh></v>
<v t="felix.20210517001459.1"><vh>Mark Nodes</vh></v>
</v>
<v t="ekr.20200815123601.28"><vh>viewsWelcome</vh>
<v t="ekr.20200815123601.29"><vh>Leo Integration</vh>
<v t="ekr.20200815123601.30"><vh>Not Ready: [start], [connect] and settings</vh></v>
<v t="ekr.20200815123601.31"><vh>Not Ready Auto Start: [connect] and settings</vh></v>
<v t="ekr.20200815123601.32"><vh>Not Ready Server Started: [connect] and settings</vh></v>
<v t="ekr.20200815123601.33"><vh>Not Ready: Connecting</vh></v>
<v t="ekr.20200815123601.34"><vh>Ready: [open] and settings</vh></v>
</v>
<v t="ekr.20200815123601.35"><vh>Leo Documents</vh>
<v t="ekr.20200815123601.36"><vh>Not Ready</vh></v>
<v t="ekr.20200815123601.37"><vh>Ready: Empty</vh></v>
</v>
<v t="ekr.20200815123601.38"><vh>leoButtons</vh>
<v t="ekr.20200815123601.39"><vh>Not Ready</vh></v>
<v t="ekr.20200815123601.40"><vh>Ready: No Opened Files</vh></v>
<v t="ekr.20200815123601.41"><vh>Ready: No Buttons</vh></v>
</v>
<v t="felix.20210522233604.1"><vh>leoFind</vh>
<v t="felix.20210522233744.1"><vh>Not Ready</vh></v>
</v>
</v>
<v t="ekr.20200815123601.42"><vh>menus</vh>
<v t="ekr.20200815123601.43"><vh>commandPalette</vh>
<v t="ekr.20200815123601.44"><vh>Server</vh></v>
<v t="ekr.20200815123601.45"><vh>Scripting &amp; @buttons</vh></v>
<v t="ekr.20200815123601.46"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.47"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.48"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.49"><vh>Node Editing</vh></v>
<v t="felix.20210530160638.1"><vh>Text Editing</vh></v>
<v t="ekr.20200815123601.50"><vh>Move Nodes</vh></v>
<v t="ekr.20200815123601.51"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.52"><vh>Goto Nodes</vh></v>
<v t="ekr.20200815123601.53"><vh>Hoist/Dehoist</vh></v>
<v t="ekr.20200815123601.54"><vh>Undo/Redo</vh></v>
<v t="felix.20210530153353.1"><vh>Search</vh></v>
<v t="felix.20210530153359.1"><vh>Mark Nodes</vh></v>
<v t="ekr.20200815123601.56"><vh>Hidden Commands</vh>
<v t="ekr.20200815123601.57"><vh>Tests</vh></v>
<v t="ekr.20200815123601.58"><vh>Scripting &amp; @buttons</vh></v>
<v t="ekr.20200815123601.59"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.60"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.61"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.62"><vh>Node Editing</vh></v>
<v t="ekr.20200815123601.63"><vh>Move Nodes</vh></v>
<v t="ekr.20200815123601.64"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.65"><vh>Goto Nodes</vh></v>
<v t="ekr.20200815123601.66"><vh>Hoist/Dehoist</vh></v>
<v t="ekr.20200815123601.67"><vh>Undo/Redo</vh></v>
<v t="felix.20210530161800.1"><vh>Search</vh></v>
</v>
</v>
<v t="ekr.20200815123601.68"><vh>explorer/context</vh></v>
<v t="felix.20210610022645.1"><vh>editor/title</vh></v>
<v t="felix.20201215210439.1"><vh>view/title</vh></v>
<v t="felix.20201215210510.1"><vh>view/item/context</vh></v>
</v>
<v t="ekr.20200815123601.76"><vh>keybindings</vh>
<v t="ekr.20200815123601.77"><vh>Scripting</vh></v>
<v t="ekr.20200815123601.78"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.79"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.80"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.81"><vh>Node Editing</vh></v>
<v t="felix.20201105010253.1"><vh>Text Editing</vh></v>
<v t="ekr.20200815123601.82"><vh>Move Nodes</vh>
<v t="ekr.20200815123601.83"><vh>Move Down</vh></v>
<v t="ekr.20200815123601.84"><vh>Move left</vh></v>
<v t="ekr.20200815123601.85"><vh>Move right</vh></v>
<v t="ekr.20200815123601.86"><vh>Move Up</vh></v>
</v>
<v t="ekr.20200815123601.87"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.88"><vh>Goto Nodes</vh></v>
<v t="felix.20210517004335.1"><vh>Search</vh></v>
</v>
<v t="ekr.20200815123601.89"><vh>resourceLabelFormatters</vh></v>
</v>
<v t="ekr.20200722130456.1"><vh>@edit .gitignore</vh></v>
</v>
<v t="felix.20200718165721.1"><vh>Files: Typescript</vh>
<v t="felix.20200718024635.1"><vh>@clean src/commandStack.ts</vh>
<v t="felix.20200718024635.2"><vh>class CommandStack</vh>
<v t="felix.20200718024635.3"><vh>size</vh></v>
<v t="felix.20200718024635.4"><vh>newSelection</vh></v>
<v t="felix.20200718024635.5"><vh>add</vh></v>
<v t="felix.20200718024635.6"><vh>_tryStart</vh></v>
<v t="felix.20200718024635.7"><vh>_runStackCommand</vh></v>
<v t="felix.20200718024635.8"><vh>_resolveResult</vh></v>
</v>
</v>
<v t="felix.20200718030926.1"><vh>@clean src/config.ts</vh>
<v t="felix.20200718030926.2"><vh>class Config</vh>
<v t="felix.20200718030926.3"><vh>getConfig</vh></v>
<v t="felix.20200718030926.4"><vh>setLeoIntegSettings</vh></v>
<v t="felix.20200718030926.5"><vh>buildFromSavedSettings</vh></v>
</v>
</v>
<v t="felix.20200718020912.1"><vh>@clean src/constants.ts</vh>
<v t="felix.20200718020912.2"><vh>class Constants</vh>
<v t="felix.20200718020912.3"><vh>general constants</vh></v>
<v t="felix.20210530233134.1"><vh>find panel ids</vh></v>
<v t="felix.20200718020912.5"><vh>workbench interface panels</vh></v>
<v t="felix.20200718020912.6"><vh>user messages</vh></v>
<v t="felix.20210602213308.1"><vh>import file types</vh></v>
<v t="felix.20200718020912.7"><vh>ask/save buttons</vh></v>
<v t="felix.20201126235315.1"><vh>at-buttons strings</vh></v>
<v t="felix.20200718020912.8"><vh>configuration keys</vh></v>
<v t="ekr.20200815084016.1"><vh>config defaults</vh></v>
<v t="felix.20200718020912.9"><vh>context flags</vh></v>
<v t="felix.20201208235246.1"><vh>vscode commands</vh></v>
<v t="felix.20200718020912.10"><vh>async actions</vh></v>
<v t="felix.20200718020912.11"><vh>async info messages codes</vh></v>
<v t="felix.20200718020912.12"><vh>async ask return codes</vh></v>
<v t="felix.20201103000337.1"><vh>body language code strings</vh></v>
<v t="felix.20200718020912.13"><vh>leoBridge action strings</vh></v>
<v t="felix.20200718020912.15"><vh>commands strings</vh></v>
<v t="felix.20210602151654.1"><vh>minibuffer overridden commands</vh></v>
</v>
</v>
<v t="felix.20200718031424.1"><vh>@clean src/extension.ts</vh>
<v t="felix.20200718031424.2"><vh>activate</vh>
<v t="ekr.20200815113156.1"><vh>&lt;&lt; Define entries for all commands &gt;&gt;</vh></v>
</v>
<v t="felix.20200718031424.24"><vh>deactivate</vh></v>
<v t="felix.20200718031424.25"><vh>showWelcomeIfNewer</vh></v>
</v>
<v t="felix.20200718035737.1"><vh>@clean src/leoAsync.ts</vh>
<v t="ekr.20200815083608.1"><vh>class LeoAsync</vh>
<v t="ekr.20200815083608.2"><vh>log</vh></v>
<v t="ekr.20200815083608.3"><vh>showSaveAsDialog</vh></v>
<v t="ekr.20200815083609.1"><vh>showAskModalDialog</vh></v>
<v t="ekr.20200815083609.2"><vh>showWarnModalMessage</vh></v>
<v t="ekr.20200815083609.3"><vh>showChangesDetectedInfoMessage</vh></v>
<v t="ekr.20200815084550.1"><vh>&lt;&lt; TODO &gt;&gt;</vh></v>
</v>
</v>
<v t="felix.20200718040540.1"><vh>@clean src/leoBody.ts</vh>
<v t="felix.20200718040540.2"><vh>class LeoBodyProvider</vh>
<v t="felix.20200718040540.3"><vh>setBodyTime</vh></v>
<v t="felix.20200718040540.5"><vh>fireRefreshFile</vh></v>
<v t="felix.20200718040540.6"><vh>refreshPossibleGnxList</vh></v>
<v t="felix.20200718040540.8"><vh>watch</vh></v>
<v t="felix.20200718040540.10"><vh>stat</vh></v>
<v t="felix.20200718040540.11"><vh>readFile</vh></v>
<v t="felix.20200718040540.12"><vh>readDirectory</vh></v>
<v t="felix.20200718040540.13"><vh>createDirectory</vh></v>
<v t="felix.20200718040540.14"><vh>writeFile</vh></v>
<v t="felix.20200718040540.15"><vh>rename</vh></v>
<v t="felix.20200718040540.16"><vh>delete</vh></v>
<v t="felix.20200718040540.17"><vh>copy</vh></v>
<v t="felix.20200718040540.18"><vh>_fireSoon</vh></v>
</v>
</v>
<v t="felix.20200718153505.1"><vh>@clean src/leoBridge.ts</vh>
<v t="felix.20200718153505.2"><vh>class LeoBridge</vh>
<v t="felix.20200718153505.3"><vh>action</vh></v>
<v t="felix.20200718155251.1"><vh>isBusy</vh></v>
<v t="felix.20200718153505.4"><vh>_asyncAction</vh></v>
<v t="felix.20200718153505.5"><vh>_buildActionParameter</vh></v>
<v t="felix.20200718153505.6"><vh>_resolveBridgeReady</vh></v>
<v t="felix.20200718153505.7"><vh>_rejectAction</vh></v>
<v t="felix.20200718153505.8"><vh>_callAction</vh></v>
<v t="felix.20200718153505.9"><vh>_tryParseJSON</vh></v>
<v t="felix.20200718153505.11"><vh>_processAnswer</vh></v>
<v t="felix.20200718153505.12"><vh>initLeoProcess</vh></v>
<v t="felix.20200718153505.13"><vh>_send</vh></v>
</v>
</v>
<v t="felix.20200718162303.1"><vh>@clean src/leoButtonNode.ts</vh>
<v t="felix.20200718162303.2"><vh>class LeoButtonNode</vh>
<v t="felix.20200718162435.1"><vh>iconPath</vh></v>
<v t="felix.20200718162442.1"><vh>id</vh></v>
<v t="felix.20200718162452.1"><vh>tooltip</vh></v>
<v t="felix.20200718162459.1"><vh>description</vh></v>
</v>
</v>
<v t="felix.20200718164130.1"><vh>@clean src/leoButtons.ts</vh>
<v t="felix.20200718164130.2"><vh>class LeoButtonsProvider</vh>
<v t="felix.20200718164130.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718164130.4"><vh>getTreeItem</vh></v>
<v t="felix.20200718164130.5"><vh>getChildren</vh></v>
<v t="felix.20200718164130.6"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718164509.1"><vh>@clean src/leoDocumentNode.ts</vh>
<v t="felix.20200718164509.2"><vh>class LeoDocumentNode</vh>
<v t="felix.20200718164635.1"><vh>iconPath</vh></v>
<v t="felix.20200718164638.1"><vh>id</vh></v>
</v>
</v>
<v t="felix.20200718165108.1"><vh>@clean src/leoDocuments.ts</vh>
<v t="felix.20200718165108.2"><vh>class LeoDocumentsProvider</vh>
<v t="felix.20200718165108.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718165108.4"><vh>getTreeItem</vh></v>
<v t="felix.20200718165108.5"><vh>getChildren</vh></v>
<v t="felix.20200718165108.6"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718170429.1"><vh>@clean src/leoFileBrowser.ts</vh>
<v t="felix.20200718170429.2"><vh>class LeoFilesBrowser</vh>
<v t="felix.20200718170429.3"><vh>_getBestOpenFolderUri</vh></v>
<v t="felix.20210602160216.1"><vh>getImportFileUrl</vh></v>
<v t="felix.20200718170429.4"><vh>getLeoFileUrl</vh></v>
</v>
</v>
<v t="felix.20200719025231.1"><vh>@clean src/leoIntegration.ts</vh>
<v t="felix.20200719025231.2"><vh>class LeoIntegration</vh>
<v t="felix.20200719025231.3"><vh>Constructor</vh></v>
<v t="felix.20200719025231.4"><vh>Server</vh>
<v t="felix.20200719025231.5"><vh>sendAction</vh></v>
<v t="felix.20200719025231.6"><vh>startNetworkServices</vh></v>
<v t="felix.20200719025231.7"><vh>startServer</vh></v>
<v t="felix.20200719025231.8"><vh>connect</vh></v>
<v t="felix.20200719025231.9"><vh>cancelConnect</vh></v>
<v t="felix.20210613210351.1"><vh>chooseLeoFolder</vh></v>
<v t="felix.20200719031346.1"><vh>sendConfigToServer</vh></v>
</v>
<v t="felix.20200719025231.10"><vh>Recent files</vh>
<v t="felix.20200719025231.11"><vh>_openLastFiles</vh></v>
<v t="felix.20200719025231.12"><vh>_addRecentAndLastFile</vh></v>
<v t="felix.20200719025231.13"><vh>_removeRecentFile</vh></v>
<v t="felix.20200719025231.14"><vh>_removeLastFile</vh></v>
<v t="felix.20200719025231.15"><vh>showRecentLeoFiles</vh></v>
</v>
<v t="ekr.20200815085229.1"><vh>Log &amp; Terminal panes</vh>
<v t="ekr.20200815085316.1"><vh>showTerminalPane</vh></v>
<v t="ekr.20200815085316.2"><vh>hideTerminalPane</vh></v>
<v t="ekr.20200815085316.3"><vh>addTerminalPaneEntry</vh></v>
<v t="ekr.20200815085316.4"><vh>showLogPane</vh></v>
<v t="ekr.20200815085316.5"><vh>hideLogPane</vh></v>
<v t="ekr.20200815085316.6"><vh>addLogPaneEntry</vh></v>
</v>
<v t="felix.20200719031802.1"><vh>Document States</vh>
<v t="felix.20200719025231.19"><vh>_triggerGetStates</vh></v>
<v t="felix.20200719025231.20"><vh>_isBusy</vh></v>
<v t="felix.20201107224112.1"><vh>_isBusyTriggerSave</vh></v>
<v t="felix.20200719025231.21"><vh>_isCurrentFileNamed</vh></v>
<v t="felix.20200719025231.22"><vh>_setupNoOpenedLeoDocument</vh></v>
<v t="felix.20200719025231.23"><vh>_setupOpenedLeoDocument</vh></v>
</v>
<v t="felix.20200719030811.1"><vh>UI Change Events</vh>
<v t="felix.20200719025231.24"><vh>_onChangeConfiguration</vh></v>
<v t="ekr.20200815085628.1"><vh>_onDidOpenTextDocument</vh></v>
<v t="felix.20200719025231.25"><vh>_onChangeCollapsedState</vh></v>
<v t="felix.20200719025231.26"><vh>_onTreeViewVisibilityChanged</vh></v>
<v t="felix.20200719025231.27"><vh>_onDocTreeViewVisibilityChanged</vh></v>
<v t="ekr.20200815085705.1"><vh>_onButtonsTreeViewVisibilityChanged</vh></v>
<v t="felix.20200719025231.29"><vh>_onActiveEditorChanged</vh></v>
<v t="felix.20210418014039.1"><vh>_changedTextEditorViewColumn</vh></v>
<v t="felix.20210418014040.1"><vh>_changedVisibleTextEditors</vh></v>
<v t="felix.20210418014040.2"><vh>_changedWindowState</vh></v>
<v t="felix.20200928004727.1"><vh>_onChangeEditorSelection</vh></v>
<v t="felix.20201014020145.1"><vh>_onChangeEditorScroll</vh></v>
<v t="felix.20200719025231.31"><vh>_onDocumentChanged</vh></v>
</v>
<v t="felix.20200719030842.1"><vh>Body Editing</vh>
<v t="felix.20200719025231.32"><vh>triggerBodySave</vh></v>
<v t="felix.20200928133238.1"><vh>_bodySaveSelection</vh></v>
<v t="felix.20200719025231.33"><vh>_bodySaveDocument</vh></v>
</v>
<v t="felix.20200719030902.1"><vh>Refresh UI</vh>
<v t="felix.20200719025231.34"><vh>setDocumentSelection</vh></v>
<v t="felix.20200719025231.35"><vh>showOutline</vh></v>
<v t="felix.20201114185218.1"><vh>setTreeViewTitle</vh></v>
<v t="ekr.20200815085806.1"><vh>configTreeRefresh</vh></v>
<v t="ekr.20200815085830.1"><vh>_refreshOutline</vh></v>
<v t="ekr.20200815085830.2"><vh>_revealTreeViewNode</vh></v>
<v t="ekr.20200815085830.3"><vh>launchRefresh</vh></v>
<v t="ekr.20200815085830.4"><vh>_refreshDocumentsPane</vh></v>
<v t="ekr.20200815085830.5"><vh>_gotSelection</vh></v>
<v t="felix.20210528012836.1"><vh>getBridgeFocus</vh></v>
</v>
<v t="felix.20200719030909.1"><vh>Conversion</vh>
<v t="felix.20200719025231.38"><vh>apToLeoNode</vh></v>
<v t="felix.20200719025231.39"><vh>_apToLeoNodeConvertReveal</vh></v>
<v t="felix.20200719025231.40"><vh>arrayToLeoNodesArray</vh></v>
</v>
<v t="felix.20200719031115.1"><vh>Body Pane Management</vh>
<v t="ekr.20200815090152.1"><vh>_tryApplyNodeToBody</vh></v>
<v t="felix.20200719025231.47"><vh>_switchBody</vh></v>
<v t="felix.20200719025231.48"><vh>_locateOpenedBody</vh></v>
<v t="felix.20210418230204.1"><vh>_findUriColumn</vh></v>
<v t="felix.20210418230204.2"><vh>_findGnxColumn</vh></v>
<v t="felix.20210418013332.1"><vh>_hideDeleteBody</vh></v>
<v t="felix.20210418220343.1"><vh>_checkPreviewMode</vh></v>
<v t="felix.20200719025231.49"><vh>closeBody</vh></v>
<v t="felix.20200719025231.50"><vh>showBody</vh></v>
</v>
<v t="felix.20200719025231.51"><vh>Commands</vh>
<v t="felix.20201114185813.1"><vh>minibuffer</vh></v>
<v t="felix.20200719025231.52"><vh>selectTreeNode</vh></v>
<v t="ekr.20200815090400.1"><vh>nodeCommand</vh></v>
<v t="felix.20200719025231.54"><vh>changeMark</vh></v>
<v t="felix.20200719025231.55"><vh>editHeadline</vh></v>
<v t="felix.20200719025231.56"><vh>insertNode</vh></v>
</v>
<v t="felix.20210530225640.1"><vh>Search</vh>
<v t="felix.20210516233931.1"><vh>startSearch</vh></v>
<v t="felix.20210613212439.1"><vh>newHeadline</vh></v>
<v t="felix.20210613205741.1"><vh>_inputFindPattern</vh></v>
<v t="felix.20210516234059.1"><vh>find</vh></v>
<v t="felix.20210530223726.1"><vh>replace</vh></v>
<v t="felix.20210530230354.1"><vh>replaceAll</vh></v>
<v t="felix.20210530230400.1"><vh>cloneFind</vh></v>
<v t="felix.20210530225306.1"><vh>setSearchOption</vh></v>
<v t="felix.20210525232728.1"><vh>loadSearchSettings</vh></v>
<v t="felix.20210524215215.1"><vh>saveSearchSettings</vh></v>
<v t="felix.20210601164915.1"><vh>gotoGlobalLine</vh></v>
</v>
<v t="felix.20200719025231.57"><vh>Leo Documents</vh>
<v t="felix.20200719025231.58"><vh>saveAsLeoFile</vh></v>
<v t="felix.20200719025231.59"><vh>saveLeoFile</vh></v>
<v t="felix.20200719025231.60"><vh>switchLeoFile</vh></v>
<v t="felix.20200719025231.61"><vh>selectOpenedLeoDocument</vh></v>
<v t="fil.20210609233100.1"><vh>clearRecentLeoFiles</vh></v>
<v t="felix.20200719025231.64"><vh>closeLeoFile</vh></v>
<v t="felix.20200719025231.65"><vh>newLeoFile</vh></v>
<v t="felix.20200719025231.66"><vh>openLeoFile</vh></v>
<v t="felix.20210602155312.1"><vh>importFile</vh></v>
</v>
<v t="felix.20200719033306.1"><vh>AtButtons</vh>
<v t="ekr.20200815090517.1"><vh>clickAtButton</vh></v>
<v t="ekr.20200815090517.2"><vh>removeAtButton</vh></v>
</v>
<v t="felix.20200719033511.1"><vh>Other</vh>
<v t="felix.20210610022836.1"><vh>prevNextNode</vh></v>
<v t="felix.20210524231157.1"><vh>setFindPanel</vh></v>
<v t="felix.20200719025231.69"><vh>statusBarOnClick</vh></v>
<v t="felix.20200719025231.70"><vh>test</vh></v>
</v>
</v>
</v>
<v t="felix.20200718170712.1"><vh>@clean src/leoNode.ts</vh>
<v t="felix.20200718170712.2"><vh>class LeoNode</vh>
<v t="felix.20200718170712.4"><vh>setRoot</vh></v>
<v t="felix.20200718170712.5"><vh>_getNodeContextValue</vh></v>
<v t="felix.20200718171904.1"><vh>get_iconPath</vh></v>
<v t="felix.20200718171854.1"><vh>get_id</vh></v>
<v t="felix.20200718171837.1"><vh>get_description</vh></v>
<v t="felix.20200718171849.1"><vh>get tooltip</vh></v>
</v>
</v>
<v t="felix.20200718180428.1"><vh>@clean src/leoOutline.ts</vh>
<v t="felix.20200718180428.2"><vh>class LeoOutlineProvider</vh>
<v t="felix.20200718180428.4"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718180428.5"><vh>getTreeItem</vh></v>
<v t="felix.20200718180428.6"><vh>getChildren</vh></v>
<v t="felix.20200718180428.7"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718192351.1"><vh>@clean src/leoStates.ts</vh>
<v t="felix.20200718192411.1"><vh>class LeoStates</vh>
<v t="felix.20200718193719.1"><vh>General State Flags</vh>
<v t="felix.20200718193219.1"><vh>leoBridgeReady &amp; helper</vh></v>
<v t="felix.20200718193222.1"><vh>fileOpenedReady &amp; helper</vh></v>
<v t="felix.20200718193226.1"><vh>leoOpenedFileName</vh></v>
<v t="felix.20200718193230.1"><vh>leoChanged &amp; helper</vh></v>
<v t="felix.20200718193233.1"><vh>leoCanUndo &amp; helper</vh></v>
<v t="felix.20200718193235.1"><vh>leoCanRedo &amp; helper</vh></v>
<v t="felix.20200718193238.1"><vh>leoCanDemote &amp; helper</vh></v>
<v t="felix.20200718193241.1"><vh>leoCanPromote &amp; helper</vh></v>
<v t="felix.20200718193244.1"><vh>leoCanDehoist &amp; helper</vh></v>
</v>
<v t="felix.20200718193731.1"><vh>Selected Node Flags</vh>
<v t="felix.20200718193338.1"><vh>leoMarked</vh></v>
<v t="felix.20200718193341.1"><vh>leoCloned</vh></v>
<v t="felix.20200718193343.1"><vh>leoDirty</vh></v>
<v t="felix.20200718193348.1"><vh>leoEmpty</vh></v>
<v t="felix.20200718193350.1"><vh>leoChild</vh></v>
<v t="felix.20200718193353.1"><vh>leoAtFile</vh></v>
<v t="felix.20200718193403.1"><vh>leoRoot</vh></v>
</v>
<v t="felix.20200718193500.1"><vh>constructor</vh></v>
<v t="felix.20200718192411.2"><vh>selectedNodeFlags</vh></v>
<v t="felix.20200718192411.3"><vh>leoStateFlags</vh></v>
</v>
</v>
<v t="felix.20200718185403.1"><vh>@clean src/leoStatusBar.ts</vh>
<v t="felix.20200718185403.2"><vh>class LeoStatusBar</vh>
<v t="felix.20200718185403.3"><vh>show</vh></v>
<v t="felix.20200718185403.4"><vh>hide</vh></v>
<v t="felix.20200718185403.5"><vh>setString</vh></v>
<v t="felix.20200718185403.6"><vh>update</vh></v>
<v t="felix.20200718185403.7"><vh>_updateLeoObjectIndicatorDebounced</vh></v>
<v t="felix.20200718185403.8"><vh>_updateLeoObjectIndicator</vh></v>
</v>
</v>
<v t="felix.20200718191946.1"><vh>@clean src/serverManager.ts</vh>
<v t="felix.20200718191946.2"><vh>class ServerService</vh>
<v t="ekr.20200815091220.1"><vh>_gotTerminalData</vh></v>
<v t="felix.20200718191946.4"><vh>startServer</vh></v>
</v>
</v>
<v t="felix.20200718194857.1"><vh>@clean src/types.d.ts</vh>
<v t="felix.20200718194857.2"><vh>ConfigMembers</vh></v>
<v t="felix.20201017224340.1"><vh>ConfigSetting</vh></v>
<v t="felix.20200718194857.3"><vh>RevealType</vh></v>
<v t="felix.20200718194857.4"><vh>RefreshType</vh></v>
<v t="felix.20200718194857.5"><vh>UserCommand</vh></v>
<v t="ekr.20200815091346.1"><vh>ShowBodyParam</vh></v>
<v t="felix.20200718194857.6"><vh>LeoAction</vh></v>
<v t="felix.20200718194857.7"><vh>LeoLogEntry</vh></v>
<v t="felix.20200718194857.8"><vh>ArchivedPosition</vh></v>
<v t="ekr.20200815091408.1"><vh>LeoPackageStates</vh></v>
<v t="felix.20200718194857.10"><vh>LeoBridgePackage</vh></v>
<v t="felix.20200718194857.11"><vh>LeoDocument</vh></v>
<v t="felix.20200718194857.12"><vh>LeoButton</vh></v>
<v t="felix.20210522152922.1"><vh>LeoSearchScope</vh></v>
<v t="felix.20210522152739.1"><vh>LeoSearchSettings</vh></v>
<v t="felix.20210523162125.1"><vh>LeoGuiFindTabManagerSettings</vh></v>
<v t="felix.20200718194857.13"><vh>Icon</vh></v>
<v t="felix.20200718194857.14"><vh>BodyTimeInfo</vh></v>
<v t="felix.20201119002510.1"><vh>BodyPosition</vh></v>
<v t="felix.20201006195046.1"><vh>BodySelectionInfo</vh></v>
<v t="felix.20200718194857.15"><vh>showSaveAsDialogParameters</vh></v>
<v t="felix.20200718194857.16"><vh>runAskYesNoDialogParameters</vh></v>
<v t="felix.20200718194857.17"><vh>runWarnMessageDialogParameters</vh></v>
<v t="felix.20200718194857.18"><vh>runInfoMessageDialogParameters</vh></v>
<v t="felix.20200718194857.19"><vh>AskMessageItem</vh></v>
<v t="felix.20200718194857.20"><vh>ChooseDocumentItem</vh></v>
<v t="ekr.20200815091534.1"><vh>MinibufferCommand</vh></v>
</v>
<v t="felix.20200718195558.1"><vh>@clean src/utils.ts</vh>
<v t="felix.20200718195558.2"><vh>padNumber2</vh></v>
<v t="ekr.20200815091619.1"><vh>hashNode</vh></v>
<v t="felix.20201106200100.1"><vh>addFileToGlobal</vh></v>
<v t="felix.20201106200109.1"><vh>removeFileFromGlobal</vh></v>
<v t="felix.20200718195558.3"><vh>buildNodeIconPaths</vh></v>
<v t="felix.20200718195558.4"><vh>buildDocumentIconPaths</vh></v>
<v t="ekr.20200815091945.1"><vh>buildButtonsIconPaths</vh></v>
<v t="felix.20200718195558.6"><vh>buildNodeAndTextJson</vh></v>
<v t="felix.20201018163510.1"><vh>getDurationMilliseconds</vh></v>
<v t="felix.20200718195558.7"><vh>getFileFromPath</vh></v>
<v t="felix.20200718195558.8"><vh>isIconChangedByEdit</vh></v>
<v t="felix.20200718195558.9"><vh>isHexColor</vh></v>
<v t="felix.20200718195558.10"><vh>strToLeoUri</vh></v>
<v t="felix.20200718195558.11"><vh>leoUriToStr</vh></v>
<v t="felix.20200718195558.12"><vh>setContext</vh></v>
<v t="felix.20210612214028.1"><vh>findNextAvailablePort</vh></v>
<v t="felix.20210612230258.1"><vh>asyncFindPort</vh></v>
<v t="felix.20210612155932.1"><vh>portInUse</vh></v>
</v>
<v t="felix.20210522001751.1"><vh>@clean src/webviews/leoFindPanelWebview.ts</vh>
<v t="felix.20210522001814.1"><vh>class LeoFindPanelProvider</vh>
<v t="fil.20210603195851.1"><vh>resolveWebviewView</vh></v>
<v t="fil.20210603195902.1"><vh>_getHtmlForWebview</vh></v>
<v t="fil.20210603195909.1"><vh>getNonce</vh></v>
</v>
</v>
<v t="fil.20210603195218.1"><vh>@clean src/webviews/leoSettingsWebview.ts</vh>
<v t="fil.20210603195319.1"><vh>class LeoSettingsWebview</vh>
<v t="fil.20210603195319.2"><vh>_onChangeConfiguration</vh></v>
<v t="fil.20210603195319.3"><vh>openWebview</vh></v>
<v t="fil.20210603195319.4"><vh>_getBaseHtml</vh></v>
</v>
</v>
</v>
<v t="fil.20210603223013.1"><vh>Files: Find Panel Webview</vh>
<v t="fil.20210603223013.2"><vh>@clean src/webviews/findPanel/main.css</vh></v>
<v t="fil.20210603223013.4"><vh>@clean src/webviews/findPanel/main.js</vh>
<v t="fil.20210603223013.5"><vh>function</vh>
<v t="fil.20210603223013.6"><vh>window.addEventListener =&gt;</vh></v>
<v t="fil.20210603223013.7"><vh>function setSearchSetting</vh></v>
<v t="fil.20210603223013.8"><vh>function setSettings</vh>
<v t="fil.20210603223013.9"><vh>inputIds.forEach =&gt;</vh></v>
<v t="fil.20210603223013.10"><vh>checkboxIds.forEach =&gt;</vh></v>
</v>
<v t="fil.20210603223013.11"><vh>function sendSearchConfig</vh></v>
<v t="fil.20210603223013.12"><vh>function processChange</vh>
<v t="fil.20210603223013.13"><vh>timer = setTimeout =&gt;</vh></v>
</v>
<v t="fil.20210603223013.14"><vh>inputIds.forEach =&gt;</vh>
<v t="fil.20210603223013.15"><vh>document.getElementById(p_inputId).onkeypress = function</vh></v>
<v t="fil.20210603223013.16"><vh>document.getElementById(p_inputId).addEventListener('input', function</vh></v>
</v>
<v t="fil.20210603223013.17"><vh>checkboxIds.forEach =&gt;</vh>
<v t="fil.20210603223013.18"><vh>document.getElementById(p_inputId).addEventListener('change', function</vh></v>
</v>
<v t="fil.20210603223013.19"><vh>radioIds.forEach =&gt;</vh>
<v t="fil.20210603223013.20"><vh>document.getElementById(p_inputId).addEventListener('change', function</vh></v>
</v>
<v t="fil.20210603223013.21"><vh>function toggleCheckbox</vh></v>
<v t="fil.20210603223013.22"><vh>function setRadio</vh></v>
<v t="fil.20210603223013.23"><vh>function checkKeyDown</vh></v>
<v t="fil.20210603223013.24"><vh>function focusOnField</vh>
<v t="fil.20210603223013.25"><vh>setTimeout =&gt;</vh></v>
</v>
<v t="fil.20210603223013.26"><vh>function getSettings</vh></v>
</v>
</v>
<v t="fil.20210603223014.2"><vh>@clean src/webviews/findPanel/reset.css</vh></v>
<v t="fil.20210603223014.4"><vh>@clean src/webviews/findPanel/vscode.css</vh></v>
</v>
<v t="fil.20210603223933.1"><vh>Files: Settings Panel Webview</vh>
<v t="fil.20210603223933.2"><vh>@clean src/webviews/settingsPanel/colors.ts</vh>
<v t="fil.20210603223933.3"><vh>adjustLight</vh></v>
<v t="fil.20210603223933.4"><vh>darken</vh></v>
<v t="fil.20210603223933.5"><vh>lighten</vh></v>
<v t="fil.20210603223933.6"><vh>opacity</vh></v>
<v t="fil.20210603223933.7"><vh>toRgba</vh></v>
</v>
<v t="fil.20210603223933.9"><vh>@clean src/webviews/settingsPanel/index.html</vh>
<v t="fil.20210603223933.10"><vh>&lt;html&gt;</vh></v>
</v>
<v t="fil.20210603223933.165"><vh>@clean src/webviews/settingsPanel/index.ts</vh>
<v t="fil.20210603223933.166"><vh>main</vh>
<v t="fil.20210603223934.1"><vh>listenAll</vh></v>
<v t="fil.20210603223934.2"><vh>chooseLeoServerPath</vh></v>
<v t="fil.20210603223934.3"><vh>onBind</vh></v>
<v t="fil.20210603223934.4"><vh>onInputSelected</vh></v>
<v t="fil.20210603223934.5"><vh>onInputChecked</vh></v>
<v t="fil.20210603223934.6"><vh>onInputBlurred</vh></v>
<v t="fil.20210603223934.7"><vh>onInputFocused</vh></v>
<v t="fil.20210603223934.8"><vh>onInputChanged</vh></v>
<v t="fil.20210603223934.9"><vh>setControls</vh></v>
<v t="fil.20210603223934.10"><vh>setVisibility</vh></v>
<v t="fil.20210603223934.11"><vh>parseStateExpression</vh></v>
<v t="fil.20210603223934.12"><vh>evaluateStateExpression</vh></v>
<v t="fil.20210603223934.13"><vh>getSettingValue</vh></v>
</v>
</v>
<v t="fil.20210603223934.15"><vh>@clean src/webviews/settingsPanel/theme.ts</vh>
<v t="fil.20210603223934.16"><vh>initializeAndWatchThemeColors</vh></v>
</v>
<v t="fil.20210603223956.2"><vh>@clean src/webviews/settingsPanel/scss/main.scss</vh></v>
<v t="fil.20210603223956.4"><vh>@clean src/webviews/settingsPanel/scss/popup.scss</vh></v>
</v>
<v t="ekr.20200808100339.1"><vh>----- TS Classes</vh>
<v t="felix.20200718024635.2"></v>
<v t="felix.20200718030926.2"></v>
<v t="felix.20200718020912.2"></v>
<v t="ekr.20200815083608.1"></v>
<v t="felix.20200718040540.2"></v>
<v t="felix.20200718153505.2"></v>
<v t="felix.20200718162303.2"></v>
<v t="felix.20200718164130.2"></v>
<v t="felix.20200718164509.2"></v>
<v t="felix.20200718165108.2"></v>
<v t="felix.20200718170429.2"></v>
<v t="felix.20210522001814.1"></v>
<v t="felix.20200719025231.2"></v>
<v t="felix.20200718170712.2"></v>
<v t="fil.20210603195319.1"></v>
<v t="felix.20200718192411.1"></v>
<v t="felix.20200718180428.2"></v>
<v t="felix.20200718185403.2"></v>
<v t="felix.20200718191946.2"></v>
</v>
<v t="felix.20191126232434.4"></v>
<v t="felix.20210516004048.1"><vh>BACKUP WIP class LeoServer</vh>
<v t="felix.20210516004048.2"><vh>server.__init__ (load bridge)</vh></v>
<v t="felix.20210516004048.3"><vh>server:public commands</vh>
<v t="felix.20210516004048.4"><vh>server:button commands</vh>
<v t="felix.20210516004048.5"><vh>_check_button_command</vh></v>
<v t="felix.20210516004048.6"><vh>server.click_button</vh></v>
<v t="felix.20210516004048.7"><vh>server.get_buttons</vh></v>
<v t="felix.20210516004048.8"><vh>server.remove_button</vh></v>
</v>
<v t="felix.20210516004048.9"><vh>server:file commands</vh>
<v t="felix.20210516004048.10"><vh>server.open_file</vh></v>
<v t="felix.20210516004048.11"><vh>server.open_files</vh></v>
<v t="felix.20210516004048.12"><vh>server.set_opened_file</vh></v>
<v t="felix.20210516004048.13"><vh>server.close_file</vh></v>
<v t="felix.20210516004048.14"><vh>server.save_file</vh></v>
</v>
<v t="felix.20210516004048.15"><vh>server:find commands</vh>
<v t="felix.20210516004048.16"><vh>server._get_find_settings</vh></v>
<v t="felix.20210516004048.17"><vh>server.find_all</vh></v>
<v t="felix.20210516004048.18"><vh>server.change_all</vh></v>
<v t="felix.20210516004048.19"><vh>server.change_then_find</vh></v>
<v t="felix.20210516004048.20"><vh>server.clone_find_all</vh></v>
<v t="felix.20210516004048.21"><vh>server.clone_find_all_flattened</vh></v>
<v t="felix.20210516004048.22"><vh>server.clone_find_tag</vh></v>
<v t="felix.20210516004048.23"><vh>server.find_def</vh></v>
<v t="felix.20210516004048.24"><vh>server.find_next</vh></v>
<v t="felix.20210516004048.25"><vh>server.find_previous</vh></v>
<v t="felix.20210516004048.26"><vh>server.find_var</vh></v>
<v t="felix.20210516004048.27"><vh>server.tag_children</vh></v>
</v>
<v t="felix.20210516004048.28"><vh>server:getter commands</vh>
<v t="felix.20210516004048.29"><vh>server.get_all_open_commanders</vh></v>
<v t="felix.20210516004048.30"><vh>server.get_all_positions</vh></v>
<v t="felix.20210516004048.31"><vh>server.get_all_gnx</vh></v>
<v t="felix.20210516004048.32"><vh>server.get_body</vh></v>
<v t="felix.20210516004048.33"><vh>server.get_body_length</vh></v>
<v t="felix.20210516004048.34"><vh>server.get_body_states</vh></v>
<v t="felix.20210516004048.35"><vh>server.get_children</vh></v>
<v t="felix.20210516004048.36"><vh>server.get_focus</vh></v>
<v t="felix.20210516004048.37"><vh>server.get_parent</vh></v>
<v t="felix.20210516004048.38"><vh>server.get_position_dict</vh></v>
<v t="felix.20210516004048.39"><vh>server.get_ua</vh></v>
<v t="felix.20210516004048.40"><vh>server.get_sign_on</vh></v>
<v t="felix.20210516004048.41"><vh>server.get_ui_states</vh></v>
</v>
<v t="felix.20210516004048.42"><vh>server:node commands</vh>
<v t="felix.20210516004048.43"><vh>server.clone_node</vh></v>
<v t="felix.20210516004048.44"><vh>server.contract_node</vh></v>
<v t="felix.20210516004048.45"><vh>server.cut_node</vh></v>
<v t="felix.20210516004048.46"><vh>server.delete_node</vh></v>
<v t="felix.20210516004048.47"><vh>server.expand_node</vh></v>
<v t="felix.20210516004048.48"><vh>server.insert_node</vh></v>
<v t="felix.20210516004048.49"><vh>server.insert_named_node</vh></v>
<v t="felix.20210516004048.50"><vh>server.page_down</vh></v>
<v t="felix.20210516004048.51"><vh>server.page_up</vh></v>
<v t="felix.20210516004048.52"><vh>server.redo</vh></v>
<v t="felix.20210516004048.53"><vh>server.set_body</vh></v>
<v t="felix.20210516004048.54"><vh>server.set_current_position</vh></v>
<v t="felix.20210516004048.55"><vh>server.set_headline</vh></v>
<v t="felix.20210516004048.56"><vh>server.set_selection</vh></v>
<v t="felix.20210516004048.57"><vh>server.mark_node</vh></v>
<v t="felix.20210516004048.58"><vh>server.unmark_node</vh></v>
<v t="felix.20210516004048.59"><vh>server.undo</vh></v>
</v>
<v t="felix.20210516004048.60"><vh>server:server commands</vh>
<v t="felix.20210516004048.61"><vh>server.error</vh></v>
<v t="felix.20210516004048.62"><vh>server.get_all_leo_commands &amp; helper</vh>
<v t="felix.20210516004048.63"><vh>server._bad_commands</vh></v>
<v t="felix.20210516004048.64"><vh>server._good_commands</vh></v>
</v>
<v t="felix.20210516004048.65"><vh>server.get_all_server_commands</vh></v>
<v t="felix.20210516004048.66"><vh>server.init_connection</vh></v>
<v t="felix.20210516004048.67"><vh>server.set_ask_result</vh></v>
<v t="felix.20210516004048.68"><vh>server.set_config</vh></v>
<v t="felix.20210516004048.69"><vh>server.shut_down</vh></v>
</v>
</v>
<v t="felix.20210516004048.70"><vh>server:server utils</vh>
<v t="felix.20210516004048.71"><vh>server._ap_to_p</vh></v>
<v t="felix.20210516004048.72"><vh>server._check_c</vh></v>
<v t="felix.20210516004048.73"><vh>server._check_outline</vh></v>
<v t="felix.20210516004048.74"><vh>server._check_outline_positions</vh></v>
<v t="felix.20210516004048.75"><vh>server._do_leo_command</vh></v>
<v t="felix.20210516004048.76"><vh>server._do_message</vh></v>
<v t="felix.20210516004048.77"><vh>server._do_server_command</vh></v>
<v t="felix.20210516004048.78"><vh>server._dump_*</vh></v>
<v t="felix.20210516004048.79"><vh>server._es &amp; helper</vh>
<v t="felix.20210516004048.80"><vh>server._async_output</vh></v>
</v>
<v t="felix.20210516004048.81"><vh>server._get_p</vh></v>
<v t="felix.20210516004048.82"><vh>server._get_position_d</vh></v>
<v t="felix.20210516004048.83"><vh>server._make_response</vh></v>
<v t="felix.20210516004048.84"><vh>server._make_minimal_response</vh></v>
<v t="felix.20210516004048.85"><vh>server._p_to_ap</vh></v>
<v t="felix.20210516004048.86"><vh>serverver._test_round_trip_positions</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20200722125546.1">@language python

g.cls()
d = c.commandsDict  # keys are command names, values are functions.
for command_name in sorted(d):
    if command_name.startswith('@'):
        continue
    func = d.get(command_name)
    # Prefer func.__func_name__ to func.__name__: Leo's decorators change func.__name__!
    func_name = getattr(func, '__func_name__', func.__name__)
    # print(f"{command_name:&gt;40} {func_name}")
    print(command_name)
print('len(d)', len(d))

</t>
<t tx="ekr.20200722190504.1"></t>
<t tx="ekr.20200722190517.1"></t>
<t tx="ekr.20200724052304.1">c.backup_helper(sub_dir='leoInteg')
</t>
<t tx="ekr.20200808100339.1"></t>
<t tx="ekr.20200808100711.1"></t>
<t tx="ekr.20200808100717.1">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20200815083608.1">/**
 * * Handles the functions called by Leo through leoBridge such as adding a log pane entry, runAskYesNoDialog for file changes, etc.
 * * Some config settings affect this behavior, such as defaultReloadIgnore and checkForChangeExternalFiles
 */
export class LeoAsync {

    private _askResult: string = "";

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    /**
     * * Adds message string to leoInteg's log pane, used when leoBridge gets an async 'log' command
     */
    @others
}

&lt;&lt; TODO &gt;&gt;
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200815083608.2">public log(p_message: string): void {
    this._leoIntegration.addLogPaneEntry(p_message);
}

</t>
<t tx="ekr.20200815083608.3">/**
 * * Equivalent to runSaveFileDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * @param p_saveAsArg
 */
public showSaveAsDialog(p_saveAsArg: showSaveAsDialogParameters): void {
    console.log('TODO: SHOW SAVE AS DIALOG!');
}

</t>
<t tx="ekr.20200815083609.1">/**
 * * Equivalent to runAskYesNoDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * * Opens a modal dialog to return one of 'yes', 'yes-all', 'no' or 'no-all' to be sent back with the leoBridge 'ASK_RESULT' action
 * @param p_askArg an async package object {"ask": title, "message": message, "yes_all": yes_all, "no_all": no_all}
 */
public showAskModalDialog(p_askArg: runAskYesNoDialogParameters): void {
    this._askResult = "no"; // defaults to not doing anything, matches isCloseAffordance just to be safe
    // Note: "last line" could be eventually used in the message
    // const w_lastLine = p_askArg.message.substr(p_askArg.message.lastIndexOf("\n") + 1);
    const w_items: AskMessageItem[] = [
        {
            title: Constants.USER_MESSAGES.YES,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES,
            isCloseAffordance: false
        },
        {
            title: Constants.USER_MESSAGES.NO,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO,
            isCloseAffordance: true
        }
    ];
    if (p_askArg.yes_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.YES_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES_ALL,
            isCloseAffordance: false
        });
    }
    if (p_askArg.no_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.NO_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO_ALL,
            isCloseAffordance: false
        });
    }
    const w_askRefreshInfoMessage: Thenable&lt;AskMessageItem | undefined&gt; = vscode.window.showInformationMessage(
        p_askArg.message,
        { modal: true },
        ...w_items
    );
    w_askRefreshInfoMessage.then((p_result: AskMessageItem | undefined) =&gt; {
        if (p_result) {
            this._askResult = p_result.value;
        }
        const w_sendResultPromise = this._leoIntegration.sendAction(Constants.LEOBRIDGE.ASK_RESULT, '"' + this._askResult + '"'); // Quotes in string as a 'JSON parameter'
        if (this._askResult.includes(Constants.ASYNC_ASK_RETURN_CODES.YES)) {
            w_sendResultPromise.then(() =&gt; {
                this._leoIntegration.launchRefresh({ tree: true, body: true, buttons: true, states: true, documents: true }, false);
            });
        }
    });
}

</t>
<t tx="ekr.20200815083609.2">/**
 * * Equivalent to runAskOkDialog from Leo's qt_gui.py, used when leoBridge gets an async 'warn' command
 * @param p_waitArg an async package object {"warn": "", "message": ""}
 */
public showWarnModalMessage(p_waitArg: runWarnMessageDialogParameters): void {
    vscode.window.showInformationMessage(
        p_waitArg.message,
        { modal: true }
    ).then(() =&gt; {
        this._leoIntegration.sendAction(Constants.LEOBRIDGE.ASK_RESULT, Constants.ASYNC_ASK_RETURN_CODES.OK); // Quotes in string as a 'JSON parameter'
    });
}

</t>
<t tx="ekr.20200815083609.3">/**
 * * Show non-blocking info message about detected file changes, used when leoBridge gets an async 'info' command
 * @param p_infoArg an async package object { "message": string; }
 */
public showChangesDetectedInfoMessage(p_infoArg: runInfoMessageDialogParameters): void {
    let w_message = Constants.USER_MESSAGES.CHANGES_DETECTED;
    switch (p_infoArg.message) {
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_REFRESHED:
            w_message += Constants.USER_MESSAGES.REFRESHED;
            // TODO : #34 @boltex Deal with focus placement
            this._leoIntegration.launchRefresh({ tree: true, body: true, states: true, documents: true }, false);
            break;
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_IGNORED:
            w_message += Constants.USER_MESSAGES.IGNORED;
            break;
        default:
            break;
    }
    vscode.window.showInformationMessage(w_message);
}

</t>
<t tx="ekr.20200815084016.1">/**
 * * Configuration Defaults used in config.ts
 * Used when setting itself and getting parameters from vscode
 */
public static CONFIG_DEFAULTS = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "none",  // Used in leoBridge scrip,
    DEFAULT_RELOAD_IGNORE: "none", // Used in leoBridge scrip,
    LEO_TREE_BROWSE: true,
    TREE_KEEP_FOCUS: true,
    TREE_KEEP_FOCUS_WHEN_ASIDE: false,
    STATUSBAR_STRING: "", // Strings like "Literate", "Leo", UTF-8 also supported: \u{1F981}
    STATUSBAR_COLOR: "fb7c47",
    TREE_IN_EXPLORER: true,
    SHOW_OPEN_ASIDE: true,
    SHOW_EDIT: true,
    SHOW_ARROWS: false,
    SHOW_ADD: false,
    SHOW_MARK: false,
    SHOW_CLONE: false,
    SHOW_COPY: false,
    INVERT_NODES: false,
    LEO_PYTHON_COMMAND: "",
    LEO_EDITOR_PATH: "",
    AUTO_START_SERVER: false,
    AUTO_CONNECT: false,
    IP_ADDRESS: "localhost",
    IP_LOOPBACK: "127.0.0.1",
    IP_PORT: 32125
};

</t>
<t tx="ekr.20200815084550.1">/*
    TODO : Should Reproduce those interactive controls that may be asked by Leo, and redo a true UI bridge

def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    return self.simulateDialog("aboutLeoDialog", None)

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog", None)

def runAskOkDialog(self, c, title, message=None, text="Ok"):
    return self.simulateDialog("okDialog", "Ok")

def runAskOkCancelNumberDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
):
    return self.simulateDialog("numberDialog", -1)

def runAskOkCancelStringDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
    default="",
    wide=False,
):
    return self.simulateDialog("stringDialog", '')

def runCompareDialog(self, c):
    return self.simulateDialog("compareDialog", '')

def runOpenFileDialog(self, c, title, filetypes, defaultextension,
    multiple=False,
    startpath=None,
):
    return self.simulateDialog("openFileDialog", None)

def runSaveFileDialog(self, c, initialfile, title, filetypes, defaultextension):
    return self.simulateDialog("saveFileDialog", None)

def runAskYesNoDialog(self, c, title,
    message=None,
    yes_all=False,
    no_all=False,
):
    return self.simulateDialog("yesNoDialog", "no")

def runAskYesNoCancelDialog(self, c, title,
    message=None,
    yesMessage="Yes",
    noMessage="No",
    yesToAllMessage=None,
    defaultButton="Yes",
    cancelMessage=None,
):
    return self.simulateDialog("yesNoCancelDialog", "cancel")

def simulateDialog(self, key, defaultVal):
    return defaultVal

*/
</t>
<t tx="ekr.20200815085229.1"></t>
<t tx="ekr.20200815085316.1">/**
 * * Reveals the leoBridge server terminal output if not already visible
 */
public showTerminalPane(): void {
    if (this._leoTerminalPane) {
        this._leoTerminalPane.show(true);
    }
}

</t>
<t tx="ekr.20200815085316.2">/**
 * * Hides the leoBridge server terminal output
 */
public hideTerminalPane(): void {
    if (this._leoTerminalPane) {
        this._leoTerminalPane.hide();
    }
}

</t>
<t tx="ekr.20200815085316.3">/**
 * * Adds a message string to leoInteg's leoBridge server terminal output.
 * @param p_message The string to be added in the log
 */
public addTerminalPaneEntry(p_message: string): void {
    if (this._leoTerminalPane) {
        this._leoTerminalPane.appendLine(p_message);
    }
}

</t>
<t tx="ekr.20200815085316.4">/**
 * * Reveals the log pane if not already visible
 */
public showLogPane(): void {
    this._leoLogPane.show(true);
}

</t>
<t tx="ekr.20200815085316.5">/**
 * * Hides the log pane
 */
public hideLogPane(): void {
    this._leoLogPane.hide();
}

</t>
<t tx="ekr.20200815085316.6">/**
 * * Adds a message string to leoInteg's log pane. Used when leoBridge receives an async 'log' command.
 * @param p_message The string to be added in the log
 */
public addLogPaneEntry(p_message: string): void {
    this._leoLogPane.appendLine(p_message);
}

</t>
<t tx="ekr.20200815085628.1">/**
 * * Handles the opening of a file in vscode, and check if it's a Leo file to suggest opening options
 * @param p_event The opened document event passed by vscode
 */
private _onDidOpenTextDocument(p_document: vscode.TextDocument): void {
    if (
        this.leoStates.leoBridgeReady &amp;&amp;
        p_document.uri.scheme === Constants.URI_LEO_SCHEME &amp;&amp;
        p_document.uri.fsPath.toLowerCase().endsWith('.leo')
    ) {
        if (!this._hasShownContextOpenMessage) {
            vscode.window.showInformationMessage(Constants.USER_MESSAGES.RIGHT_CLICK_TO_OPEN);
            this._hasShownContextOpenMessage = true;
        }
        // vscode.window.showQuickPick(
        //     [Constants.USER_MESSAGES.YES, Constants.USER_MESSAGES.NO],
        //     { placeHolder: Constants.USER_MESSAGES.OPEN_WITH_LEOINTEG }
        // )
        //     .then(p_result =&gt; {
        //         if (p_result &amp;&amp; p_result === Constants.USER_MESSAGES.YES) {
        //             const w_uri = p_document.uri;
        //             vscode.window.showTextDocument(p_document.uri, { preview: true, preserveFocus: false })
        //                 .then(() =&gt; {
        //                     return vscode.commands.executeCommand('workbench.action.closeActiveEditor');
        //                 })
        //                 .then(() =&gt; {
        //                     this.openLeoFile(w_uri);
        //                 });
        //         }
        //     });
    }
}

</t>
<t tx="ekr.20200815085705.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onButtonsTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {
    if (p_explorerView) {
    } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this._leoButtonsProvider.refreshTreeRoot();
    }
}

</t>
<t tx="ekr.20200815085806.1">/**
 * * Refresh tree for 'node hover icons' to show up properly after changing their settings
 */
public configTreeRefresh(): void {
    if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
        this._preventShowBody = true;
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="ekr.20200815085830.1">/**
 * * Refreshes the outline. A reveal type can be passed along to specify the reveal type for the selected node
 * @param p_revealType Facultative reveal type to specify type of reveal when the 'selected node' is encountered
 */
private _refreshOutline(p_incrementTreeID: boolean, p_revealType?: RevealType): void {
    if (p_incrementTreeID) {
        this._treeId++;
    }
    if (p_revealType !== undefined) {
        // To check if selected node should self-select while redrawing whole tree
        this._revealType = p_revealType; // To be read/cleared (in arrayToLeoNodesArray instead of directly by nodes)
    }
    // Force showing last used Leo outline first
    if (this.lastSelectedNode &amp;&amp; !(this._leoTreeExView.visible || this._leoTreeView.visible)) {
        this._lastTreeView.reveal(this.lastSelectedNode).then(() =&gt; {
            this._leoTreeProvider.refreshTreeRoot();
        });
    } else {
        this._leoTreeProvider.refreshTreeRoot();
    }
}

</t>
<t tx="ekr.20200815085830.2">/**
 * * 'TreeView.reveal' for any opened leo outline that is currently visible
 * @param p_leoNode The node to be revealed
 * @param p_options Options object for the revealed node to either also select it, focus it, and expand it
 */
private _revealTreeViewNode(
    p_leoNode: LeoNode,
    p_options?: { select?: boolean; focus?: boolean; expand?: boolean | number }
): Thenable&lt;void&gt; {
    if (this._leoTreeView.visible) {
        return this._leoTreeView.reveal(p_leoNode, p_options);
    }
    if (this._leoTreeExView.visible &amp;&amp; this.config.treeInExplorer) {
        return this._leoTreeExView.reveal(p_leoNode, p_options);
    }
    return Promise.resolve(); // Defaults to resolving even if both are hidden
}

</t>
<t tx="ekr.20200815085830.3">/**
 * * Launches refresh for UI components and states
 * @param p_refreshType choose to refresh the outline, or the outline and body pane along with it
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_ap // TODO ! DOCUMENT !
 */
public launchRefresh(
    p_refreshType: ReqRefresh,
    p_fromOutline: boolean,
    p_ap?: ArchivedPosition
): void {
    // Set w_revealType, it will ultimately set this._revealType.
    // Used when finding the OUTLINE's selected node and setting or preventing focus into it
    // Set this._fromOutline. Used when finding the selected node and showing the BODY to set or prevent focus in it
    this._refreshType = Object.assign({}, p_refreshType);
    let w_revealType: RevealType;
    if (p_fromOutline) {
        this._fromOutline = true;
        w_revealType = RevealType.RevealSelectFocus;
    } else {
        this._fromOutline = false;
        w_revealType = RevealType.RevealSelect;
    }
    if (
        p_ap &amp;&amp;
        this._refreshType.body &amp;&amp;
        this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty
    ) {
        // When this refresh is launched with 'refresh body' requested, we need to lose any pending edits and save on vscode's side.
        // do this only if gnx is different from what is coming from Leo in this refresh cycle
        if (
            p_ap.gnx !== utils.leoUriToStr(this._bodyLastChangedDocument.uri) &amp;&amp;
            !this._bodyLastChangedDocumentSaved
        ) {
            this._bodyLastChangedDocument.save(); // Voluntarily save to 'clean' any pending body
            this._bodyLastChangedDocumentSaved = true;
        }

        if (p_ap.gnx === utils.leoUriToStr(this._bodyLastChangedDocument.uri)) {
            this._leoFileSystem.preventSaveToLeo = true;
            this._bodyLastChangedDocument.save();
        }
    }
    // * _focusInterrupt insertNode Override
    if (this._focusInterrupt) {
        // this._focusInterrupt = false; // TODO : Test if reverting this in _gotSelection is 'ok'
        w_revealType = RevealType.RevealSelect;
    }
    // * Either the whole tree refreshes, or a single tree node is revealed when just navigating
    if (this._refreshType.tree) {
        this._refreshType.tree = false;
        this._refreshOutline(true, w_revealType);
    } else if (this._refreshType.node &amp;&amp; p_ap) {
        // * Force single node "refresh" by revealing it, instead of "refreshing" it
        this._refreshType.node = false;
        const w_node = this.apToLeoNode(p_ap);
        this.leoStates.setSelectedNodeFlags(w_node);
        this._revealTreeViewNode(w_node, {
            select: true,
            focus: true, // FOCUS FORCED TO TRUE always leave focus on tree when navigating
        });
        if (this._refreshType.body) {
            this._refreshType.body = false;
            this._tryApplyNodeToBody(w_node, false, true); // ! NEEDS STACK AND THROTTLE!
        }
    }
    this.getStates();
}

</t>
<t tx="ekr.20200815085830.4">/**
 * * Refresh the documents pane
 */
private _refreshDocumentsPane(): void {
    this._leoDocumentsProvider.refreshTreeRoot();
}

</t>
<t tx="ekr.20200815085830.5">/**
 * * Handle the selected node that was reached while converting received ap_nodes to LeoNodes
 * @param p_node The selected node that was reached while receiving 'children' from tree view api implementing Leo's outline
 */
private _gotSelection(p_node: LeoNode): void {
    // * Use the 'from outline' concept to decide if focus should be on body or outline after editing a headline
    let w_showBodyKeepFocus: boolean = this._fromOutline; // Will preserve focus where it is without forcing into the body pane if true
    if (this._focusInterrupt) {
        this._focusInterrupt = false; // TODO : Test if reverting this in _gotSelection is 'ok'
        w_showBodyKeepFocus = true;
    }
    this._tryApplyNodeToBody(p_node, false, w_showBodyKeepFocus);
}

</t>
<t tx="ekr.20200815090152.1">/**
 * * Makes sure the body now reflects the selected node.
 * This is called after 'selectTreeNode', or after '_gotSelection' when refreshing.
 * @param p_node Node that was just selected
 * @param p_aside Flag to indicate opening 'Aside' was required
 * @param p_showBodyKeepFocus Flag used to keep focus where it was instead of forcing in body
 * @param p_force_open Flag to force opening the body pane editor
 */
private _tryApplyNodeToBody(
    p_node: LeoNode,
    p_aside: boolean,
    p_showBodyKeepFocus: boolean,
    p_force_open?: boolean
): Thenable&lt;vscode.TextEditor&gt; {
    // console.log('try to apply node -&gt; ', p_node.gnx);

    this.lastSelectedNode = p_node; // Set the 'lastSelectedNode' this will also set the 'marked' node context
    this._commandStack.newSelection(); // Signal that a new selected node was reached and to stop using the received selection as target for next command

    if (this._bodyTextDocument) {
        // if not first time and still opened - also not somewhat exactly opened somewhere.
        if (
            !this._bodyTextDocument.isClosed &amp;&amp;
            !this._locateOpenedBody(p_node.gnx) // LOCATE NEW GNX
        ) {
            // if needs switching by actually having different gnx
            if (utils.leoUriToStr(this.bodyUri) !== p_node.gnx) {
                this._locateOpenedBody(utils.leoUriToStr(this.bodyUri)); // * LOCATE OLD GNX FOR PROPER COLUMN*
                return this._bodyTextDocument.save().then(() =&gt; {
                    return this._switchBody(p_node.gnx, p_aside, p_showBodyKeepFocus);
                });
            }
        }
    } else {
        // first time?
        this.bodyUri = utils.strToLeoUri(p_node.gnx);
    }
    return this.showBody(p_aside, p_showBodyKeepFocus);

    /*
        this._showBodyParams = {
            node: p_node,
            aside: p_aside,
            showBodyKeepFocus: p_showBodyKeepFocus,
            force_open: p_force_open // can be undefined
        };
        // Start it if possible, otherwise the last _showBodyParams will be used again right after
        if (!this._showBodyStarted) {
            this._showBodyStarted = true;
            this._applyNodeToBody(this._showBodyParams)
                .then((p_textEditor: vscode.TextEditor) =&gt; {
                    // finished
                    this._showBodyStarted = false;
                    if (this._showBodyParams) {
                        // New node to show again! Call itself faking params from the specified ones.
                        this._tryApplyNodeToBody(
                            this._showBodyParams.node,
                            this._showBodyParams.aside,
                            this._showBodyParams.showBodyKeepFocus,
                            this._showBodyParams.force_open
                        );
                    }
                });
            // Clear global body params, will get refilled if needed
            this._showBodyParams = undefined;
        }
        */
}

</t>
<t tx="ekr.20200815090400.1">/**
 * * Tries to add a command to the frontend stack, returns true if added, false otherwise
 * @param p_action A string commands for leobridgeserver.py, from Constants.LEOBRIDGE,
 * @param p_node Specific node to pass as parameter, or the selected node if omitted
 * @param p_refresh Specifies to either refresh nothing, the tree or body and tree when finished
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_text Specific string to pass along as parameter with the action, similar to p_node parameter
 * @returns Promise back from commands execution on leoBridgeServer if added, undefined otherwise
 * (see command stack 'rules' in commandStack.ts)
 */
public nodeCommand(p_userCommand: UserCommand): Promise&lt;LeoBridgePackage&gt; | undefined {
    // No forced vscode save-triggers for direct calls from extension.js
    this.triggerBodySave();
    const q_result = this._commandStack.add(p_userCommand);
    if (q_result) {
        return q_result;
    } else {
        // TODO : Use cleanup message string CONSTANT instead
        vscode.window.showInformationMessage(
            Constants.USER_MESSAGES.TOO_FAST + p_userCommand.action
        );
        return undefined;
    }
}

</t>
<t tx="ekr.20200815090517.1">/**
 * * Invoke an '@button' click directly by index string. Used by '@buttons' treeview.
 * @returns the launchRefresh promise started after it's done running the 'atButton' command
 */
public clickAtButton(p_node: LeoButtonNode): Promise&lt;boolean&gt; {
    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {
            return this.sendAction(
                Constants.LEOBRIDGE.CLICK_BUTTON,
                JSON.stringify({ index: p_node.button.index })
            );
        })
        .then((p_clickButtonResult: LeoBridgePackage) =&gt; {
            this.launchRefresh(
                { tree: true, body: true, documents: true, buttons: true, states: true },
                false
            );
            return Promise.resolve(true); // TODO launchRefresh should be a returned promise
        });
}

</t>
<t tx="ekr.20200815090517.2">/**
 * * Removes an '@button' from Leo's button dict, directly by index string. Used by '@buttons' treeview.
 * @returns the launchRefresh promise started after it's done removing the button
 */
public removeAtButton(p_node: LeoButtonNode): Promise&lt;boolean&gt; {
    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {
            return this.sendAction(
                Constants.LEOBRIDGE.REMOVE_BUTTON,
                JSON.stringify({ index: p_node.button.index })
            );
        })
        .then((p_removeButtonResult: LeoBridgePackage) =&gt; {
            this.launchRefresh({ buttons: true }, false);
            return Promise.resolve(true); // TODO launchRefresh should be a returned promise
        });
}

</t>
<t tx="ekr.20200815091220.1">/**
 * * Splits the received data into lines and parses output to detect server start event
 * * Otherwise just outputs lines to the terminal Output
 * @param p_data Data object (not pure string)
 */
private _gotTerminalData(p_data: string): void {
    p_data.toString().split("\n").forEach(p_line =&gt; {
        p_line = p_line.trim();
        if (p_line) { // * std out process line by line: json shouldn't have line breaks
            if (p_line.startsWith(Constants.SERVER_STARTED_TOKEN)) {
                if (this._resolvePromise &amp;&amp; !this._isStarted) {
                    this._isStarted = true;
                    this._resolvePromise(p_line); // * Server confirmed started
                }
            }
            this._leoIntegration.addTerminalPaneEntry(p_line); // Output message anyways
        }
    });
}

</t>
<t tx="ekr.20200815091346.1">/**
 * * Object container for parameters of leoIntegration's "apply-selected-node-to-body" method
 */
export interface ShowBodyParam {
    node: LeoNode,
    aside: boolean,
    showBodyKeepFocus: boolean,
    force_open?: boolean
}
</t>
<t tx="ekr.20200815091408.1">/**
 * * Object sent back from leoInteg's 'getStates' command
 */
export interface LeoPackageStates {
    changed: boolean; // Leo document has changed (is dirty)
    canUndo: boolean; // Leo document can undo the last operation done
    canRedo: boolean; // Leo document can redo the last operation 'undone'
    canDemote: boolean; // Currently selected node can have its siblings demoted
    canPromote: boolean; // Currently selected node can have its children promoted
    canDehoist: boolean; // Leo Document is currently hoisted and can be de-hoisted
}

</t>
<t tx="ekr.20200815091534.1">/**
 * * Used by the minibuffer command pallette
 * Acquired from the getCommands method in leobridgeserver.py
 */
export interface MinibufferCommand extends vscode.QuickPickItem {
    func: string;
}
</t>
<t tx="ekr.20200815091619.1">/**
 * Builds a string hash out of of an archived position, default without taking collapsed state into account
 * @param p_ap Archived position
 * @param p_salt To be added to the hashing process (Change when tree changes)
 */
export function hashNode(p_ap: ArchivedPosition, p_salt: string, p_withCollapse?: boolean): string {
    const w_string1: string = p_ap.headline + p_ap.gnx + p_ap.childIndex.toString(36);
    const w_string2: string = w_string1 + p_ap.childIndex.toString(36) + JSON.stringify(p_ap.stack);
    const w_first: string = murmur.murmur3(w_string2).toString(36);
    if (p_withCollapse) {
        p_salt += p_ap.expanded ? "1" : "0";
    }
    return p_salt + w_string1 + w_first + murmur.murmur3(w_first + w_string2).toString(36);
}

</t>
<t tx="ekr.20200815091945.1">/**
 * * Build all possible strings for buttons icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildButtonsIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON_ADD),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON_ADD)
        }
    ];
}

</t>
<t tx="ekr.20200815113156.1">// * Define entries for all commands
[CMD.MINIBUFFER, () =&gt; w_leo.minibuffer()], // Is referenced in package.json
[CMD.EXECUTE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXECUTE_SCRIPT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],

[CMD.CLICK_BUTTON, (p_node: LeoButtonNode) =&gt; w_leo.clickAtButton(p_node)], // Not referenced in package.json
[CMD.REMOVE_BUTTON, (p_node: LeoButtonNode) =&gt; w_leo.removeAtButton(p_node)],

[CMD.CLOSE_FILE, () =&gt; w_leo.closeLeoFile()],
[CMD.NEW_FILE, () =&gt; w_leo.newLeoFile()],

[CMD.OPEN_FILE, (p_uri?: vscode.Uri) =&gt; w_leo.openLeoFile(p_uri)],
[CMD.IMPORT_ANY_FILE, (p_uri?: vscode.Uri) =&gt; w_leo.importAnyFile(p_uri)],

[CMD.CLEAR_RECENT_FILES, () =&gt; w_leo.clearRecentLeoFiles()],
[CMD.RECENT_FILES, () =&gt; w_leo.showRecentLeoFiles()],
[CMD.SAVE_AS_FILE, () =&gt; w_leo.saveAsLeoFile()],
[CMD.SAVE_FILE, () =&gt; w_leo.saveLeoFile()],
[CMD.SAVE_FILE_FO, () =&gt; w_leo.saveLeoFile(true)],
[CMD.SWITCH_FILE, () =&gt; w_leo.switchLeoFile()],

[CMD.SET_OPENED_FILE, (p_index: number) =&gt; w_leo.selectOpenedLeoDocument(p_index)],

[CMD.REFRESH_FROM_DISK, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.REFRESH_FROM_DISK_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: false
})],
[CMD.REFRESH_FROM_DISK_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REFRESH_FROM_DISK_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.REFRESH_FROM_DISK_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REFRESH_FROM_DISK_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.GIT_DIFF, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GIT_DIFF,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],

[CMD.HEADLINE, (p_node: LeoNode) =&gt; w_leo.editHeadline(p_node, true)],
[CMD.HEADLINE_SELECTION, () =&gt; w_leo.editHeadline(U, false)],
[CMD.HEADLINE_SELECTION_FO, () =&gt; w_leo.editHeadline(U, true)],

// cut/copy/paste/delete given node.
[CMD.COPY, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.COPY_PNODE,
    node: p_node,
    refreshType: NO_REFRESH,
    fromOutline: true,
    keepSelection: true
})],
[CMD.CUT, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.CUT_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.DELETE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.PASTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: false
})],
[CMD.PASTE_CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_CLONE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: false
})],

// cut/copy/paste/delete current selection (self.commander.p)
[CMD.COPY_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.COPY_PNODE,
    node: U,
    refreshType: NO_REFRESH,
    fromOutline: false
})],
[CMD.CUT_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CUT_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.CUT_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CUT_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.DELETE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.DELETE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.PASTE_CLONE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.PASTE_CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.PASTE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.PASTE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.CONTRACT_ALL, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.CONTRACT_ALL_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.CONTRACT_OR_GO_LEFT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_OR_GO_LEFT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.EXPAND_AND_GO_RIGHT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXPAND_AND_GO_RIGHT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.GOTO_NEXT_CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: p_node,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_NEXT_CLONE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: false
})],
[CMD.GOTO_NEXT_CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],

[CMD.GOTO_NEXT_MARKED, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_MARKED,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_FIRST_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_FIRST_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_LAST_SIBLING, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_LAST_SIBLING,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_LAST_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_LAST_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_NEXT_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_PREV_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_PREV_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],

[CMD.PAGE_UP, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PAGE_UP,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.PAGE_DOWN, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PAGE_DOWN,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],

[CMD.DEHOIST, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEHOIST,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.DEHOIST_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEHOIST,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.HOIST, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.HOIST_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.HOIST_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.CLONE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.INSERT, (p_node: LeoNode) =&gt; w_leo.insertNode(p_node, true)],
[CMD.INSERT_SELECTION, () =&gt; w_leo.insertNode(U, false)],
[CMD.INSERT_SELECTION_FO, () =&gt; w_leo.insertNode(U, true)],

// Special command for when inserting rapidly more than one node without
// even specifying a headline label, such as spamming CTRL+I rapidly.
[CMD.INSERT_SELECTION_INTERRUPT, () =&gt; w_leo.insertNode(U, false, true)],

[CMD.MARK, (p_node: LeoNode) =&gt; w_leo.changeMark(true, p_node, true)],
[CMD.MARK_SELECTION, () =&gt; w_leo.changeMark(true, U, false)],
[CMD.MARK_SELECTION_FO, () =&gt; w_leo.changeMark(true, U, true)],

[CMD.UNMARK, (p_node: LeoNode) =&gt; w_leo.changeMark(false, p_node, true)],
[CMD.UNMARK_SELECTION, () =&gt; w_leo.changeMark(false, U, false)],
[CMD.UNMARK_SELECTION_FO, () =&gt; w_leo.changeMark(false, U, true)],

[CMD.EXTRACT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXTRACT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.EXTRACT_NAMES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXTRACT_NAMES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],

[CMD.MOVE_DOWN, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_DOWN_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_DOWN_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.MOVE_LEFT, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_LEFT_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_LEFT_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.MOVE_RIGHT, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_RIGHT_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_RIGHT_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.MOVE_UP, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_UP_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_UP_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.DEMOTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.DEMOTE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.DEMOTE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],
[CMD.PROMOTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.PROMOTE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.PROMOTE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.SORT_CHILDREN, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_CHILDREN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false,
    keepSelection: true
})],
[CMD.SORT_CHILDREN_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_CHILDREN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true,
    keepSelection: true
})],
[CMD.SORT_SIBLING, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_SIBLINGS,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false,
    keepSelection: true
})],
[CMD.SORT_SIBLING_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_SIBLINGS,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true,
    keepSelection: true
})],

[CMD.REDO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.REDO_DISABLED, () =&gt; { }],
[CMD.REDO_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.UNDO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.UNDO_DISABLED, () =&gt; { }],
[CMD.UNDO_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.CONNECT, () =&gt; w_leo.connect()],
[CMD.START_SERVER, () =&gt; w_leo.startServer()],
[CMD.CHOOSE_LEO_FOLDER, () =&gt; w_leo.chooseLeoFolder()],

// Called by nodes in tree when selected either by mouse, or with enter
[CMD.SELECT_NODE, (p_node: LeoNode) =&gt; w_leo.selectTreeNode(p_node, false, false)],
[CMD.OPEN_ASIDE, (p_node: LeoNode) =&gt; w_leo.selectTreeNode(p_node, false, true)],

[CMD.SHOW_OUTLINE, () =&gt; w_leo.showOutline(true)], // Also focuses on outline

[CMD.SHOW_LOG, () =&gt; w_leo.showLogPane()],
[CMD.SHOW_BODY, () =&gt; w_leo.showBody(false)], // Also focuses on body

[CMD.SHOW_WELCOME, () =&gt; w_leoSettingsWebview.openWebview()],
[CMD.SHOW_SETTINGS, () =&gt; w_leoSettingsWebview.openWebview()], // Same as SHOW_WELCOME

[CMD.COPY_MARKED, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.COPY_MARKED,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.DIFF_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DIFF_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.MARK_CHANGED_ITEMS, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MARK_CHANGED_ITEMS,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.MARK_SUBHEADS, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MARK_SUBHEADS,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.UNMARK_ALL, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNMARK_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.CLONE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.DELETE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.MOVE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.PREV_NODE, () =&gt; w_leo.prevNextNode(false)],
[CMD.NEXT_NODE, () =&gt; w_leo.prevNextNode(true)],

[CMD.START_SEARCH, () =&gt; w_leo.startSearch()],
[CMD.FIND_ALL, () =&gt; w_leo.findAll(false)],
[CMD.FIND_NEXT, () =&gt; w_leo.find(false, false)],
[CMD.FIND_NEXT_FO, () =&gt; w_leo.find(true, false)],
[CMD.FIND_PREVIOUS, () =&gt; w_leo.find(false, true)],
[CMD.FIND_PREVIOUS_FO, () =&gt; w_leo.find(true, true)],
[CMD.REPLACE, () =&gt; w_leo.replace(false, false)],
[CMD.REPLACE_FO, () =&gt; w_leo.replace(true, false)],
[CMD.REPLACE_THEN_FIND, () =&gt; w_leo.replace(false, true)],
[CMD.REPLACE_THEN_FIND_FO, () =&gt; w_leo.replace(true, true)],
[CMD.REPLACE_ALL, () =&gt; w_leo.findAll(true)],
[CMD.GOTO_GLOBAL_LINE, () =&gt; w_leo.gotoGlobalLine()],

[CMD.CLONE_FIND_ALL, () =&gt; w_leo.cloneFind(false, false)],
[CMD.CLONE_FIND_ALL_FLATTENED, () =&gt; w_leo.cloneFind(false, true)],
[CMD.CLONE_FIND_MARKED, () =&gt; w_leo.cloneFind(true, false)],
[CMD.CLONE_FIND_FLATTENED_MARKED, () =&gt; w_leo.cloneFind(true, true)],

[CMD.SET_FIND_EVERYWHERE_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.ENTIRE_OUTLINE)],
[CMD.SET_FIND_NODE_ONLY_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.NODE_ONLY)],
[CMD.SET_FIND_SUBOUTLINE_ONLY_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.SUBOUTLINE_ONLY)],
[CMD.TOGGLE_FIND_IGNORE_CASE_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.IGNORE_CASE)],
[CMD.TOGGLE_FIND_MARK_CHANGES_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.MARK_CHANGES)],
[CMD.TOGGLE_FIND_MARK_FINDS_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.MARK_FINDS)],
[CMD.TOGGLE_FIND_REGEXP_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.REG_EXP)],
[CMD.TOGGLE_FIND_WORD_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.WHOLE_WORD)],
[CMD.TOGGLE_FIND_SEARCH_BODY_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.SEARCH_BODY)],
[CMD.TOGGLE_FIND_SEARCH_HEADLINE_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.SEARCH_HEADLINE)],
</t>
<t tx="ekr.20200815113508.1">@language python
g.cls()

def is_significant(p):
    s = p.b
    for ch in '()[]{};':
        s = s.replace(ch, '')
    return s.strip()

for p in c.all_unique_positions():
    if not is_significant(p) and not p.hasChildren():
        print(p.h)
print('done')

</t>
<t tx="ekr.20200815123601.1">@language json
@tabwidth -2
{
  "name": "leointeg",
  "displayName": "Leo Editor Integration with Visual Studio Code",
  "description": "Use Leo, the literate editor with outline, directly in vscode.",
  "version": "0.1.15",
  "author": {
    "name": "Flix"
  },
  "publisher": "boltex",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/boltex/leointeg"
  },
  "engines": {
    "vscode": "^1.57.0"
  },
  "keywords": [
    "leo",
    "literate",
    "editor",
    "outline",
    "programming"
  ],
  "categories": [
    "Other"
  ],
  "activationEvents": [
    "onStartupFinished"
  ],
  "main": "./dist/extension",
  "icon": "resources/leoapp128px.png",
  "galleryBanner": {
    "color": "#fffbdc",
    "theme": "light"
  },
  "contributes": {
    @others
  },
  "scripts": {
    "vscode:prepublish": "webpack --mode production",
    "webpack": "webpack --mode development",
    "webpack-dev": "webpack --mode development --watch",
    "test-compile": "tsc -p ./",
    "lint": "tslint -p ./"
  },
  "devDependencies": {
    "@types/glob": "^7.1.3",
    "@types/mocha": "^7.0.2",
    "@types/node": "^14.11.2",
    "@types/vscode": "^1.57.0",
    "@types/ws": "^7.2.6",
    "clean-webpack-plugin": "^3.0.0",
    "csp-html-webpack-plugin": "^4.0.0",
    "css-loader": "^3.5.3",
    "eslint": "^7.9.0",
    "fork-ts-checker-webpack-plugin": "^4.1.6",
    "glob": "^7.1.6",
    "html-loader": "^1.1.0",
    "html-webpack-exclude-assets-plugin": "0.0.7",
    "html-webpack-plugin": "^3.2.0",
    "imagemin-webpack-plugin": "^2.4.2",
    "mini-css-extract-plugin": "^0.9.0",
    "mocha": "^7.2.0",
    "node-sass": "^4.14.1",
    "sass-loader": "^8.0.2",
    "ts-loader": "^7.0.5",
    "tslint": "^6.1.3",
    "typescript": "^3.9.7",
    "vscode-test": "^1.4.0",
    "webpack": "^4.44.2",
    "webpack-cli": "^3.3.12"
  },
  "dependencies": {
    "@types/debounce": "^1.2.0",
    "@types/murmurhash-js": "^1.0.3",
    "bufferutil": "^4.0.1",
    "debounce": "^1.2.0",
    "hasbin": "^1.2.3",
    "murmurhash-js": "^1.0.0",
    "portfinder": "^1.0.28",
    "ws": "^7.3.1"
  }
}
</t>
<t tx="ekr.20200815123601.10">"languages": [
  {
    "id": "leobody.plain",
    "aliases": [
      "Leo Body Plain",
      "leobody"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.plain.language-configuration.json"
  },
  {
    "id": "leobody.python",
    "aliases": [
      "Leo Body Python",
      "leobody.python"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.python.language-configuration.json"
  },
  {
    "id": "leobody.typescript",
    "aliases": [
      "Leo Body Typescript",
      "leobody.typescript"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.typescript.language-configuration.json"
  },
  {
    "id": "leobody.javascript",
    "aliases": [
      "Leo Body Javascript",
      "leobody.javascript"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.javascript.language-configuration.json"
  },
  {
    "id": "leobody.c",
    "aliases": [
      "Leo Body c",
      "leobody.c"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.c.language-configuration.json"
  },
  {
    "id": "leobody.cpp",
    "aliases": [
      "Leo Body C++",
      "leobody.cpp"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.cpp.language-configuration.json"
  },
  {
    "id": "leobody.css",
    "aliases": [
      "Leo Body CSS",
      "leobody.css"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.css.language-configuration.json"
  },
  {
    "id": "leobody.html",
    "aliases": [
      "Leo Body HTML",
      "leobody.html"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.html.language-configuration.json"
  },
  {
    "id": "leobody.java",
    "aliases": [
      "Leo Body Java",
      "leobody.java"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.java.language-configuration.json"
  },
  {
    "id": "leobody.json",
    "aliases": [
      "Leo Body Json",
      "leobody.json"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.json.language-configuration.json"
  },
  {
    "id": "leobody.markdown",
    "aliases": [
      "Leo Body Markdown",
      "leobody.markdown"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.markdown.language-configuration.json"
  },
  {
    "id": "leobody.php",
    "aliases": [
      "Leo Body PHP",
      "leobody.php"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.php.language-configuration.json"
  },
  {
    "id": "leobody.rust",
    "aliases": [
      "Leo Body Rust",
      "leobody.rust"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.rust.language-configuration.json"
  }
],
</t>
<t tx="ekr.20200815123601.11">"grammars": [
  {
    "language": "leobody.plain",
    "scopeName": "source.leobody.plain",
    "path": "./syntaxes/leobody.plain.tmLanguage.json"
  },
  {
    "language": "leobody.python",
    "scopeName": "source.leobody.python",
    "path": "./syntaxes/leobody.python.tmLanguage.json"
  },
  {
    "language": "leobody.typescript",
    "scopeName": "source.leobody.typescript",
    "path": "./syntaxes/leobody.typescript.tmLanguage.json"
  },
  {
    "language": "leobody.javascript",
    "scopeName": "source.leobody.javascript",
    "path": "./syntaxes/leobody.javascript.tmLanguage.json"
  },
  {
    "language": "leobody.c",
    "scopeName": "source.leobody.c",
    "path": "./syntaxes/leobody.c.tmLanguage.json"
  },
  {
    "language": "leobody.cpp",
    "scopeName": "source.leobody.cpp",
    "path": "./syntaxes/leobody.cpp.tmLanguage.json"
  },
  {
    "language": "leobody.css",
    "scopeName": "source.leobody.css",
    "path": "./syntaxes/leobody.css.tmLanguage.json"
  },
  {
    "language": "leobody.html",
    "scopeName": "source.leobody.html",
    "path": "./syntaxes/leobody.html.tmLanguage.json"
  },
  {
    "language": "leobody.java",
    "scopeName": "source.leobody.java",
    "path": "./syntaxes/leobody.java.tmLanguage.json"
  },
  {
    "language": "leobody.json",
    "scopeName": "source.leobody.json",
    "path": "./syntaxes/leobody.json.tmLanguage.json"
  },
  {
    "language": "leobody.markdown",
    "scopeName": "source.leobody.markdown",
    "path": "./syntaxes/leobody.markdown.tmLanguage.json"
  },
  {
    "language": "leobody.php",
    "scopeName": "source.leobody.php",
    "path": "./syntaxes/leobody.php.tmLanguage.json"
  },
  {
    "language": "leobody.rust",
    "scopeName": "source.leobody.rust",
    "path": "./syntaxes/leobody.rust.tmLanguage.json"
  },
  {
    "//TODO 1": "MAKE PHP/HTML/CSS/JS EMBEDDED FUNCTIONALITY WORK TOO",
    "injectTo": [
      "source.leobody.plain",
      "source.leobody.python",
      "source.leobody.typescript",
      "source.leobody.javascript",
      "source.leobody.c",
      "source.leobody.cpp",
      "source.leobody.css",
      "source.leobody.html",
      "source.leobody.java",
      "source.leobody.json",
      "source.leobody.markdown",
      "source.leobody.php",
      "source.leobody.rust"
    ],
    "path": "./syntaxes/leobody.tmLanguage.json",
    "scopeName": "leo.injection",
    "//TODO 2": "MAKE EMBEDDED LANGUAGE SWITCHES WORK",
    "//tokenTypes": {
      "//meta.embedded.block.leobody.python": "other",
      "//meta.embedded.block.leobody.typescript": "other",
      "//...": "..."
    },
    "//embeddedLanguages": {
      "//meta.embedded.block.leobody.python": "leobody.python",
      "//meta.embedded.block.leobody.typescript": "leobody.typescript",
      "//...": "..."
    }
  }
],
</t>
<t tx="ekr.20200815123601.12">"snippets": [
  {
    "language": "leobody.c",
    "path": "./snippets/c.code-snippets"
  },
  {
    "language": "leobody.cpp",
    "path": "./snippets/cpp.code-snippets"
  },
  {
    "language": "leobody.javascript",
    "path": "./snippets/javascript.code-snippets"
  },
  {
    "language": "leobody.typescript",
    "path": "./snippets/typescript.code-snippets"
  },
  {
    "language": "leobody.java",
    "path": "./snippets/java.code-snippets"
  },
  {
    "language": "leobody.php",
    "path": "./snippets/php.code-snippets"
  },
  {
    "language": "leobody.markdown",
    "path": "./snippets/markdown.code-snippets"
  },
  {
    "language": "leobody.rust",
    "path": "./snippets/rust.code-snippets"
  }
],
</t>
<t tx="ekr.20200815123601.13">"commands": [
  @others
],
</t>
<t tx="ekr.20200815123601.14">{
  "command": "leointeg.test",
  "category": "Leo",
  "title": "Test Leo Integration"
},
</t>
<t tx="ekr.20200815123601.15">{
  "command": "leointeg.showSettingsPage",
  "title": "Open Settings",
  "category": "Leo",
  "icon": {
    "light": "resources/light/gear.svg",
    "dark": "resources/dark/gear.svg"
  }
},
{
  "command": "leointeg.showWelcomePage",
  "title": "Welcome",
  "category": "Leo"
},
</t>
<t tx="ekr.20200815123601.16">{
  "command": "leointeg.chooseLeoFolder",
  "title": "Choose Leo Installation Folder",
  "category": "Leo"
},
{
  "command": "leointeg.startServer",
  "category": "Leo",
  "title": "Start Leo Bridge Server"
},
{
  "command": "leointeg.connectToServer",
  "title": "Connect to Leo Bridge Server",
  "category": "Leo",
  "icon": {
    "light": "resources/light/connect.svg",
    "dark": "resources/dark/connect.svg"
  }
},
</t>
<t tx="ekr.20200815123601.17">{
  "command": "leointeg.executeScript",
  "category": "Leo",
  "title": "Execute Script"
},
{
  "command": "leointeg.minibuffer",
  "category": "Leo",
  "title": "Minibuffer"
},
{
  "command": "leointeg.removeButton",
  "category": "Leo",
  "title": "Remove Button"
},
</t>
<t tx="ekr.20200815123601.18">{
  "command": "leointeg.showBody",
  "category": "Leo",
  "title": "Focus on Body"
},
{
  "command": "leointeg.showOutline",
  "category": "Leo",
  "title": "Focus on Tree"
},
{
  "command": "leointeg.showLogPane",
  "category": "Leo",
  "title": "Show Log Pane"
},
</t>
<t tx="ekr.20200815123601.19">{
  "command": "leointeg.openLeoFile",
  "title": "Open Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/folder.svg",
    "dark": "resources/dark/folder.svg"
  }
},
{
  "command": "leointeg.importAnyFile",
  "title": "Import File",
  "category": "Leo"
},
{
  "command": "leointeg.clearRecentFiles",
  "category": "Leo",
  "title": "Clear Recent Files",
  "icon": {
    "light": "resources/light/clear-files.svg",
    "dark": "resources/dark/clear-files.svg"
  }
},
{
  "command": "leointeg.recentLeoFiles",
  "category": "Leo",
  "title": "Recent Files"
},
{
  "command": "leointeg.switchLeoFile",
  "title": "Switch Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/switch.svg",
    "dark": "resources/dark/switch.svg"
  }
},
{
  "command": "leointeg.newLeoFile",
  "title": "New Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/new-file.svg",
    "dark": "resources/dark/new-file.svg"
  }
},
{
  "command": "leointeg.closeLeoFile",
  "title": "Close Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leointeg.saveLeoFile",
  "category": "Leo",
  "title": "Save Leo File",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leointeg.saveLeoFileFromOutline",
  "category": "Leo",
  "title": "Save Leo File",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leointeg.saveAsLeoFile",
  "category": "Leo",
  "title": "Save Leo File as...",
  "icon": {
    "light": "resources/light/save-as.svg",
    "dark": "resources/dark/save-as.svg"
  }
},
{
  "command": "leointeg.refreshFromDisk",
  "category": "Leo",
  "title": "Refresh from Disk"
},
{
  "command": "leointeg.refreshFromDiskSelection",
  "category": "Leo",
  "title": "Refresh from Disk"
},
{
  "command": "leointeg.refreshFromDiskSelectionFromOutline",
  "category": "Leo",
  "title": "Refresh from Disk"
},
{
  "command": "leointeg.gitDiff",
  "category": "Leo",
  "title": "Git Diff"
},
</t>
<t tx="ekr.20200815123601.2">"configuration": {
  "title": "Leo Integration",
  "properties": {
    @others
  }
},
</t>
<t tx="ekr.20200815123601.20">{
  "command": "leointeg.selectTreeNode",
  "category": "Leo",
  "title": "Select Node"
},
{
  "command": "leointeg.openAside",
  "category": "Leo",
  "title": "Open to the Side"
},
{
  "command": "leointeg.contractAll",
  "category": "Leo",
  "title": "Contract All",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
{
  "command": "leointeg.contractAllFromOutline",
  "category": "Leo",
  "title": "Contract All",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
{
  "command": "leointeg.prev",
  "category": "Leo",
  "title": "Prev",
  "icon": {
    "light": "resources/light/prev.svg",
    "dark": "resources/dark/prev.svg"
  }
},
{
  "command": "leointeg.next",
  "category": "Leo",
  "title": "Next",
  "icon": {
    "light": "resources/light/next.svg",
    "dark": "resources/dark/next.svg"
  }
},
</t>
<t tx="ekr.20200815123601.21">{
  "command": "leointeg.editHeadline",
  "category": "Leo",
  "title": "Edit Headline",
  "icon": {
    "light": "resources/light/edit.svg",
    "dark": "resources/dark/edit.svg"
  }
},
{
  "command": "leointeg.editSelectedHeadline",
  "category": "Leo",
  "title": "Edit Headline"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "category": "Leo",
  "title": "Edit Headline"
},
{
  "command": "leointeg.copyNode",
  "category": "Leo",
  "title": "Copy Node",
  "icon": {
    "light": "resources/light/clipboard.svg",
    "dark": "resources/dark/clipboard.svg"
  }
},
{
  "command": "leointeg.copyNodeSelection",
  "category": "Leo",
  "title": "Copy Node"
},
{
  "command": "leointeg.cutNode",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.cutNodeSelection",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.pasteNode",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAsClone",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelection",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.delete",
  "category": "Leo",
  "title": "Delete",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leointeg.deleteSelection",
  "category": "Leo",
  "title": "Delete Node"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "category": "Leo",
  "title": "Delete Node"
},
</t>
<t tx="ekr.20200815123601.22">{
  "command": "leointeg.moveOutlineDown",
  "category": "Leo",
  "title": "Move Outline Down",
  "icon": {
    "light": "resources/light/arrow-down.svg",
    "dark": "resources/dark/arrow-down.svg"
  }
},
{
  "command": "leointeg.moveOutlineDownSelection",
  "category": "Leo",
  "title": "Move Outline Down"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Down"
},
{
  "command": "leointeg.moveOutlineLeft",
  "category": "Leo",
  "title": "Move Outline Left",
  "icon": {
    "light": "resources/light/arrow-left.svg",
    "dark": "resources/dark/arrow-left.svg"
  }
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "category": "Leo",
  "title": "Move Outline Left"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Left"
},
{
  "command": "leointeg.moveOutlineRight",
  "category": "Leo",
  "title": "Move Outline Right",
  "icon": {
    "light": "resources/light/arrow-right.svg",
    "dark": "resources/dark/arrow-right.svg"
  }
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "category": "Leo",
  "title": "Move Outline Right"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Right"
},
{
  "command": "leointeg.moveOutlineUp",
  "category": "Leo",
  "title": "Move Outline Up",
  "icon": {
    "light": "resources/light/arrow-up.svg",
    "dark": "resources/dark/arrow-up.svg"
  }
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "category": "Leo",
  "title": "Move Outline Up"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Up"
},
</t>
<t tx="ekr.20200815123601.23">{
  "command": "leointeg.insertNode",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.insertNodeSelection",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.cloneNode",
  "category": "Leo",
  "title": "Clone Node",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leointeg.cloneNodeSelection",
  "category": "Leo",
  "title": "Clone Node"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Clone Node"
},
{
  "command": "leointeg.promote",
  "category": "Leo",
  "title": "Promote Children"
},
{
  "command": "leointeg.promoteSelection",
  "category": "Leo",
  "title": "Promote Children"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "category": "Leo",
  "title": "Promote Children"
},
{
  "command": "leointeg.demote",
  "category": "Leo",
  "title": "Demote Siblings"
},
{
  "command": "leointeg.demoteSelection",
  "category": "Leo",
  "title": "Demote Siblings"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "category": "Leo",
  "title": "Demote Siblings"
},
{
  "command": "leointeg.sortChildrenSelection",
  "category": "Leo",
  "title": "Sort Children"
},
{
  "command": "leointeg.sortChildrenSelectionFromOutline",
  "category": "Leo",
  "title": "Sort Children"
},
{
  "command": "leointeg.sortSiblingsSelection",
  "category": "Leo",
  "title": "Sort Siblings"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "category": "Leo",
  "title": "Sort Siblings"
},
</t>
<t tx="ekr.20200815123601.24">{
  "command": "leointeg.gotoFirstVisible",
  "category": "Leo",
  "title": "Goto First Visible"
},
{
  "command": "leointeg.gotoLastVisible",
  "category": "Leo",
  "title": "Goto Last Visible"
},
{
  "command": "leointeg.pageUp",
  "category": "Leo",
  "title": "Page Up"
},
{
  "command": "leointeg.pageDown",
  "category": "Leo",
  "title": "Page Down"
},
{
  "command": "leointeg.gotoLastSibling",
  "category": "Leo",
  "title": "Goto Last Sibling"
},
{
  "command": "leointeg.gotoNextVisible",
  "category": "Leo",
  "title": "Goto Next Visible"
},
{
  "command": "leointeg.gotoPrevVisible",
  "category": "Leo",
  "title": "Goto Prev Visible"
},
{
  "command": "leointeg.contractOrGoLeft",
  "category": "Leo",
  "title": "Contract Or Go Left"
},
{
  "command": "leointeg.expandAndGoRight",
  "category": "Leo",
  "title": "Expand And Go Right"
},
{
  "command": "leointeg.gotoNextMarked",
  "category": "Leo",
  "title": "Goto Next Marked"
},
{
  "command": "leointeg.gotoNextClone",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "category": "Leo",
  "title": "Goto Next Clone"
},
</t>
<t tx="ekr.20200815123601.25">{
  "command": "leointeg.hoistNode",
  "category": "Leo",
  "title": "Hoist"
},
{
  "command": "leointeg.hoistSelection",
  "category": "Leo",
  "title": "Hoist"
},
{
  "command": "leointeg.hoistSelectionFromOutline",
  "category": "Leo",
  "title": "Hoist"
},
{
  "command": "leointeg.deHoist",
  "category": "Leo",
  "title": "De-Hoist",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
{
  "command": "leointeg.deHoistFromOutline",
  "category": "Leo",
  "title": "De-Hoist",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
</t>
<t tx="ekr.20200815123601.26">{
  "command": "leointeg.undo",
  "category": "Leo",
  "title": "Undo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leointeg.undoDisabled",
  "category": "Leo",
  "title": "Can't Undo",
  "icon": {
    "light": "resources/light/undo-disabled.svg",
    "dark": "resources/dark/undo-disabled.svg"
  }
},
{
  "command": "leointeg.undoFromOutline",
  "category": "Leo",
  "title": "Undo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leointeg.redo",
  "category": "Leo",
  "title": "Redo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
{
  "command": "leointeg.redoDisabled",
  "category": "Leo",
  "title": "Can't Redo",
  "icon": {
    "light": "resources/light/redo-disabled.svg",
    "dark": "resources/dark/redo-disabled.svg"
  }
},
{
  "command": "leointeg.redoFromOutline",
  "category": "Leo",
  "title": "Redo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
</t>
<t tx="ekr.20200815123601.28">"viewsWelcome": [
  @others
],
</t>
<t tx="ekr.20200815123601.29"></t>
<t tx="ekr.20200815123601.3">"leoIntegration.checkForChangeExternalFiles": {
  "scope": "application",
  "default": "none",
  "type": "string",
  "description": "Set default for checking changes to external files",
  "enum": [
    "none",
    "force-check",
    "force-ignore"
  ],
  "enumDescriptions": [
    "Default from Leo's config",
    "Check for changes",
    "Ignore all changes"
  ]
},
"leoIntegration.defaultReloadIgnore": {
  "scope": "application",
  "default": "none",
  "type": "string",
  "description": "Set default for derived files to always reload, or always ignore, when changes are detected",
  "enum": [
    "none",
    "yes-all",
    "no-all"
  ],
  "enumDescriptions": [
    "Choose each time",
    "Reload All",
    "Ignore All"
  ]
},
</t>
<t tx="ekr.20200815123601.30">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nStart a local server\n[Start Server](command:leointeg.startServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nStart a local server\n[Start Server](command:leointeg.startServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="ekr.20200815123601.31">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="ekr.20200815123601.32">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="ekr.20200815123601.33">{
  "view": "leoIntegration",
  "contents": "Connecting...",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Connecting...",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; connectToServerAutomatically"
},
</t>
<t tx="ekr.20200815123601.34">{
  "view": "leoIntegration",
  "contents": "leoBridge Connected\n[Open Leo File](command:leointeg.openLeoFile)\nView LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "leoBridge Connected\n[Open Leo File](command:leointeg.openLeoFile)\nView LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.35"></t>
<t tx="ekr.20200815123601.36">{
  "view": "leoDocuments",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
{
  "view": "leoDocumentsExplorer",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
</t>
<t tx="ekr.20200815123601.37">{
  "view": "leoDocuments",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoDocumentsExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.38"></t>
<t tx="ekr.20200815123601.39">{
  "view": "leoButtons",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
{
  "view": "leoButtonsExplorer",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
</t>
<t tx="ekr.20200815123601.4">"leoIntegration.leoTreeBrowse": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Specifies whether to use Leo's style of tree browsing with the arrow keys"
},
"leoIntegration.treeKeepFocus": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Specifies whether to keep focus in the outline when selecting a node - overridden by \"leoTreeBrowse\""
},
"leoIntegration.treeKeepFocusWhenAside": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Specifies whether to keep focus in the outline when opening a body pane on the side"
},
</t>
<t tx="ekr.20200815123601.40">{
  "view": "leoButtons",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoButtonsExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.41">{
  "view": "leoButtons",
  "contents": "There are no @buttons in this outline",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "view": "leoButtonsExplorer",
  "contents": "There are no @buttons in this outline",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.42">"menus": {
  @others
},
</t>
<t tx="ekr.20200815123601.43">"commandPalette": [
  @others
],
</t>
<t tx="ekr.20200815123601.44">{
  "command": "leointeg.startServer",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; !leoServerStarted"
},
{
  "command": "leointeg.connectToServer",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.45">{
  "command": "leointeg.executeScript",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.minibuffer",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.46">{
  "command": "leointeg.showLogPane",
  "when": "leoBridgeReady"
},
</t>
<t tx="ekr.20200815123601.47">{
  "command": "leointeg.openLeoFile",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.importAnyFile",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "command": "leointeg.recentLeoFiles",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.switchLeoFile",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "command": "leointeg.newLeoFile",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.closeLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.saveLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.saveAsLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.refreshFromDiskSelection",
  "when": "leoTreeOpened &amp;&amp; leoAtFile"
},
{
  "command": "leointeg.gitDiff",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.48">{
  "command": "leointeg.contractAll",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.49">{
  "command": "leointeg.editSelectedHeadline",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markSelection",
  "when": "leoTreeOpened &amp;&amp; !leoMarked"
},
{
  "command": "leointeg.unmarkSelection",
  "when": "leoTreeOpened &amp;&amp; leoMarked"
},
{
  "command": "leointeg.copyNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cutNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.deleteSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.5">"leoIntegration.statusBarString": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Sets the message string of the Status Bar Indicator"
},
"leoIntegration.statusBarColor": {
  "scope": "application",
  "default": "fb7c47",
  "type": "string",
  "description": "Specifies the hexadecimal color string for the Status Bar Indicator"
},
</t>
<t tx="ekr.20200815123601.50">{
  "command": "leointeg.moveOutlineDownSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.51">{
  "command": "leointeg.insertNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.promoteSelection",
  "when": "leoTreeOpened &amp;&amp; leoCanPromote"
},
{
  "command": "leointeg.demoteSelection",
  "when": "leoTreeOpened &amp;&amp; leoCanDemote"
},
{
  "command": "leointeg.sortChildrenSelection",
  "when": "leoTreeOpened &amp;&amp; leoChild"
},
{
  "command": "leointeg.sortSiblingsSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.52">{
  "command": "leointeg.gotoNextMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "when": "leoTreeOpened &amp;&amp; leoCloned"
},
</t>
<t tx="ekr.20200815123601.53">{
  "command": "leointeg.hoistSelection",
  "when": "leoTreeOpened &amp;&amp; !leoRoot"
},
{
  "command": "leointeg.deHoist",
  "when": "leoTreeOpened &amp;&amp; leoCanDehoist"
},
</t>
<t tx="ekr.20200815123601.54">{
  "command": "leointeg.undo",
  "when": "leoTreeOpened &amp;&amp; leoCanUndo"
},
{
  "command": "leointeg.redo",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.56"></t>
<t tx="ekr.20200815123601.57">{
  "command": "leointeg.test",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.58">{
  "command": "leointeg.removeButton",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.59">{
  "command": "leointeg.showBody",
  "when": "false"
},
{
  "command": "leointeg.showOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.6">"leoIntegration.treeInExplorer": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Show the outline tree in the explorer view"
},
"leoIntegration.showOpenAside": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Offer 'Open to the Side' in nodes context menu"
},
"leoIntegration.showEditOnNodes": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Edit Headline' button on tree nodes"
},
"leoIntegration.showArrowsOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Move Node' arrow buttons on tree nodes"
},
"leoIntegration.showAddOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Insert' button on tree nodes"
},
"leoIntegration.showMarkOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Mark/Unmark' buttons on tree nodes"
},
"leoIntegration.showCloneOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Clone' button on tree nodes"
},
"leoIntegration.showCopyOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Copy' button on tree nodes"
},
"leoIntegration.invertNodeContrast": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Inverts the contrast of the dirty/clean border aspect of tree nodes"
},
</t>
<t tx="ekr.20200815123601.60">{
  "command": "leointeg.saveLeoFileFromOutline",
  "when": "false"
},
{
  "command": "leointeg.refreshFromDisk",
  "when": "false"
},
{
  "command": "leointeg.refreshFromDiskSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.61">{
  "command": "leointeg.selectTreeNode",
  "when": "false"
},
{
  "command": "leointeg.openAside",
  "when": "false"
},
{
  "command": "leointeg.contractAllFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.62">{
  "command": "leointeg.editHeadline",
  "when": "false"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "when": "false"
},
{
  "command": "leointeg.mark",
  "when": "false"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.unmark",
  "when": "false"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.copyNode",
  "when": "false"
},
{
  "command": "leointeg.cutNode",
  "when": "false"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.pasteNode",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAsClone",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.delete",
  "when": "false"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.63">{
  "command": "leointeg.moveOutlineDown",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineLeft",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineRight",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineUp",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.64">{
  "command": "leointeg.insertNode",
  "when": "false"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "when": "false"
},
{
  "command": "leointeg.cloneNode",
  "when": "false"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.promote",
  "when": "false"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.demote",
  "when": "false"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.sortChildrenSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.65">{
  "command": "leointeg.gotoNextClone",
  "when": "false"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.gotoFirstVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoLastVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoLastSibling",
  "when": "false"
},
{
  "command": "leointeg.gotoNextVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoPrevVisible",
  "when": "false"
},
{
  "command": "leointeg.contractOrGoLeft",
  "when": "false"
},
{
  "command": "leointeg.expandAndGoRight",
  "when": "false"
},
{
  "command": "leointeg.pageUp",
  "when": "false"
},
{
  "command": "leointeg.pageDown",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.66">{
  "command": "leointeg.hoistNode",
  "when": "false"
},
{
  "command": "leointeg.hoistSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.deHoistFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.67">{
  "command": "leointeg.undoFromOutline",
  "when": "false"
},
{
  "command": "leointeg.redoFromOutline",
  "when": "false"
},
{
  "command": "leointeg.undoDisabled",
  "when": "false"
},
{
  "command": "leointeg.redoDisabled",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.68">"explorer/context": [
  {
    "command": "leointeg.openLeoFile",
    "when": "resourceScheme == file &amp;&amp; resourceExtname == .leo",
    "group": "navigation@1"
  }
],
</t>
<t tx="ekr.20200815123601.7">"leoIntegration.leoEditorPath": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Specifies the location of your Leo-Editor installation"
},
"leoIntegration.leoPythonCommand": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Specifies the command to start python (Defaults to 'py' on windows and 'python3' otherwise)"
},
"leoIntegration.startServerAutomatically": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Starts a LeoBridge server automatically, by running the Leo server script"
},
"leoIntegration.connectToServerAutomatically": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Connect automatically to a Leo server on specified 'Connection Port' upon activation of this extension"
},
"leoIntegration.connectionAddress": {
  "default": "localhost",
  "scope": "application",
  "type": "string",
  "description": "Connection host"
},
"leoIntegration.connectionPort": {
  "default": 32125,
  "scope": "application",
  "minimum": 0,
  "maximum": 65535,
  "type": "number",
  "description": "Connection port"
}
</t>
<t tx="ekr.20200815123601.76">"keybindings": [
  @others
],
</t>
<t tx="ekr.20200815123601.77">{
  "command": "leointeg.executeScript",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.executeScript",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.minibuffer",
  "key": "alt+x",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.78">{
  "command": "leointeg.showOutline",
  "key": "alt+t",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.showOutline",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.showBody",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.showBody",
  "key": "alt+d",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.showBody",
  "key": "ctrl+g",
  "mac": "cmd+g",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.showBody",
  "key": "tab",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.showBody",
  "key": "enter",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.79">{
  "command": "leointeg.saveLeoFileFromOutline",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.saveLeoFile",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
</t>
<t tx="ekr.20200815123601.8">"viewsContainers": {
  "activitybar": [
    {
      "id": "leoIntegrationView",
      "title": "Leo",
      "icon": "resources/icon.svg"
    }
  ]
},
</t>
<t tx="ekr.20200815123601.80">{
  "command": "leointeg.contractAll",
  "key": "alt+-",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.contractAllFromOutline",
  "key": "alt+-",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
</t>
<t tx="ekr.20200815123601.81">{
  "command": "leointeg.editSelectedHeadline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.markSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.unmarkSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.82"></t>
<t tx="ekr.20200815123601.83">{
  "command": "leointeg.moveOutlineDownSelection",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineDownSelection",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "shift+down",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.84">{
  "command": "leointeg.moveOutlineLeftSelection",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "shift+left",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.85">{
  "command": "leointeg.moveOutlineRightSelection",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "shift+right",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.86">{
  "command": "leointeg.moveOutlineUpSelection",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "shift+up",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.87">{
  "command": "leointeg.sortSiblingsSelection",
  "key": "alt+a",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "key": "alt+a",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.promoteSelection",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.demoteSelection",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelection",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; !sideBarFocus &amp;&amp; !editorTextFocus"
},
{
  "command": "leointeg.cloneNodeSelection",
  "key": "ctrl+`",
  "win": "ctrl+oem_3",
  "linux": "ctrl+`",
  "mac": "cmd+`",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "key": "ctrl+`",
  "win": "ctrl+oem_3",
  "linux": "ctrl+`",
  "mac": "cmd+`",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.cutNodeSelection",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.deleteSelection",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "key": "delete",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.88">{
  "command": "leointeg.gotoFirstVisible",
  "key": "alt+home",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoLastSibling",
  "key": "alt+end",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoFirstVisible",
  "key": "home",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoLastVisible",
  "key": "end",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.pageUp",
  "key": "pageup",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.pageDown",
  "key": "pagedown",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "key": "alt+n",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "key": "alt+n",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "down",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "alt+down",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "up",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "alt+up",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection  &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "left",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "alt+left",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "right",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "alt+right",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
</t>
<t tx="ekr.20200815123601.89">"resourceLabelFormatters": [
  {
    "scheme": "leo",
    "formatting": {
      "label": "LEO: BODY",
      "separator": "/",
      "workspaceSuffix": ""
    }
  }
]
</t>
<t tx="ekr.20200815123601.9">"views": {
  "explorer": [
    {
      "id": "leoIntegrationExplorer",
      "name": "Leo Integration",
      "contextualTitle": "Leo",
      "when": "treeInExplorer",
      "visibility": "visible"
    },
    {
      "id": "leoDocumentsExplorer",
      "name": "Leo Documents",
      "contextualTitle": "Leo",
      "when": "treeInExplorer",
      "visibility": "collapsed"
    },
    {
      "id": "leoButtonsExplorer",
      "name": "Leo Buttons",
      "contextualTitle": "Leo",
      "when": "treeInExplorer",
      "visibility": "collapsed"
    },
    {
      "type": "webview",
      "id": "leoFindPanelExplorer",
      "contextualTitle": "Leo",
      "name": "Leo Find",
      "title": "Leo Find",
      "when": "treeInExplorer &amp;&amp; leoTreeOpened",
      "visibility": "collapsed"
    }
  ],
  "leoIntegrationView": [
    {
      "id": "leoIntegration",
      "contextualTitle": "Leo",
      "name": "Integration",
      "visibility": "visible"
    },
    {
      "id": "leoDocuments",
      "contextualTitle": "Leo",
      "name": "Documents",
      "visibility": "collapsed"
    },
    {
      "id": "leoButtons",
      "contextualTitle": "Leo",
      "name": "Buttons",
      "visibility": "collapsed"
    },
    {
      "type": "webview",
      "contextualTitle": "Leo",
      "id": "leoFindPanel",
      "name": "Find",
      "title": "Find",
      "when": "leoTreeOpened",
      "visibility": "collapsed"
    }
  ]
},
</t>
<t tx="felix.20191126232434.13">def open_file(self, param):
    """
    Open a leo file via leoBridge controller, or create a new document if empty string.
    Returns an object that contains a 'opened' member.
    """
    w_found = False
    w_filename = param.get('filename')  # Optional.
    # If not empty string (asking for New file) then check if already opened
    if w_filename:
        for w_commander in self.g.app.commanders():
            if w_commander.fileName() == w_filename:
                w_found = True
                self.commander = w_commander

    if not w_found:
        if os.path.isfile(w_filename):
            # create self.commander by opening the file
            self.commander = self.bridge.openLeoFile(w_filename)
            self.commander.findCommands.ftm = StringFindTabManager(
                self.commander)

    # Leo at this point has done this too: g.app.windowList.append(c.frame)
    # and so, now, app.commanders() yields this: return [f.c for f in g.app.windowList]

    if self.commander:
        self.commander.closed = False
        if not w_found:
            # is new so also replace wrapper
            self.commander.frame.body.wrapper = IntegTextWrapper(
                self.commander, "integBody", self.g)
            self.commander.selectPosition(self.commander.p)

        self._create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self._p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage(w_result)
    else:
        return self._outputError('Error in openFile')

</t>
<t tx="felix.20191126232434.14">def close_file(self, param):
    """
    Closes a leo file. A file can then be opened with "openFile".
    Returns a 'total' member in the package if close is successful

    """
    if self.commander:
        # First, revert to prevent asking user.
        if param["forced"] and self.commander.changed:
            self.commander.revert()
        # Then, if still possible, close it.
        if param["forced"] or not self.commander.changed:
            self.commander.closed = True
            self.commander.close()
        else:
            # Cannot close, ask to save, ignore or cancel
            return self.sendLeoBridgePackage()

    # Switch commanders to first available
    w_total = self._getTotalOpened()
    if w_total:
        self.commander = self._getFirstOpenedCommander()
    else:
        self.commander = None

    if self.commander:
        self._create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self._p_to_ap(self.commander.p)}
    else:
        w_result = {"total": 0}

    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20191126232434.16">def get_children(self, p_ap):
    '''EMIT OUT list of children of a node'''
    if p_ap:
        w_p = self._ap_to_p(p_ap)
        if w_p and w_p.hasChildren():
            return self._outputPNodes(w_p.children())
        else:
            return self._outputPNodes([])  # default empty array
    else:
        if self.commander.hoistStack:
            return self._outputPNodes([self.commander.hoistStack[-1].p])
        else:
            # this outputs all Root Children
            return self._outputPNodes(self._yieldAllRootChildren())

</t>
<t tx="felix.20191126232434.17">def get_parent(self, p_ap):
    '''EMIT OUT the parent of a node, as an array, even if unique or empty'''
    if p_ap:
        w_p = self._ap_to_p(p_ap)
        if w_p and w_p.hasParent():
            return self._outputPNode(w_p.getParent())  # if not root
    return self._outputPNode()  # default empty for root as default

</t>
<t tx="felix.20191126232434.19">def get_body(self, p_gnx):
    '''EMIT OUT body of a node'''
    # TODO : if not found, send code to prevent unresolved promise if 'document switch' occurred shortly before
    if p_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(p_gnx)  # vitalije
        if w_v:
            if w_v.b:
                return self._outputBodyData(w_v.b)
            else:
                return self._outputBodyData()  # default "" empty string
    # Send as empty to fix unresolved promise if 'document switch' occurred shortly before
    return self._outputBodyData()

</t>
<t tx="felix.20191126232434.2">#! python3
@language python
@tabwidth -4
&lt;&lt; imports &gt;&gt;
&lt;&lt; constants &gt;&gt;
@others
if __name__ == '__main__':
    # Startup
    try:
        main()
    except KeyboardInterrupt:
        print("\nKeyboard Interupt: Stopping leobridge server", flush=True)
        sys.exit()
</t>
<t tx="felix.20191126232434.20">def get_body_length(self, p_gnx):
    '''EMIT OUT body string length of a node'''
    if p_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(p_gnx)  # vitalije
        if w_v and w_v.b:
            # Length in bytes, not just by character count.
            return self.sendLeoBridgePackage({"len": len(w_v.b.encode('utf-8'))})
    # TODO : May need to signal inexistent by self.sendLeoBridgePackage()
    return self.sendLeoBridgePackage({"len": 0})  # empty as default

</t>
<t tx="felix.20191126232434.22">def set_body(self, param):
    '''Change Body text of a v node'''
    w_gnx = param['gnx']
    w_body = param['body']
    for w_p in self.commander.all_positions():
        if w_p.v.gnx == w_gnx:
            # TODO : Before setting undo and trying to set body, first check if different than existing body
            w_bunch = self.commander.undoer.beforeChangeNodeContents(
                w_p)  # setup undoable operation
            w_p.v.setBodyString(w_body)
            self.commander.undoer.afterChangeNodeContents(
                w_p, "Body Text", w_bunch)
            if self.commander.p.v.gnx == w_gnx:
                self.commander.frame.body.wrapper.setAllText(w_body)
            if not self.commander.isChanged():
                self.commander.setChanged()
            if not w_p.v.isDirty():
                w_p.setDirty()
            break
    # additional forced string setting
    if w_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(w_gnx)  # vitalije
        if w_v:
            w_v.b = w_body
    return self._outputPNode(self.commander.p)  # return selected node

</t>
<t tx="felix.20191126232434.23">def set_headline(self, param):
    '''Change Headline of a node'''
    w_newHeadline = param['name']
    w_ap = param["ap"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            # set this node's new headline
            w_bunch = self.commander.undoer.beforeChangeNodeContents(w_p)
            w_p.h = w_newHeadline
            self.commander.undoer.afterChangeNodeContents(
                w_p, 'Change Headline', w_bunch)
            return self._outputPNode(w_p)
    return self._outputError("Error in setNewHeadline")

</t>
<t tx="felix.20191126232434.24">def set_current_position(self, p_ap):
    '''Select a node, or the first one found with its GNX'''
    if p_ap:
        w_p = self._ap_to_p(p_ap)
        if w_p:
            if self.commander.positionExists(w_p):
                # set this node as selection
                self.commander.selectPosition(w_p)
            else:
                w_foundPNode = self._findPNodeFromGnx(p_ap['gnx'])
                if w_foundPNode:
                    self.commander.selectPosition(w_foundPNode)
                else:
                    print("Set Selection node does not exist! ap was:" +
                          json.dumps(p_ap), flush=True)
    # * return the finally selected node
    if self.commander.p:
        return self._outputPNode(self.commander.p)
    else:
        return self._outputPNode()

</t>
<t tx="felix.20191126232434.25">def expand_node(self, p_ap):
    '''Expand a node'''
    if p_ap:
        w_p = self._ap_to_p(p_ap)
        if w_p:
            w_p.expand()
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.26">def contract_node(self, p_ap):
    '''Collapse a node'''
    if p_ap:
        w_p = self._ap_to_p(p_ap)
        if w_p:
            w_p.contract()
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.27">def _create_gnx_to_vnode(self):
    '''Make the first gnx_to_vnode array with all unique nodes'''
    t1 = time.process_time()
    self.gnx_to_vnode = {
        v.gnx: v for v in self.commander.all_unique_nodes()}
    # This is likely the only data that ever will be needed.
    if 0:
        print('app.create_all_data: %5.3f sec. %s entries' % (
            (time.process_time()-t1), len(list(self.gnx_to_vnode.keys()))), flush=True)
    self._test_round_trip_positions()

</t>
<t tx="felix.20191126232434.28">def _test_round_trip_positions(self):
    '''(From Leo plugin leoflexx.py) Test the round tripping of p_to_ap and ap_to_p.'''
    # Bug fix: p_to_ap updates app.gnx_to_vnode. Save and restore it.
    old_d = self.gnx_to_vnode.copy()
    old_len = len(list(self.gnx_to_vnode.keys()))
    # t1 = time.process_time()
    qtyAllPositions = 0
    for p in self.commander.all_positions():
        qtyAllPositions += 1
        ap = self._p_to_ap(p)
        p2 = self._ap_to_p(ap)
        assert p == p2, (repr(p), repr(p2), repr(ap))
    gnx_to_vnode = old_d
    new_len = len(list(gnx_to_vnode.keys()))
    assert old_len == new_len, (old_len, new_len)
    # print('Leo file opened. Its outline contains ' + str(qtyAllPositions) + " nodes positions.", flush=True)
    # print(('Testing app.test_round_trip_positions for all nodes: Total time: %5.3f sec.' % (time.process_time()-t1)), flush=True)

</t>
<t tx="felix.20191126232434.29">def _yieldAllRootChildren(self):
    '''Return all root children P nodes'''
    p = self.commander.rootPosition()
    while p:
        yield p
        p.moveToNext()

</t>
<t tx="felix.20191126232434.30">def _ap_to_p(self, ap):
    '''
    (From Leo plugin leoflexx.py) Convert an archived position to a true Leo position.
    Return false if no key
    '''
    childIndex = ap['childIndex']

    try:
        v = self.gnx_to_vnode[ap['gnx']]  # Trap this
        stack = [
            (self.gnx_to_vnode[d['gnx']], d['childIndex'])
            for d in ap['stack']
        ]
    except Exception:
        return False

    return leoNodes.position(v, childIndex, stack)

</t>
<t tx="felix.20191126232434.31">def _p_to_ap(self, p):
    '''(From Leo plugin leoflexx.py) Converts Leo position to a serializable archived position.'''
    if not p.v:
        print('app.p_to_ap: no p.v: %r %s' % (p), flush=True)
        assert False
    p_gnx = p.v.gnx
    # * Expand gnx-vnode translation table for any new node encountered
    if p_gnx not in self.gnx_to_vnode:
        self.gnx_to_vnode[p_gnx] = p.v
    # * necessary properties for outline
    w_ap = {
        'childIndex': p._childIndex,
        'gnx': p.v.gnx,
        'level': p.level(),
        'headline': p.h,
        'stack': [{
            'gnx': stack_v.gnx,
            'childIndex': stack_childIndex,
            'headline': stack_v.h,
        } for (stack_v, stack_childIndex) in p.stack],
    }
    # TODO : Convert all those booleans into an 8 bit integer 'status' flag
    # TODO : Send p.v.u as simple boolean flag and let user inspect ...
    # TODO ... it with context menu command instead of hover tooltip.
    if p.v.u:
        w_ap['u'] = p.v.u
    if bool(p.b):
        w_ap['hasBody'] = True
    if p.hasChildren():
        w_ap['hasChildren'] = True
    if p.isCloned():
        w_ap['cloned'] = True
    if p.isDirty():
        w_ap['dirty'] = True
    if p.isExpanded():
        w_ap['expanded'] = True
    if p.isMarked():
        w_ap['marked'] = True
    if p.isAnyAtFileNode():
        w_ap['atFile'] = True
    if p == self.commander.p:
        w_ap['selected'] = True
    return w_ap


</t>
<t tx="felix.20191126232434.4">class LeoBridgeIntegController:
    '''Leo Bridge Controller'''
    # pylint: disable=no-else-return

    @others
</t>
<t tx="felix.20191126232434.5">def __init__(self):
    self.gnx_to_vnode = []  # utility array - see leoflexx.py in leoPluginsRef.leo
    self.bridge = leoBridge.controller(
        gui='nullGui',
        loadPlugins=True,   # True: attempt to load plugins.
        readSettings=True,  # True: read standard settings files.
        silent=True,       # True: don't print signon messages.
        # True: prints what would be sent to the log pane.
        verbose=False,
    )
    self.g = self.bridge.globals()

    # * Trace outputs to pythons stdout, also prints the function call stack
    # self.g.trace('test trace')

    # * Intercept Log Pane output: Sends to client's log pane
    self.g.es = self.es  # pointer - not a function call

    # print(dir(self.g), flush=True)
    self.currentActionId = 1  # Id of action being processed, STARTS AT 1 = Initial 'ready'

    # * Currently Selected Commander (opened from leo.core.leoBridge or chosen via the g.app.windowList 2 list)
    self.commander = None

    self.leoIntegConfig = None
    self.webSocket = None
    self.loop = None

    # * Replacement instances to Leo's codebase : getScript, IdleTime, idleTimeManager and externalFilesController
    self.g.getScript = self._getScript
    self.g.IdleTime = self._idleTime
    self.g.app.idleTimeManager = IdleTimeManager(self.g)
    # attach instance to g.app for calls to set_time, etc.
    self.g.app.externalFilesController = ExternalFilesController(self)
    # TODO : Maybe use those yes/no replacement right before actual usage instead of in init. (to allow re-use/switching)
    # override for "revert to file" operation
    self.g.app.gui.runAskYesNoDialog = self._returnYes
    self.g.app.gui.show_find_success = self._show_find_success
    self.headlineWidget = self.g.bunch(_name='tree')

    # self.g.app.loadManager.createAllImporterData()  # Fixed in #1965 of leo-editor

    # * setup leoBackground to get messages from leo
    try:
        self.g.app.idleTimeManager.start()  # To catch derived file changes
    except Exception:
        print('ERROR with idleTimeManager')

</t>
<t tx="felix.20191126232435.1">def main():
    '''python script for leo integration via leoBridge'''
    global wsHost, wsPort
    print("Starting Leobridgeserver.py (Launch with -h for help)", flush=True)
    # replace default host address and port if provided as arguments

    args = None
    try:
        opts, args = getopt.getopt(sys.argv[1:], "ha:p:", [
                                   "help", "address=", "port="])
    except getopt.GetoptError:
        print('leobridgeserver.py -a &lt;address&gt; -p &lt;port&gt;')
        print('defaults to localhost on port 32125', flush=True)
        if args:
            print("unused args: " + str(args), flush=True)
        sys.exit(2)
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            print('leobridgeserver.py -a &lt;address&gt; -p &lt;port&gt;')
            print('defaults to localhost on port 32125', flush=True)
            sys.exit()
        elif opt in ("-a", "--address"):
            wsHost = arg
        elif opt in ("-p", "--port"):
            wsPort = arg

    # * start Server
    integController = LeoBridgeIntegController()

    # * This is a basic example loop
    # async def asyncInterval(timeout):
    #     dummyCounter = 0
    #     strTimeout = str(timeout) + ' sec interval'
    #     while True:
    #         await asyncio.sleep(timeout)
    #         dummyCounter = dummyCounter+1
    #         await integController.asyncOutput("{\"interval\":" + str(timeout+dummyCounter) + "}")  # as number
    #         print(strTimeout)

    async def leoBridgeServer(websocket, path):
        try:
            integController.initConnection(websocket)
            # * Start by sending empty as 'ok'.
            await websocket.send(integController.sendLeoBridgePackage())
            integController.logSignon()
            async for json_string_message in websocket:
                messageObject = json.loads(json_string_message)
                if messageObject and messageObject['action']:
                    action = messageObject['action']
                    param = messageObject['param']
                    # printAction(w_param)  # Debug output
                    # * Storing id of action in global var instead of passing as parameter.
                    integController.setActionId(messageObject['id'])
                    # ! functions called this way need to accept at least a parameter other than 'self'
                    # ! See : getSelectedNode and getAllGnx
                    if action[0] == "!":
                        w_func = getattr(integController, action[1:], None)
                        if not w_func:
                            print(action)
                        w_answer = w_func(param)
                    elif action[0] == "_":
                        integController._outputError(
                            'Error : Command starting with underscore')
                    else:
                        # Attempt to execute the command directly on the commander/subcommander.
                        w_answer = integController.leoCommand(
                            action, param)
                else:
                    w_answer = "Error in processCommand"
                    print(w_answer, flush=True)
                await websocket.send(w_answer)
        except websockets.exceptions.ConnectionClosedError:
            print("Websocket connection closed", flush=True)
        except Exception:
            print('Exception in leobridgeserver.py!', flush=True)
            # Like g.es_exception()...
            typ, val, tb = sys.exc_info()
            for line in traceback.format_exception(typ, val, tb):
                print(line.rstrip(), flush=True)
        finally:
            asyncio.get_event_loop().stop()

    localLoop = asyncio.get_event_loop()
    start_server = websockets.serve(leoBridgeServer, wsHost, wsPort)
    # localLoop.create_task(asyncInterval(5)) # Starts a test loop of async communication.
    localLoop.run_until_complete(start_server)
    # This SERVER_STARTED_TOKEN special string signals server startup success.
    print(SERVER_STARTED_TOKEN + " at " + wsHost + " on port: " +
          str(wsPort) + " [ctrl+c] to break", flush=True)
    localLoop.run_forever()
    print("Stopping leobridge server", flush=True)


</t>
<t tx="felix.20191128001054.1"></t>
<t tx="felix.20191128002414.1">import leo.core.leoBridge as leoBridge
import leo.core.leoNodes as leoNodes
from leo.core.leoGui import StringFindTabManager
import asyncio
import getopt
import json
import os.path
import sys
import time
import traceback
import websockets
</t>
<t tx="felix.20191128002417.1"># server defaults
wsHost = "localhost"
wsPort = 32125

# To help in printout
commonActions = ["getChildren", "getBody", "getBodyLength"]

# Special string signals server startup success
SERVER_STARTED_TOKEN = "LeoBridge started"


</t>
<t tx="felix.20191128003648.1"></t>
<t tx="felix.20191201194046.1">def get_all_gnx(self, param):
    '''Get gnx array from all unique nodes'''
    w_all_gnx = [
        p.v.gnx for p in self.commander.all_unique_positions(copy=False)]
    return self.sendLeoBridgePackage({"gnx": w_all_gnx})

</t>
<t tx="felix.20191216195906.1">def _findPNodeFromGnx(self, p_gnx):
    '''Return first p node with this gnx or false'''
    for p in self.commander.all_unique_positions():
        if p.v.gnx == p_gnx:
            return p
    return False

</t>
<t tx="felix.20200211202929.1">def initConnection(self, p_webSocket):
    self.webSocket = p_webSocket
    self.loop = asyncio.get_event_loop()

</t>
<t tx="felix.20200216160305.1">def save_file(self, param):
    '''Saves the leo file. New or dirty derived files are rewritten'''
    if self.commander:
        try:
            if "name" in param:
                self.commander.save(fileName=param['name'])
            else:
                self.commander.save()
        except Exception as e:
            self.g.trace('Error while saving')
            print("Error while saving", param['name'], flush=True)
            print(str(e),  param['name'],  flush=True)

    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200219222712.1">def es(self, * args, **keys):
    '''Output to the Log Pane'''
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
        'nodeLink': None,
    }
    d = self.g.doKeywordArgs(keys, d)
    s = self.g.translateArgs(args, d)
    w_package = {"async": "log", "log": s}
    self.sendAsyncOutput(w_package)

</t>
<t tx="felix.20200219224515.1">def logSignon(self):
    '''Simulate the Initial Leo Log Entry'''
    if self.loop:
        self.g.app.computeSignon()
        self.g.es(str(self.g.app.signon))
        self.g.es(str(self.g.app.signon1))
    else:
        print('no loop in logSignon', flush=True)

</t>
<t tx="felix.20200302204251.1">class IdleTimeManager:
    """
    A singleton class to manage idle-time handling. This class handles all
    details of running code at idle time, including running 'idle' hooks.

    Any code can call g.app.idleTimeManager.add_callback(callback) to cause
    the callback to be called at idle time forever.
    """
    # TODO : REVISE/REPLACE WITH OWN SYSTEM

    def __init__(self, g):
        """Ctor for IdleTimeManager class."""
        self.g = g
        self.callback_list = []
        self.timer = None
        self.on_idle_count = 0

    @others

</t>
<t tx="felix.20200302204251.2">def add_callback(self, callback):
    """Add a callback to be called at every idle time."""
    self.callback_list.append(callback)

</t>
<t tx="felix.20200302204251.3">def on_idle(self, timer):
    """IdleTimeManager: Run all idle-time callbacks."""
    if not self.g.app:
        return
    if self.g.app.killed:
        return
    if not self.g.app.pluginsController:
        self.g.trace('No g.app.pluginsController', self.g.callers())
        timer.stop()
        return  # For debugger.
    self.on_idle_count += 1
    # Handle the registered callbacks.
    # print("list length : ", len(self.callback_list))
    for callback in self.callback_list:
        try:
            callback()
        except Exception:
            self.g.es_exception()
            self.g.es_print(f"removing callback: {callback}")
            self.callback_list.remove(callback)
    # Handle idle-time hooks.
    self.g.app.pluginsController.on_idle()

</t>
<t tx="felix.20200302204251.4">def start(self):
    """Start the idle-time timer."""
    self.timer = self.g.IdleTime(
        self.on_idle,
        delay=500,  # Milliseconds
        tag='IdleTimeManager.on_idle')
    if self.timer:
        self.timer.start()

</t>
<t tx="felix.20200302205810.1">class ExternalFilesController:
    '''EFC Modified from Leo's sources'''
    # pylint: disable=no-else-return

    @others

</t>
<t tx="felix.20200302205810.2">def __init__(self, integController):
    '''Ctor for ExternalFiles class.'''
    self.on_idle_count = 0
    self.integController = integController
    self.checksum_d = {}
    # Keys are full paths, values are file checksums.
    self.enabled_d = {}
    # For efc.on_idle.
    # Keys are commanders.
    # Values are cached @bool check-for-changed-external-file settings.
    self.has_changed_d = {}
    # Keys are commanders. Values are boolean.
    # Used only to limit traces.
    self.unchecked_commanders = []
    # Copy of g.app.commanders()
    self.unchecked_files = []
    # Copy of self file. Only one files is checked at idle time.
    self._time_d = {}
    # Keys are full paths, values are modification times.
    # DO NOT alter directly, use set_time(path) and
    # get_time(path), see set_time() for notes.
    self.yesno_all_time = 0  # previous yes/no to all answer, time of answer
    self.yesno_all_answer = None  # answer, 'yes-all', or 'no-all'

    # if yesAll/noAll forced, then just show info message after idle_check_commander
    self.infoMessage = None
    # False or "detected", "refreshed" or "ignored"

    self.integController.g.app.idleTimeManager.add_callback(self.on_idle)

    self.waitingForAnswer = False
    self.lastPNode = None  # last p node that was asked for if not set to "AllYes\AllNo"
    self.lastCommander = None

</t>
<t tx="felix.20200302205810.21"></t>
<t tx="felix.20200302205810.22">def ask(self, c, path, p=None):
    '''
    Ask user whether to overwrite an @&lt;file&gt; tree.
    Return True if the user agrees.
    '''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["defaultReloadIgnore"].lower(
        )
        if not bool('none' in w_check_config):
            if bool('yes' in w_check_config):
                self.infoMessage = "refreshed"
                return True
            else:
                self.infoMessage = "ignored"
                return False
    # let original function resolve

    if self.yesno_all_time + 3 &gt;= time.time() and self.yesno_all_answer:
        self.yesno_all_time = time.time()  # Still reloading?  Extend time.
        # if yesAll/noAll forced, then just show info message
        w_yesno_all_bool = bool('yes' in self.yesno_all_answer.lower())

        return w_yesno_all_bool
    if not p:
        where = 'the outline node'
    else:
        where = p.h

    _is_leo = path.endswith(('.leo', '.db'))

    if _is_leo:
        s = '\n'.join([
            f'{self.integController.g.splitLongFileName(path)} has changed outside Leo.',
            'Overwrite it?'
        ])
    else:
        s = '\n'.join([
            f'{self.integController.g.splitLongFileName(path)} has changed outside Leo.',
            f"Reload {where} in Leo?",
        ])

    w_package = {"async": "ask", "ask": 'Overwrite the version in Leo?',
                 "message": s, "yes_all": not _is_leo, "no_all": not _is_leo}

    self.integController.sendAsyncOutput(w_package)
    self.waitingForAnswer = True
    return False
    # result = self.integController.g.app.gui.runAskYesNoDialog(c, 'Overwrite the version in Leo?', s,
    # yes_all=not _is_leo, no_all=not _is_leo)

    # if result and "-all" in result.lower():
    # self.yesno_all_time = time.time()
    # self.yesno_all_answer = result.lower()

    # return bool(result and 'yes' in result.lower())

</t>
<t tx="felix.20200302205810.23">def checksum(self, path):
    '''Return the checksum of the file at the given path.'''
    import hashlib
    return hashlib.md5(open(path, 'rb').read()).hexdigest()

</t>
<t tx="felix.20200302205810.25">def get_mtime(self, path):
    '''Return the modification time for the path.'''
    return self.integController.g.os_path_getmtime(self.integController.g.os_path_realpath(path))

</t>
<t tx="felix.20200302205810.26">def get_time(self, path):
    '''
    return timestamp for path

    see set_time() for notes
    '''
    return self._time_d.get(self.integController.g.os_path_realpath(path))

</t>
<t tx="felix.20200302205810.27">def has_changed(self, path):
    '''Return True if p's external file has changed outside of Leo.'''
    if not path:
        return False
    if not self.integController.g.os_path_exists(path):
        return False
    if self.integController.g.os_path_isdir(path):
        return False
    #
    # First, check the modification times.
    old_time = self.get_time(path)
    new_time = self.get_mtime(path)
    if not old_time:
        # Initialize.
        self.set_time(path, new_time)
        self.checksum_d[path] = self.checksum(path)
        return False
    if old_time == new_time:
        return False
    #
    # Check the checksums *only* if the mod times don't match.
    old_sum = self.checksum_d.get(path)
    new_sum = self.checksum(path)
    if new_sum == old_sum:
        # The modtime changed, but it's contents didn't.
        # Update the time, so we don't keep checking the checksums.
        # Return False so we don't prompt the user for an update.
        self.set_time(path, new_time)
        return False
    # The file has really changed.
    assert old_time, path
    # #208: external change overwrite protection only works once.
    # If the Leo version is changed (dirtied) again,
    # overwrite will occur without warning.
    # self.set_time(path, new_time)
    # self.checksum_d[path] = new_sum
    return True

</t>
<t tx="felix.20200302205810.28">def is_enabled(self, c):
    '''Return the cached @bool check_for_changed_external_file setting.'''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["checkForChangeExternalFiles"].lower(
        )
        if bool('check' in w_check_config):
            return True
        if bool('ignore' in w_check_config):
            return False
    # let original function resolve
    d = self.enabled_d
    val = d.get(c)
    if val is None:
        val = c.config.getBool(
            'check-for-changed-external-files', default=False)
        d[c] = val
    return val

</t>
<t tx="felix.20200302205810.29">def join(self, s1, s2):
    '''Return s1 + ' ' + s2'''
    return f"{s1} {s2}"

</t>
<t tx="felix.20200302205810.30">def set_time(self, path, new_time=None):
    '''
    Implements c.setTimeStamp.

    Update the timestamp for path.

    NOTE: file paths with symbolic links occur with and without those links
    resolved depending on the code call path.  This inconsistency is
    probably not Leo's fault but an underlying Python issue.
    Hence the need to call realpath() here.
    '''

    # print("called set_time for " + str(path), flush=True)

    t = new_time or self.get_mtime(path)
    self._time_d[self.integController.g.os_path_realpath(path)] = t

</t>
<t tx="felix.20200302205810.31">def warn(self, c, path, p):
    '''
    Warn that an @asis or @nosent node has been changed externally.

    There is *no way* to update the tree automatically.
    '''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["defaultReloadIgnore"].lower(
        )

        if w_check_config != "none":
            # if not 'none' then do not warn, just infoMessage 'warn' at most
            if not self.infoMessage:
                self.infoMessage = "warn"
            return

    # let original function resolve
    if self.integController.g.unitTesting or c not in self.integController.g.app.commanders():
        return
    if not p:
        self.integController.g.trace('NO P')
        return

    s = '\n'.join([
        '%s has changed outside Leo.\n' % self.integController.g.splitLongFileName(
            path),
        'Leo can not update this file automatically.\n',
        'This file was created from %s.\n' % p.h,
        'Warning: refresh-from-disk will destroy all children.'
    ])

    w_package = {"async": "warn",
                 "warn": 'External file changed', "message": s}

    self.integController.sendAsyncOutput(w_package)
    self.waitingForAnswer = True

</t>
<t tx="felix.20200302205810.7">def on_idle(self):
    '''
    Check for changed open-with files and all external files in commanders
    for which @bool check_for_changed_external_file is True.
    '''
    # Fix for flushing the terminal console to traverse
    # python through node.js when using start server in leoInteg
    sys.stdout.flush()

    if not self.integController.g.app or self.integController.g.app.killed:
        return
    if self.waitingForAnswer:
        return

    self.on_idle_count += 1

    if self.unchecked_commanders:
        # Check the next commander for which
        # @bool check_for_changed_external_file is True.
        c = self.unchecked_commanders.pop()
        self.lastCommander = c
        self.idle_check_commander(c)
    else:
        # Add all commanders for which
        # @bool check_for_changed_external_file is True.
        self.unchecked_commanders = [
            z for z in self.integController.g.app.commanders() if self.is_enabled(z)
        ]

</t>
<t tx="felix.20200302205810.8">def idle_check_commander(self, c):
    '''
    Check all external files corresponding to @&lt;file&gt; nodes in c for
    changes.
    '''
    # #1100: always scan the entire file for @&lt;file&gt; nodes.
    # #1134: Nested @&lt;file&gt; nodes are no longer valid, but this will do no harm.

    self.infoMessage = None  # reset infoMessage
    # False or "detected", "refreshed" or "ignored"

    for p in c.all_unique_positions():
        if self.waitingForAnswer:
            break
        if p.isAnyAtFileNode():
            self.idle_check_at_file_node(c, p)

    # if yesAll/noAll forced, then just show info message
    if self.infoMessage:
        w_package = {"async": "info", "message": self.infoMessage}
        self.integController.sendAsyncOutput(w_package)

</t>
<t tx="felix.20200302205810.9">def idle_check_at_file_node(self, c, p):
    '''Check the @&lt;file&gt; node at p for external changes.'''
    trace = False
    # Matt, set this to True, but only for the file that interests you.\
    # trace = p.h == '@file unregister-leo.leox'
    path = self.integController.g.fullPath(c, p)
    has_changed = self.has_changed(path)
    if trace:
        self.integController.g.trace('changed', has_changed, p.h)
    if has_changed:
        self.lastPNode = p  # can be set here because its the same process for ask/warn
        if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
            # Fix #1081: issue a warning.
            self.warn(c, path, p=p)
        elif self.ask(c, path, p=p):
            self.lastCommander.selectPosition(self.lastPNode)
            c.refreshFromDisk()

        # Always update the path &amp; time to prevent future warnings.
        self.set_time(path)
        self.checksum_d[path] = self.checksum(path)

</t>
<t tx="felix.20200303214235.1">async def _asyncIdleLoop(self, p_seconds, p_fn):
    while True:
        await asyncio.sleep(p_seconds)
        p_fn(self)

</t>
<t tx="felix.20200303214255.1">def _idleTime(self, fn, delay, tag):
    # TODO : REVISE/REPLACE WITH OWN SYSTEM
    asyncio.get_event_loop().create_task(self._asyncIdleLoop(delay/1000, fn))

</t>
<t tx="felix.20200304220844.1">def set_ask_result(self, p_result):
    '''Got the result to an asked question/warning from client'''
    self.g.app.externalFilesController.integResult(p_result)
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200304221925.1">def integResult(self, p_result):
    '''Received result from client'''
    # Got the result to an asked question/warning from the client
    if not self.waitingForAnswer:
        print("ERROR: Received Result but no Asked Dialog", flush=True)
        return
    # check if p_resultwas from a warn (ok) or an ask ('yes','yes-all','no','no-all')
    # act accordingly

    path = self.integController.g.fullPath(
        self.lastCommander, self.lastPNode)

    # 1- if ok, unblock 'warn'
    # 2- if no, unblock 'ask'
    # ------------------------------------------ Nothing special to do

    # 3- if noAll, set noAll, and unblock 'ask'
    if p_result and "-all" in p_result.lower():
        self.yesno_all_time = time.time()
        self.yesno_all_answer = p_result.lower()
    # ------------------------------------------ Also covers setting yesAll in #5

    # 4- if yes, REFRESH self.lastPNode, and unblock 'ask'
    # 5- if yesAll,REFRESH self.lastPNode, set yesAll, and unblock 'ask'
    if bool(p_result and 'yes' in p_result.lower()):
        self.lastCommander.selectPosition(self.lastPNode)
        self.lastCommander.refreshFromDisk()

    # Always update the path &amp; time to prevent future warnings for this PNode.
    self.set_time(path)
    self.checksum_d[path] = self.checksum(path)

    self.waitingForAnswer = False  # unblock
    # unblock: run the loop as if timer had hit
    self.idle_check_commander(self.lastCommander)

</t>
<t tx="felix.20200304224909.1">def sendAsyncOutput(self, p_package):
    if "async" not in p_package:
        print('[sendAsyncOutput] Error async member missing in package parameter')
        print(json.dumps(p_package, separators=(',', ':')), flush=True)
        return
    if self.loop:
        self.loop.create_task(self.asyncOutput(
            json.dumps(p_package, separators=(',', ':'))))
    else:
        print('[sendAsyncOutput] Error loop not ready' +
              json.dumps(p_package, separators=(',', ':')))

</t>
<t tx="felix.20200308145948.1"># Some methods are called in the usual (non-leoBridge without 'efc') save process.
# Those may be called by the 'save' function, like check_overwrite,
# or by any other functions from the instance of leo.core.leoBridge that's running.

</t>
<t tx="felix.20200308150821.1">def shut_down(self):
    return

</t>
<t tx="felix.20200308150842.1">def destroy_frame(self, f):
    return

</t>
<t tx="felix.20200308150848.1">def check_overwrite(self, c, fn):
    # print("check_overwrite!! ", flush=True)
    return True

</t>
<t tx="felix.20200308150856.1">def open_with(self, c, d):
    return

</t>
<t tx="felix.20200312231358.1">def set_config(self, p_config):
    '''Got leoInteg's config from client'''
    self.leoIntegConfig = p_config
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200622230608.1">def get_all_open_commanders(self, param):
    '''Return array of opened file path/names to be used as openFile parameters to switch files'''
    w_files = []
    for w_commander in self.g.app.commanders():
        if not w_commander.closed:
            w_isSelected = False
            w_isChanged = w_commander.changed
            if self.commander == w_commander:
                w_isSelected = True
            w_entry = {
                "name": w_commander.mFileName,
                "changed": w_isChanged,
                "selected": w_isSelected
            }
            w_files.append(w_entry)

    return self.sendLeoBridgePackage({"files": w_files})

</t>
<t tx="felix.20200623201853.1">def _getTotalOpened(self):
    '''Get total of opened commander (who have closed == false)'''
    w_total = 0
    for w_commander in self.g.app.commanders():
        if not w_commander.closed:
            w_total = w_total + 1
    return w_total

</t>
<t tx="felix.20200623215904.1">def _getFirstOpenedCommander(self):
    '''Get first opened commander, or False if there are none.'''
    for w_commander in self.g.app.commanders():
        if not w_commander.closed:
            return w_commander
    return False

</t>
<t tx="felix.20200624172552.1">def set_opened_file(self, param):
    '''Choose the new active commander from array of opened file path/names by numeric index'''
    w_openedCommanders = []

    for w_commander in self.g.app.commanders():
        if not w_commander.closed:
            w_openedCommanders.append(w_commander)

    w_index = param['index']  # index in param

    if w_openedCommanders[w_index]:
        self.commander = w_openedCommanders[w_index]

    if self.commander:
        self.commander.closed = False
        self._create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self._p_to_ap(self.commander.p)}
        # maybe needed for frame wrapper
        self.commander.selectPosition(self.commander.p)
        return self.sendLeoBridgePackage(w_result)
    else:
        return self._outputError('Error in setOpenedFile')

</t>
<t tx="felix.20200626012709.1">def _returnNo(self, *arguments, **kwargs):
    '''Used to override g.app.gui.ask[XXX] dialogs answers'''
    return "no"

</t>
<t tx="felix.20200626030820.1">def _returnYes(self, *arguments, **kwargs):
    '''Used to override g.app.gui.ask[XXX] dialogs answers'''
    return "yes"

</t>
<t tx="felix.20200718020912.1">import * as vscode from "vscode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718020912.10">/**
 * * Actions that can be invoked by Leo through leobridge
 */
public static ASYNC_ACTIONS = {
    ASYNC_LOG: "log",
    ASYNC_ASK: "ask",
    ASYNC_WARN: "warn",
    ASYNC_INFO: "info",
    ASYNC_INTERVAL: "interval"
};

</t>
<t tx="felix.20200718020912.11">/**
 * * When async action was ASYNC_INFO
 */
public static ASYNC_INFO_MESSAGE_CODES = {
    ASYNC_REFRESHED: "refreshed",
    ASYNC_IGNORED: "ignored"
};

</t>
<t tx="felix.20200718020912.12">/**
 * * runAskYesNoDialog or runAskOkDialog result codes, used when async action requires a response
 */
public static ASYNC_ASK_RETURN_CODES = {
    YES: "yes",
    NO: "no",
    YES_ALL: "yes-all",
    NO_ALL: "no-all",
    OK: '"ok"' // Quotes in string as a 'JSON parameter'
};

</t>
<t tx="felix.20200718020912.13">/**
 * * Commands for leobridgeserver.py
 */
public static LEOBRIDGE = {
    TEST: "!test",
    // * Server Commands
    GET_COMMANDS: "!get_all_leo_commands", // "getCommands",
    APPLY_CONFIG: "!set_config", // "applyConfig",
    ASK_RESULT: "!set_ask_result", // "askResult",
    // * GUI
    GET_ALL_GNX: "!get_all_gnx", // "getAllGnx",
    GET_BODY_LENGTH: "!get_body_length", // "getBodyLength",
    GET_BODY_STATES: "!get_body_states", // "getBodyStates",
    GET_BODY: "!get_body", // "getBody",
    GET_PARENT: "!get_parent", // "getParent",
    GET_CHILDREN: "!get_children", // "getChildren",
    SET_SELECTED_NODE: "!set_current_position", // "setSelectedNode",
    SET_BODY: "!set_body", // "setBody",
    SET_SELECTION: "!set_selection", // "setSelection",
    SET_HEADLINE: "!set_headline", // "setNewHeadline",
    EXPAND_NODE: "!expand_node", // "expandNode",
    COLLAPSE_NODE: "!contract_node", // "collapseNode",
    CONTRACT_ALL: "contractAllHeadlines", // * Direct Leo Command
    GET_STATES: "!get_ui_states", // "getStates",
    // * Leo Documents
    GET_OPENED_FILES: "!get_all_open_commanders", //"getOpenedFiles",
    SET_OPENED_FILE: "!set_opened_file", // "setOpenedFile",
    OPEN_FILE: "!open_file", // "openFile",
    IMPORT_ANY_FILE: "!import_any_file", // "importAnyFile",
    OPEN_FILES: "!open_files", //  "openFiles",
    CLOSE_FILE: "!close_file", // "closeFile",
    SAVE_FILE: "!save_file", // "saveFile",
    // * @-Buttons
    GET_BUTTONS: "!get_buttons", // "getButtons",
    REMOVE_BUTTON: "!remove_button", // "removeButton",
    CLICK_BUTTON: "!click_button", // "clickButton",
    // * Goto operations
    PAGE_UP: "!page_up", // "pageUp",
    PAGE_DOWN: "!page_down", // "pageDown",
    GOTO_FIRST_VISIBLE: "goToFirstVisibleNode", // * Direct Leo Command
    GOTO_LAST_VISIBLE: "goToLastVisibleNode", // * Direct Leo Command
    GOTO_LAST_SIBLING: "goToLastSibling", // * Direct Leo Command
    GOTO_NEXT_VISIBLE: "selectVisNext", // * Direct Leo Command
    GOTO_PREV_VISIBLE: "selectVisBack", // * Direct Leo Command
    GOTO_NEXT_MARKED: "goToNextMarkedHeadline", // * Direct Leo Command
    GOTO_NEXT_CLONE: "goToNextClone", // * Direct Leo Command
    CONTRACT_OR_GO_LEFT: "contractNodeOrGoToParent", // * Direct Leo Command
    EXPAND_AND_GO_RIGHT: "expandNodeAndGoToFirstChild", // * Direct Leo Command
    // * Leo Operations
    MARK_PNODE: "!mark_node", // "markPNode",
    UNMARK_PNODE: "!unmark_node", // "unmarkPNode",
    COPY_PNODE: "copyOutline", // * Direct Leo Command
    CUT_PNODE: "!cut_node", // "cutPNode",
    PASTE_PNODE: "pasteOutline", // * Direct Leo Command
    PASTE_CLONE_PNODE: "pasteOutlineRetainingClones", // * Direct Leo Command
    DELETE_PNODE: "!delete_node", // "deletePNode",
    MOVE_PNODE_DOWN: "moveOutlineDown", // * Direct Leo Command
    MOVE_PNODE_LEFT: "moveOutlineLeft", // * Direct Leo Command
    MOVE_PNODE_RIGHT: "moveOutlineRight", // * Direct Leo Command
    MOVE_PNODE_UP: "moveOutlineUp", // * Direct Leo Command
    INSERT_PNODE: "!insert_node", // "insertPNode",
    INSERT_NAMED_PNODE: "!insert_named_node", // "insertNamedPNode",
    CLONE_PNODE: "!clone_node", // "clonePNode",
    PROMOTE_PNODE: "promote", // * Direct Leo Command
    DEMOTE_PNODE: "demote", // * Direct Leo Command
    REFRESH_FROM_DISK_PNODE: "refreshFromDisk", // * Direct Leo Command
    SORT_CHILDREN: "sortChildren", // * Direct Leo Command
    SORT_SIBLINGS: "sortSiblings", // * Direct Leo Command
    UNDO: "!undo",
    REDO: "!redo",
    EXECUTE_SCRIPT: "executeScript", // * Direct Leo Command
    HOIST_PNODE: "hoist", // * Direct Leo Command
    DEHOIST: "dehoist", // * Direct Leo Command
    EXTRACT: "extract", // * Direct Leo Command
    EXTRACT_NAMES: "extractSectionNames", // * Direct Leo Command
    COPY_MARKED: "copyMarked", // * Direct Leo Command
    DIFF_MARKED_NODES: "deleteMarked", // * Direct Leo Command
    MARK_CHANGED_ITEMS: "markChangedHeadlines", // * Direct Leo Command
    MARK_SUBHEADS: "markSubheads", // * Direct Leo Command
    UNMARK_ALL: "unmarkAll", // * Direct Leo Command
    CLONE_MARKED_NODES: "cloneMarked", // * Direct Leo Command
    DELETE_MARKED_NODES: "deleteMarked", // * Direct Leo Command
    MOVE_MARKED_NODES: "moveMarked", // * Direct Leo Command
    GIT_DIFF: "gitDiff", // * Direct Leo Command
    GET_FOCUS: "!get_focus",
    GET_SEARCH_SETTINGS: "!get_search_settings",
    SET_SEARCH_SETTINGS: "!set_search_settings",
    START_SEARCH: "!start_search",
    FIND_ALL: "!find_all",
    FIND_NEXT: "!find_next",
    FIND_PREVIOUS: "!find_previous",
    REPLACE: "!replace",
    REPLACE_THEN_FIND: "!replace_then_find",
    REPLACE_ALL: "!replace_all",
    GOTO_GLOBAL_LINE: "!goto_global_line",
    CLONE_FIND_ALL: "!clone_find_all",
    CLONE_FIND_ALL_FLATTENED: "!clone_find_all_flattened",
    CLONE_FIND_MARKED: "cloneFindAllMarked", // * Direct Leo Command
    CLONE_FIND_FLATTENED_MARKED: "cloneFindAllFlattenedMarked" // * Direct Leo Command
};

</t>
<t tx="felix.20200718020912.15">/**
 * * All commands this expansion exposes (in package.json, contributes &gt; commands)
 */
public static COMMANDS = {
    SHOW_WELCOME: Constants.NAME + ".showWelcomePage", // Always available: not in the commandPalette section of package.json
    SHOW_SETTINGS: Constants.NAME + ".showSettingsPage", // Always available: not in the commandPalette section of package.json
    // * LeoBridge
    CHOOSE_LEO_FOLDER: Constants.NAME + ".chooseLeoFolder",
    START_SERVER: Constants.NAME + ".startServer",
    CONNECT: Constants.NAME + ".connectToServer",
    SET_OPENED_FILE: Constants.NAME + ".setOpenedFile",
    OPEN_FILE: Constants.NAME + ".openLeoFile", // sets focus on BODY
    CLEAR_RECENT_FILES: Constants.NAME + ".clearRecentFiles",
    IMPORT_ANY_FILE: Constants.NAME + ".importAnyFile",
    RECENT_FILES: Constants.NAME + ".recentLeoFiles", // shows recent Leo files, opens one on selection
    SWITCH_FILE: Constants.NAME + ".switchLeoFile",
    NEW_FILE: Constants.NAME + ".newLeoFile",
    SAVE_FILE: Constants.NAME + ".saveLeoFile",
    SAVE_FILE_FO: Constants.NAME + ".saveLeoFileFromOutline",
    SAVE_AS_FILE: Constants.NAME + ".saveAsLeoFile",
    CLOSE_FILE: Constants.NAME + ".closeLeoFile",
    CLICK_BUTTON: Constants.NAME + ".clickButton",
    REMOVE_BUTTON: Constants.NAME + ".removeButton",
    MINIBUFFER: Constants.NAME + ".minibuffer",
    GIT_DIFF: Constants.NAME + ".gitDiff", // TODO : Test &amp; Fix this Proof of concept leoCommand
    // * Outline selection
    SELECT_NODE: Constants.NAME + ".selectTreeNode",
    OPEN_ASIDE: Constants.NAME + ".openAside",
    // * Goto operations that always finish with focus in outline
    PAGE_UP: Constants.NAME + ".pageUp",
    PAGE_DOWN: Constants.NAME + ".pageDown",
    GOTO_FIRST_VISIBLE: Constants.NAME + ".gotoFirstVisible",
    GOTO_LAST_VISIBLE: Constants.NAME + ".gotoLastVisible",
    GOTO_LAST_SIBLING: Constants.NAME + ".gotoLastSibling",
    GOTO_NEXT_VISIBLE: Constants.NAME + ".gotoNextVisible",
    GOTO_PREV_VISIBLE: Constants.NAME + ".gotoPrevVisible",
    GOTO_NEXT_MARKED: Constants.NAME + ".gotoNextMarked",
    GOTO_NEXT_CLONE: Constants.NAME + ".gotoNextClone",
    GOTO_NEXT_CLONE_SELECTION: Constants.NAME + ".gotoNextCloneSelection",
    GOTO_NEXT_CLONE_SELECTION_FO: Constants.NAME + ".gotoNextCloneSelectionFromOutline",
    CONTRACT_OR_GO_LEFT: Constants.NAME + ".contractOrGoLeft",
    EXPAND_AND_GO_RIGHT: Constants.NAME + ".expandAndGoRight",
    // * Leo Operations
    UNDO: Constants.NAME + ".undo", // From command Palette
    UNDO_FO: Constants.NAME + ".undoFromOutline", // from button, return focus on OUTLINE
    UNDO_DISABLED: Constants.NAME + ".undoDisabled", // Disabled - nop
    REDO: Constants.NAME + ".redo", // From command Palette
    REDO_FO: Constants.NAME + ".redoFromOutline", // from button, return focus on OUTLINE
    REDO_DISABLED: Constants.NAME + ".redoDisabled", // Disabled - nop
    EXECUTE: Constants.NAME + ".executeScript",
    SHOW_BODY: Constants.NAME + ".showBody",
    SHOW_OUTLINE: Constants.NAME + ".showOutline",
    SHOW_LOG: Constants.NAME + ".showLogPane",
    SORT_CHILDREN: Constants.NAME + ".sortChildrenSelection",
    SORT_CHILDREN_FO: Constants.NAME + ".sortChildrenSelectionFromOutline",
    SORT_SIBLING: Constants.NAME + ".sortSiblingsSelection",
    SORT_SIBLING_FO: Constants.NAME + ".sortSiblingsSelectionFromOutline",
    CONTRACT_ALL: Constants.NAME + ".contractAll", // From command Palette
    CONTRACT_ALL_FO: Constants.NAME + ".contractAllFromOutline", // from button, return focus on OUTLINE
    PREV_NODE: Constants.NAME + ".prev",
    NEXT_NODE: Constants.NAME + ".next",
    // * Commands from tree panel buttons or context: focus on OUTLINE
    MARK: Constants.NAME + ".mark",
    UNMARK: Constants.NAME + ".unmark",
    COPY: Constants.NAME + ".copyNode",
    CUT: Constants.NAME + ".cutNode",
    PASTE: Constants.NAME + ".pasteNode",
    PASTE_CLONE: Constants.NAME + ".pasteNodeAsClone",
    DELETE: Constants.NAME + ".delete",
    HEADLINE: Constants.NAME + ".editHeadline",
    MOVE_DOWN: Constants.NAME + ".moveOutlineDown",
    MOVE_LEFT: Constants.NAME + ".moveOutlineLeft",
    MOVE_RIGHT: Constants.NAME + ".moveOutlineRight",
    MOVE_UP: Constants.NAME + ".moveOutlineUp",
    INSERT: Constants.NAME + ".insertNode",
    CLONE: Constants.NAME + ".cloneNode",
    PROMOTE: Constants.NAME + ".promote",
    DEMOTE: Constants.NAME + ".demote",
    REFRESH_FROM_DISK: Constants.NAME + ".refreshFromDisk",
    // * Commands from keyboard, while focus on BODY (command-palette returns to BODY for now)
    MARK_SELECTION: Constants.NAME + ".markSelection",
    UNMARK_SELECTION: Constants.NAME + ".unmarkSelection",
    COPY_SELECTION: Constants.NAME + ".copyNodeSelection", // Nothing to refresh/focus so no "FO" version
    CUT_SELECTION: Constants.NAME + ".cutNodeSelection",
    PASTE_SELECTION: Constants.NAME + ".pasteNodeAtSelection",
    PASTE_CLONE_SELECTION: Constants.NAME + ".pasteNodeAsCloneAtSelection",
    DELETE_SELECTION: Constants.NAME + ".deleteSelection",
    HEADLINE_SELECTION: Constants.NAME + ".editSelectedHeadline",
    MOVE_DOWN_SELECTION: Constants.NAME + ".moveOutlineDownSelection",
    MOVE_LEFT_SELECTION: Constants.NAME + ".moveOutlineLeftSelection",
    MOVE_RIGHT_SELECTION: Constants.NAME + ".moveOutlineRightSelection",
    MOVE_UP_SELECTION: Constants.NAME + ".moveOutlineUpSelection",
    INSERT_SELECTION: Constants.NAME + ".insertNodeSelection", // Can be interrupted
    INSERT_SELECTION_INTERRUPT: Constants.NAME + ".insertNodeSelectionInterrupt", // Interrupted version
    CLONE_SELECTION: Constants.NAME + ".cloneNodeSelection",
    PROMOTE_SELECTION: Constants.NAME + ".promoteSelection",
    DEMOTE_SELECTION: Constants.NAME + ".demoteSelection",
    REFRESH_FROM_DISK_SELECTION: Constants.NAME + ".refreshFromDiskSelection",
    // * Commands from keyboard, while focus on OUTLINE
    MARK_SELECTION_FO: Constants.NAME + ".markSelectionFromOutline",
    UNMARK_SELECTION_FO: Constants.NAME + ".unmarkSelectionFromOutline",
    // COPY_SELECTION Nothing to refresh/focus for "copy a node" so no "FO" version
    CUT_SELECTION_FO: Constants.NAME + ".cutNodeSelectionFromOutline",
    PASTE_SELECTION_FO: Constants.NAME + ".pasteNodeAtSelectionFromOutline",
    PASTE_CLONE_SELECTION_FO: Constants.NAME + ".pasteNodeAsCloneAtSelectionFromOutline",
    DELETE_SELECTION_FO: Constants.NAME + ".deleteSelectionFromOutline",
    HEADLINE_SELECTION_FO: Constants.NAME + ".editSelectedHeadlineFromOutline",
    MOVE_DOWN_SELECTION_FO: Constants.NAME + ".moveOutlineDownSelectionFromOutline",
    MOVE_LEFT_SELECTION_FO: Constants.NAME + ".moveOutlineLeftSelectionFromOutline",
    MOVE_RIGHT_SELECTION_FO: Constants.NAME + ".moveOutlineRightSelectionFromOutline",
    MOVE_UP_SELECTION_FO: Constants.NAME + ".moveOutlineUpSelectionFromOutline",
    INSERT_SELECTION_FO: Constants.NAME + ".insertNodeSelectionFromOutline",
    CLONE_SELECTION_FO: Constants.NAME + ".cloneNodeSelectionFromOutline",
    PROMOTE_SELECTION_FO: Constants.NAME + ".promoteSelectionFromOutline",
    DEMOTE_SELECTION_FO: Constants.NAME + ".demoteSelectionFromOutline",
    REFRESH_FROM_DISK_SELECTION_FO: Constants.NAME + ".refreshFromDiskSelectionFromOutline",
    HOIST: Constants.NAME + ".hoistNode",
    HOIST_SELECTION: Constants.NAME + ".hoistSelection",
    HOIST_SELECTION_FO: Constants.NAME + ".hoistSelectionFromOutline",
    DEHOIST: Constants.NAME + ".deHoist",
    DEHOIST_FO: Constants.NAME + ".deHoistFromOutline",
    EXTRACT: Constants.NAME + ".extract",
    EXTRACT_NAMES: Constants.NAME + ".extractNames",
    COPY_MARKED: Constants.NAME + ".copyMarked",
    DIFF_MARKED_NODES: Constants.NAME + ".diffMarkedNodes",
    MARK_CHANGED_ITEMS: Constants.NAME + ".markChangedItems",
    MARK_SUBHEADS: Constants.NAME + ".markSubheads",
    UNMARK_ALL: Constants.NAME + ".unmarkAll",
    CLONE_MARKED_NODES: Constants.NAME + ".cloneMarkedNodes",
    DELETE_MARKED_NODES: Constants.NAME + ".deleteMarkedNodes",
    MOVE_MARKED_NODES: Constants.NAME + ".moveMarkedNodes",
    START_SEARCH: Constants.NAME + ".startSearch",
    FIND_ALL: Constants.NAME + ".findAll",
    FIND_NEXT: Constants.NAME + ".findNext",
    FIND_NEXT_FO: Constants.NAME + ".findNextFromOutline",
    FIND_PREVIOUS: Constants.NAME + ".findPrevious",
    FIND_PREVIOUS_FO: Constants.NAME + ".findPreviousFromOutline",
    REPLACE: Constants.NAME + ".replace",
    REPLACE_FO: Constants.NAME + ".replaceFromOutline",
    REPLACE_THEN_FIND: Constants.NAME + ".replaceThenFind",
    REPLACE_THEN_FIND_FO: Constants.NAME + ".replaceThenFindFromOutline",
    REPLACE_ALL: Constants.NAME + ".replaceAll",
    CLONE_FIND_ALL: Constants.NAME + ".cloneFindAll",
    CLONE_FIND_ALL_FLATTENED: Constants.NAME + ".cloneFindAllFlattened",
    CLONE_FIND_MARKED: Constants.NAME + ".cloneFindMarked",
    CLONE_FIND_FLATTENED_MARKED: Constants.NAME + ".cloneFindFlattenedMarked",
    GOTO_GLOBAL_LINE: Constants.NAME + ".gotoGlobalLine",
    SET_FIND_EVERYWHERE_OPTION: Constants.NAME + ".setFindEverywhereOption",
    SET_FIND_NODE_ONLY_OPTION: Constants.NAME + ".setFindNodeOnlyOption",
    SET_FIND_SUBOUTLINE_ONLY_OPTION: Constants.NAME + ".setFindSuboutlineOnlyOption",
    TOGGLE_FIND_IGNORE_CASE_OPTION: Constants.NAME + ".toggleFindIgnoreCaseOption",
    TOGGLE_FIND_MARK_CHANGES_OPTION: Constants.NAME + ".toggleFindMarkChangesOption",
    TOGGLE_FIND_MARK_FINDS_OPTION: Constants.NAME + ".toggleFindMarkFindsOption",
    TOGGLE_FIND_REGEXP_OPTION: Constants.NAME + ".toggleFindRegexpOption",
    TOGGLE_FIND_WORD_OPTION: Constants.NAME + ".toggleFindWordOption",
    TOGGLE_FIND_SEARCH_BODY_OPTION: Constants.NAME + ".toggleFindSearchBodyOption",
    TOGGLE_FIND_SEARCH_HEADLINE_OPTION: Constants.NAME + ".toggleFindSearchHeadlineOption",
};

</t>
<t tx="felix.20200718020912.2">/**
 * * Text and numeric constants used throughout leoInteg
 */
export class Constants {

    @others
}
</t>
<t tx="felix.20200718020912.3">public static PUBLISHER: string = "boltex";
public static NAME: string = "leointeg";
public static CONFIG_NAME: string = "leoIntegration";
public static CONFIG_WORKBENCH_ENABLED_PREVIEW: string = "workbench.editor.enablePreview";
public static CONFIG_REFRESH_MATCH: string = "OnNodes"; // substring to distinguish 'on-hover' icon commands

public static TREEVIEW_ID: string = Constants.CONFIG_NAME;
public static TREEVIEW_EXPLORER_ID: string = Constants.CONFIG_NAME + "Explorer";

public static DOCUMENTS_ID: string = "leoDocuments";
public static DOCUMENTS_EXPLORER_ID: string = "leoDocumentsExplorer";

public static BUTTONS_ID: string = "leoButtons";
public static BUTTONS_EXPLORER_ID: string = "leoButtonsExplorer";

public static FIND_ID: string = "leoFindPanel";
public static FIND_EXPLORER_ID: string = "leoFindPanelExplorer";

public static VERSION_STATE_KEY: string = "leoIntegVersion";

public static FILE_EXTENSION: string = "leo";
public static URI_LEO_SCHEME: string = "leo";
public static URI_FILE_SCHEME: string = "file";
public static URI_SCHEME_HEADER: string = "leo:/";
public static FILE_OPEN_FILTER_MESSAGE: string = "Leo Files";
public static UNTITLED_FILE_NAME: string = "untitled";
public static RECENT_FILES_KEY: string = "leoRecentFiles";
public static LAST_FILES_KEY: string = "leoLastFiles";

public static DEFAULT_PYTHON: string = "python3";
public static WIN32_PYTHON: string = "py";
public static OLD_SERVER_NAME: string = "/leobridgeserver.py";
public static SERVER_NAME: string = "/leoserver.py";
public static SERVER_STARTED_TOKEN: string = "LeoBridge started";
public static TCPIP_DEFAULT_PROTOCOL: string = "ws://";

public static ERROR_PACKAGE_ID: number = 0;
public static STARTING_PACKAGE_ID: number = 1;
public static STATUSBAR_DEBOUNCE_DELAY: number = 60;
public static DOCUMENTS_DEBOUNCE_DELAY: number = 80;
public static STATES_DEBOUNCE_DELAY: number = 100;

</t>
<t tx="felix.20200718020912.5">/**
 * * Strings used in the workbench interface panels (not for messages or dialogs)
 */
public static GUI = {
    ICON_LIGHT_DOCUMENT: "resources/light/document.svg",
    ICON_DARK_DOCUMENT: "resources/dark/document.svg",
    ICON_LIGHT_DOCUMENT_DIRTY: "resources/light/document-dirty.svg",
    ICON_DARK_DOCUMENT_DIRTY: "resources/dark/document-dirty.svg",
    ICON_LIGHT_BUTTON: "resources/light/button.svg",
    ICON_DARK_BUTTON: "resources/dark/button.svg",
    ICON_LIGHT_BUTTON_ADD: "resources/light/button-add.svg",
    ICON_DARK_BUTTON_ADD: "resources/dark/button-add.svg",
    ICON_LIGHT_PATH: "resources/light/box",
    ICON_DARK_PATH: "resources/dark/box",
    ICON_FILE_EXT: ".svg",
    STATUSBAR_INDICATOR: "$(keyboard) ",
    QUICK_OPEN_LEO_COMMANDS: "&gt;leo: ",
    EXPLORER_TREEVIEW_PREFIX: "LEO ",
    TREEVIEW_TITLE: "OUTLINE",
    TREEVIEW_TITLE_NOT_CONNECTED: "NOT CONNECTED",
    TREEVIEW_TITLE_CONNECTED: "CONNECTED",
    TREEVIEW_TITLE_INTEGRATION: "INTEGRATION",
    BODY_TITLE: "LEO BODY",
    LOG_PANE_TITLE: "Leo Log Window",
    TERMINAL_PANE_TITLE: "LeoBridge Server",
    THEME_STATUSBAR: "statusBar.foreground"
};

</t>
<t tx="felix.20200718020912.6">/**
 * * Basic user messages strings for messages and dialogs
 */
public static USER_MESSAGES = {
    SCRIPT_BUTTON: "Creates a button from selected node's script",
    SCRIPT_BUTTON_TOOLTIP:
        "The 'Script Button' button creates a new button.\n" +
        "Its name will be the headline of the presently selected node\n" +
        "Hitting this newly created button executes the button's script.\n" +
        "\n" +
        "For example, to run a script on any part of an outline:\n" +
        "\n" +
        "1.  Select the node containing a script. (Ex.: \"g.es(p.h)\")\n" +
        "2.  Press 'Script Button'. This will create a new button.\n" +
        "3.  Select a node on which you want to run the script.\n" +
        "4.  Press the *new* button.",
    SAVE_CHANGES: "Save changes to",
    BEFORE_CLOSING: "before closing?",
    CANCEL: "Cancel",
    OPEN_WITH_LEOINTEG: "Open this Leo file with LeoInteg?",
    OPEN_RECENT_FILE: "Open Recent Leo File",
    RIGHT_CLICK_TO_OPEN: "Right-click Leo files to open with LeoInteg",
    FILE_ALREADY_OPENED: "Leo file already opened",
    CHOOSE_OPENED_FILE: "Select an opened Leo File",
    FILE_NOT_OPENED: "No files opened.",
    STATUSBAR_TOOLTIP_ON: "Leo Key Bindings are in effect", // TODO : Add description of what happens if clicked
    STATUSBAR_TOOLTIP_OFF: "Leo Key Bindings off", // TODO : Add description of what happens if clicked
    PROMPT_EDIT_HEADLINE: "Edit Headline",
    PROMPT_INSERT_NODE: "Insert Node",
    DEFAULT_HEADLINE: "New Headline",
    TITLE_GOTO_GLOBAL_LINE: "Goto global line",
    PLACEHOLDER_GOTO_GLOBAL_LINE: "#",
    PROMPT_GOTO_GLOBAL_LINE: "Line number",
    START_SERVER_ERROR: "Error - Cannot start server: ",
    CONNECT_FAILED: "Leo Bridge Connection Failed",
    CONNECT_ERROR: "Leo Bridge Connection Error: Incorrect id",
    CONNECTED: "Connected",
    ALREADY_CONNECTED: "Already connected",
    DISCONNECTED: "Disconnected",
    CLEARED_RECENT: "Cleared recent files list",
    CLOSE_ERROR: "Cannot close: No files opened.",
    YES: "Yes",
    NO: "No",
    YES_ALL: "Yes to all",
    NO_ALL: "No to all",
    MINIBUFFER_PROMPT: "Minibuffer Full Command",
    CHANGES_DETECTED: "Changes to external files were detected.",
    REFRESHED: " Nodes refreshed.", // with voluntary leading space
    IGNORED: " They were ignored.", // with voluntary leading space
    TOO_FAST: "leoInteg is busy! " // with voluntary trailing space
};

</t>
<t tx="felix.20200718020912.7">/**
 * * Choices offered when about to lose current changes to a Leo Document
 */
public static ASK_SAVE_CHANGES_BUTTONS: vscode.MessageItem[] = [
    {
        title: Constants.USER_MESSAGES.YES,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.NO,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.CANCEL,
        isCloseAffordance: true
    }
];

</t>
<t tx="felix.20200718020912.8">/**
 * * String for JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public static CONFIG_NAMES = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "checkForChangeExternalFiles",
    DEFAULT_RELOAD_IGNORE: "defaultReloadIgnore",
    LEO_TREE_BROWSE: "leoTreeBrowse",
    TREE_KEEP_FOCUS: "treeKeepFocus",
    TREE_KEEP_FOCUS_WHEN_ASIDE: "treeKeepFocusWhenAside",
    STATUSBAR_STRING: "statusBarString",
    STATUSBAR_COLOR: "statusBarColor",
    TREE_IN_EXPLORER: "treeInExplorer",
    SHOW_OPEN_ASIDE: "showOpenAside",
    SHOW_EDIT: "showEditOnNodes",
    SHOW_ARROWS: "showArrowsOnNodes",
    SHOW_ADD: "showAddOnNodes",
    SHOW_MARK: "showMarkOnNodes",
    SHOW_CLONE: "showCloneOnNodes",
    SHOW_COPY: "showCopyOnNodes",
    INVERT_NODES: "invertNodeContrast",
    LEO_EDITOR_PATH: "leoEditorPath",
    LEO_PYTHON_COMMAND: "leoPythonCommand",
    AUTO_START_SERVER: "startServerAutomatically",
    AUTO_CONNECT: "connectToServerAutomatically",
    IP_ADDRESS: "connectionAddress",
    IP_PORT: "connectionPort",
};

</t>
<t tx="felix.20200718020912.9">/**
 * * Used in 'when' clauses, set with vscode.commands.executeCommand("setContext",...)
 */
public static CONTEXT_FLAGS = {
    // Main flags for connection and opened file
    BRIDGE_READY: "leoBridgeReady", // Connected to leoBridge
    TREE_OPENED: "leoTreeOpened", // At least one Leo file opened
    TREE_TITLED: "leoTreeTitled", // Tree is a Leo file and not a new untitled document
    SERVER_STARTED: "leoServerStarted", // Auto-start or manually started
    // 'states' flags for currently opened tree view
    LEO_CHANGED: "leoChanged",
    LEO_CAN_UNDO: "leoCanUndo",
    LEO_CAN_REDO: "leoCanRedo",
    LEO_CAN_DEMOTE: "leoCanDemote",
    LEO_CAN_PROMOTE: "leoCanPromote",
    LEO_CAN_DEHOIST: "leoCanDehoist",
    // 'states' flags about current selection, for visibility and commands availability
    SELECTED_MARKED: "leoMarked", // no need for unmarked here, use !leoMarked
    SELECTED_CLONE: "leoCloned",
    SELECTED_DIRTY: "leoDirty",
    SELECTED_EMPTY: "leoEmpty",
    SELECTED_CHILD: "leoChild", // Has children
    SELECTED_ATFILE: "LeoAtFile", // Can be refreshed
    SELECTED_ROOT: "leoRoot", // ! Not given by Leo: Computed by leoInteg/vscode instead
    // Statusbar Flag 'keybindings in effect'
    LEO_SELECTED: "leoObjectSelected", // keybindings "On": Outline or body has focus
    // Context Flags for 'when' clauses, used concatenated, for each outline node
    NODE_MARKED: "leoNodeMarked",  // Selected node is marked
    NODE_UNMARKED: "leoNodeUnmarked", // Selected node is unmarked (Needed for regexp)
    NODE_ATFILE: "leoNodeAtFile", // Selected node is an @file or @clean, etc...
    NODE_CLONED: "leoNodeCloned",
    NODE_ROOT: "leoNodeRoot",
    NODE_NOT_ROOT: "leoNodeNotRoot",
    // Flags for Leo documents tree view icons and hover node command buttons
    DOCUMENT_SELECTED_TITLED: "leoDocumentSelectedTitled",
    DOCUMENT_TITLED: "leoDocumentTitled",
    DOCUMENT_SELECTED_UNTITLED: "leoDocumentSelectedUntitled",
    DOCUMENT_UNTITLED: "leoDocumentUntitled",
    // Flags that match specific LeoInteg config settings
    LEO_TREE_BROWSE: Constants.CONFIG_NAMES.LEO_TREE_BROWSE, // Force ar'jan's suggestion of Leo's tree behavior override
    TREE_IN_EXPLORER: Constants.CONFIG_NAMES.TREE_IN_EXPLORER, // Leo outline also in the explorer view
    SHOW_OPEN_ASIDE: Constants.CONFIG_NAMES.SHOW_OPEN_ASIDE,   // Show 'open aside' in context menu
    SHOW_EDIT: Constants.CONFIG_NAMES.SHOW_EDIT,              // Hover Icons on outline nodes
    SHOW_ARROWS: Constants.CONFIG_NAMES.SHOW_ARROWS,           // Hover Icons on outline nodes
    SHOW_ADD: Constants.CONFIG_NAMES.SHOW_ADD,                 // Hover Icons on outline nodes
    SHOW_MARK: Constants.CONFIG_NAMES.SHOW_MARK,               // Hover Icons on outline nodes
    SHOW_CLONE: Constants.CONFIG_NAMES.SHOW_CLONE,             // Hover Icons on outline nodes
    SHOW_COPY: Constants.CONFIG_NAMES.SHOW_COPY,               // Hover Icons on outline nodes
    AUTO_START_SERVER: Constants.CONFIG_NAMES.AUTO_START_SERVER,   // Used at startup
    AUTO_CONNECT: Constants.CONFIG_NAMES.AUTO_CONNECT              // Used at startup
};

</t>
<t tx="felix.20200718024635.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { UserCommand, LeoBridgePackage, ReqRefresh } from "./types";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718024635.2">/**
 * * Front-facing, user command stack of actions
 * This implements a user-facing command stack, (push on top, remove bottom)
 * Commands can also be added while this stack has started resolving.
 * This 'stack' concept is similar to the 'LeoBridge' class used for interacting with Leo.
 */
export class CommandStack {

    private _stack: UserCommand[] = []; // Actual commands array
    private _busy: boolean = false; // Flag stating commands started resolving

    // Refresh type, for use after the last command has done resolving (From highest so far)
    private _finalRefreshType: ReqRefresh = {}; // new empty ReqRefresh

    // Flag used to set focus on outline instead of body when done resolving (From last pushed)
    private _finalFromOutline: boolean = false;

    // Received selection from the last command that finished as JSON string representation
    // It will be re-sent as 'target node' instead of lastSelectedNode if present
    private _selectedNode: string = ""; // Empty string is used as 'falsy'

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20200718024635.3">/**
 * * Returns the command stack size
 * @returns number of actions on the command stack
 */
public size(): number {
    return this._stack.length;
}

</t>
<t tx="felix.20200718024635.4">/**
 * * Signal to the command stack that a new selected node was received.
 * Command stack needs to know when to clear its own '_receivedSelection'
 */
public newSelection(): void {
    if (!this._busy) {
        this._selectedNode = "";
    }
}

</t>
<t tx="felix.20200718024635.5">/**
 * * Adds on top and try to execute the bottom command if not already running
 * Targeted command (targeting a specific node) can only be added on an empty stack
 * @param p_command Object that has the action, targeted node (if any), refresh type and 'fromOutline' flag
 * @returns true if added, false if it could not (due to front end stack 'rules')
 */
public add(p_command: UserCommand): Promise&lt;LeoBridgePackage&gt; | undefined {
    if (p_command.node &amp;&amp; this.size()) {
        return undefined; // Can only add a command which targets a node if the stack is empty
    } else {
        const q_promise = new Promise&lt;LeoBridgePackage&gt;((p_resolve, p_reject) =&gt; {
            p_command.resolveFn = p_resolve;
            p_command.rejectFn = p_reject;
        });
        this._stack.push(p_command);
        this._finalFromOutline = p_command.fromOutline; // Set final "focus-placement"
        this._tryStart();
        return q_promise;
    }
}

</t>
<t tx="felix.20200718024635.6">/**
 * * Try to launch commands that were added on the stack, if any.
 */
private _tryStart(): void {
    if (this.size() &amp;&amp; !this._busy) {
        // Ok to start, so set the busy flag and start from the bottom
        this._busy = true; // Cleared when the last command has returned (and the stack is empty)
        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}

</t>
<t tx="felix.20200718024635.7">/**
 * * Run the command at index 0: The bottom of the stack.
 */
private _runStackCommand(): Promise&lt;LeoBridgePackage&gt; {
    // Reference from bottom of stack, but don't remove it yet!
    const w_command: UserCommand = this._stack[0];

    let w_nodeJson: string = ""; // ap json used in building w_jsonParam
    let w_jsonParam: string = ""; // Finished parameter that is sent

    // First command uses given node or last selected node.
    // Other subsequent commands on stack will use _receivedSelection regardless.
    // (Commands such as 'collapse all' just ignore node parameter)
    if (w_command.node) {
        // Was node specific, so starting a new stack of commands
        w_nodeJson = w_command.node.apJson;
    } else {
        // Use received "selected node" unless first use, then use last selected node
        if (this._selectedNode) {
            w_nodeJson = this._selectedNode;
        } else {
            w_nodeJson = this._leoIntegration.lastSelectedNode ? this._leoIntegration.lastSelectedNode.apJson : "";
        }
        if (!w_nodeJson) {
            console.log('ERROR NO ARCHIVED POSITION JSON');
        }
    }
    w_jsonParam = utils.buildNodeAndTextJson(w_nodeJson, w_command); // 'Insert Named Node' or 'Edit Headline'

    // Setup _finalRefreshType, if command requires higher than the one setup so far
    Object.assign(this._finalRefreshType, w_command.refreshType); // add all properties (expecting only 'true' properties)

    // Submit this action to Leo and return a promise of its packaged answer
    return this._leoIntegration.sendAction(w_command.action, w_jsonParam)
        .then((p_package) =&gt; {
            if (w_command.resolveFn) {
                w_command.resolveFn(p_package);
            }
            return p_package;
        },
            (p_reason) =&gt; {
                if (w_command.rejectFn) {
                    w_command.rejectFn(p_reason);
                }
                return p_reason;
            }
        );
}

</t>
<t tx="felix.20200718024635.8">/**
 * * Handle the result from the command that has finished: either launch the next one, or refresh accordingly.
 * @param p_package is the json return 'package' that was just received back from Leo
 */
private _resolveResult(p_package: LeoBridgePackage): void {
    this._stack.shift(); // Finally remove resolved command from stack bottom

    this._selectedNode = JSON.stringify(p_package.node);

    if (!this.size()) {
        // If last is done then do refresh outline and focus on outline, or body, as required
        this._busy = false;
        if (Object.keys(this._finalRefreshType).length) {
            // At least some type of refresh
            this._leoIntegration.launchRefresh(this._finalRefreshType, this._finalFromOutline, p_package.node);
        }
        // Reset refresh type and focus flag nonetheless
        this._finalRefreshType = {};
        this._finalFromOutline = false;
    } else {
        // Size &gt; 0, so call _runStackCommand again, keep _busy set to true
        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}

</t>
<t tx="felix.20200718030926.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { ConfigMembers, ConfigSetting } from "./types";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718030926.2">/**
 * * Configuration Settings Service
 */
export class Config implements ConfigMembers {

    // Config settings used in leobridgeserver.py, on Leo's side
    public checkForChangeExternalFiles: string = Constants.CONFIG_DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES;
    public defaultReloadIgnore: string = Constants.CONFIG_DEFAULTS.DEFAULT_RELOAD_IGNORE;
    // Config settings used in leoInteg/vscode's side
    public leoTreeBrowse: boolean = Constants.CONFIG_DEFAULTS.LEO_TREE_BROWSE;
    public treeKeepFocus: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS;
    public treeKeepFocusWhenAside: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE;
    public statusBarString: string = Constants.CONFIG_DEFAULTS.STATUSBAR_STRING;
    public statusBarColor: string = Constants.CONFIG_DEFAULTS.STATUSBAR_COLOR;
    public treeInExplorer: boolean = Constants.CONFIG_DEFAULTS.TREE_IN_EXPLORER;
    public showOpenAside: boolean = Constants.CONFIG_DEFAULTS.SHOW_OPEN_ASIDE;
    public showEditOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_EDIT;
    public showArrowsOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_ARROWS;
    public showAddOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_ADD;
    public showMarkOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_MARK;
    public showCloneOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_CLONE;
    public showCopyOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_COPY;
    public invertNodeContrast: boolean = Constants.CONFIG_DEFAULTS.INVERT_NODES;
    public leoPythonCommand: string = Constants.CONFIG_DEFAULTS.LEO_PYTHON_COMMAND;
    public leoEditorPath: string = Constants.CONFIG_DEFAULTS.LEO_EDITOR_PATH;
    public startServerAutomatically: boolean = Constants.CONFIG_DEFAULTS.AUTO_START_SERVER;
    public connectToServerAutomatically: boolean = Constants.CONFIG_DEFAULTS.AUTO_CONNECT;
    public connectionAddress: string = Constants.CONFIG_DEFAULTS.IP_ADDRESS;
    public connectionPort: number = Constants.CONFIG_DEFAULTS.IP_PORT;

    private _isBusySettingConfig: boolean = false;
    private _needsTreeRefresh: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20200718030926.3">/**
 * * Get actual 'live' Leointeg configuration
 * @returns An object with config settings members such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public getConfig(): ConfigMembers {
    return {
        checkForChangeExternalFiles: this.checkForChangeExternalFiles,  // Used in leoBridge script
        defaultReloadIgnore: this.defaultReloadIgnore,  // Used in leoBridge script
        leoTreeBrowse: this.leoTreeBrowse,
        treeKeepFocus: this.treeKeepFocus,
        treeKeepFocusWhenAside: this.treeKeepFocusWhenAside,
        statusBarString: this.statusBarString,
        statusBarColor: this.statusBarColor,
        treeInExplorer: this.treeInExplorer,
        showOpenAside: this.showOpenAside,
        showEditOnNodes: this.showEditOnNodes,
        showArrowsOnNodes: this.showArrowsOnNodes,
        showAddOnNodes: this.showAddOnNodes,
        showMarkOnNodes: this.showMarkOnNodes,
        showCloneOnNodes: this.showCloneOnNodes,
        showCopyOnNodes: this.showCopyOnNodes,
        invertNodeContrast: this.invertNodeContrast,
        leoPythonCommand: this.leoPythonCommand,
        leoEditorPath: this.leoEditorPath,
        startServerAutomatically: this.startServerAutomatically,
        connectToServerAutomatically: this.connectToServerAutomatically,
        connectionAddress: this.connectionAddress,
        connectionPort: this.connectionPort,
    };
}

</t>
<t tx="felix.20200718030926.4">/**
 * * Apply changes to the expansion config settings and save them in ser settings.
 * @param p_changes is an array of codes and values to be changed
 * @returns a promise that resolves upon completion
 */
public setLeoIntegSettings(p_changes: ConfigSetting[]): Promise&lt;void&gt; {
    this._isBusySettingConfig = true;
    const w_promises: Thenable&lt;void&gt;[] = [];
    const w_vscodeConfig = vscode.workspace.getConfiguration(Constants.CONFIG_NAME);
    p_changes.forEach(i_change =&gt; {
        if (i_change &amp;&amp; i_change.code.includes(Constants.CONFIG_REFRESH_MATCH)) {
            // Check if tree refresh is required for hover-icons to be displayed or hidden accordingly
            this._needsTreeRefresh = true;
        }
        if (w_vscodeConfig.inspect(i_change.code)!.defaultValue === i_change.value) {
            // Set as undefined - same as default
            w_promises.push(w_vscodeConfig.update(i_change.code, undefined, true));
        } else {
            // Set as value which is not default
            w_promises.push(w_vscodeConfig.update(i_change.code, i_change.value, true));
        }
    });
    return Promise.all(w_promises).then(() =&gt; {
        if (this._needsTreeRefresh) {
            this._needsTreeRefresh = false;
            setTimeout(() =&gt; {
                this._leoIntegration.configTreeRefresh();
            }, 200);
        }
        this._isBusySettingConfig = false;
        this.buildFromSavedSettings();
        return Promise.resolve();
    });
}

</t>
<t tx="felix.20200718030926.5">/**
 * * Build config from settings from vscode's saved config settings
 */
public buildFromSavedSettings(): void {
    // Shorthand pointers for readability
    const GET = vscode.workspace.getConfiguration;
    const NAME = Constants.CONFIG_NAME;
    const NAMES = Constants.CONFIG_NAMES;
    const DEFAULTS = Constants.CONFIG_DEFAULTS;
    const FLAGS = Constants.CONTEXT_FLAGS;

    if (this._isBusySettingConfig) {
        // * Currently setting config, wait until its done all, and this will be called automatically
        return;
    } else {
        this.checkForChangeExternalFiles = GET(NAME).get(NAMES.CHECK_FOR_CHANGE_EXTERNAL_FILES, DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES);
        this.defaultReloadIgnore = GET(NAME).get(NAMES.DEFAULT_RELOAD_IGNORE, DEFAULTS.DEFAULT_RELOAD_IGNORE);
        this.leoTreeBrowse = GET(NAME).get(NAMES.LEO_TREE_BROWSE, DEFAULTS.LEO_TREE_BROWSE);
        this.treeKeepFocus = GET(NAME).get(NAMES.TREE_KEEP_FOCUS, DEFAULTS.TREE_KEEP_FOCUS);
        this.treeKeepFocusWhenAside = GET(NAME).get(NAMES.TREE_KEEP_FOCUS_WHEN_ASIDE, DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE);
        this.statusBarString = GET(NAME).get(NAMES.STATUSBAR_STRING, DEFAULTS.STATUSBAR_STRING);
        if (this.statusBarString.length &gt; 8) {
            this.statusBarString = DEFAULTS.STATUSBAR_STRING;
        }
        this.statusBarColor = GET(NAME).get(NAMES.STATUSBAR_COLOR, DEFAULTS.STATUSBAR_COLOR);
        if (!utils.isHexColor(this.statusBarColor)) {
            this.statusBarColor = DEFAULTS.STATUSBAR_COLOR;
        }
        this.treeInExplorer = GET(NAME).get(NAMES.TREE_IN_EXPLORER, DEFAULTS.TREE_IN_EXPLORER);
        this.showOpenAside = GET(NAME).get(NAMES.SHOW_OPEN_ASIDE, DEFAULTS.SHOW_OPEN_ASIDE);
        this.showEditOnNodes = GET(NAME).get(NAMES.SHOW_EDIT, DEFAULTS.SHOW_EDIT);
        this.showArrowsOnNodes = GET(NAME).get(NAMES.SHOW_ARROWS, DEFAULTS.SHOW_ARROWS);
        this.showAddOnNodes = GET(NAME).get(NAMES.SHOW_ADD, DEFAULTS.SHOW_ADD);
        this.showMarkOnNodes = GET(NAME).get(NAMES.SHOW_MARK, DEFAULTS.SHOW_MARK);
        this.showCloneOnNodes = GET(NAME).get(NAMES.SHOW_CLONE, DEFAULTS.SHOW_CLONE);
        this.showCopyOnNodes = GET(NAME).get(NAMES.SHOW_COPY, DEFAULTS.SHOW_COPY);
        this.invertNodeContrast = GET(NAME).get(NAMES.INVERT_NODES, DEFAULTS.INVERT_NODES);
        this.leoEditorPath = GET(NAME).get(NAMES.LEO_EDITOR_PATH, DEFAULTS.LEO_EDITOR_PATH);
        this.leoPythonCommand = GET(NAME).get(NAMES.LEO_PYTHON_COMMAND, DEFAULTS.LEO_PYTHON_COMMAND);
        this.startServerAutomatically = GET(NAME).get(NAMES.AUTO_START_SERVER, DEFAULTS.AUTO_START_SERVER);
        this.connectToServerAutomatically = GET(NAME).get(NAMES.AUTO_CONNECT, DEFAULTS.AUTO_CONNECT);
        this.connectionAddress = GET(NAME).get(NAMES.IP_ADDRESS, DEFAULTS.IP_ADDRESS);
        this.connectionPort = GET(NAME).get(NAMES.IP_PORT, DEFAULTS.IP_PORT);

        // * Set context for tree items visibility that are based on config options
        if (this._leoIntegration.leoStates.leoBridgeReady) {
            this._leoIntegration.sendConfigToServer(this.getConfig());
        }
        utils.setContext(FLAGS.LEO_TREE_BROWSE, this.leoTreeBrowse);
        utils.setContext(FLAGS.TREE_IN_EXPLORER, this.treeInExplorer);
        utils.setContext(FLAGS.SHOW_OPEN_ASIDE, this.showOpenAside);
        utils.setContext(FLAGS.SHOW_EDIT, this.showEditOnNodes);
        utils.setContext(FLAGS.SHOW_ARROWS, this.showArrowsOnNodes);
        utils.setContext(FLAGS.SHOW_ADD, this.showAddOnNodes);
        utils.setContext(FLAGS.SHOW_MARK, this.showMarkOnNodes);
        utils.setContext(FLAGS.SHOW_CLONE, this.showCloneOnNodes);
        utils.setContext(FLAGS.SHOW_COPY, this.showCopyOnNodes);
        if (!this._leoIntegration.finishedStartup) {
            // Only relevant 'viewWelcome' content at startup.
            utils.setContext(FLAGS.AUTO_START_SERVER, this.startServerAutomatically); // server started
            utils.setContext(FLAGS.AUTO_CONNECT, this.connectToServerAutomatically); // server started
        }
    }
}

</t>
<t tx="felix.20200718031424.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { ReqRefresh } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { LeoSettingsProvider } from "./webviews/leoSettingsWebview";
import { LeoButtonNode } from "./leoButtonNode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718031424.2">/**
 * * Called by vscode when extension is activated
 * It creates the leoIntegration instance
 * Will also open the 'welcome/Settings' webview instance if a new version is opened
 */
export function activate(p_context: vscode.ExtensionContext) {

    // * Reset Extension context flags (used in 'when' clauses in package.json)
    utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, false); // Connected to a leobridge server?
    utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, false); // Having a Leo file opened on that server?

    const w_leoIntegExtension = vscode.extensions.getExtension(Constants.PUBLISHER + '.' + Constants.NAME)!;
    const w_leoIntegVersion = w_leoIntegExtension.packageJSON.version;
    const w_leo: LeoIntegration = new LeoIntegration(p_context);
    const w_leoSettingsWebview: LeoSettingsProvider = new LeoSettingsProvider(p_context, w_leo);
    const w_previousVersion = p_context.globalState.get&lt;string&gt;(Constants.VERSION_STATE_KEY);
    const w_start = process.hrtime(); // For calculating total startup time duration

    // Shortcut pointers for readability
    const U = undefined;
    const BRIDGE = Constants.LEOBRIDGE;
    const CMD = Constants.COMMANDS;
    const NO_REFRESH: ReqRefresh = {};
    const REFRESH_NODE_BODY: ReqRefresh = {
        node: true, // Reveal the returned 'selected position' without changes to the tree
        body: true, // Goto/select another node needs the body pane refreshed
        states: true
    };
    const REFRESH_TREE: ReqRefresh = {
        tree: true,
        states: true
    };
    const REFRESH_TREE_BODY: ReqRefresh = {
        tree: true,
        body: true,
        states: true
    };
    const showInfo = vscode.window.showInformationMessage;

    const w_commands: [string, (...args: any[]) =&gt; any][] = [

        // ! REMOVE TESTS ENTRIES FROM PACKAGE.JSON FOR MASTER BRANCH RELEASES !
        ["leointeg.test", () =&gt; w_leo.test()], // Test function useful when debugging
        // ["leointeg.testFromOutline", () =&gt; w_leo.test(true)], // Test function useful when debugging.

        &lt;&lt; Define entries for all commands &gt;&gt;
    ];

    w_commands.map(function (p_command) {
        p_context.subscriptions.push(vscode.commands.registerCommand(...p_command));
    });

    showWelcomeIfNewer(w_leoIntegVersion, w_previousVersion).then(() =&gt; {
        // Start server and/or connect to it, as per user settings
        w_leo.startNetworkServices();
        // Save version # for next startup comparison
        p_context.globalState.update(Constants.VERSION_STATE_KEY, w_leoIntegVersion);
        console.log('leoInteg startup launched in ', utils.getDurationMs(w_start), 'ms');
    });
}

</t>
<t tx="felix.20200718031424.24">/**
 * * Called when extension is deactivated
 */
export function deactivate() {
    console.log('deactivate called for extension "leointeg"');
}

</t>
<t tx="felix.20200718031424.25">/**
 * * Show welcome screen if needed, based on last version executed
 * @param p_version Current version, as a string, from packageJSON.version
 * @param p_previousVersion Previous version, as a string, from context.globalState.get service
 * @returns A promise that triggers when command to show the welcome screen is finished, or immediately if not needed
 */
async function showWelcomeIfNewer(p_version: string, p_previousVersion: string | undefined): Promise&lt;unknown&gt; {
    let w_showWelcomeScreen: boolean = false;
    if (p_previousVersion === undefined) {
        console.log('leoInteg first-time install');
        w_showWelcomeScreen = true;
    } else {
        if (p_previousVersion !== p_version) {
            vscode.window.showInformationMessage(`leoInteg upgraded from v${p_previousVersion} to v${p_version}`);
        }
        const [w_major, w_minor] = p_version.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        const [w_prevMajor, w_prevMinor] = p_previousVersion.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        if (
            (w_major === w_prevMajor &amp;&amp; w_minor === w_prevMinor) ||
            // Don't notify on downgrades
            (w_major &lt; w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &lt; w_prevMinor))
        ) {
            w_showWelcomeScreen = false;
        } else if (w_major !== w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &gt; w_prevMinor)) {
            // Will show on major or minor upgrade (Formatted as 'Major.Minor.Revision' eg. 1.2.3)
            w_showWelcomeScreen = true;
        }
    }
    if (w_showWelcomeScreen) {
        return vscode.commands.executeCommand(Constants.COMMANDS.SHOW_WELCOME);
    } else {
        return Promise.resolve();
    }
}
</t>
<t tx="felix.20200718035737.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import {
    AskMessageItem,
    runAskYesNoDialogParameters,
    runWarnMessageDialogParameters,
    runInfoMessageDialogParameters,
    showSaveAsDialogParameters
} from "./types";
import { LeoIntegration } from "./leoIntegration";

@others
</t>
<t tx="felix.20200718040540.1">import * as vscode from "vscode";
import * as utils from "./utils";
import * as path from 'path';
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { BodyTimeInfo } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718040540.10">public stat(p_uri: vscode.Uri): vscode.FileStat | Thenable&lt;vscode.FileStat&gt; {
    // TODO : Fix/Check extraneous stat(...) call(s)

    if (this._leoIntegration.leoStates.fileOpenedReady) {
        const w_gnx = utils.leoUriToStr(p_uri);
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            // console.log('called stat on root');
            return { type: vscode.FileType.Directory, ctime: 0, mtime: 0, size: 0 };

        } else if (w_gnx === this._lastGnx &amp;&amp; this._openedBodiesGnx.includes(this._lastGnx)) {

            // If same as last checked, sending back time at absolute past
            // ? VERIFY this._selectedBody.mtime we get file changed on disk error??
            // console.log('VERIFY this._selectedBody.mtime we get file changed on disk error :', p_uri);
            return {
                type: vscode.FileType.File,
                ctime: this._openedBodiesInfo[this._lastGnx].ctime,
                mtime: this._openedBodiesInfo[this._lastGnx].mtime,
                size: this._lastBodyLength
            };

        } else if (this._openedBodiesGnx.includes(w_gnx)) {

            return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BODY_LENGTH, '"' + w_gnx + '"')
                .then((p_result) =&gt; {
                    return Promise.resolve(
                        {
                            type: vscode.FileType.File,
                            ctime: this._openedBodiesInfo[w_gnx].ctime,
                            mtime: this._openedBodiesInfo[w_gnx].mtime,
                            size: p_result.len ? p_result.len : 0
                        }
                    );
                });
        }
    }
    throw vscode.FileSystemError.FileNotFound();
}

</t>
<t tx="felix.20200718040540.11">public readFile(p_uri: vscode.Uri): Thenable&lt;Uint8Array&gt; {
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            throw vscode.FileSystemError.FileIsADirectory();
        } else {
            const w_gnx = utils.leoUriToStr(p_uri);
            // if (!this._possibleGnxList.includes(w_gnx)) {
            if (!this._openedBodiesGnx.includes(w_gnx)) {
                console.error("readFile: ERROR File not in _openedBodiesGnx! readFile missing refreshes?");
                throw vscode.FileSystemError.FileNotFound();
            } else {
                return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BODY, '"' + w_gnx + '"')
                    .then((p_result) =&gt; {
                        if (p_result.body) {
                            this._lastGnx = w_gnx;
                            this._lastBodyData = p_result.body;
                            const w_buffer: Uint8Array = Buffer.from(p_result.body);
                            this._lastBodyLength = w_buffer.byteLength;
                            return Promise.resolve(w_buffer);
                        } else if (p_result.body === "") {
                            this._lastGnx = w_gnx;
                            this._lastBodyLength = 0;
                            this._lastBodyData = "";
                            return Promise.resolve(Buffer.from(""));
                        } else {
                            if (this._lastGnx === w_gnx) {
                                // was last gnx of closed file about to be switched to new document selected
                                console.log('Passed in not found: ' + w_gnx);

                                return Promise.resolve(Buffer.from(this._lastBodyData));
                            }
                            console.error("ERROR =&gt; readFile of unknown GNX"); // is possibleGnxList updated correctly?
                            return Promise.resolve(Buffer.from(""));
                            //  throw vscode.FileSystemError.FileNotFound();
                        }
                    });
            }
        }
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20200718040540.12">public readDirectory(p_uri: vscode.Uri): Thenable&lt;[string, vscode.FileType][]&gt; {
    // console.warn('Called readDirectory with ', p_uri.fsPath); // should not happen
    if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
        const w_directory: [string, vscode.FileType][] = [];
        w_directory.push([this._lastBodyTimeGnx, vscode.FileType.File]);
        return Promise.resolve(w_directory);
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20200718040540.13">public createDirectory(p_uri: vscode.Uri): void {
    console.warn('Called createDirectory with ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20200718040540.14">public writeFile(p_uri: vscode.Uri, p_content: Uint8Array, p_options: { create: boolean, overwrite: boolean }): void {

    if (!this.preventSaveToLeo) {
        this._leoIntegration.triggerBodySave(true); // Might have been a vscode 'save' via the menu
    } else {
        this.preventSaveToLeo = false;
    }

    const w_gnx = utils.leoUriToStr(p_uri);

    if (!this._openedBodiesGnx.includes(w_gnx)) {
        console.error("ASKED TO SAVE NOT EVEN IN SELECTED BODY: ", w_gnx);
        this._openedBodiesGnx.push(w_gnx);
    }

    const w_now = new Date().getTime();
    this._openedBodiesInfo[w_gnx] = {
        ctime: w_now,
        mtime: w_now
    };

    this._fireSoon({ type: vscode.FileChangeType.Changed, uri: p_uri });
}

</t>
<t tx="felix.20200718040540.15">public rename(p_oldUri: vscode.Uri, p_newUri: vscode.Uri, p_options: { overwrite: boolean }): void {
    console.warn('Called rename on ', p_oldUri.fsPath, p_newUri.fsPath); // should not happen
    this._fireSoon(
        { type: vscode.FileChangeType.Deleted, uri: p_oldUri },
        { type: vscode.FileChangeType.Created, uri: p_newUri }
    );
}

</t>
<t tx="felix.20200718040540.16">public delete(p_uri: vscode.Uri): void {
    // console.log("delete", p_uri.fsPath);
    const w_gnx = utils.leoUriToStr(p_uri);
    if (this._openedBodiesGnx.includes(w_gnx)) {
        this._openedBodiesGnx.splice(this._openedBodiesGnx.indexOf(w_gnx), 1);
        delete this._openedBodiesInfo[w_gnx];
    } else {
        // console.log("not deleted");
    }

    // dirname is just a slash "/"
    let w_dirname = p_uri.with({ path: path.posix.dirname(p_uri.path) });

    this._fireSoon(
        { type: vscode.FileChangeType.Changed, uri: w_dirname },
        { uri: p_uri, type: vscode.FileChangeType.Deleted }
    );
}

</t>
<t tx="felix.20200718040540.17">public copy(p_uri: vscode.Uri): void {
    console.warn('Called copy on ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20200718040540.18">private _fireSoon(...p_events: vscode.FileChangeEvent[]): void {
    this._bufferedEvents.push(...p_events);
    if (this._fireSoonHandle) {
        clearTimeout(this._fireSoonHandle);
    }
    this._fireSoonHandle = setTimeout(() =&gt; {
        this._onDidChangeFileEmitter.fire(this._bufferedEvents);
        this._bufferedEvents.length = 0; // clearing events array
    }, 5);
}

</t>
<t tx="felix.20200718040540.2">/**
 * * Body panes implementation as a file system using "leo" as a scheme identifier
 * Saving and renaming prevents flickering and prevents undos to 'traverse through' different gnx
 */
export class LeoBodyProvider implements vscode.FileSystemProvider {

    // * Flag normally false
    public preventSaveToLeo: boolean = false;

    // * Simple structure to keep mtime of selected and renamed body virtual files
    private _selectedBody: string = "";

    // * Last file read data with the readFile method
    private _lastGnx: string = ""; // gnx of last file read
    private _lastBodyData: string = ""; // body content of last file read
    private _lastBodyLength: number = 0; // length of last file read

    // * List of currently opened body panes gnx (from 'watch' &amp; 'dispose' methods)
    private _watchedBodiesGnx: string[] = [];

    // * List of gnx that should be available (from more.selectNode and fs.delete)
    private _openedBodiesGnx: string[] = [];
    private _openedBodiesInfo: { [key: string]: BodyTimeInfo } = {};

    // * List of all possible vNodes gnx in the currently opened leo file (since last refresh/tree operation)
    private _possibleGnxList: string[] = []; // Maybe deprecated

    private _lastBodyTimeGnx: string = "";

    // * An event to signal that a resource has been changed
    // * It should fire for resources that are being [watched](#FileSystemProvider.watch) by clients of this provider
    private _onDidChangeFileEmitter = new vscode.EventEmitter&lt;vscode.FileChangeEvent[]&gt;();
    readonly onDidChangeFile: vscode.Event&lt;vscode.FileChangeEvent[]&gt; = this._onDidChangeFileEmitter.event;
    private _bufferedEvents: vscode.FileChangeEvent[] = [];
    private _fireSoonHandle?: NodeJS.Timer;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718040540.3">/**
 * * Sets selected node body's modified time for this gnx virtual file
 * @param p_uri URI of file for which to set made-up modified time
 */
public setBodyTime(p_uri: vscode.Uri): void {

    const w_gnx = utils.leoUriToStr(p_uri);
    this._lastBodyTimeGnx = w_gnx;

    // console.log('Selected', w_gnx, ' total:', this._openedBodiesGnx.length);

    if (!this._openedBodiesGnx.includes(w_gnx)) {
        this._openedBodiesGnx.push(w_gnx);
    }
    const w_now = new Date().getTime();
    this._openedBodiesInfo[w_gnx] = {
        ctime: w_now,
        mtime: w_now
    };
}

</t>
<t tx="felix.20200718040540.5">/**
 * * Refresh the body pane for a particular gnx by telling vscode that the file from the Leo file provider has changed
 * @param p_gnx Gnx of body associated with this virtual file, mostly Leo's selected node
 */
public fireRefreshFile(p_gnx: string): void {
    this._selectedBody = p_gnx;
    if (!this._openedBodiesGnx.includes(p_gnx)) {
        console.error("ASKED TO REFRESH NOT EVEN IN SELECTED BODY: ", p_gnx);
        this._openedBodiesGnx.push(p_gnx);
    }
    const w_now = new Date().getTime();
    this._openedBodiesInfo[p_gnx] = {
        ctime: w_now,
        mtime: w_now
    };
    this._onDidChangeFileEmitter.fire([{
        type: vscode.FileChangeType.Changed,
        uri: utils.strToLeoUri(p_gnx)
    } as vscode.FileChangeEvent]);
}

</t>
<t tx="felix.20200718040540.6">/**
 * Maybe deprecated
 * * Refreshes the '_possibleGnxList' list of all unique gnx from Leo
 * @returns a promise that resolves to the fresh gnx string array
 */
public refreshPossibleGnxList(): Thenable&lt;string[]&gt; {
    // * Get updated list of possible gnx
    return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_ALL_GNX).then((p_result) =&gt; {
        this._possibleGnxList = p_result.gnx || [];
        return Promise.resolve(this._possibleGnxList);
    });
}

</t>
<t tx="felix.20200718040540.8">public watch(p_resource: vscode.Uri): vscode.Disposable {
    const w_gnx = utils.leoUriToStr(p_resource);

    if (!this._watchedBodiesGnx.includes(w_gnx)) {
        // console.log('MORE fs watch put in _openedBodiesGnx:', p_resource.fsPath);
        this._watchedBodiesGnx.push(w_gnx); // add gnx
    } else {
        // console.warn('MORE fs watch: already in _openedBodiesGnx:', p_resource.fsPath);

    }
    return new vscode.Disposable(() =&gt; {
        const w_position = this._watchedBodiesGnx.indexOf(w_gnx); // find and remove it
        if (w_position &gt; -1) {
            // console.log('MORE fs removed from _openedBodiesGnx: ', w_gnx);
            this._watchedBodiesGnx.splice(w_position, 1);
        }
    });
}

</t>
<t tx="felix.20200718153505.1">import * as vscode from "vscode";
import * as WebSocket from 'ws';
import { Constants } from "./constants";
import { LeoBridgePackage, LeoAction } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoAsync } from "./leoAsync";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718153505.11">/**
 * * Process data that came from the Leo process
 * @param p_data given JSON data
 */
private _processAnswer(p_data: string): void {
    const w_parsedData = this._tryParseJSON(p_data);
    if (w_parsedData &amp;&amp; w_parsedData.id) {
        this._resolveBridgeReady(w_parsedData);
        this._callAction();
    } else if (w_parsedData &amp;&amp; w_parsedData.async) {
        // * Check for async messages such as log pane entries or other
        this._asyncAction(w_parsedData);
    } else {
        // unprocessed/unknown python output
        console.error("[leoBridge] Unprocessed or unknown JSON received: ", p_data);
    }
}

</t>
<t tx="felix.20200718153505.12">/**
 * * Create a websocket connection to leoserver on
 * @param p_port facultative port number to override config port
 * @returns A promise for a LeoBridgePackage object containing only an 'id' member of 1 that will resolve when the 'leoBridge' is established
 */
public initLeoProcess(p_port?: number): Promise&lt;LeoBridgePackage&gt; {
    this._websocket = new WebSocket(
        Constants.TCPIP_DEFAULT_PROTOCOL +
        this._leoIntegration.config.connectionAddress +
        ":" +
        (p_port ? p_port : this._leoIntegration.config.connectionPort)
    );
    // * Capture the python process output
    this._websocket.onmessage = (p_event) =&gt; {
        if (p_event.data) {
            this._processAnswer(p_event.data.toString());
        }
    };
    this._websocket.onerror = (p_event: WebSocket.ErrorEvent) =&gt; {
        console.error(`Websocket error: ${p_event.message}`);
    };
    this._websocket.onclose = (p_event: WebSocket.CloseEvent) =&gt; {
        // * Disconnected from server
        console.log(`Websocket closed, code: ${p_event.code}`);
        this._rejectAction(`Websocket closed, code: ${p_event.code}`);
        // TODO : Implement a better connection error handling
        if (this._leoIntegration.leoStates.leoBridgeReady) {
            this._leoIntegration.cancelConnect(`Websocket closed, code: ${p_event.code}`);
        }
    };
    // * Start first with 'preventCall' set to true: no need to call anything for the first 'ready'
    this._readyPromise = this.action("", "", { id: Constants.STARTING_PACKAGE_ID }, true);
    return this._readyPromise; // This promise will resolve when the started python process starts
}

</t>
<t tx="felix.20200718153505.13">/**
 * * Send into the python process input
 * @param p_data JSON Message string to be sent to leobridgeserver.py
 */
private _send(p_data: string): any {
    if (this._readyPromise) {
        this._readyPromise.then(() =&gt; { // using '.then' that was surely resolved already: to be buffered in case process isn't ready.
            if (this._websocket &amp;&amp; this._websocket.OPEN) {
                this._websocket.send(p_data); // p_message should be json
            }
        });
    }
}

</t>
<t tx="felix.20200718153505.2">/**
 * * Handles communication with the leobridgeserver.py python script via websockets
 * This implements a bridge-facing action stack, (push on top, remove bottom)
 * 'actions' get sent to Leo, and resolve a promise with the result when the answer comes back.
 * This 'stack' concept is similar to the 'CommandStack' class used for vscode's user interactions.
 */
export class LeoBridge {

    private _callStack: LeoAction[] = [];
    private _actionBusy: boolean = false; // Action was started from the bottom, but has yet to resolve

    private _leoBridgeSerialId: number = 0; // TODO : Error checking (should be Constants.STARTING_PACKAGE_ID or 0 or 2...?)
    private _readyPromise: Promise&lt;LeoBridgePackage&gt; | undefined;

    private _websocket: WebSocket | null = null;
    private _leoAsync: LeoAsync;

    // TODO : #10 @boltex See if this can help with anaconda/miniconda issues
    // private _hasbin = require('hasbin');

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._leoAsync = new LeoAsync(_context, _leoIntegration);
    }

    @others
}
</t>
<t tx="felix.20200718153505.3">/**
 * * Places an action on top of a stack, to be resolved from the bottom
 * @param p_action Command string to be performed by Leo via leobridgeserver.py
 * @param p_jsonParam Optional JSON parameter for the specified action
 * @param p_deferredPayload Used to build this._readyPromise that resolves itself at startup
 * @param p_preventCall Flag for special action used to build this._readyPromise that resolves itself at startup
 * @returns a Promise that will contain the JSON package answered back by leobridgeserver.py
 */
public action(p_action: string, p_jsonParam = "null", p_deferredPayload?: LeoBridgePackage, p_preventCall?: boolean): Promise&lt;LeoBridgePackage&gt; {
    return new Promise((p_resolve, p_reject) =&gt; {
        const w_action: LeoAction = {
            parameter: this._buildActionParameter(p_action, p_jsonParam),
            deferredPayload: p_deferredPayload ? p_deferredPayload : undefined,
            resolveFn: p_resolve,
            rejectFn: p_reject
        };

        this._callStack.push(w_action);
        if (!p_preventCall) {
            this._callAction();
        }
    });
}

</t>
<t tx="felix.20200718153505.4">/**
 * * Actions invoked by Leo that can be called asynchronously at any time
 * @param w_parsedData that contains an 'async' string member,
 * that was parsed from a _websocket.onmessage package
 */
private _asyncAction(w_parsedData: any): void {
    if (w_parsedData &amp;&amp; w_parsedData.async &amp;&amp; (typeof w_parsedData.async === "string")) {
        switch (w_parsedData.async) {
            case Constants.ASYNC_ACTIONS.ASYNC_LOG: {
                this._leoAsync.log(w_parsedData.log);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_ASK: {
                this._leoAsync.showAskModalDialog(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_WARN: {
                this._leoAsync.showWarnModalMessage(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_INFO: {
                this._leoAsync.showChangesDetectedInfoMessage(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_INTERVAL: {
                console.log("interval ", w_parsedData); // 'ping' interval for debugging
                break;
            }
            default: {
                console.error("[leoIntegration] Unknown async action ", w_parsedData);
                break;
            }
        }
    } else {
        console.error("[leoIntegration] Unknown async command from leoBridge");
    }
}

</t>
<t tx="felix.20200718153505.5">/**
 * * Build JSON string for action parameter to the leoBridge
 * @param p_action Action string to be invoked as command by Leo in the leobridgeserver.py script
 * @param p_jsonParam Optional JSON string to be added as a 'param' to the action sent to Leo
 */
private _buildActionParameter(p_action: string, p_jsonParam?: string): string {
    return "{\"id\":" + (++this._leoBridgeSerialId) + // no quotes, serial id is a number, pre incremented
        ", \"action\": \"" + p_action +  // action is string so surround with quotes
        "\", \"param\":" + p_jsonParam +  // param is already json, no need for added quotes
        "}";
}

</t>
<t tx="felix.20200718153505.6">/**
 * * Resolves promises with the answers from an action that was finished
 * @param p_object Parsed data that was given as the answer by the Leo command that finished
 */
private _resolveBridgeReady(p_object: string) {
    let w_bottomAction = this._callStack.shift();
    if (w_bottomAction) {
        if (w_bottomAction.deferredPayload) {
            // Used when the action already has a return value ready but is also waiting for python's side
            w_bottomAction.resolveFn(w_bottomAction.deferredPayload); // given back 'as is'
        } else {
            w_bottomAction.resolveFn(p_object);
        }
        this._actionBusy = false;
    } else {
        console.error("[leoBridge] Error stack empty");
    }
}

</t>
<t tx="felix.20200718153505.7">/**
 * * Rejects an action from the bottom of the stack
 * @param p_reason Given rejection 'reason'
 */
private _rejectAction(p_reason: string): void {
    const w_bottomAction = this._callStack.shift();
    if (w_bottomAction) {
        w_bottomAction.rejectFn(p_reason);
    }
}

</t>
<t tx="felix.20200718153505.8">/**
 * * Sends an action from the bottom of the stack
 */
private _callAction(): void {
    if (this._callStack.length &amp;&amp; !this._actionBusy) {
        this._actionBusy = true; // launch / resolve bottom one
        const w_action = this._callStack[0];
        this._send(w_action.parameter + "\n");
    }
}

</t>
<t tx="felix.20200718153505.9">/**
 * * JSON.parse encased in a Try/Catch block
 * @param p_jsonStr The JSON string to be parsed
 * @returns The resulting object or 'false' if unsuccessful
 */
private _tryParseJSON(p_jsonStr: string): boolean | any {
    try {
        var w_object = JSON.parse(p_jsonStr);
        // JSON.parse(null) returns null, and typeof null === "object", null is falsy, so this suffices:
        if (w_object &amp;&amp; typeof w_object === "object") {
            return w_object;
        }
    }
    catch (e) {
        console.error('[leoBridge] JSON was invalid: ' + p_jsonStr);
    }
    return false;
}

</t>
<t tx="felix.20200718155251.1">/**
 * * Busy state of the leoBridge's command stack
 */
public isBusy(): boolean {
    return this._actionBusy || !!this._callStack.length;
}

</t>
<t tx="felix.20200718162303.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoButton, Icon } from "./types";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718162303.2">/**
 * * Leo @buttons tree view node item implementation, for usage in a TreeDataProvider.
 */
export class LeoButtonNode extends vscode.TreeItem {

    // Context string that is checked in package.json with 'when' clauses
    public contextValue: string;

    // is the special 'add' button used to create button from a given node's script
    private _isAdd: boolean;

    constructor(
        public button: LeoButton,
        private _leoIntegration: LeoIntegration
    ) {
        super(button.name);
        // Setup this instance (just differentiate 'script-button' for now)
        this.command = {
            command: Constants.COMMANDS.CLICK_BUTTON,
            title: '',
            arguments: [this]
        };
        this._isAdd = (this.button.index.startsWith(Constants.BUTTON_STRINGS.NULL_WIDGET) &amp;&amp;
            this.button.name === Constants.BUTTON_STRINGS.SCRIPT_BUTTON);
        this.contextValue = this._isAdd ? Constants.BUTTON_STRINGS.ADD_BUTTON : Constants.BUTTON_STRINGS.NORMAL_BUTTON;
    }

    @others
}
</t>
<t tx="felix.20200718162435.1">// @ts-ignore
public get iconPath(): Icon {
    return this._leoIntegration.buttonIcons[this._isAdd ? 1 : 0];
}

</t>
<t tx="felix.20200718162442.1">// @ts-ignore
public get id(): string {
    // Add prefix and suffix salt to index to prevent accidental duplicates
    return "p" + this.button.index + "s" + this.button.name;
}

</t>
<t tx="felix.20200718162452.1">// @ts-ignore
public get tooltip(): string {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON_TOOLTIP;
    } else {
        return this.button.name;
    }
}

</t>
<t tx="felix.20200718162459.1">// @ts-ignore
public get description(): string | boolean {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20200718164130.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoButtonNode } from "./leoButtonNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoButton } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718164130.2">/**
 * * '@buttons' shown as a list with this TreeDataProvider implementation
 */
export class LeoButtonsProvider implements vscode.TreeDataProvider&lt;LeoButtonNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoButtonNode | undefined&gt; = new vscode.EventEmitter&lt;LeoButtonNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoButtonNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718164130.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718164130.4">public getTreeItem(element: LeoButtonNode): Thenable&lt;LeoButtonNode&gt; | LeoButtonNode {
    return element;
}

</t>
<t tx="felix.20200718164130.5">public getChildren(element?: LeoButtonNode): Thenable&lt;LeoButtonNode[]&gt; {

    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

        // call action to get get list, and convert to LeoButtonNode(s) array
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BUTTONS).then(p_package =&gt; {
            if (p_package &amp;&amp; p_package) {
                const w_list: LeoButtonNode[] = [];
                const w_buttons: LeoButton[] = p_package.buttons!;
                if (w_buttons &amp;&amp; w_buttons.length) {
                    w_buttons.forEach((i_button: LeoButton) =&gt; {
                        w_list.push(new LeoButtonNode(i_button, this._leoIntegration));
                    });
                }
                return Promise.resolve(w_list);
            } else {
                return Promise.resolve([]);
            }
        });
    } else {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
}

</t>
<t tx="felix.20200718164130.6">public getParent(element: LeoButtonNode): ProviderResult&lt;LeoButtonNode&gt; | null {
    // Buttons are just a list, as such, entries are always child of root so return null
    return null;
}

</t>
<t tx="felix.20200718164509.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoDocument, Icon } from "./types";
import * as utils from "./utils";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718164509.2">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoDocumentNode extends vscode.TreeItem {

    // Context string is checked in package.json with 'when' clauses
    public contextValue: string;

    constructor(
        public documentEntry: LeoDocument,
        private _leoIntegration: LeoIntegration
    ) {
        super(documentEntry.name);
        // Setup this instance
        const w_isNamed: boolean = !!this.documentEntry.name;
        this.label = w_isNamed ? utils.getFileFromPath(this.documentEntry.name) : Constants.UNTITLED_FILE_NAME;
        this.tooltip = w_isNamed ? this.documentEntry.name : Constants.UNTITLED_FILE_NAME;
        this.command = {
            command: Constants.COMMANDS.SET_OPENED_FILE,
            title: '',
            arguments: [this.documentEntry.index]
        };
        // If this was created as a selected node, make sure it's selected as we may have opened/closed document
        if (this.documentEntry.selected) {
            this._leoIntegration.setDocumentSelection(this);
            this.contextValue = w_isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_UNTITLED;
        } else {
            this.contextValue = w_isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_UNTITLED;
        }
    }

    @others
}
</t>
<t tx="felix.20200718164635.1">// @ts-ignore
public get iconPath(): Icon {
    return this._leoIntegration.documentIcons[this.documentEntry.changed ? 1 : 0];
}

</t>
<t tx="felix.20200718164638.1">// @ts-ignore
public get id(): string {
    // Add prefix and suffix salt to numeric index to prevent accidental duplicates
    return "p" + this.documentEntry.index + "s" + this.documentEntry.name;
}

</t>
<t tx="felix.20200718165108.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoDocumentNode } from "./leoDocumentNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoDocument } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718165108.2">/**
 * * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
export class LeoDocumentsProvider implements vscode.TreeDataProvider&lt;LeoDocumentNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoDocumentNode | undefined&gt; = new vscode.EventEmitter&lt;LeoDocumentNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoDocumentNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718165108.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718165108.4">public getTreeItem(element: LeoDocumentNode): Thenable&lt;LeoDocumentNode&gt; | LeoDocumentNode {
    return element;
}

</t>
<t tx="felix.20200718165108.5">public getChildren(element?: LeoDocumentNode): Thenable&lt;LeoDocumentNode[]&gt; {

    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

        // call action to get get list, and convert to LeoDocumentNode(s) array
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_OPENED_FILES).then(p_package =&gt; {
            if (p_package &amp;&amp; p_package.files) {
                const w_list: LeoDocumentNode[] = [];
                const w_files: LeoDocument[] = p_package.files;

                let w_index: number = 0;

                if (w_files &amp;&amp; w_files.length) {
                    w_files.forEach((i_file: LeoDocument) =&gt; {
                        i_file.index = w_index;
                        w_list.push(new LeoDocumentNode(i_file, this._leoIntegration));
                        w_index++;
                    });
                }

                return Promise.resolve(w_list);
            } else {
                return Promise.resolve([]);
            }
        });
    } else {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
}

</t>
<t tx="felix.20200718165108.6">public getParent(element: LeoDocumentNode): ProviderResult&lt;LeoDocumentNode&gt; | null {
    // Leo documents are just a list, as such, entries are always child of root, so return null
    return null;
}

</t>
<t tx="felix.20200718165721.1"></t>
<t tx="felix.20200718170429.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import * as path from "path"; // TODO : Use this to have reliable support for window-vs-linux file-paths

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718170429.2">/**
 * * Handles opening of file browser when choosing which Leo file to open
 */
export class LeoFilesBrowser {

    private _fileBrowserActive: boolean = false;

    constructor(private _context: vscode.ExtensionContext) { }

    @others
}
</t>
<t tx="felix.20200718170429.3">/**
 * * Finds a folder to propose when opening the browse-for-leo-file chooser
 * @returns An Uri for path to a folder for initial opening
 */
private _getBestOpenFolderUri(): vscode.Uri {
    let w_openedFileEnvUri: vscode.Uri | boolean = false;
    let w_activeUri: vscode.Uri | undefined = undefined;

    if (vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders[0]) {
        w_activeUri = vscode.workspace.workspaceFolders[0].uri;
    }

    if (w_activeUri) {
        const w_defaultFolder = vscode.workspace.getWorkspaceFolder(w_activeUri);
        if (w_defaultFolder) {
            w_openedFileEnvUri = w_defaultFolder.uri; // Set as current opened document-path's folder
        }
    }
    if (!w_openedFileEnvUri) {
        w_openedFileEnvUri = vscode.Uri.file("~"); // TODO : set as home folder properly, this doesn't work
        // ! EXAMPLE WITH os : const homedir = require('os').homedir();
    }
    return w_openedFileEnvUri;
}

</t>
<t tx="felix.20200718170429.4">/**
 * * Open a file browser and let the user choose a Leo file or cancel the operation
 * @param p_saveAsFlag Optional flag that will ask for a 'save' path+filename
 * @returns A promise resolving to a chosen path string, or rejected with an empty string if cancelled
 */
public getLeoFileUrl(p_saveAsFlag?: boolean): Promise&lt;string&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve("");
    }
    this._fileBrowserActive = true;
    return new Promise((p_resolve, p_reject) =&gt; {
        const w_filters: { [name: string]: string[] } = {};
        w_filters[Constants.FILE_OPEN_FILTER_MESSAGE] = [Constants.FILE_EXTENSION];

        if (p_saveAsFlag) {
            // Choose file
            vscode.window.showSaveDialog({
                saveLabel: "Save Leo File",
                defaultUri: this._getBestOpenFolderUri(),
                filters: { 'Leo File': ['leo'] }
            })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // single string
                        p_resolve(p_chosenLeoFile.fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                    } else {
                        p_resolve(""); // not rejection - resolve empty string
                    }
                });
        } else {
            vscode.window
                .showOpenDialog({
                    canSelectMany: false,
                    defaultUri: this._getBestOpenFolderUri(),
                    canSelectFolders: false,
                    filters: w_filters
                })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // array instead of single string
                        p_resolve(p_chosenLeoFile[0].fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                    } else {
                        p_resolve("");
                    }
                });
        }
    });
}

</t>
<t tx="felix.20200718170712.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { ArchivedPosition, Icon } from "./types"; // ArchivedPosition included to help debug

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718170712.2">/**
 * * Implementation of tree nodes for usage in a TreeDataProvider
 */
export class LeoNode extends vscode.TreeItem {

    public contextValue: string; // * Context string is checked in package.json with 'when' clauses

    public isRoot: boolean = false; // * for hoist/dehoist context flags purposes

    constructor(
        public label: string, // Node headline
        public gnx: string,
        public collapsibleState: vscode.TreeItemCollapsibleState, // Computed in receiver/creator
        public apJson: string, // Key for leo/python side of things
        public childIndex: number, // For debugging purposes
        public cloned: boolean,
        public dirty: boolean,
        public marked: boolean,
        public atFile: boolean,
        public hasBody: boolean,
        public u: any,
        private _leoIntegration: LeoIntegration,
        private _id: string
    ) {
        super(label, collapsibleState);
        this.contextValue = this._getNodeContextValue();
        this.command = {
            command: Constants.COMMANDS.SELECT_NODE,
            title: '',
            arguments: [this]
        };
    }

    // * TO HELP DEBUG
    // get description(): string {
    //     // * some smaller grayed-out text accompanying the main label
    //     const w_ap: ArchivedPosition = JSON.parse(this.apJson);
    //     return "child:" + w_ap.childIndex + " lvl:" + w_ap.level + " gnx:" + w_ap.gnx;
    // }

    // get description(): string {
    //     // * some smaller grayed-out text accompanying the main label
    //     return "id:" + this.id;
    // }

    @others
}
</t>
<t tx="felix.20200718170712.4">/**
 * * Set this node as the root for hoist/dehoist context flags purposes
 */
public setRoot(): void {
    this.isRoot = true;
    this._leoIntegration.leoStates.leoRoot = true; // Set this special global 'selected node' flag
    this.contextValue = this._getNodeContextValue();
}

</t>
<t tx="felix.20200718170712.5">private _getNodeContextValue(): string {
    // Start it with 'leoNodeMarked' or 'leoNodeUnmarked'
    let w_contextValue = Constants.CONTEXT_FLAGS.NODE_UNMARKED;
    if (this.marked) {
        w_contextValue = Constants.CONTEXT_FLAGS.NODE_MARKED;
    }
    // then append 'leoNodeAtFile' to existing if needed
    if (this.atFile) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ATFILE;
    }
    // then append 'leoNodeCloned' to existing if needed
    if (this.cloned) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_CLONED;
    }
    // and finally, check for 'root' too
    if (this.isRoot) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ROOT;
    } else {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_NOT_ROOT;
    }
    return w_contextValue;
}

</t>
<t tx="felix.20200718171837.1">// @ts-ignore
public get description(): string {
    // * some smaller grayed-out text accompanying the main label
    if (this.u) {
        return "\u{1F4CE} (" + Object.keys(this.u).length + ")";
    } else {
        // return "id:" + this.id; // ! debug test
        // return "gnx:" + this.gnx; // ! debug test
        return ""; // Falsy will not be shown
    }
}

</t>
<t tx="felix.20200718171849.1">// @ts-ignore
public get tooltip(): string {
    if (this.u) {
        //  "\ntotal keys is :" + Object.keys(this.u).length
        return this.label + "\n" +
            JSON.stringify(this.u, undefined, 2);
    } else {
        return this.label; // * Whole headline as tooltip
    }
}

</t>
<t tx="felix.20200718171854.1">// Optional id for the tree item that has to be unique across tree.
// The id is used to preserve the selection and expansion state of the tree item.
// If not provided, an id is generated using the tree item's label.
// Note that when labels change, ids will change and that selection and expansion state cannot be kept stable anymore.
// @ts-ignore
public get id(): string { return this._id; }

</t>
<t tx="felix.20200718171904.1">// @ts-ignore
public get iconPath(): Icon {
    // From Leo's leoNodes.py computeIcon function
    // 1=has Body, 2=marked, 4=cloned, 8=dirty
    let w_dirty: boolean = this._leoIntegration.config.invertNodeContrast ? !this.dirty : this.dirty;
    let w_icon: number =
        (+w_dirty &lt;&lt; 3) |
        (+this.cloned &lt;&lt; 2) |
        (+this.marked &lt;&lt; 1) |
        +this.hasBody;
    return this._leoIntegration.nodeIcons[w_icon];
}

</t>
<t tx="felix.20200718180428.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoBridgePackage } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718180428.2">/**
 * * Leo outline implemented as a tree view with this TreeDataProvider
 */
export class LeoOutlineProvider implements vscode.TreeDataProvider&lt;LeoNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718180428.4">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    // TODO : have this return a promise that resolves when the selected node is encountered by ap_to_p
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718180428.5">public getTreeItem(element: LeoNode): Thenable&lt;LeoNode&gt; | LeoNode {
    return element;
}

</t>
<t tx="felix.20200718180428.6">public getChildren(element?: LeoNode): Thenable&lt;LeoNode[]&gt; {
    if (!this._leoIntegration.leoStates.fileOpenedReady) {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
    if (element) {
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_CHILDREN, element.apJson)
            .then((p_package: LeoBridgePackage) =&gt; {
                return this._leoIntegration.arrayToLeoNodesArray(p_package.children!);
            });
    } else {
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_CHILDREN, "null")
            .then((p_package: LeoBridgePackage) =&gt; {
                const w_nodes = this._leoIntegration.arrayToLeoNodesArray(p_package.children!);
                if (w_nodes &amp;&amp; w_nodes.length === 1) {
                    w_nodes[0].setRoot();
                }
                return w_nodes;
            });
    }
}

</t>
<t tx="felix.20200718180428.7">public getParent(element: LeoNode): ProviderResult&lt;LeoNode&gt; | null {
    // * This method should be implemented in order to access reveal API.
    // ! But it should NOT have to be called if only trying to 'select' already revealed nodes
    // ! Called when revealing single nodes

    // ! Might be called if nodes are revealed while in vscode's refresh process
    // ! Parent asked for this way will go up till root and effectively refresh whole tree.
    // console.log('ERROR! GET PARENT CALLED! on: ', element.label);

    if (this._leoIntegration.leoStates.fileOpenedReady) {
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_PARENT, element ? element.apJson : "null")
            .then((p_package: LeoBridgePackage) =&gt; {
                if (p_package.node === null) {
                    return null;
                } else {
                    return this._leoIntegration.apToLeoNode(p_package.node!);
                }
            });
    } else {
        return null; // Default gives no parent
    }
}

</t>
<t tx="felix.20200718185403.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718185403.2">/**
 * * Statusbar indicator controller service
 */
export class LeoStatusBar {

    private _leoStatusBarItem: vscode.StatusBarItem;
    private _statusbarNormalColor = new vscode.ThemeColor(Constants.GUI.THEME_STATUSBAR);  // "statusBar.foreground"
    private _updateStatusBarTimeout: NodeJS.Timeout | undefined;
    private _string: string = ""; // Use this string with indicator, using this will replace the default from config

    // * Represents having focus on a leo tree, body or document panel to enable leo keybindings
    private _statusBarFlag: boolean = false;
    set statusBarFlag(p_value: boolean) {
        this._statusBarFlag = p_value;
    }
    get statusBarFlag(): boolean {
        return this._statusBarFlag;
    }

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._leoStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
        this._leoStatusBarItem.color = this._leoIntegration.config.statusBarColor;

        this._leoStatusBarItem.command = Constants.COMMANDS.SWITCH_FILE;
        // this._leoStatusBarItem.command = "leointeg.test"; // just call test function for now to help debugging
        this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR + this._leoIntegration.config.statusBarString;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;
        _context.subscriptions.push(this._leoStatusBarItem);
        this._leoStatusBarItem.hide();
    }

    @others
}
</t>
<t tx="felix.20200718185403.3">/**
 * * Makes the statusbar indicator visible
 */
public show(): void {
    this._leoStatusBarItem.show();
}

</t>
<t tx="felix.20200718185403.4">/**
 * * Hides the statusbar indicator
 */
public hide(): void {
    this._leoStatusBarItem.hide();
}

</t>
<t tx="felix.20200718185403.5">/**
 * * Sets string to replace default from config &amp; refresh it
 */
public setString(p_string: string): void {
    this._string = p_string;
    this._updateLeoObjectIndicator();
}

</t>
<t tx="felix.20200718185403.6">/**
 * * Updates the status bar visual indicator visual indicator with optional debouncing delay
 * @param p_state True/False flag for On or Off status
 * @param p_debounceDelay Optional, in milliseconds
 */
public update(p_state: boolean, p_debounceDelay?: number, p_forced?: boolean): void {
    if (p_forced || (p_state !== this.statusBarFlag)) {
        this.statusBarFlag = p_state;
        if (p_debounceDelay) {
            this._updateLeoObjectIndicatorDebounced(p_debounceDelay);
        } else {
            this._updateLeoObjectIndicator();
        }
    }
}

</t>
<t tx="felix.20200718185403.7">/**
 * * Updates the status bar visual indicator flag in a debounced manner
 * @param p_delay number of milliseconds
 */
private _updateLeoObjectIndicatorDebounced(p_delay: number): void {
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }
    this._updateStatusBarTimeout = setTimeout(() =&gt; {
        this._updateLeoObjectIndicator();
    }, p_delay);
}

</t>
<t tx="felix.20200718185403.8">/**
 * * Updates the status bar visual indicator flag directly
 */
private _updateLeoObjectIndicator(): void {
    // Can be called directly, so clear timer if any
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }

    utils.setContext(Constants.CONTEXT_FLAGS.LEO_SELECTED, !!this.statusBarFlag);

    this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR +
        (this._string ? this._string : this._leoIntegration.config.statusBarString) + " " +
        (this._leoIntegration.leoStates.leoOpenedFileName ? utils.getFileFromPath(this._leoIntegration.leoStates.leoOpenedFileName) : Constants.UNTITLED_FILE_NAME);

    // Also check in constructor for statusBar properties (the createStatusBarItem call itself)
    if (this.statusBarFlag &amp;&amp; this._leoIntegration.leoStates.fileOpenedReady) {
        this._leoStatusBarItem.color = "#" + this._leoIntegration.config.statusBarColor;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;
    } else {
        this._leoStatusBarItem.color = this._statusbarNormalColor;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_OFF;
    }
}

</t>
<t tx="felix.20200718191946.1">import * as os from 'os';
import * as fs from 'fs';
import * as child from 'child_process';
import * as path from "path"; // TODO : Use this to have reliable support for window-vs-linux file-paths
import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from './leoIntegration';

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718191946.2">/**
 * * Leo bridge server service
 * Provides simple automatic leo bridge server startup functionality
 */
export class ServerService {
    // TODO : See #10 @boltex Problem starting the leo-bridge server automatically with anaconda/miniconda on windows
    // See https://github.com/yhirose/vscode-filtertext/blob/master/src/extension.ts#L196

    private _platform: string;
    private _isWin32: boolean;
    public usingPort: number = 0; // set to other than zero if server is started by leointeg itself

    /**
     * * Leo Bridge Server Process
     */
    private _serverProcess: child.ChildProcess | undefined;

    private _resolvePromise: ((value?: unknown) =&gt; void) | undefined;
    private _rejectPromise: ((reason?: any) =&gt; void) | undefined;

    private _isStarted: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._platform = os.platform();
        this._isWin32 = this._platform === "win32";
    }

    @others
}
</t>
<t tx="felix.20200718191946.4">/**
 * * Get command from settings or best command for the current OS
 * @param p_leoPythonCommand String command to start python on this computer
 * @returns A promise that resolves when the server is started, or that is rejected in case of problem while starting
 */
public startServer(p_leoPythonCommand: string, p_leoEditorPath: string, p_port: number): Promise&lt;any&gt; {

    /*
        * -----------------------------------------------------------------
        * Documentation for child_process.spawn(command[, args][, options])
        * -----------------------------------------------------------------

        The child_process.spawn() method spawns a new process
        using the given command, with command-line arguments in args.
        If omitted, args defaults to an empty array.

        If the shell option is enabled, do not pass unsanitized
        user input to this function. Any input containing shell
        metacharacters may be used to trigger arbitrary command execution.

        A third argument may be used to specify additional options, with these defaults:

        const defaults = {
            cwd: undefined,
            env: process.env
        };
    */

    if (!p_leoEditorPath) {
        vscode.window.showInformationMessage(
            "Specify the location of your Leo Editor installation in leointeg's settings",
            "leointeg settings").then(p_button =&gt; {
                if (p_button === 'leointeg settings') {
                    vscode.commands.executeCommand(Constants.COMMANDS.SHOW_SETTINGS);
                }
            });
        return Promise.reject("Leo Editor Path Setting Missing");
    }

    let w_pythonPath = ""; // Command of child.spawn call

    this._leoIntegration.showTerminalPane(); // Show problems when running the server, if any.

    // If a leo server path is set then use it - otherwise use old script for now
    // OLD // const w_serverScriptPath = p_leoEditorPath ? p_leoEditorPath : this._context.extensionPath + Constants.OLD_SERVER_NAME;

    return utils.findNextAvailablePort(p_port).then((p_availablePort) =&gt; {
        if (!p_availablePort) {
            // vscode.window.showInformationMessage("Port " + p_port+" already in use.");
            return Promise.reject("Port " + p_port + " already in use.");
        }

        this.usingPort = p_availablePort;

        // Leo Editor installation path is mandatory - Start with Leo Editor's folder
        let w_serverScriptPath = p_leoEditorPath + "/leo/core";

        try {
            if (fs.existsSync(w_serverScriptPath + Constants.OLD_SERVER_NAME)) {
                //old file exists
                console.log('Found old server');
                w_serverScriptPath += Constants.OLD_SERVER_NAME;
            } else if (fs.existsSync(w_serverScriptPath + Constants.SERVER_NAME)) {
                //new file exists
                console.log('found leoserver.py');
                w_serverScriptPath += Constants.SERVER_NAME;
            } else {
                return Promise.reject("Cannot find server script");
            }
        } catch (p_err) {
            console.error(p_err);
            return Promise.reject("Cannot find server script");
        }

        if (p_leoPythonCommand &amp;&amp; p_leoPythonCommand.length) {
            // Start by running command (see executeCommand for multiple useful snippets)
            w_pythonPath = p_leoPythonCommand; // Set path
        } else {
            w_pythonPath = Constants.DEFAULT_PYTHON;
            if (this._isWin32) {
                w_pythonPath = Constants.WIN32_PYTHON;
            }
        }

        const w_serverStartPromise = new Promise((p_resolve, p_reject) =&gt; {
            // * Spawn a python child process for a leoBridge server
            this._resolvePromise = p_resolve;
            this._rejectPromise = p_reject;
        });

        // * Setup arguments: Order is important!

        let w_args: string[] = []; //  "\"" + w_serverScriptPath + "\"" // For on windows ??

        // * on windows, if the default py is used, make sure it's got a '-3'
        if (this._isWin32 &amp;&amp; w_pythonPath === "py") {
            w_args.push("-3");
        }

        // * The server script itself
        w_args.push(w_serverScriptPath);

        // * Add port
        w_args.push("-p " + this.usingPort);

        this._leoIntegration.addTerminalPaneEntry(
            'Starting server with command: ' +
            w_pythonPath + " " + w_args.join(" ")
        );
        console.log('w_args', w_args);

        this._serverProcess = child.spawn(w_pythonPath, w_args);

        if (this._serverProcess &amp;&amp; this._serverProcess.stdout) {
            // * Capture the python process output
            this._serverProcess.stdout.on("data", (p_data: string) =&gt; {
                this._gotTerminalData(p_data);
            });
        } else {
            console.error("No stdout");
        }
        if (this._serverProcess &amp;&amp; this._serverProcess.stderr) {
            // * Capture other python process outputs
            this._serverProcess.stderr.on("data", (p_data: string) =&gt; {
                console.log(`stderr: ${p_data}`);
                this._isStarted = false;
                utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);
                this._serverProcess = undefined;
                if (this._rejectPromise) {
                    this._rejectPromise(`stderr: ${p_data}`);
                }
            });
        } else {
            console.error("No stderr");
        }
        if (this._serverProcess) {
            this._serverProcess!.on("close", (p_code: any) =&gt; {
                console.log(`leoBridge exited with code ${p_code}`);
                this._isStarted = false;
                utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);
                this._serverProcess = undefined;
                if (this._rejectPromise) {
                    this._rejectPromise(`leoBridge exited with code ${p_code}`);
                }
            });
        }

        return w_serverStartPromise;

    });


}

</t>
<t tx="felix.20200718192351.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { LeoPackageStates } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718192411.1">/**
 * * Global states service
 * Holds state flags used to restrict command availability and icon visibility
 * Changes UI by changing vscode's context variables
 */
export class LeoStates {

    @others
}
</t>
<t tx="felix.20200718192411.2">public setSelectedNodeFlags(p_node: LeoNode): void {
    this.leoRoot = false; // * RESET the root flag : It is set by vscode instead right after getting list of children for root of outline
    this.leoMarked = p_node.marked;
    this.leoCloned = p_node.cloned;
    this.leoDirty = p_node.dirty;
    this.leoEmpty = !p_node.hasBody;
    this.leoChild = !(p_node.collapsibleState === vscode.TreeItemCollapsibleState.None);
    this.leoAtFile = p_node.atFile;
}

</t>
<t tx="felix.20200718192411.3">public setLeoStateFlags(p_states: LeoPackageStates): void {
    this.leoChanged = p_states.changed;
    this.leoCanUndo = p_states.canUndo;
    this.leoCanRedo = p_states.canRedo;
    this.leoCanDemote = p_states.canDemote;
    this.leoCanPromote = p_states.canPromote;
    this.leoCanDehoist = p_states.canDehoist;
}
</t>
<t tx="felix.20200718193219.1">// * Connected to a Leo bridge server
private _leoBridgeReady: boolean = false;
get leoBridgeReady(): boolean {
    return this._leoBridgeReady;
}
set leoBridgeReady(p_value: boolean) {
    this._leoBridgeReady = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, p_value);
}

</t>
<t tx="felix.20200718193222.1">// * A Leo file is opened
private _fileOpenedReady: boolean = false; // Sets context flag along with treeview title
get fileOpenedReady(): boolean {
    return this._fileOpenedReady;
}
set fileOpenedReady(p_value: boolean) {
    this._fileOpenedReady = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, p_value);
    this._leoIntegration.setTreeViewTitle(
        p_value ? Constants.GUI.TREEVIEW_TITLE : Constants.GUI.TREEVIEW_TITLE_INTEGRATION
    );
}

</t>
<t tx="felix.20200718193226.1">// * Currently opened Leo file path and name, empty string if new unsaved file.
private _leoOpenedFileName: string = "";
get leoOpenedFileName(): string {
    return this._leoOpenedFileName;
}
set leoOpenedFileName(p_name: string) {
    if (p_name &amp;&amp; p_name.length) {
        this._leoOpenedFileName = p_name;
        utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, true);
    } else {
        this._leoOpenedFileName = "";
        utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, false);
    }
}

</t>
<t tx="felix.20200718193230.1">// * 'states' flags for currently opened tree view
private _leoChanged: boolean = false;
get leoChanged(): boolean {
    return this._leoChanged;
}
set leoChanged(p_value: boolean) {
    if (this._leoChanged !== p_value) {
        // Refresh Documents Panel
        this._leoIntegration.refreshDocumentsPane();
    }
    this._leoChanged = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CHANGED, p_value);
}

</t>
<t tx="felix.20200718193233.1">private _leoCanUndo: boolean = false;
get leoCanUndo(): boolean {
    return this._leoCanUndo;
}
set leoCanUndo(p_value: boolean) {
    this._leoCanUndo = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_UNDO, p_value);
}

</t>
<t tx="felix.20200718193235.1">private _leoCanRedo: boolean = false;
get leoCanRedo(): boolean {
    return this._leoCanRedo;
}
set leoCanRedo(p_value: boolean) {
    this._leoCanRedo = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_REDO, p_value);
}

</t>
<t tx="felix.20200718193238.1">private _leoCanDemote: boolean = false;
get leoCanDemote(): boolean {
    return this._leoCanDemote;
}
set leoCanDemote(p_value: boolean) {
    this._leoCanDemote = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEMOTE, p_value);
}

</t>
<t tx="felix.20200718193241.1">private _leoCanPromote: boolean = false;
get leoCanPromote(): boolean {
    return this._leoCanPromote;
}
set leoCanPromote(p_value: boolean) {
    this._leoCanPromote = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_PROMOTE, p_value);
}

</t>
<t tx="felix.20200718193244.1">private _leoCanDehoist: boolean = false;
get leoCanDehoist(): boolean {
    return this._leoCanDehoist;
}
set leoCanDehoist(p_value: boolean) {
    this._leoCanDehoist = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEHOIST, p_value);
}

</t>
<t tx="felix.20200718193338.1">// * 'states' flags about current selection, for visibility and commands availability
private _leoMarked: boolean = false;
get leoMarked(): boolean {
    return this._leoMarked;
}
set leoMarked(p_value: boolean) {
    this._leoMarked = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_value);
}

</t>
<t tx="felix.20200718193341.1">private _leoCloned: boolean = false;
get leoCloned(): boolean {
    return this._leoCloned;
}
set leoCloned(p_value: boolean) {
    this._leoCloned = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CLONE, p_value);
}

</t>
<t tx="felix.20200718193343.1">private _leoDirty: boolean = false;
get leoDirty(): boolean {
    return this._leoDirty;
}
set leoDirty(p_value: boolean) {
    this._leoDirty = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_DIRTY, p_value);
}

</t>
<t tx="felix.20200718193348.1">private _leoEmpty: boolean = false;
get leoEmpty(): boolean {
    return this._leoEmpty;
}
set leoEmpty(p_value: boolean) {
    this._leoEmpty = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_EMPTY, p_value);
}

</t>
<t tx="felix.20200718193350.1">private _leoChild: boolean = false;
get leoChild(): boolean {
    return this._leoChild;
}
set leoChild(p_value: boolean) {
    this._leoChild = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CHILD, p_value);
}

</t>
<t tx="felix.20200718193353.1">private _leoAtFile: boolean = false;
get leoAtFile(): boolean {
    return this._leoAtFile;
}
set leoAtFile(p_value: boolean) {
    this._leoAtFile = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_ATFILE, p_value);
}

</t>
<t tx="felix.20200718193403.1">// * Special is-root 'state' flag about current selection, for visibility and commands availability
private _leoRoot: boolean = false;
get leoRoot(): boolean {
    return this._leoRoot;
}
set leoRoot(p_value: boolean) {
    this._leoRoot = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_ROOT, p_value);
}

</t>
<t tx="felix.20200718193500.1">constructor(
    private _context: vscode.ExtensionContext,
    private _leoIntegration: LeoIntegration
) { }

</t>
<t tx="felix.20200718193719.1"></t>
<t tx="felix.20200718193731.1"></t>
<t tx="felix.20200718194857.1">import * as vscode from "vscode";
import { LeoNode } from "./leoNode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718194857.10">/**
 * * Main interface for JSON sent from Leo back to leoInteg
 */
export interface LeoBridgePackage {
    // * Common to all result packages
    id: number;
    // * Possible answers from a "Constants.LEOBRIDGE" command
    gnx?: string[]; // get_all_gnx
    len?: number; // get_body_length
    body?: string; // get_body
    buttons?: LeoButton[]; // get_buttons
    commands?: MinibufferCommand[]; // getCommands
    filename?: string; // set_opened_file, open_file(s), ?close_file
    files?: LeoDocument[]; // get_all_open_commanders
    focus?: string; // find_next, find_previous
    found?: boolean // find_next, find_previous
    index?: number; // get_all_open_commanders
    language?: string; // get_body_states
    node?: ArchivedPosition; // get_parent, set_opened_file, open_file(s), ?close_file
    children?: ArchivedPosition[]; // get_children
    searchSettings?: LeoGuiFindTabManagerSettings // get_search_settings
    selection?: BodySelectionInfo; // get_body_states
    states?: LeoPackageStates; // get_ui_states
    total?: number; // set_opened_file, open_file(s), close_file
}

</t>
<t tx="felix.20200718194857.11">/**
 * * Leo document structure used in the 'Opened Leo Documents' tree view provider sent back by the server
 */
export interface LeoDocument {
    name: string;
    index: number;
    changed: boolean;
    selected: boolean;
}

</t>
<t tx="felix.20200718194857.12">/**
 * * Leo '@button' structure used in the '@buttons' tree view provider sent back by the server
 */
export interface LeoButton {
    name: string;
    index: string; // STRING KEY
}

</t>
<t tx="felix.20200718194857.13">/**
 * * Icon path names used in leoNodes for rendering in treeview
 */
export interface Icon {
    light: string;
    dark: string;
}

</t>
<t tx="felix.20200718194857.14">/**
 * * LeoBody virtual file time information object
 */
export interface BodyTimeInfo {
    ctime: number;
    mtime: number;
}

</t>
<t tx="felix.20200718194857.15">/**
 * * Parameter structure used in the 'runSaveFileDialog' equivalent when asking user input
 */
export interface showSaveAsDialogParameters {
    // See TODO in leoAsync.ts
    initialFile: string;
    title: string;
    message: string;
    filetypes: string[];
    defaultExtension: string;
}

</t>
<t tx="felix.20200718194857.16">/**
 * * Parameter structure used in the 'runAskYesNoDialog' equivalent when asking user input
 */
export interface runAskYesNoDialogParameters {
    ask: string;
    message: string;
    yes_all: boolean;
    no_all: boolean;
}

</t>
<t tx="felix.20200718194857.17">/**
 * * Parameter structure used in the 'runAskOkDialog' equivalent when showing a warning
 */
export interface runWarnMessageDialogParameters {
    warn: string;
    message: string;
}

</t>
<t tx="felix.20200718194857.18">/**
 * * Parameter structure for non-blocking info message about detected file changes
 */
export interface runInfoMessageDialogParameters {
    message: string;
}

</t>
<t tx="felix.20200718194857.19">/**
 * * Used in showAskModalDialog to get answer from user interaction
 */
export interface AskMessageItem extends vscode.MessageItem {
    value: string;
}

</t>
<t tx="felix.20200718194857.2">/**
 * * Types of the various JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
export interface ConfigMembers {
    checkForChangeExternalFiles: string;
    defaultReloadIgnore: string;
    leoTreeBrowse: boolean;
    treeKeepFocus: boolean;
    treeKeepFocusWhenAside: boolean;
    statusBarString: string;
    statusBarColor: string;
    treeInExplorer: boolean;
    showOpenAside: boolean;
    showEditOnNodes: boolean;
    showArrowsOnNodes: boolean;
    showAddOnNodes: boolean;
    showMarkOnNodes: boolean;
    showCloneOnNodes: boolean;
    showCopyOnNodes: boolean;
    invertNodeContrast: boolean;
    leoEditorPath: string;
    leoPythonCommand: string;
    startServerAutomatically: boolean;
    connectToServerAutomatically: boolean;
    connectionAddress: string;
    connectionPort: number;
}

</t>
<t tx="felix.20200718194857.20">/**
 * * Used in switch Leo document to get answer from user interaction
 */
export interface ChooseDocumentItem extends vscode.QuickPickItem {
    value: number;
}

</t>
<t tx="felix.20200718194857.3">/**
 * * When refreshing the outline and getting to Leo's selected node
 */
export const enum RevealType {
    NoReveal = 0, // In apToLeoNode conversion, If if the global revealType is "NoReveal" and its the selected node, re-use the old id
    Reveal,
    RevealSelect,
    RevealSelectFocus
}

</t>
<t tx="felix.20200718194857.4">/**
 * * Required Refresh Dictionary of "elements to refresh" flags
 */
export interface ReqRefresh {
    node?: boolean; // Reveal received selected node (Navigation only, no tree change)
    tree?: boolean; // Tree needs refresh
    body?: boolean; // Body needs refresh
    scroll?: boolean; // Body needs to scroll to selection
    states?: boolean; // States needs refresh (changed, canUndo, canRedo, canDemote, canPromote, canDehoist)
    buttons?: boolean; // Buttons needs refresh
    documents?: boolean; // Documents needs refresh
}

</t>
<t tx="felix.20200718194857.5">/**
 * * Stackable front end commands
 */
export interface UserCommand {
    action: string; // String from Constants.LEOBRIDGE, which are commands for leobridgeserver
    node?: LeoNode | undefined;  // We can START a stack with a targeted command
    name?: string | undefined; // If a string is required, for headline, etc.
    refreshType: ReqRefresh; // Minimal refresh level required by this command
    fromOutline: boolean; // Focus back on outline instead of body
    keepSelection?: boolean; // Should bring back selection on node prior to command
    resolveFn?: (result: any) =&gt; void; // call that with an answer from python's (or other) side
    rejectFn?: (reason: any) =&gt; void; // call if problem is encountered
}

</t>
<t tx="felix.20200718194857.6">
/**
 * * Stackable leoBridge actions to be performed by Leo
 */
export interface LeoAction {
    parameter: string; // to pass along with action to python's side
    deferredPayload?: any | undefined; // Used when the action already has a return value ready but is also waiting for python's side
    resolveFn: (result: any) =&gt; void; // call that with an answer from python's (or other) side
    rejectFn: (reason: any) =&gt; void; // call if problem is encountered
}

</t>
<t tx="felix.20200718194857.7">/**
 * * Simple 'string log entry' package format
 */
export interface LeoLogEntry {
    log: string;
}

</t>
<t tx="felix.20200718194857.8">/**
 * * ArchivedPosition format package from Leo's leoflexx.py
 */
export interface ArchivedPosition {
    hasBody: boolean;       // bool(p.b),
    hasChildren: boolean;   // p.hasChildren()
    childIndex: number;     // p._childIndex
    cloned: boolean;        // p.isCloned()
    dirty: boolean;         // p.isDirty()
    expanded: boolean;      // p.isExpanded()
    gnx: string;            // p.v.gnx
    level: number;          // p.level()
    headline: string;       // p.h
    marked: boolean;        // p.isMarked()
    atFile: boolean         // p.isAnyAtFileNode():
    selected: boolean;      // p == commander.p
    u?: any;               // User Attributes
    stack: {
        gnx: string;        // stack_v.gnx
        childIndex: number; // stack_childIndex
        headline: string;   // stack_v.h
    }[];                    // for (stack_v, stack_childIndex) in p.stack]
}

</t>
<t tx="felix.20200718195558.1">import * as vscode from "vscode";
import * as murmur from "murmurhash-js";
import * as net from "net";
var portfinder = require('portfinder');
import { Constants } from "./constants";
import { Icon, UserCommand, ArchivedPosition } from "./types";
import { LeoNode } from "./leoNode";

// String and other types/structures helper functions, along with common vscode API calls

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718195558.10">/**
 * * Builds a 'Leo Scheme' vscode.Uri from a gnx (or strings like 'LEO BODY' or empty strings to decorate breadcrumbs)
 * with a scheme header like "leo:/" or 'more:/'
 * @param p_str leo node gnx strings are used to build Uri
 * @returns A vscode 'Uri' object
 */
export function strToLeoUri(p_str: string): vscode.Uri {
    return vscode.Uri.parse(Constants.URI_SCHEME_HEADER + p_str);
}

</t>
<t tx="felix.20200718195558.11">/**
 * * Gets the gnx, (or another string like 'LEO BODY' or other), from a vscode.Uri object
 * @param p_uri Source uri to extract from
 * @returns The string source that was used to build this Uri
 */
export function leoUriToStr(p_uri: vscode.Uri): string {
    // TODO : Use length of a constant or something other than 'fsPath'
    // For now, just remove the '/' (or backslash on Windows) before the path string
    return p_uri.fsPath.substr(1);
}

</t>
<t tx="felix.20200718195558.12">/**
 * * Sets a vscode context variable with 'vscode.commands.executeCommand' &amp; 'setContext'
 * @param p_key Key string name such as constants 'bridgeReady' or 'treeOpened', etc.
 * @param p_value Value to be assigned to the p_key 'key'
 * @returns A Thenable that is returned by the executeCommand call
 */
export function setContext(p_key: string, p_value: any): Thenable&lt;unknown&gt; {
    return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.SET_CONTEXT, p_key, p_value);
}

</t>
<t tx="felix.20200718195558.2">/**
 * * Build a string for representing a number that's 2 digits wide, padding with a zero if needed
 * @param p_number Between 0 and 99
 * @returns a 2 digit wide string representation of the number, left padded with zeros as needed.
 */
export function padNumber2(p_number: number): string {
    return ("0" + p_number).slice(-2);
}

</t>
<t tx="felix.20200718195558.3">/**
 * * Build all possible strings for node icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array of the 16 vscode node icons used in this vscode expansion
 */
export function buildNodeIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return Array(16).fill("").map((p_val, p_index) =&gt; {
        return {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT)
        };
    });
}

</t>
<t tx="felix.20200718195558.4">/**
 * * Build all possible strings for documents icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildDocumentIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_DOCUMENT),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_DOCUMENT)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_DOCUMENT_DIRTY),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_DOCUMENT_DIRTY)
        }
    ];
}

</t>
<t tx="felix.20200718195558.6">/**
 * * Builds and returns a JSON string with 'node' and 'name' members
 * @param p_nodeJson Targeted tree node in the proper JSON format
 * @param p_command from which to extract possible name and 'keep selection' flag
 * @returns JSON string suitable for being a parameter of a leoBridge action
 */
export function buildNodeAndTextJson(p_nodeJson: string, p_command: UserCommand): string {
    let w_json = "{\"ap\":" + p_nodeJson; // already json
    if (p_command.name) {
        w_json += ", \"name\": " + JSON.stringify(p_command.name);
    }
    if (p_command.keepSelection) {
        w_json += ", \"keep\": true";
    }
    // TODO : Generalize this function to send any other members of p_command / other members
    w_json += "}";
    return w_json;
}

</t>
<t tx="felix.20200718195558.7">/**
 * * Extracts the file name from a full path, such as "foo.bar" from "/abc/def/foo.bar"
 * @param p_path Full path such as "/var/drop/foo/boo/moo.js" or "C:\Documents and Settings\img\recycled log.jpg"
 * @returns file name string such as "moo.js" or "recycled log.jpg""
 */
export function getFileFromPath(p_path: string): string {
    return p_path.replace(/^.*[\\\/]/, '');
}

</t>
<t tx="felix.20200718195558.8">/**
 * * Checks if a node would become dirty if it were to now have body content at all
 * @param p_node LeoNode from vscode's outline
 * @param p_newHasBody Flag to signify presence of body content, to be compared with its current state
 * @returns True if it would change the icon with actual body content, false otherwise
 */
export function isIconChangedByEdit(p_node: LeoNode, p_newHasBody: boolean): boolean {
    if (!p_node.dirty || (p_node.hasBody === !p_newHasBody)) {
        return true;
    }
    return false;
}

</t>
<t tx="felix.20200718195558.9">/**
 * * Checks if a string is formatted as a valid rrggbb color code.
 * @param p_hexString hexadecimal 6 digits string, without leading '0x'
 * @returns True if the string is a valid representation of an hexadecimal 6 digit number
 */
export function isHexColor(p_hexString: string): boolean {
    return typeof p_hexString === 'string'
        &amp;&amp; p_hexString.length === 6
        &amp;&amp; !isNaN(Number('0x' + p_hexString));
}

</t>
<t tx="felix.20200718220811.1"></t>
<t tx="felix.20200718220818.1">@language md
@tabwidth -4
# ![LeoEditor](resources/leoapp.png) Leo for VS Code

## Literate Programming with _Directed Acyclic Graphs_ ([dag](https://en.wikipedia.org/wiki/Directed_acyclic_graph))

### Break your code down into sections structured as an outline, to derive or parse back your files

&gt; Leo is a fundamentally different way of using and organizing data, programs and scripts.\
&gt; [View Preview Video](https://www.youtube.com/watch?v=SYwlfdEukD4) 

See Leo, the Literate Editor with Outline, at [leoeditor.com](https://leoeditor.com/)
or on [github](https://github.com/leo-editor/leo-editor), and VS Code at [code.visualstudio.com](https://code.visualstudio.com/).

![Screenshot](resources/animated-screenshot.gif)

@others

---

** Enjoy!**
</t>
<t tx="felix.20200718220833.1">@language md
@tabwidth -4
# Change Log

## 0.1.15

- Modified server location logic

@others
</t>
<t tx="felix.20200718220833.2">@language md
@tabwidth -4
# How to install and run the development version

Thanks for trying out the development version of LeoInteg! :sunglasses: Contributions and pull requests are more than welcome!

@others
</t>
<t tx="felix.20200718221645.1">## Requirements

- Having [Leo's path made available in the \$PYTHONPATH environment variable](https://docs.python.org/2/using/windows.html#excursus-setting-environment-variables)\
  ([More info](https://docs.python.org/2/using/cmdline.html#environment-variables))
- Having the Websocket Python Library installed.
  _Install with :_ `pip install websockets`\
  (See [websockets.readthedocs.io/en/stable/intro.html](https://websockets.readthedocs.io/en/stable/intro.html))

</t>
<t tx="felix.20200718222026.1">## Development Version Installation

[Video tutorial of installation and startup](https://www.youtube.com/watch?v=rutt11xL54I):

[![Installation and startup video](https://img.youtube.com/vi/rutt11xL54I/0.jpg)](https://www.youtube.com/watch?v=rutt11xL54I)

In addition to the above requirements, **use Leo's 'devel' branch** (This is temporary until Leo's next release), make sure you have Node.js and Git installed, then clone the sources and run `npm install` in a terminal to install the remaining development dependencies.

![run extension](resources/run-extension.png)

You can then run the **Run Extension** target, as shown above, in the **Debug View**.

&gt; See [CONTRIBUTING.md](CONTRIBUTING.md) for complete details on how to install and run this extension.

</t>
<t tx="felix.20200718222035.1">## Features

- UI controls such as a **Leo Outline** in the explorer view, or as a standalone sidebar, **body pane**, **opened documents selector**, **find panel**, along with a **Log Window** and **Terminal** [output channels](https://code.visualstudio.com/api/extension-capabilities/common-capabilities#output-channel).
- Keybindings that match those of the Leo editor, including arrow keys behavior for outline keyboard navigation. (Can be turned off with the **'Leo Tree Browsing'** option setting)
- A **welcome screen** that also gives access to this extension's **settings**.
- **Derived files change detection**. See [External Files](#derive-external-files) below for more details
- **'@button' panel** for [creating your own commands with @buttons](https://leoeditor.com/tutorial-tips.html#use-button-nodes)
- Access **Leo commands** with context menus, outline-node hover icons, keyboard shortcuts, the command palette **`Ctrl+Shift+P`** or Leo's minibuffer **`Alt+X`**:
  - Open body panes to the side in any 'column'
  - Outline editing commands
  - Find operations
  - Clipboard operations
  - Undo/Redo commands

![Menu](resources/context-hover-menus.png)

</t>
<t tx="felix.20200718222043.1">## Keybindings

| Outline Commands           |     |            |                  |
| :------------------------- | :-- | :--------- | :--------------- |
| `Ctrl + I`                 |     |            | Insert Node      |
| `Ctrl + H`                 |     |            | Edit Headline    |
| `Ctrl + Shift + C`         |     |            | Copy Node        |
| `Ctrl + Shift + X`         |     |            | Cut Node         |
| `Ctrl + Shift + V`         |     |            | Paste Node       |
| `Ctrl + Shift + Backspace` | or  | `Delete`   | Delete Node      |
| `Ctrl + Backquote`         |     |            | Clone Node       |
| `Ctrl + {`                 | and | `Ctrl + }` | Promote / Demote |

| Moving Outline Nodes |     |                         |                    |
| :------------------- | :-- | :---------------------- | :----------------- |
| `Ctrl + U`           | or  | `Shift [+ Alt] + Up`    | Move Outline Up    |
| `Ctrl + D`           | or  | `Shift [+ Alt] + Down`  | Move Outline Down  |
| `Ctrl + L`           | or  | `Shift [+ Alt] + Left`  | Move Outline Left  |
| `Ctrl + R`           | or  | `Shift [+ Alt] + Right` | Move Outline Right |

_Move Outline commands need the 'Alt' key modifier only when focus is on body pane._

| Common Operations  |     |           |                     |
| :----------------- | :-- | :-------- | :------------------ |
| `Alt + -`          |     |           | Contract All        |
| `Ctrl + M`         |     |           | Mark / Unmark       |
| `Ctrl + B`         |     |           | Execute Script      |
| `Ctrl + T`         |     |           | Toggle Outline/Body |
| `Tab`              | or  | `Alt + D` | Focus on Body       |
| `Alt + T`          |     |           | Focus on Outline    |
| `Ctrl + Shift + D` |     |           | Extract             |
| `Ctrl + Shift + N` |     |           | Extract Names       |
| `Alt + A`          |     |           | Sort Siblings       |
| `Ctrl + F`         |     |           | Start Search        |
| `F3`               |     |           | Find Next           |
| `F2`               |     |           | Find Previous       |

| Tree Navigation    |     |                 |                          |
| :----------------- | :-- | :-------------- | :----------------------- |
| `Alt + Home`       | or  | `Home` \*       | Go To First Visible Node |
| `Alt + End`        |     |                 | Go To Last Sibling       |
|                    |     | `End` \*        | Go To Last Visible Node  |
| `Alt + N`          |     |                 | Go To Next Clone         |
| `Alt + Arrow Keys` | or  | `Arrow Keys` \* | Browse Tree              |
| `Ctrl + T`         |     |                 | Switch Tree/Body Focus   |
| `Tab`              |     |                 | Focus from Tree to Body  |
| `Alt + G`          |     |                 | Go To Global Line        |

\* _With the **'Leo Tree Browsing'** setting enabled by default, all arrows and numeric keypad keys change the outline's selection directly_

---

</t>
<t tx="felix.20200718222048.1">## Derive External Files

Use the **Save Leo File** command to derive external files.

Leo will detect derived file changes and will ask to either **refresh from disk** or **ignore the changes**.

![derive files](resources/derived-file.gif)

</t>
<t tx="felix.20200718222053.1">## Automate Synchronization

The **change detection** process can be automated to always refresh, or ignore file changes: A **notification** will inform you of the action taken instead.

![auto sync](resources/auto-sync.gif)

</t>
<t tx="felix.20200718222058.1">## Status Bar Indicator

A customizable keyboard status bar indicator is shown when this extension is activated.
It will turn orange (or your choice of text and color), when leo's **keyboard shortcuts** are active.
This occurs when an outline node or a body pane has focus:

![Statusbar](resources/statusbar-keyboard.gif)

</t>
<t tx="felix.20200718222102.1">## Extension Settings

### Open the command palette `Ctrl+Shift+P` and start typing `leo settings` to access LeoInteg's welcome/settings screen

&gt; _(Changes are auto-saved to the user's profile after 0.5 seconds)_

- Control the visibility of the outline pane in the explorer view.
- Decide how and when to refresh and synchronize content when derived (external) file are modified.
- Show additional icons on outline nodes (Move, delete, mark, copy, paste...)
- Choose to either focus on the body pane, or keep focus in the outline when a node is selected.
- Hide or show the "Open on the side" command in the context menu to open a node beside the active editor
- Set preferences for setting the address and port, and for automatically starting, and/or connecting, to a Leo Bridge server.

![Settings](resources/welcome-settings.gif)

</t>
<t tx="felix.20200718222108.1">## Issues

Main issues are listed below. See the repository's [Issues Page](https://github.com/boltex/leointeg/issues) to submit issues.

### Keybindings Conflicts Resolution

If you have a keybinding conflict that you would like to be resolved by Leo when the focus is on the body pane, add **`&amp;&amp; resourceScheme != 'leo'`** to the keybinding's "*when*" condition. (Use **`Ctrl+K Ctrl+S`** in vscode to open the Keyboards Shortcuts panel)

### Linux Keybindings

If you're experiencing trouble with the keyboard shortcuts for
the 'Clone Node' or the 'Promote' and 'Demote' commands,
use **"keyboard.dispatch": "keyCode"** in your settings and restart vscode.
See [Troubleshoot Linux Keybindings](https://github.com/microsoft/vscode/wiki/Keybinding-Issues#troubleshoot-linux-keybindings)
for more information.

### Move Outline Keyboard Commands

For some users, the **`Alt+[Arrow Keys]`**, **`Ctrl+D`** and **`Ctrl+T`** keybinding are already assigned.
To help with this conflict, tree-browsing, outline-move keyboard commands, and switch focus command will only trigger
with the additional condition of having no text selection in the editor.
So select at least one character to use the previously assigned original keyboard commands while focus is in the body pane.

&gt; This extension is still in development, so please refer to its [issue tracker](https://github.com/boltex/leointeg/issues) to learn more about its intended features, or to contribute with additional information if you encounter other issues yourself.

</t>
<t tx="felix.20200718222113.1">## How It Works

Leo integration into VS Code is done by starting a python server script and connecting to it via a [websocket](https://websockets.readthedocs.io/en/stable/intro.html) to exchange JSON data. That script leverages [leoBridge](https://leoeditor.com/leoBridge.html) and re-uses code from the leoflexx.py plugin.

The outline pane is made by implementing a [TreeDataProvider for vscode's TreeView API](https://code.visualstudio.com/api/extension-guides/tree-view#tree-view-api-basics), while the body-pane's _virtual document_ is made by [implementing a filesystem provider](https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api) and using the node's gnx as identifier.

---

</t>
<t tx="felix.20200718222118.1">## Acknowledgments

### _Thanks to_

- [Edward K. Ream](https://github.com/edreamleo) creator of the [Leo Editor](https://leoeditor.com/)
- [Eric Amodio](https://github.com/eamodio) for the [welcome screen templates](https://github.com/eamodio/vscode-gitlens/tree/master/src/webviews)
- [Vitalije](https://github.com/vitalije) for his contributions and support
- [Arjan](https://github.com/ar-jan) for his suggestions and ideas
</t>
<t tx="felix.20200718222417.1">## 0.1.12

- Added support for multiple opened files along with the 'new', 'Close', 'Save-As' commands.
- Improved the icons and commands, which are visible, or invisible depending on context.
- Added 'tree view' listing the opened Leo documents which is available in the Leo view, and the explorer view.
- Added basic leonine syntax coloring. (No specific \@languages yet)
- Added selection support to the 'Execute-Script' command.

</t>
<t tx="felix.20200718222419.1">## 0.1.11

- Fixed undo operation for the _insert_ and _rename_ commands (Some other commands may still need fixes to their 'undo' support)
- Fixed crashing when editing body pane under Leo 6.2.

</t>
<t tx="felix.20200718222422.1">## 0.1.10

- Added more [welcome content](https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content) in outlines panes that have not yet opened a tree for starting a server, connecting to it, and added content to help with automation settings.
- Changed the starting default configuration setting for starting and connecting to the leoBridge server script to false.
- Made starting and connecting to the leoBridge server script easier to access in the interface, and in the welcome/settings webview.
- Added new CONTRIBUTING.md markdown file for running the development version of the leoInteg extension.
- Closes [#44](https://github.com/boltex/leointeg/issues/44)

</t>
<t tx="felix.20200718222425.1">## 0.1.9

- Added new compilation configuration (server, extension, or both) to help debugging.
- Support async output from leoBridge, for log pane and other events.
- External file change detection with modal dialogs matching Leo's gui dialogs.
- Added config options to bypass derived files change detection dialogs with defaults, allowing automatic synchronization of derived files in both directions.
- Added support for redo, refresh from disk and many any other core Leo commands and operations.
- Added support for rapid outline edition command entry, including 'insert node' command **`Ctrl+I`** and for replacing focus on relevant elements to mimic actual Leo interface workflow.
- Added [welcome content](https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content) in outlines panes that have not yet opened a tree to help with connecting and opening
- Replaced body-editor content transfer logic and removed the related option in the expansion's settings. The body is sent to Leo when appropriate without need of a timed delay.
- _REMOVED FEATURE_ Rolled back 'multi-body' feature for simultaneous body panes from different gnx. Body panes from the same gnx are still available.

</t>
<t tx="felix.20200718222427.1">## 0.1.8

- Extension now built with webpack. [As recommended by vsCode's extension guidelines](https://code.visualstudio.com/api/working-with-extensions/bundling-extension#using-webpack)
- Added a 'Welcome Screen' webview (also compiled by webpack from html, scss and ts files) to show a greeting with basic info, and provide an easy way to change the configuration settings.
- Added commands accessible via either tree menu, context menu, and 'standard' Leo keyboard shortcuts:
  - Insert, delete
  - Cut/Copy/Paste/Clone/Paste as clone
  - Move, promote, demote node operations
  - Mark, unmark, sort children, sort siblings and undo

</t>
<t tx="felix.20200718222429.1">## 0.1.7

- Changed main mode of communication from stdin/out to tcp/ip websockets.
- Made a standalone 'Leo Server' python script.

</t>
<t tx="felix.20200718222433.1">## 0.1.6

- Major 'Browsing' update before adding outline editing and file saving &amp; derivation (Thanks for testing!)
- Refactored and simplified communication between vscode and leoBridge.
- Stabilized browsing with multiple simultaneous body panes.
- Added Leo Outline into explorer view.
- Supports new command to open a node on the side from the context menu.
- Multiple configuration options: Open Settings with CTRL+',' type 'leo', or look for 'leo integration' in extensions.

_Note: Headline and body edition does not affect the Leo file yet._

</t>
<t tx="felix.20200718222435.1">## 0.1.5

- Stabilized tree browsing, along with headline and body editing.

</t>
<t tx="felix.20200718222437.1">## 0.1.4

- Major Refactor to streamline codebase; Eliminated code duplication.
- Complete rewrite after going trying out most of what is possible with both vscode and leo APIs.
- New body pane system that prevents corrupting undos across different positions: It uses the node's actual gnx instead of a generic "body" string as a file path for the custom filesystem.

</t>
<t tx="felix.20200718222439.1">## 0.1.3

- This version creates a body panel via a custom filesystem: 'leo'. It only has a file, "leo:/body", the body of the currently selected node.

_Note: This editable body panel does not affect Leo file yet._

</t>
<t tx="felix.20200718222440.1">## 0.1.2

- Prototype Goal Achieved!
- Browsing Now shows body text too, just like browsing in Leo without editing body nor headlines. (read only for now)

</t>
<t tx="felix.20200718222442.1">## 0.1.1

- Leo File Opening.
- Basic outline browsing, along with the recognizable node icons.

</t>
<t tx="felix.20200718222445.1">## 0.0.1

- Initial basic skeleton of this extension. Press F5 to view icon and test the startup of the extension!
- Implemented [leoBridge](https://leoeditor.com/leoBridge.html) interaction.

![LeoEditor](resources/leoapp96px.png)
</t>
<t tx="felix.20200718222731.1">## Introduction

[Video tutorial of installation and startup](https://www.youtube.com/watch?v=rutt11xL54I):

[![Installation and startup video](https://img.youtube.com/vi/rutt11xL54I/0.jpg)](https://www.youtube.com/watch?v=rutt11xL54I)

If you're new to vscode and want to try out Leo with this vscode extension, you might want to look at this [Getting Started](https://code.visualstudio.com/docs#vscode-in-action) page to get an overview of vscode.

Furthermore, if you've never ran a vscode extension in an **Extension Development Host**, here is a [short overview about running and modifying a simple extension](https://code.visualstudio.com/api/get-started/your-first-extension).

If you're having problems with the procedures below, try [running this sample extension](https://github.com/Microsoft/vscode-extension-samples/tree/master/helloworld-sample#running-the-sample) first to catch underlying problems or missing dependencies.

</t>
<t tx="felix.20200718222739.1">## Development requirements

- **use Leo's 'devel' branch** (This is temporary until Leo's next release)

- Make sure you have [Node.js](https://nodejs.org/en/download/) and [Git](https://git-scm.com/downloads) installed.

- Check your node.js version by typing `node -v` in a terminal. [The latest lts version is 12.18.0](https://nodejs.org/en/download/).

- Also check your vscode version by opening the 'about' dialog from the help menu. You should at least match or exceed the version below.

On Windows:

![about](resources/vscode-about-win.png)

On Linux:

![about](resources/vscode-about.png)

</t>
<t tx="felix.20200718222741.1">## Getting the source and its development dependencies

- Clone the repository using the command line by typing : `git clone https://github.com/boltex/leointeg.git`

![clone](resources/git-clone.png)

- Although you could 'cd' into the leoInteg folder and run some commands from the same terminal, let's instead use the terminal from within vscode. So open the leoInteg folder with vscode instead, either with the context menu as shown below, or by choosing "Open Folder..." from within vscode:

![open with vscode](resources/open-with-vscode.png)

- With vscode now opened with the **leoInteg folder as its workspace**, use the `ctrl+shift+p` keyboard shortcut to open command palette and toggle the terminal. (You can find any command through the command palette)

![open terminal](resources/open-terminal.png)

- Install the development dependencies by entering the `npm install` command in the terminal. **(Important if you also just _pulled_ updated sources)**

- When the command has finished running, you should see logged results in the terminal and also that a new **node_modules** folder was created.

![dependencies](resources/node-modules.png)

- You're now ready to **compile and run** the development version of the leoInteg extension.

</t>
<t tx="felix.20200718222745.1">## Choosing a debug profile

- Bring up the **Run view**, by selecting the Run icon in the **Activity Bar**. _(Screenshot below)_

- When simply running the extension, choose the **Run Extension** profile.

![profile](resources/debug-profile.png)

&gt; (**Optional**) To contribute code to the python server script, or run it through the vscode debugger, you may need to install the [python development extension](https://marketplace.visualstudio.com/items?itemName=ms-python.python).

- For simply running and using leoInteg, just start the extension and the server as shown below.

</t>
<t tx="felix.20200718222748.1">## Starting the extension

- Use the **Start Debugging** command (or press **F5**) to start another vscode window with the expansion _installed and running_ within it.

![extension started](resources/leointeg-started.png)

- If any problems occurred during the extension compilation it will be logged in the vscode instance that started the debug process in its **task-webpack** terminal panel. Otherwise if its running, the extension itself will be logging any messages in the **debug-console** panel. (See animation below)

![extension logs](resources/debug-anim.gif)

</t>
<t tx="felix.20200718222754.1">## The python server script

- This extension needs the **`leobridgeserver.py`** script to be running. That is where the two extra extension requirements come into play:
  - Having [Leo's path made available in the \$PYTHONPATH environment variable](https://docs.python.org/2/using/windows.html#excursus-setting-environment-variables) ([More info](https://docs.python.org/2/using/cmdline.html#environment-variables))
  - Having the [Websocket Python Library installed](https://websockets.readthedocs.io/en/stable/intro.html)

### 3 ways to start the server script

1. You can have LeoInteg try to start a server script instance itself via the **Start Leo Bridge Server** command or button. It will use the 'py' command on Windows and 'python3' command on other OSes by default. _You can automate this process via leoInteg's configuration settings._
2. You can have vscode's **Debug View** start it as a debug session starts by choosing a debug profile that includes the server script. It's then possible to step in, inspect and debug the python server script. _The [python development extension](https://marketplace.visualstudio.com/items?itemName=ms-python.python) may be required._
3. You can also start it yourself manually, by running the leobridgeserver.py script from a command prompt.

### Using Anaconda or other custom python installations

- LeoInteg provides configuration options to specify how to launch python interpreter but this may not be enough to get it to start on your system, see [#10](https://github.com/boltex/leointeg/issues/10) and other issues relating to configurations in _sitecustomize.py_ file as noted in [Leo's google group forum](https://groups.google.com/d/msg/leo-editor/FAP8lVnWLyQ/lWHWEYH9AgAJ).

- If Leointeg or vscode cannot start running the server script on you system or OS, a **workaround** is to start the server script beforehand manually with whichever python interpreter you have installed.

![launch server](resources/manual-server-start.png)

- It will terminate automatically when a user disconnect.

**Note**: If force-closing the server from the integrated vscode terminal, use the 'Kill terminal' button instead of the 'X' that just hides the panel.

![kill terminal](resources/kill-terminal.png)

</t>
<t tx="felix.20200718222757.1">## Issues

More information can be found on the repository's [Issues Page](https://github.com/boltex/leointeg/issues), where details and troubleshooting can be addressed more directly.
</t>
<t tx="felix.20200719025231.1">import * as vscode from 'vscode';
import { debounce } from 'debounce';
import * as utils from './utils';
import { Constants } from './constants';
import {
    LeoBridgePackage,
    RevealType,
    ArchivedPosition,
    Icon,
    ConfigMembers,
    ReqRefresh,
    ChooseDocumentItem,
    LeoDocument,
    MinibufferCommand,
    UserCommand,
    ShowBodyParam,
    BodySelectionInfo,
    BodyPosition,
    LeoGuiFindTabManagerSettings,
    LeoSearchSettings,
} from './types';
import { Config } from './config';
import { LeoFilesBrowser } from './leoFileBrowser';
import { LeoNode } from './leoNode';
import { LeoOutlineProvider } from './leoOutline';
import { LeoBodyProvider } from './leoBody';
import { LeoBridge } from './leoBridge';
import { ServerService } from './serverManager';
import { LeoStatusBar } from './leoStatusBar';
import { CommandStack } from './commandStack';
import { LeoDocumentsProvider } from './leoDocuments';
import { LeoDocumentNode } from './leoDocumentNode';
import { LeoStates } from './leoStates';
import { LeoButtonsProvider } from './leoButtons';
import { LeoButtonNode } from './leoButtonNode';
import { LeoFindPanelProvider } from './webviews/leoFindPanelWebview';

@others
@language typescript
@tabwidth -4
</t>
<t tx="felix.20200719025231.10"></t>
<t tx="felix.20200719025231.11">/**
 * * Open Leo files found in "context.globalState.leoFiles"
 * @returns promise that resolves with editor of last opened from the list, or rejects if empty
 */
private _openLastFiles(): Promise&lt;vscode.TextEditor&gt; {
    // Loop through context.globalState.&lt;something&gt; and check if they exist: open them
    const w_lastFiles: string[] = this._context.globalState.get(Constants.LAST_FILES_KEY) || [];
    if (w_lastFiles.length) {
        return this.sendAction(
            Constants.LEOBRIDGE.OPEN_FILES,
            JSON.stringify({ files: w_lastFiles })
        ).then(
            (p_openFileResult: LeoBridgePackage) =&gt; {
                this.leoStates.leoBridgeReady = true;
                this.finishedStartup = true;
                return this._setupOpenedLeoDocument(p_openFileResult);
            },
            (p_errorOpen) =&gt; {
                this.leoStates.leoBridgeReady = true;
                this.finishedStartup = true;
                console.log('in .then not opened or already opened');
                return Promise.reject(p_errorOpen);
            }
        );
    } else {
        return Promise.reject('Recent files list is empty');
    }
}

</t>
<t tx="felix.20200719025231.12">/**
 * * Adds to the context.globalState.&lt;xxx&gt;files if not already in there (no duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when all global storage modifications are done
 */
private _addRecentAndLastFile(p_file: string): Promise&lt;void&gt; {
    if (!p_file.length) {
        return Promise.reject();
    }
    return Promise.all([
        utils.addFileToGlobal(this._context, p_file, Constants.RECENT_FILES_KEY),
        utils.addFileToGlobal(this._context, p_file, Constants.LAST_FILES_KEY),
    ]).then(() =&gt; {
        return Promise.resolve();
    });
}

</t>
<t tx="felix.20200719025231.13">/**
 * * Removes from context.globalState.leoRecentFiles if found (should not have duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when the global storage modification is done
 */
private _removeRecentFile(p_file: string): Thenable&lt;void&gt; {
    return utils.removeFileFromGlobal(this._context, p_file, Constants.RECENT_FILES_KEY);
}

</t>
<t tx="felix.20200719025231.14">/**
 * * Removes from context.globalState.leoLastFiles if found (should not have duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when the global storage modification is done
 */
private _removeLastFile(p_file: string): Thenable&lt;void&gt; {
    return utils.removeFileFromGlobal(this._context, p_file, Constants.LAST_FILES_KEY);
}

</t>
<t tx="felix.20200719025231.15">/**
 * * Shows the recent Leo files list, choosing one will open it
 * @returns A promise that resolves when the a file is finally opened, rejected otherwise
 */
public showRecentLeoFiles(): Thenable&lt;vscode.TextEditor | undefined&gt; {
    const w_recentFiles: string[] =
        this._context.globalState.get(Constants.RECENT_FILES_KEY) || [];
    let q_chooseFile: Thenable&lt;string | undefined&gt;;
    if (w_recentFiles.length) {
        q_chooseFile = vscode.window.showQuickPick(w_recentFiles, {
            placeHolder: Constants.USER_MESSAGES.OPEN_RECENT_FILE,
        });
    } else {
        // No file to list
        return Promise.resolve(undefined);
    }
    return q_chooseFile.then((p_result) =&gt; {
        if (p_result) {
            return this.openLeoFile(vscode.Uri.file(p_result));
        } else {
            // Canceled
            return Promise.resolve(undefined);
        }
    });
}

</t>
<t tx="felix.20200719025231.19">/**
 * * 'getStates' action for use in debounced method call
 */
private _triggerGetStates(): void {
    if (this._refreshType.documents) {
        this._refreshType.documents = false;
        this.refreshDocumentsPane();
    }
    if (this._refreshType.buttons) {
        this._refreshType.buttons = false;
        this._leoButtonsProvider.refreshTreeRoot();
    }
    if (this._refreshType.states) {
        this._refreshType.states = false;
        this.sendAction(Constants.LEOBRIDGE.GET_STATES).then((p_package: LeoBridgePackage) =&gt; {
            //                            **********************************
            //                             TODO : Check if still same GNX !
            //                            **********************************

            if (p_package.states) {
                this.leoStates.setLeoStateFlags(p_package.states);
            }
        });
    }
}

</t>
<t tx="felix.20200719025231.2">/**
 * * Orchestrates Leo integration into vscode
 */
export class LeoIntegration {
    // * Status Flags
    public finishedStartup: boolean = false;
    private _leoIsConnecting: boolean = false; // Used in connect method, to prevent other attempts while trying
    private _leoBridgeReadyPromise: Promise&lt;LeoBridgePackage&gt; | undefined; // Is set when leoBridge has a leo controller ready
    private _currentOutlineTitle: string = Constants.GUI.TREEVIEW_TITLE_INTEGRATION; // Might need to be re-set when switching visibility
    private _hasShownContextOpenMessage: boolean = false; // Used to show this information only once

    // * State flags
    public leoStates: LeoStates;

    // * Frontend command stack
    private _commandStack: CommandStack;

    // * Configuration Settings Service
    public config: Config; // Public configuration service singleton, used in leoSettingsWebview, leoBridge, and leoNode for inverted contrast

    // * Icon Paths
    public nodeIcons: Icon[] = []; // Singleton static array of all icon paths used in leoNodes for rendering in treeview
    public documentIcons: Icon[] = [];
    public buttonIcons: Icon[] = [];

    // * File Browser
    private _leoFilesBrowser: LeoFilesBrowser; // Browsing dialog service singleton used in the openLeoFile and save-as methods

    // * LeoBridge
    private _leoBridge: LeoBridge; // Singleton service to access leobridgeserver

    // * Outline Pane
    private _leoTreeProvider: LeoOutlineProvider; // TreeDataProvider single instance
    private _leoTreeView: vscode.TreeView&lt;LeoNode&gt;; // Outline tree view added to the Tree View Container with an Activity Bar icon
    private _leoTreeExView: vscode.TreeView&lt;LeoNode&gt;; // Outline tree view added to the Explorer Sidebar
    private _lastTreeView: vscode.TreeView&lt;LeoNode&gt;; // Last visible treeview
    private _treeId: number = 0; // Starting salt for tree node murmurhash generated Ids

    private _lastSelectedNode: LeoNode | undefined; // Last selected node we got a hold of; leoTreeView.selection maybe newer and unprocessed
    get lastSelectedNode(): LeoNode | undefined {
        return this._lastSelectedNode;
    }
    set lastSelectedNode(p_leoNode: LeoNode | undefined) {
        // Needs undefined type because it cannot be set in the constructor
        this._lastSelectedNode = p_leoNode;
        if (p_leoNode) {
            utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_leoNode.marked); // Global context to 'flag' the selected node's marked state
        }
    }

    // * Outline Pane redraw/refresh flags. Also set when calling refreshTreeRoot
    // If there's no reveal and its the selected node, the old id will be re-used for the node. (see _id property in LeoNode)
    private _revealType: RevealType = RevealType.NoReveal; // to be read/cleared in arrayToLeoNodesArray, to check if any should self-select
    private _preventShowBody = false; // Used when refreshing treeview from config: It requires not to open the body pane when refreshing.

    // * Documents Pane
    private _leoDocumentsProvider: LeoDocumentsProvider;
    private _leoDocuments: vscode.TreeView&lt;LeoDocumentNode&gt;;
    private _leoDocumentsExplorer: vscode.TreeView&lt;LeoDocumentNode&gt;;
    private _currentDocumentChanged: boolean = false; // if clean and an edit is done: refresh opened documents view

    // * Commands stack finishing resolving "refresh flags", for type of refresh after finishing stack
    private _refreshType: ReqRefresh = {}; // Flags for commands to require parts of UI to refresh
    private _fromOutline: boolean = false; // Last command issued had focus on outline, as opposed to the body
    private _focusInterrupt: boolean = false; // Flag for preventing setting focus when interrupting (canceling) an 'insert node' text input dialog with another one

    // * Body Pane
    private _bodyFileSystemStarted: boolean = false;
    private _bodyEnablePreview: boolean = true;
    private _leoFileSystem: LeoBodyProvider; // as per https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api
    private _bodyTextDocument: vscode.TextDocument | undefined; // Set when selected in tree by user, or opening a Leo file in showBody. and by _locateOpenedBody.
    private _bodyMainSelectionColumn: vscode.ViewColumn | undefined; // Column of last body 'textEditor' found, set to 1

    private _bodyPreviewMode: boolean = true;

    private _showBodyStarted: boolean = false; // Flag for when _applySelectionToBody 'show body' cycle is busy
    private _showBodyParams: ShowBodyParam | undefined; // _applySelectionToBody parameters, may be overwritten at each call if not finished

    // * Find panel
    private _findPanelWebviewView: vscode.WebviewView | undefined;
    private _findPanelWebviewExplorerView: vscode.WebviewView | undefined;
    private _lastSettingsUsed: LeoSearchSettings | undefined; // Last settings loaded / saved for current document

    // * Selection
    private _selectionDirty: boolean = false; // Flag set when cursor selection is changed
    private _selectionGnx: string = ''; // Packaged into 'BodySelectionInfo' structures, sent to Leo
    private _selection: vscode.Selection | undefined; // also packaged into 'BodySelectionInfo'
    private _scrollDirty: boolean = false; // Flag set when cursor selection is changed
    private _scrollGnx: string = '';
    private _scroll: vscode.Range | undefined;

    private _bodyUri: vscode.Uri = utils.strToLeoUri('');
    get bodyUri(): vscode.Uri {
        return this._bodyUri;
    }
    set bodyUri(p_uri: vscode.Uri) {
        this._leoFileSystem.setBodyTime(p_uri);
        this._bodyUri = p_uri;
    }

    // * '@button' pane
    private _leoButtonsProvider: LeoButtonsProvider;
    private _leoButtons: vscode.TreeView&lt;LeoButtonNode&gt;;
    private _leoButtonsExplorer: vscode.TreeView&lt;LeoButtonNode&gt;;

    // * Leo Find Panel
    private _leoFindPanelProvider: vscode.WebviewViewProvider;

    // * Log and terminal Panes
    private _leoLogPane: vscode.OutputChannel = vscode.window.createOutputChannel(
        Constants.GUI.LOG_PANE_TITLE
    );
    private _leoTerminalPane: vscode.OutputChannel | undefined;

    // * Status Bar
    private _leoStatusBar: LeoStatusBar;

    // * Edit/Insert Headline Input Box options instance, setup so clicking outside cancels the headline change
    private _headlineInputOptions: vscode.InputBoxOptions = {
        ignoreFocusOut: false,
        value: '',
        valueSelection: undefined,
        prompt: '',
    };

    // * Automatic leobridgeserver startup management service
    private _serverService: ServerService;

    // * Timing
    private _needLastSelectedRefresh = false;
    private _bodyLastChangedDocument: vscode.TextDocument | undefined; // Only set in _onDocumentChanged
    private _bodyLastChangedDocumentSaved: boolean = true; // don't use 'isDirty' of the document!

    // * Debounced method used to get states for UI display flags (commands such as undo, redo, save, ...)
    public getStates: (() =&gt; void) &amp; {
        clear(): void;
    } &amp; {
        flush(): void;
    };

    // * Debounced method used to get opened Leo Files for the documents pane
    public refreshDocumentsPane: (() =&gt; void) &amp; {
        clear(): void;
    } &amp; {
        flush(): void;
    };

    @others
}
</t>
<t tx="felix.20200719025231.20">/**
 * * Returns the 'busy' state flag of the command stack, and leoBridge stack, while showing a message if it is.
 * Needed by special unstackable commands such as new, open,...
 * @param p_all Flag to also return true if either front command stack or bridge stack is busy
 * @returns true if command stack is busy, also returns true if p_all flag is set and bridge is busy
 */
private _isBusy(p_all?: boolean): boolean {
    if (this._commandStack.size() || (p_all &amp;&amp; this._leoBridge.isBusy())) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.TOO_FAST);
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20200719025231.21">/**
 * * Returns true if the current opened Leo document's filename has some content. (not a new unnamed file)
 */
private _isCurrentFileNamed(): boolean {
    return !!this.leoStates.leoOpenedFileName.length; // checks if it's an empty string
}

</t>
<t tx="felix.20200719025231.22">/**
 * * Setup leoInteg's UI for having no opened Leo documents
 */
private _setupNoOpenedLeoDocument(): void {
    this.leoStates.fileOpenedReady = false;
    this._bodyTextDocument = undefined;
    this.lastSelectedNode = undefined;
    this._refreshOutline(false, RevealType.NoReveal);
    this.refreshDocumentsPane();
    this._leoButtonsProvider.refreshTreeRoot();
    this.closeBody();
}

</t>
<t tx="felix.20200719025231.23">/**
 * * A Leo file was opened: setup leoInteg's UI accordingly.
 * @param p_openFileResult Returned info about currently opened and editing document
 * @return a promise that resolves to an opened body pane text editor
 */
private _setupOpenedLeoDocument(
    p_openFileResult: LeoBridgePackage
): Promise&lt;vscode.TextEditor&gt; {
    const w_selectedLeoNode = this.apToLeoNode(p_openFileResult.node!, false); // Just to get gnx for the body's fist appearance
    this.leoStates.leoOpenedFileName = p_openFileResult.filename!;

    // * If not unnamed file add to recent list &amp; last opened list
    this._addRecentAndLastFile(p_openFileResult.filename!);

    // * Could be already opened, so perform 'rename hack' as if another node was selected
    if (this._bodyTextDocument &amp;&amp; this.bodyUri) {
        // TODO : BUG WHEN SWITCHING LEO DOCUMENT : NEED CROSSOVER LOGIC!
        this._switchBody(w_selectedLeoNode.gnx, false, true);
    } else {
        this.bodyUri = utils.strToLeoUri(w_selectedLeoNode.gnx);
    }

    // * Start body pane system
    if (!this._bodyFileSystemStarted) {
        this._context.subscriptions.push(
            vscode.workspace.registerFileSystemProvider(
                Constants.URI_LEO_SCHEME,
                this._leoFileSystem,
                { isCaseSensitive: true }
            )
        );
        this._bodyFileSystemStarted = true;
    }
    // * Startup flag
    this.leoStates.fileOpenedReady = true;
    // * Maybe first valid redraw of tree along with the selected node and its body
    this._refreshOutline(true, RevealType.RevealSelectFocus); // p_revealSelection flag set
    // * Maybe first StatusBar appearance
    this._leoStatusBar.update(true, 0, true);
    this._leoStatusBar.show(); // Just selected a node
    // * Show leo log pane
    this.showLogPane();
    // * Send config to python's side (for settings such as defaultReloadIgnore and checkForChangeExternalFiles)
    this.sendConfigToServer(this.config.getConfig());
    // * Refresh Opened tree views
    this.refreshDocumentsPane();
    this._leoButtonsProvider.refreshTreeRoot();
    this.loadSearchSettings();
    // * Maybe first Body appearance
    return this.showBody(false);
}

</t>
<t tx="felix.20200719025231.24">/**
 * * Handles the change of vscode config: a onDidChangeConfiguration event triggered
 * @param p_event The configuration-change event passed by vscode
 */
private _onChangeConfiguration(p_event: vscode.ConfigurationChangeEvent): void {
    if (p_event.affectsConfiguration(Constants.CONFIG_NAME)) {
        this.config.buildFromSavedSettings();
    }
    // also check if workbench.editor.enablePreview
    this._bodyEnablePreview = !!vscode.workspace
        .getConfiguration('workbench.editor')
        .get('enablePreview');
}

</t>
<t tx="felix.20200719025231.25">/**
 * * Handles the node expanding and collapsing interactions by the user in the treeview
 * @param p_event The event passed by vscode
 * @param p_expand True if it was an expand, false if it was a collapse event
 * @param p_treeView Pointer to the treeview itself, either the standalone treeview or the one under the explorer
 */
private _onChangeCollapsedState(
    p_event: vscode.TreeViewExpansionEvent&lt;LeoNode&gt;,
    p_expand: boolean,
    p_treeView: vscode.TreeView&lt;LeoNode&gt;
): void {
    // * Expanding or collapsing via the treeview interface selects the node to mimic Leo
    this.triggerBodySave(true);
    if (p_treeView.selection[0] &amp;&amp; p_treeView.selection[0] === p_event.element) {
        // * This happens if the tree selection is the same as the expanded/collapsed node: Just have Leo do the same
        // Pass
    } else {
        // * This part only happens if the user clicked on the arrow without trying to select the node
        this._revealTreeViewNode(p_event.element, { select: true, focus: false }); // No force focus : it breaks collapse/expand when direct parent
        this.selectTreeNode(p_event.element, true); // not waiting for a .then(...) so not to add any lag
    }
    this.sendAction(
        p_expand ? Constants.LEOBRIDGE.EXPAND_NODE : Constants.LEOBRIDGE.COLLAPSE_NODE,
        p_event.element.apJson
    ).then(() =&gt; {
        if (this.config.leoTreeBrowse) {
            this._refreshOutline(true, RevealType.RevealSelect);
        }
    });
}

</t>
<t tx="felix.20200719025231.26">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flag to signify that the treeview who triggered this event is the one in the explorer view
 */
private _onTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {
    if (p_event.visible) {
        this._lastTreeView = p_explorerView ? this._leoTreeExView : this._leoTreeView;
        this.setTreeViewTitle();
        this._needLastSelectedRefresh = true; // Its a new node in a new tree so refresh lastSelectedNode too
        if (this.leoStates.fileOpenedReady) {
            this.loadSearchSettings();
        }
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="felix.20200719025231.27">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onDocTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {
    if (p_explorerView) {
    } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this.refreshDocumentsPane();
    }
}

</t>
<t tx="felix.20200719025231.29">/**
 * * Handles detection of the active editor having changed from one to another, or closed
 * TODO : Make sure the selection in tree if highlighted when a body pane is selected
 * @param p_editor The editor itself that is now active
 * @param p_internalCall Flag used to signify the it was called voluntarily by leoInteg itself
 */
private _onActiveEditorChanged(
    p_editor: vscode.TextEditor | undefined,
    p_internalCall?: boolean
): void {
    if (p_editor &amp;&amp; p_editor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        if (this.bodyUri.fsPath !== p_editor.document.uri.fsPath) {
            this._hideDeleteBody(p_editor);
        }
        this._checkPreviewMode(p_editor);
    }
    if (!p_internalCall) {
        this.triggerBodySave(true); // Save in case edits were pending
    }
    // * Status flag check
    if (!p_editor &amp;&amp; this._leoStatusBar.statusBarFlag) {
        return;
    }
    // * Status flag check
    if (vscode.window.activeTextEditor) {
        this._leoStatusBar.update(
            vscode.window.activeTextEditor.document.uri.scheme === Constants.URI_LEO_SCHEME
        );
    }
}

</t>
<t tx="felix.20200719025231.3">constructor(private _context: vscode.ExtensionContext) {
    // * Setup States
    this.leoStates = new LeoStates(_context, this);

    // * Get configuration settings
    this.config = new Config(_context, this);

    // * also check workbench.editor.enablePreview
    this.config.buildFromSavedSettings();
    this._bodyEnablePreview = !!vscode.workspace
        .getConfiguration('workbench.editor')
        .get('enablePreview');

    // * Build Icon filename paths
    this.nodeIcons = utils.buildNodeIconPaths(_context);
    this.documentIcons = utils.buildDocumentIconPaths(_context);
    this.buttonIcons = utils.buildButtonsIconPaths(_context);

    // * Create file browser instance
    this._leoFilesBrowser = new LeoFilesBrowser(_context);

    // * Setup leoBridge
    this._leoBridge = new LeoBridge(_context, this);

    // * Setup frontend command stack
    this._commandStack = new CommandStack(_context, this);

    // * Create a single data provider for both outline trees, Leo view and Explorer view
    this._leoTreeProvider = new LeoOutlineProvider(this);

    // * Create Leo stand-alone view and Explorer view outline panes
    // Uses 'select node' command, so 'onDidChangeSelection' is not used
    this._leoTreeView = vscode.window.createTreeView(Constants.TREEVIEW_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoTreeProvider,
    });
    this._leoTreeView.onDidExpandElement((p_event) =&gt;
        this._onChangeCollapsedState(p_event, true, this._leoTreeView)
    );
    this._leoTreeView.onDidCollapseElement((p_event) =&gt;
        this._onChangeCollapsedState(p_event, false, this._leoTreeView)
    );
    this._leoTreeView.onDidChangeVisibility((p_event) =&gt;
        this._onTreeViewVisibilityChanged(p_event, false)
    ); // * Trigger 'show tree in Leo's view'
    this._leoTreeExView = vscode.window.createTreeView(Constants.TREEVIEW_EXPLORER_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoTreeProvider,
    });
    this._leoTreeExView.onDidExpandElement((p_event) =&gt;
        this._onChangeCollapsedState(p_event, true, this._leoTreeExView)
    );
    this._leoTreeExView.onDidCollapseElement((p_event) =&gt;
        this._onChangeCollapsedState(p_event, false, this._leoTreeExView)
    );
    this._leoTreeExView.onDidChangeVisibility((p_event) =&gt;
        this._onTreeViewVisibilityChanged(p_event, true)
    ); // * Trigger 'show tree in explorer view'
    this._lastTreeView = this.config.treeInExplorer ? this._leoTreeExView : this._leoTreeView;

    // * Create Leo Opened Documents Treeview Providers and tree views
    this._leoDocumentsProvider = new LeoDocumentsProvider(this);
    this._leoDocuments = vscode.window.createTreeView(Constants.DOCUMENTS_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoDocumentsProvider,
    });
    this._leoDocuments.onDidChangeVisibility((p_event) =&gt;
        this._onDocTreeViewVisibilityChanged(p_event, false)
    );
    this._leoDocumentsExplorer = vscode.window.createTreeView(Constants.DOCUMENTS_EXPLORER_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoDocumentsProvider,
    });
    this._leoDocumentsExplorer.onDidChangeVisibility((p_event) =&gt;
        this._onDocTreeViewVisibilityChanged(p_event, true)
    );

    // * Create '@buttons' Treeview Providers and tree views
    this._leoButtonsProvider = new LeoButtonsProvider(this);
    this._leoButtons = vscode.window.createTreeView(Constants.BUTTONS_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoButtonsProvider,
    });
    this._leoButtons.onDidChangeVisibility((p_event) =&gt;
        this._onButtonsTreeViewVisibilityChanged(p_event, false)
    );
    this._leoButtonsExplorer = vscode.window.createTreeView(Constants.BUTTONS_EXPLORER_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoButtonsProvider,
    });
    this._leoButtonsExplorer.onDidChangeVisibility((p_event) =&gt;
        this._onButtonsTreeViewVisibilityChanged(p_event, true)
    );

    // * Create Body Pane
    this._leoFileSystem = new LeoBodyProvider(this);
    this._bodyMainSelectionColumn = 1;

    // * Create Status bar Entry
    this._leoStatusBar = new LeoStatusBar(_context, this);

    // * Automatic server start service
    this._serverService = new ServerService(_context, this);

    // * Leo Find Panel
    this._leoFindPanelProvider = new LeoFindPanelProvider(
        _context.extensionUri,
        _context,
        this
    );
    this._context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(
            Constants.FIND_ID,
            this._leoFindPanelProvider,
            { webviewOptions: { retainContextWhenHidden: true } }
        )
    );
    this._context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(
            Constants.FIND_EXPLORER_ID,
            this._leoFindPanelProvider,
            { webviewOptions: { retainContextWhenHidden: true } }
        )
    );

    // * React to change in active panel/text editor (window.activeTextEditor) - also fires when the active editor becomes undefined
    vscode.window.onDidChangeActiveTextEditor((p_editor) =&gt;
        this._onActiveEditorChanged(p_editor)
    );

    // * React to change in selection, cursor position and scroll position
    vscode.window.onDidChangeTextEditorSelection((p_event) =&gt;
        this._onChangeEditorSelection(p_event)
    );
    vscode.window.onDidChangeTextEditorVisibleRanges((p_event) =&gt;
        this._onChangeEditorScroll(p_event)
    );

    // * Triggers when a different text editor/vscode window changed focus or visibility, or dragged
    // This is also what triggers after drag and drop, see '_onChangeEditorViewColumn'
    vscode.window.onDidChangeTextEditorViewColumn((p_columnChangeEvent) =&gt;
        this._changedTextEditorViewColumn(p_columnChangeEvent)
    ); // Also triggers after drag and drop
    vscode.window.onDidChangeVisibleTextEditors((p_editors) =&gt;
        this._changedVisibleTextEditors(p_editors)
    ); // Window.visibleTextEditors changed
    vscode.window.onDidChangeWindowState((p_windowState) =&gt;
        this._changedWindowState(p_windowState)
    ); // Focus state of the current window changes

    // * React when typing and changing body pane
    vscode.workspace.onDidChangeTextDocument((p_textDocumentChange) =&gt;
        this._onDocumentChanged(p_textDocumentChange)
    );

    // * React to configuration settings events
    vscode.workspace.onDidChangeConfiguration((p_configChange) =&gt;
        this._onChangeConfiguration(p_configChange)
    );

    // * React to opening of any file in vscode
    vscode.workspace.onDidOpenTextDocument((p_document) =&gt;
        this._onDidOpenTextDocument(p_document)
    );

    // * Debounced refresh flags and UI parts, other than the tree and body, when operation(s) are done executing
    this.getStates = debounce(this._triggerGetStates, Constants.STATES_DEBOUNCE_DELAY);
    this.refreshDocumentsPane = debounce(
        this._refreshDocumentsPane,
        Constants.DOCUMENTS_DEBOUNCE_DELAY
    );
}

</t>
<t tx="felix.20200719025231.31">/**
 * * Handle typing that was detected in a document
 * @param p_textDocumentChange Text changed event passed by vscode
 */
private _onDocumentChanged(p_textDocumentChange: vscode.TextDocumentChangeEvent): void {
    // ".length" check necessary, see https://github.com/microsoft/vscode/issues/50344
    if (
        this.lastSelectedNode &amp;&amp;
        p_textDocumentChange.contentChanges.length &amp;&amp;
        p_textDocumentChange.document.uri.scheme === Constants.URI_LEO_SCHEME
    ) {
        // * There was an actual change on a Leo Body by the user
        this._bodyLastChangedDocument = p_textDocumentChange.document;
        this._bodyLastChangedDocumentSaved = false;
        this._bodyPreviewMode = false;
        this._fromOutline = false; // Focus is on body pane

        // * If icon should change then do it now (if there's no document edit pending)
        if (
            !this._currentDocumentChanged ||
            utils.leoUriToStr(p_textDocumentChange.document.uri) === this.lastSelectedNode.gnx
        ) {
            const w_hasBody = !!p_textDocumentChange.document.getText().length;
            if (utils.isIconChangedByEdit(this.lastSelectedNode, w_hasBody)) {
                this._bodySaveDocument(p_textDocumentChange.document).then(() =&gt; {
                    if (this.lastSelectedNode) {
                        this.lastSelectedNode.dirty = true;
                        this.lastSelectedNode.hasBody = w_hasBody;
                        // NOT incrementing this.treeID to keep ids intact
                    }
                    // NoReveal since we're keeping the same id.
                    this._refreshOutline(false, RevealType.NoReveal);
                });
                // also refresh document panel (icon may be dirty now)
                this._refreshDocumentsPane();
            }
        }
    }
}

</t>
<t tx="felix.20200719025231.32">/**
 * * Save body to Leo if its dirty. That is, only if a change has been made to the body 'document' so far
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the possible saving process is finished
 */
public triggerBodySave(p_forcedVsCodeSave?: boolean): Promise&lt;boolean&gt; {
    // * Save body to Leo if a change has been made to the body 'document' so far
    if (
        this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty &amp;&amp;
        !this._bodyLastChangedDocumentSaved
    ) {
        const w_document = this._bodyLastChangedDocument; // backup for bodySaveDocument before reset
        if (p_forcedVsCodeSave) {
            // console.log('FORCED SAVE');
        }
        this._bodyLastChangedDocumentSaved = true;
        return this._bodySaveDocument(w_document, p_forcedVsCodeSave);
    } else {
        this._bodyLastChangedDocumentSaved = true;
        return this._bodySaveSelection();
    }
}

</t>
<t tx="felix.20200719025231.33">/**
 * * Sets new body text on leo's side, and may optionally save vsCode's body editor (which will trim spaces)
 * @param p_document Vscode's text document which content will be used to be the new node's body text in Leo
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the complete saving process is finished
 */
private _bodySaveDocument(
    p_document: vscode.TextDocument,
    p_forcedVsCodeSave?: boolean
): Promise&lt;boolean&gt; {
    if (p_document) {
        // * Fetch gnx and document's body text first, to be reused more than once in this method
        const w_param = {
            gnx: utils.leoUriToStr(p_document.uri),
            body: p_document.getText(),
        };
        this.sendAction(Constants.LEOBRIDGE.SET_BODY, JSON.stringify(w_param)); // Don't wait for promise
        // This bodySaveSelection is placed on the stack right after saving body, returns promise either way
        return this._bodySaveSelection().then(() =&gt; {
            this._refreshType.states = true;
            this.getStates();
            if (p_forcedVsCodeSave) {
                return p_document.save(); // ! USED INTENTIONALLY: This trims trailing spaces
            }
            return Promise.resolve(p_document.isDirty);
        });
    } else {
        return Promise.resolve(false);
    }
}

</t>
<t tx="felix.20200719025231.34">/**
 * * Places selection on the required node with a 'timeout'. Used after refreshing the opened Leo documents view.
 * @param p_documentNode Document node instance in the Leo document view to be the 'selected' one.
 */
public setDocumentSelection(p_documentNode: LeoDocumentNode): void {
    this._currentDocumentChanged = p_documentNode.documentEntry.changed;
    this.leoStates.leoOpenedFileName = p_documentNode.documentEntry.name;
    @others
    setTimeout(() =&gt; {
        if (!this._leoDocuments.visible &amp;&amp; !this._leoDocumentsExplorer.visible) {
            return;
        }
        let w_trigger = false;
        let w_docView: vscode.TreeView&lt;LeoDocumentNode&gt;;
        if (this._leoDocuments.visible) {
            w_docView = this._leoDocuments;
        } else {
            w_docView = this._leoDocumentsExplorer;
        }
        if (w_docView.selection.length &amp;&amp; w_docView.selection[0] === p_documentNode) {
            // console.log('already selected!');
        } else {
            w_trigger = true;
        }
        if (w_trigger) {
            w_docView.reveal(p_documentNode, { select: true, focus: false });
        }
    });
}

</t>
<t tx="felix.20200719025231.35">/**
 * * Show the outline, with Leo's selected node also selected, and optionally focussed
 * @param p_focusOutline Flag for focus to be placed in outline
 */
public showOutline(p_focusOutline?: boolean): void {
    if (this.lastSelectedNode) {
        this._lastTreeView.reveal(this.lastSelectedNode, {
            select: true,
            focus: p_focusOutline,
        });
    }
}

</t>
<t tx="felix.20200719025231.38">/**
 * * Converts an archived position object to a LeoNode instance
 * @param p_ap The archived position to convert
 * @param p_revealSelected Flag that will trigger the node to reveal, select, and focus if its selected node in Leo
 * @param p_specificNode Other specific LeoNode to be used to override when revealing the the selected node is encountered
 */
public apToLeoNode(
    p_ap: ArchivedPosition,
    p_revealSelected?: boolean,
    p_specificNode?: LeoNode
): LeoNode {
    let w_collapse: vscode.TreeItemCollapsibleState = vscode.TreeItemCollapsibleState.None;
    if (p_ap.hasChildren) {
        w_collapse = p_ap.expanded
            ? vscode.TreeItemCollapsibleState.Expanded
            : vscode.TreeItemCollapsibleState.Collapsed;
    }
    // * Unknown attributes are one-way read-only data, don't carry this in for string key for leo/python side of things
    let w_u = false;
    if (p_ap.u) {
        w_u = p_ap.u;
        delete p_ap.u;
    }
    const w_leoNode = new LeoNode(
        p_ap.headline, // label-headline
        p_ap.gnx, // gnx
        w_collapse, // collapsibleState
        JSON.stringify(p_ap), // string key for leo/python side of things
        p_ap.childIndex, // childIndex
        !!p_ap.cloned, // cloned
        !!p_ap.dirty, // dirty
        !!p_ap.marked, // marked
        !!p_ap.atFile, // atFile
        !!p_ap.hasBody, // hasBody
        w_u, // unknownAttributes
        this, // _leoIntegration pointer
        utils.hashNode(p_ap, this._treeId.toString(36))
    );
    if (p_revealSelected &amp;&amp; this._revealType &amp;&amp; p_ap.selected) {
        this._apToLeoNodeConvertReveal(p_specificNode ? p_specificNode : w_leoNode);
    }
    return w_leoNode;
}

</t>
<t tx="felix.20200719025231.39">/**
 * * Reveals the node that was detected as being the selected one while converting from archived positions
 * Also select it, or focus on it too depending on global this._revealType variable
 * @param p_leoNode The node that was detected as the selected node in Leo
 */
private _apToLeoNodeConvertReveal(p_leoNode: LeoNode): void {
    this.leoStates.setSelectedNodeFlags(p_leoNode);
    // First setup flags for selecting and focusing based on the current reveal type needed
    const w_selectFlag = this._revealType &gt;= RevealType.RevealSelect; // at least RevealSelect
    let w_focusFlag = this._revealType &gt;= RevealType.RevealSelectFocus; // at least RevealSelectFocus
    // Flags are setup so now reveal, select and / or focus as needed
    this._revealType = RevealType.NoReveal; // ok reset
    // If first time, or when treeview switched, lastSelectedNode will be undefined
    if (!this.lastSelectedNode || this._needLastSelectedRefresh) {
        this._needLastSelectedRefresh = false;
        this.lastSelectedNode = p_leoNode; // special case only: lastSelectedNode should be set in selectTreeNode
    }
    setTimeout(() =&gt; {
        // TODO : MAKE SURE TIMEOUT IS REALLY REQUIRED
        this._revealTreeViewNode(p_leoNode, { select: w_selectFlag, focus: w_focusFlag }).then(
            () =&gt; {
                // console.log('did this ask for parent?', p_leoNode.id, p_leoNode.label); // ! debug
                if (w_selectFlag) {
                    this._gotSelection(p_leoNode);
                }
            }
        );
    });
}

</t>
<t tx="felix.20200719025231.4"></t>
<t tx="felix.20200719025231.40">/**
 * * Converts an array of 'ap' to an array of leoNodes.  This is used in 'getChildren' of leoOutline.ts
 * @param p_array Array of archived positions to be converted to leoNodes for the vscode treeview
 */
public arrayToLeoNodesArray(p_array: ArchivedPosition[]): LeoNode[] {
    const w_leoNodesArray: LeoNode[] = [];
    for (let w_apData of p_array) {
        const w_leoNode = this.apToLeoNode(w_apData, true);
        w_leoNodesArray.push(w_leoNode);
    }
    return w_leoNodesArray;
}

</t>
<t tx="felix.20200719025231.47">/**
 * * Close body pane document and change the bodyUri
 * This blocks 'undos' from crossing over
 * @param p_newGnx New gnx body id to switch to
 */
private _switchBody(
    p_newGnx: string,
    p_aside: boolean,
    p_preserveFocus?: boolean
): Thenable&lt;vscode.TextEditor&gt; {
    const w_oldUri: vscode.Uri = this.bodyUri;

    // ? Set timestamps ?
    // this._leoFileSystem.setRenameTime(p_newGnx);

    let w_visibleCount = 0;
    vscode.window.visibleTextEditors.forEach((p_editor) =&gt; {
        if (p_editor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
            w_visibleCount++;
        }
    });

    if (this._bodyPreviewMode &amp;&amp; this._bodyEnablePreview &amp;&amp; w_visibleCount &lt; 2) {
        // just show in same column and delete after
        this.bodyUri = utils.strToLeoUri(p_newGnx);
        const q_showBody = this.showBody(p_aside, p_preserveFocus);
        vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_oldUri.path);
        return q_showBody;
    } else {
        // Gotta delete to close all and re-open, so:
        // Promise to Delete first, synchronously (as thenable),
        // tagged along with automatically removeFromRecentlyOpened in parallel
        const w_edit = new vscode.WorkspaceEdit();
        w_edit.deleteFile(w_oldUri, { ignoreIfNotExists: true });
        return vscode.workspace.applyEdit(w_edit).then(() =&gt; {
            // Set new uri and remove from 'Recently opened'
            this._bodyPreviewMode = true;
            this.bodyUri = utils.strToLeoUri(p_newGnx);
            // async, so don't wait for this to finish
            if (w_oldUri.fsPath !== this.bodyUri.fsPath) {
                vscode.commands.executeCommand(
                    'vscode.removeFromRecentlyOpened',
                    w_oldUri.path
                );
            }
            return this.showBody(p_aside, p_preserveFocus);
        });
    }
}

</t>
<t tx="felix.20200719025231.48">/**
 * * Sets globals if the current body is found opened in an editor panel for a particular gnx
 * @param p_gnx gnx to match
 */
private _locateOpenedBody(p_gnx: string): boolean {
    let w_found = false;
    // * Only gets to visible editors, not every tab per editor
    vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
        if (utils.leoUriToStr(p_textEditor.document.uri) === p_gnx) {
            w_found = true;
            this._bodyTextDocument = p_textEditor.document;
            this._bodyMainSelectionColumn = p_textEditor.viewColumn;
        }
    });
    return w_found;
}

</t>
<t tx="felix.20200719025231.49">/**
 * * Closes any body pane opened in this vscode window instance
 */
public closeBody(): void {
    // TODO : CLEAR UNDO HISTORY AND FILE HISTORY for this.bodyUri !
    if (this.bodyUri) {
        vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', this.bodyUri.path);
    }
    vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
        if (p_textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
            vscode.commands.executeCommand(
                'vscode.removeFromRecentlyOpened',
                p_textEditor.document.uri.path
            );
            if (p_textEditor.hide) {
                p_textEditor.hide();
            }
        }
    });
}

</t>
<t tx="felix.20200719025231.5">/**
 * * Core of the integration of Leo into vscode: Sends an action to leobridgeserver.py, to run in Leo.
 * @param p_action is the action string constant, from Constants.LEOBRIDGE
 * @param p_jsonParam (optional) JSON string to be given to the python script action call
 * @param p_deferredPayload (optional) a pre-made package that will be given back as the response, instead of package coming back from python
 * @param p_preventCall (optional) Flag for special case, only used at startup
 * @returns a Promise that will contain the JSON package answered back by leobridgeserver.py
 */
public sendAction(
    p_action: string,
    p_jsonParam = 'null',
    p_deferredPayload?: LeoBridgePackage,
    p_preventCall?: boolean
): Promise&lt;LeoBridgePackage&gt; {
    return this._leoBridge.action(p_action, p_jsonParam, p_deferredPayload, p_preventCall);
}

</t>
<t tx="felix.20200719025231.50">/**
 * * Opens an an editor for the currently selected node: "this.bodyUri". If already opened, this just 'reveals' it
 * @param p_aside Flag for opening the editor beside any currently opened and focused editor
 * @param p_preserveFocus flag that when true will stop the editor from taking focus once opened
 */
public showBody(p_aside: boolean, p_preserveFocus?: boolean): Promise&lt;vscode.TextEditor&gt; {
    // First setup timeout asking for gnx file refresh in case we were resolving a refresh of type 'RefreshTreeAndBody'
    if (this._refreshType.body) {
        this._refreshType.body = false;
        // TODO : CHECK IF TIMEOUT NECESSARY!
        setTimeout(() =&gt; {
            this._leoFileSystem.fireRefreshFile(utils.leoUriToStr(this.bodyUri));
        }, 0);
    }

    if (this._preventShowBody) {
        this._preventShowBody = false;
        return Promise.resolve(vscode.window.activeTextEditor!);
    }

    return Promise.resolve(vscode.workspace.openTextDocument(this.bodyUri)).then(
        (p_document) =&gt; {
            this._bodyTextDocument = p_document;

            // * Set document language along with the proper cursor position, selection range and scrolling position
            const q_bodyStates: Promise&lt;LeoBridgePackage&gt; = this.sendAction(
                Constants.LEOBRIDGE.GET_BODY_STATES,
                this.lastSelectedNode!.apJson
            );

            q_bodyStates.then((p_bodyStates: LeoBridgePackage) =&gt; {
                let w_language: string = p_bodyStates.language!;
                // Replace language string if in 'exceptions' array
                w_language = 'leobody.' + (Constants.LANGUAGE_CODES[w_language] || w_language);
                // Apply language if the selected node is still the same after all those events
                if (
                    !p_document.isClosed &amp;&amp;
                    this.lastSelectedNode &amp;&amp;
                    utils.leoUriToStr(p_document.uri) === this.lastSelectedNode.gnx
                ) {
                    vscode.languages.setTextDocumentLanguage(p_document, w_language);
                }
            });

            // Find body pane's position if already opened with same gnx (language still needs to be set per position)
            vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
                if (p_textEditor.document.uri.fsPath === p_document.uri.fsPath) {
                    this._bodyMainSelectionColumn = p_textEditor.viewColumn;
                    this._bodyTextDocument = p_textEditor.document;
                }
            });
            // Setup options for the preview state of the opened editor, and to choose which column it should appear
            const w_showOptions: vscode.TextDocumentShowOptions = p_aside
                ? {
                    viewColumn: vscode.ViewColumn.Beside,
                    preserveFocus: p_preserveFocus, // an optional flag that when true will stop the editor from taking focus
                    preview: true, // should text document be in preview only? set false for fully opened
                    // selection is instead set when the GET_BODY_STATES above resolves
                }
                : {
                    viewColumn: this._bodyMainSelectionColumn
                        ? this._bodyMainSelectionColumn
                        : 1, // view column in which the editor should be shown
                    preserveFocus: p_preserveFocus, // an optional flag that when true will stop the editor from taking focus
                    preview: true, // should text document be in preview only? set false for fully opened
                    // selection is instead set when the GET_BODY_STATES above resolves
                };

            // NOTE: textEditor.show() is deprecated  Use window.showTextDocument instead.
            const q_showTextDocument = vscode.window.showTextDocument(
                this._bodyTextDocument,
                w_showOptions
            );

            Promise.all([q_bodyStates, q_showTextDocument]).then(
                (p_values: [LeoBridgePackage, vscode.TextEditor]) =&gt; {
                    const w_resultBodyStates = p_values[0];
                    const w_bodyTextEditor = p_values[1];
                    const w_leoBodySel: BodySelectionInfo = w_resultBodyStates.selection!;

                    // Cursor position and selection range
                    const w_activeRow: number = w_leoBodySel.insert.line;
                    const w_activeCol: number = w_leoBodySel.insert.col;
                    let w_anchorLine: number = w_leoBodySel.start.line;
                    let w_anchorCharacter: number = w_leoBodySel.start.col;

                    if (w_activeRow === w_anchorLine &amp;&amp; w_activeCol === w_anchorCharacter) {
                        // Active insertion same as start selection, so use the other ones
                        w_anchorLine = w_leoBodySel.end.line;
                        w_anchorCharacter = w_leoBodySel.end.col;
                    }

                    const w_selection = new vscode.Selection(
                        w_anchorLine,
                        w_anchorCharacter,
                        w_activeRow,
                        w_activeCol
                    );

                    let w_scrollRange: vscode.Range | undefined;

                    // ! Test scroll position from selection range instead
                    // const w_scroll: number = w_leoBodySel.scroll;
                    // if (w_scroll) {
                    // w_scrollRange = new vscode.Range(w_scroll, 0, w_scroll, 0);
                    // }

                    // Build scroll position from selection range.
                    w_scrollRange = new vscode.Range(
                        w_activeRow,
                        w_activeCol,
                        w_activeRow,
                        w_activeCol
                    );

                    w_bodyTextEditor.selection = w_selection; // set cursor insertion point &amp; selection range

                    if (!w_scrollRange) {
                        w_scrollRange = w_bodyTextEditor.document.lineAt(0).range;
                    }

                    if (this._refreshType.scroll) {
                        this._refreshType.scroll = false;
                        w_bodyTextEditor.revealRange(w_scrollRange); // set scroll approximation
                    }
                }
            );

            return q_showTextDocument;
        }
    );
}

</t>
<t tx="felix.20200719025231.51"></t>
<t tx="felix.20200719025231.52">/**
 * * Select a tree node. Either called from user interaction, or used internally (p_internalCall flag)
 * @param p_node Node that was just selected
 * @param p_internalCall Flag used to indicate the selection is forced, and NOT originating from user interaction
 * @param p_aside Flag to force opening the body "Aside", i.e. when the selection was made from choosing "Open Aside"
 * @returns a promise with the package gotten back from Leo when asked to select the tree node
 */
public selectTreeNode(
    p_node: LeoNode,
    p_internalCall?: boolean,
    p_aside?: boolean
): Promise&lt;LeoBridgePackage | vscode.TextEditor&gt; {
    this.triggerBodySave(true);

    // * check if used via context menu's "open-aside" on an unselected node: check if p_node is currently selected, if not select it
    if (p_aside &amp;&amp; p_node !== this.lastSelectedNode) {
        this._revealTreeViewNode(p_node, { select: true, focus: false }); // no need to set focus: tree selection is set to right-click position
    }

    this.leoStates.setSelectedNodeFlags(p_node);
    this._leoStatusBar.update(true); // Just selected a node directly, or via expand/collapse
    const w_showBodyKeepFocus = p_aside
        ? this.config.treeKeepFocusWhenAside
        : this.config.treeKeepFocus;

    // * Check if having already this exact node position selected : Just show the body and exit
    // (other tree nodes with same gnx may have different syntax language coloring because of parents lineage)
    if (p_node === this.lastSelectedNode) {
        this._locateOpenedBody(p_node.gnx); // LOCATE NEW GNX
        return this.showBody(!!p_aside, w_showBodyKeepFocus); // Voluntary exit
    }

    // * Set selected node in Leo via leoBridge
    const q_setSelectedNode = this.sendAction(
        Constants.LEOBRIDGE.SET_SELECTED_NODE,
        p_node.apJson
    ).then((p_setSelectedResult) =&gt; {
        if (!p_internalCall) {
            this._refreshType.states = true;
            this.getStates();
        }
        return p_setSelectedResult;
    });

    // * Apply the node to the body text without waiting for the selection promise to resolve
    this._tryApplyNodeToBody(p_node, !!p_aside, w_showBodyKeepFocus, true);
    return q_setSelectedNode;
}

</t>
<t tx="felix.20200719025231.54">/**
 * * Changes the marked state of a specified, or currently selected node
 * @param p_isMark Set 'True' to mark, otherwise unmarks the node
 * @param p_node Specifies which node use, or leave undefined to mark or unmark the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 */
public changeMark(
    p_isMark: boolean,
    p_node?: LeoNode,
    p_fromOutline?: boolean
): Promise&lt;LeoBridgePackage&gt; {
    // No need to wait for body-save trigger for marking/un-marking a node
    const q_commandResult = this.nodeCommand({
        action: p_isMark ? Constants.LEOBRIDGE.MARK_PNODE : Constants.LEOBRIDGE.UNMARK_PNODE,
        node: p_node,
        refreshType: { tree: true },
        fromOutline: !!p_fromOutline,
    });
    if (q_commandResult) {
        if (!p_node || p_node === this.lastSelectedNode) {
            utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_isMark);
        }
        return q_commandResult;
    } else {
        return Promise.reject('Change mark on node not added on command stack');
    }
}

</t>
<t tx="felix.20200719025231.55">/**
 * * Asks for a new headline label, and replaces the current label with this new one one the specified, or currently selected node
 * @param p_node Specifies which node to rename, or leave undefined to rename the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 */
public editHeadline(
    p_node?: LeoNode,
    p_fromOutline?: boolean
): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(false, true)
        .then(() =&gt; {
            if (!p_node &amp;&amp; this.lastSelectedNode) {
                p_node = this.lastSelectedNode; // Gets last selected node if called via keyboard shortcut or command palette (not set in command stack class)
            }
            if (p_node) {
                this._headlineInputOptions.prompt =
                    Constants.USER_MESSAGES.PROMPT_EDIT_HEADLINE;
                this._headlineInputOptions.value = p_node.label; // preset input pop up
                return vscode.window.showInputBox(this._headlineInputOptions);
            } else {
                return Promise.reject('No node selected');
            }
        })
        .then((p_newHeadline) =&gt; {
            if (p_newHeadline) {
                p_node!.label = p_newHeadline; // ! When labels change, ids will change and its selection and expansion states cannot be kept stable anymore.
                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.SET_HEADLINE,
                    node: p_node,
                    refreshType: { tree: true, states: true },
                    fromOutline: !!p_fromOutline,
                    name: p_newHeadline,
                });
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject('Edit Headline not added on command stack');
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20200719025231.56">/**
 * * Asks for a headline label to be entered and creates (inserts) a new node under the current, or specified, node
 * @param p_node specified under which node to insert, or leave undefined to use whichever is currently selected
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_interrupt Signifies the insert action is actually interrupting itself (e.g. rapid CTRL+I actions by the user)
 */
public insertNode(
    p_node?: LeoNode,
    p_fromOutline?: boolean,
    p_interrupt?: boolean
): Promise&lt;LeoBridgePackage&gt; {
    let w_fromOutline: boolean = !!p_fromOutline; // Use w_fromOutline for where we intend to leave focus when done with the insert
    if (p_interrupt) {
        this._focusInterrupt = true;
        w_fromOutline = this._fromOutline; // Going to use last state
    }
    // if no node parameter, the front command stack CAN be busy, but if a node is passed, stack must be free
    if (!p_node || !this._isBusy()) {
        this.triggerBodySave(true); // Don't wait for saving to resolve because we're waiting for user input anyways
        this._headlineInputOptions.prompt = Constants.USER_MESSAGES.PROMPT_INSERT_NODE;
        this._headlineInputOptions.value = Constants.USER_MESSAGES.DEFAULT_HEADLINE;
        return new Promise&lt;LeoBridgePackage&gt;((p_resolve, p_reject) =&gt; {
            vscode.window.showInputBox(this._headlineInputOptions).then((p_newHeadline) =&gt; {
                const w_action = p_newHeadline
                    ? Constants.LEOBRIDGE.INSERT_NAMED_PNODE
                    : Constants.LEOBRIDGE.INSERT_PNODE;
                const q_commandResult = this.nodeCommand({
                    action: w_action,
                    node: p_node,
                    refreshType: { tree: true, states: true },
                    fromOutline: w_fromOutline,
                    name: p_newHeadline,
                });
                if (q_commandResult) {
                    q_commandResult.then((p_package) =&gt; p_resolve(p_package));
                } else {
                    p_reject(w_action + ' not added on command stack');
                }
            });
        });
    } else {
        return Promise.reject('Insert node not added on command stack');
    }
}

</t>
<t tx="felix.20200719025231.57"></t>
<t tx="felix.20200719025231.58">/**
 * * Asks for file name and path, then saves the Leo file
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 */
public saveAsLeoFile(p_fromOutline?: boolean): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
                return this._leoFilesBrowser.getLeoFileUrl(true);
            } else {
                // 'when-conditions' should prevent this
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            }
        })
        .then((p_chosenLeoFile) =&gt; {
            if (p_chosenLeoFile.trim()) {
                const w_hasDot = p_chosenLeoFile.indexOf('.') !== -1;
                if (
                    !w_hasDot ||
                    (p_chosenLeoFile.split('.').pop() !== Constants.FILE_EXTENSION &amp;&amp; w_hasDot)
                ) {
                    if (!p_chosenLeoFile.endsWith('.')) {
                        p_chosenLeoFile += '.'; // Add dot if needed
                    }
                    p_chosenLeoFile += Constants.FILE_EXTENSION; // Add extension
                }
                if (this.leoStates.leoOpenedFileName) {
                    this._removeLastFile(this.leoStates.leoOpenedFileName);
                    this._removeRecentFile(this.leoStates.leoOpenedFileName);
                }
                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.SAVE_FILE,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    fromOutline: !!p_fromOutline,
                    name: p_chosenLeoFile,
                });
                this.leoStates.leoOpenedFileName = p_chosenLeoFile.trim();
                this._leoStatusBar.update(true, 0, true);
                this._addRecentAndLastFile(p_chosenLeoFile.trim());
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject('Save file not added on command stack');
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20200719025231.59">/**
 * * Invokes the self.commander.save() Leo command
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns Promise that resolves when the save command is placed on the front-end command stack
 */
public saveLeoFile(p_fromOutline?: boolean): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(true, true).then((p_saveResult) =&gt; {
        if (this.leoStates.fileOpenedReady) {
            if (this.lastSelectedNode &amp;&amp; this._isCurrentFileNamed()) {
                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.SAVE_FILE,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    fromOutline: !!p_fromOutline,
                    name: '',
                });
                return q_commandResult
                    ? q_commandResult
                    : Promise.reject('Save file not added on command stack');
            } else {
                return this.saveAsLeoFile(p_fromOutline); // Override this command call if file is unnamed!
            }
        } else {
            // 'when-conditions' should prevent this
            vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
        }
    });
}

</t>
<t tx="felix.20200719025231.6">/**
 * * leoInteg starting entry point
 * Starts a leoBridge server, and/or establish a connection to a server, based on config settings.
 */
public startNetworkServices(): void {
    // * Check settings and start a server accordingly
    if (this.config.startServerAutomatically) {
        this.startServer();
    } else if (this.config.connectToServerAutomatically) {
        // * (via settings) Connect to Leo Bridge server automatically without starting one first
        this.connect();
    } else {
        this.finishedStartup = true;
    }
}

</t>
<t tx="felix.20200719025231.60">/**
 * * Show switch document 'QuickPick' dialog and switch file if selection is made, or just return if no files are opened.
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly selected document
 */
public switchLeoFile(): Promise&lt;vscode.TextEditor | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.GET_OPENED_FILES);
        })
        .then((p_package) =&gt; {
            const w_entries: ChooseDocumentItem[] = []; // Entries to offer as choices.
            const w_files: LeoDocument[] = p_package.files!;
            let w_index: number = 0;
            if (w_files &amp;&amp; w_files.length) {
                w_files.forEach(function (p_filePath: LeoDocument) {
                    w_entries.push({
                        label: w_index.toString(),
                        description: p_filePath.name
                            ? p_filePath.name
                            : Constants.UNTITLED_FILE_NAME,
                        value: w_index,
                        alwaysShow: true,
                    });
                    w_index++;
                });
                const w_pickOptions: vscode.QuickPickOptions = {
                    matchOnDescription: true,
                    placeHolder: Constants.USER_MESSAGES.CHOOSE_OPENED_FILE,
                };
                return vscode.window.showQuickPick(w_entries, w_pickOptions);
            } else {
                // "No opened documents"
                return Promise.resolve(undefined);
            }
        })
        .then((p_chosenDocument) =&gt; {
            if (p_chosenDocument) {
                return Promise.resolve(this.selectOpenedLeoDocument(p_chosenDocument.value));
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20200719025231.61">/**
 * * Switches Leo document directly by index number. Used by document treeview and switchLeoFile command.
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly opened document
 */
public selectOpenedLeoDocument(p_index: number): Promise&lt;vscode.TextEditor&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(
                Constants.LEOBRIDGE.SET_OPENED_FILE,
                JSON.stringify({ index: p_index })
            );
        })
        .then((p_openFileResult: LeoBridgePackage) =&gt; {
            // Like we just opened or made a new file
            if (p_openFileResult.filename) {
                return this._setupOpenedLeoDocument(p_openFileResult);
            } else {
                console.log('Select Opened Leo File Error');
                return Promise.reject('Select Opened Leo File Error');
            }
        });
}

</t>
<t tx="felix.20200719025231.64">/**
 * * Close an opened Leo file
 * @returns the launchRefresh promise started after it's done closing the Leo document
 */
public closeLeoFile(): Promise&lt;boolean&gt; {
    let w_removeLastFileName: string = '';
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (!this.leoStates.fileOpenedReady) {
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLOSE_ERROR);
                return Promise.reject(Constants.USER_MESSAGES.CLOSE_ERROR);
            }
            w_removeLastFileName = this.leoStates.leoOpenedFileName;
            return this.sendAction(
                Constants.LEOBRIDGE.CLOSE_FILE,
                JSON.stringify({ forced: false })
            );
        })
        .then((p_tryCloseResult) =&gt; {
            // Has a total member: closed file
            if (p_tryCloseResult.total || p_tryCloseResult.total === 0) {
                this._removeLastFile(w_removeLastFileName);
                if (p_tryCloseResult.total === 0) {
                    this._setupNoOpenedLeoDocument();
                } else {
                    this.loadSearchSettings();
                    this.launchRefresh(
                        {
                            tree: true,
                            body: true,
                            documents: true,
                            buttons: true,
                            states: true,
                        },
                        false
                    );
                }
                return Promise.resolve(true);
            } else {
                // No total member: did not close file
                const q_askSaveChangesInfoMessage: Thenable&lt;vscode.MessageItem | undefined&gt; =
                    vscode.window.showInformationMessage(
                        Constants.USER_MESSAGES.SAVE_CHANGES +
                        ' ' +
                        this.leoStates.leoOpenedFileName +
                        ' ' +
                        Constants.USER_MESSAGES.BEFORE_CLOSING,
                        { modal: true },
                        ...Constants.ASK_SAVE_CHANGES_BUTTONS
                    );
                return Promise.resolve(q_askSaveChangesInfoMessage)
                    .then((p_askSaveResult: vscode.MessageItem | undefined) =&gt; {
                        if (p_askSaveResult) {
                            if (p_askSaveResult.title === Constants.USER_MESSAGES.YES) {
                                // save and then force-close
                                let w_savePromise: Promise&lt;LeoBridgePackage | undefined&gt;;
                                if (this._isCurrentFileNamed()) {
                                    w_savePromise = this.sendAction(
                                        Constants.LEOBRIDGE.SAVE_FILE,
                                        JSON.stringify({ name: '' })
                                    );
                                } else {
                                    w_savePromise = this._leoFilesBrowser
                                        .getLeoFileUrl(true)
                                        .then((p_chosenLeoFile) =&gt; {
                                            if (p_chosenLeoFile.trim()) {
                                                return this.sendAction(
                                                    Constants.LEOBRIDGE.SAVE_FILE,
                                                    JSON.stringify({
                                                        name: p_chosenLeoFile.trim(),
                                                    })
                                                );
                                            } else {
                                                // Canceled
                                                return Promise.resolve(undefined);
                                            }
                                        });
                                }
                                return w_savePromise.then(
                                    (p_packageAfterSave) =&gt; {
                                        return this.sendAction(
                                            Constants.LEOBRIDGE.CLOSE_FILE,
                                            JSON.stringify({ forced: true })
                                        );
                                    },
                                    () =&gt; {
                                        return Promise.reject('Save failed');
                                    }
                                );
                            } else if (p_askSaveResult.title === Constants.USER_MESSAGES.NO) {
                                // Don't want to save so just force-close directly
                                return this.sendAction(
                                    Constants.LEOBRIDGE.CLOSE_FILE,
                                    JSON.stringify({ forced: true })
                                );
                            } else {
                                // Canceled
                                return Promise.resolve(undefined);
                            }
                        } else {
                            // Canceled
                            return Promise.resolve(undefined);
                        }
                    })
                    .then((p_closeResult: LeoBridgePackage | undefined) =&gt; {
                        if (p_closeResult) {
                            // * back from CLOSE_FILE action, the last that can be performed (after saving if dirty or not)
                            this._removeLastFile(w_removeLastFileName);
                            if (p_closeResult &amp;&amp; p_closeResult.total === 0) {
                                this._setupNoOpenedLeoDocument();
                            } else {
                                this.loadSearchSettings();
                                this.launchRefresh(
                                    {
                                        tree: true,
                                        body: true,
                                        documents: true,
                                        buttons: true,
                                        states: true,
                                    },
                                    false
                                );
                            }
                            return Promise.resolve(true);
                        }
                        // Canceled
                        return Promise.resolve(false);
                    });
            }
        });
}

</t>
<t tx="felix.20200719025231.65">/**
 * * Creates a new untitled Leo document
 * * If not shown already, it also shows the outline, body and log panes along with leaving focus in the outline
 * @returns A promise that resolves with a textEditor of the new file
 */
public newLeoFile(): Promise&lt;vscode.TextEditor&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.OPEN_FILE, '""');
        })
        .then((p_openFileResult: LeoBridgePackage) =&gt; {
            if (p_openFileResult.filename) {
                return this._setupOpenedLeoDocument(p_openFileResult);
            } else {
                return Promise.reject('New Leo File Error');
            }
        });
}

</t>
<t tx="felix.20200719025231.66">/**
 * * Shows an 'Open Leo File' dialog window and opens the chosen file
 * * If not shown already, it also shows the outline, body and log panes along with leaving focus in the outline
 * @returns A promise that resolves with a textEditor of the chosen file
 */
public openLeoFile(p_leoFileUri?: vscode.Uri): Promise&lt;vscode.TextEditor | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            let q_openedFile: Promise&lt;LeoBridgePackage | undefined&gt;; // Promise for opening a file
            if (p_leoFileUri &amp;&amp; p_leoFileUri.fsPath.trim()) {
                const w_fixedFilePath: string = p_leoFileUri.fsPath.replace(/\\/g, '/');
                q_openedFile = this.sendAction(
                    Constants.LEOBRIDGE.OPEN_FILE,
                    JSON.stringify({ filename: w_fixedFilePath })
                );
            } else {
                q_openedFile = this._leoFilesBrowser.getLeoFileUrl().then(
                    (p_chosenLeoFile) =&gt; {
                        if (p_chosenLeoFile.trim()) {
                            return this.sendAction(
                                Constants.LEOBRIDGE.OPEN_FILE,
                                JSON.stringify({ filename: p_chosenLeoFile })
                            );
                        } else {
                            return Promise.resolve(undefined);
                        }
                    },
                    (p_errorGetFile) =&gt; {
                        return Promise.reject(p_errorGetFile);
                    }
                );
            }
            return q_openedFile;
        })
        .then(
            (p_openFileResult: LeoBridgePackage | undefined) =&gt; {
                if (p_openFileResult) {
                    return this._setupOpenedLeoDocument(p_openFileResult);
                } else {
                    return Promise.resolve(undefined);
                }
            },
            (p_errorOpen) =&gt; {
                console.log('in .then not opened or already opened'); // TODO : IS REJECTION BEHAVIOR NECESSARY HERE TOO?
                return Promise.reject(p_errorOpen);
            }
        );
}

</t>
<t tx="felix.20200719025231.69">/**
 * * StatusBar click handler
 * @returns Thenable from the statusBar click customizable behavior
 */
public statusBarOnClick(): Thenable&lt;unknown&gt; {
    // TODO : Set definitive (customizable?) behavior (For now, offer to switch documents, or show leoInteg's commands)
    if (this.leoStates.fileOpenedReady) {
        return this.switchLeoFile();
    } else {
        return vscode.commands.executeCommand(
            Constants.VSCODE_COMMANDS.QUICK_OPEN,
            Constants.GUI.QUICK_OPEN_LEO_COMMANDS
        );
    }
}

</t>
<t tx="felix.20200719025231.7">/**
 * * Starts an instance of a leoBridge server, and may connect to it afterwards, based on configuration flags.
 */
public startServer(): void {
    if (!this._leoTerminalPane) {
        this._leoTerminalPane = vscode.window.createOutputChannel(
            Constants.GUI.TERMINAL_PANE_TITLE
        );
    }
    this._serverService
        .startServer(
            this.config.leoPythonCommand,
            this.config.leoEditorPath,
            this.config.connectionPort
        )
        .then(
            (p_message) =&gt; {
                console.log('SERVER START SUCCESS!!');

                utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, true); // server started
                if (this.config.connectToServerAutomatically) {
                    setTimeout(() =&gt; {
                        // Wait a full second
                        this.connect();
                    }, 1000);
                } else {
                    this.finishedStartup = true;
                }
            },
            (p_reason) =&gt; {
                if (p_reason !== "Leo Editor Path Setting Missing") {
                    vscode.window.showErrorMessage(
                        Constants.USER_MESSAGES.START_SERVER_ERROR + p_reason
                    );
                }
            }
        );
}

</t>
<t tx="felix.20200719025231.70">/**
 * * Test/Dummy command
 * @param p_fromOutline Flags if the call came with focus on the outline
 * @returns Thenable from the tested functionality
 */
public test(p_fromOutline?: boolean): Thenable&lt;unknown&gt; {
    // return this.statusBarOnClick();

    // vscode.commands.executeCommand(Constants.COMMANDS.MARK_SELECTION)
    //     .then((p_result) =&gt; {
    //         console.log(
    //             'BACK FROM EXEC COMMAND ' +
    //             Constants.COMMANDS.MARK_SELECTION +
    //             ', p_result: ',
    //             JSON.stringify(p_result)
    //         );

    //     });

    // Test setting scroll / selection range

    /*
    vscode.window.showQuickPick(["get", "set"]).then(p_results =&gt; {
        console.log('quick pick result:', p_results);
        let w_selection: vscode.Selection;
        let w_action = "";
        if (p_results === "get") {
           //  w_action = Constants.LEOBRIDGE.GET_SEARCH_SETTINGS;
            // w_selection = new vscode.Selection(1, 1, 1, 6);
            this.loadSearchSettings();
        } else {
            w_action = Constants.LEOBRIDGE.SET_SEARCH_SETTINGS;
            // w_selection = new vscode.Selection(2, 2, 3, 3);
        }
        console.log('w_action', w_action);
        const searchSettings: LeoGuiFindTabManagerSettings = {
            find_text: "new find text",
            change_text: "",
            ignore_case: false, // diff
            mark_changes: false,
            mark_finds: true, // diff
            node_only: false,
            pattern_match: false,
            search_body: true,
            search_headline: true,
            suboutline_only: false,
            whole_word: false
        };

        if (w_action) {
            this.sendAction(
                w_action, JSON.stringify({ searchSettings: searchSettings })
            ).then((p_result: LeoBridgePackage) =&gt; {
                console.log('got back settings: ', p_result);
            });
        }
    });
    */

    /*
    vscode.window.visibleTextEditors.forEach(p_textEditor =&gt; {
        console.log('p_textEditor.document.uri.scheme ', p_textEditor.document.uri.scheme);

        if (p_textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
            console.log('found');

            p_textEditor.selection = w_selection; // set cursor insertion point &amp; selection range
            // if (!w_scrollRange) {
            //     w_scrollRange = p_textEditor.document.lineAt(0).range;
            // }
            // p_textEditor.revealRange(w_scrollRange); // set
        }
    });
    */

    // GET_FOCUS AS A TEST
    return this.sendAction(
        // Constants.LEOBRIDGE.TEST, JSON.stringify({ testParam: "Some String" })
        Constants.LEOBRIDGE.GET_FOCUS,
        JSON.stringify({ testParam: 'Some String' })
    ).then((p_result: LeoBridgePackage) =&gt; {
        console.log('get focus: ', p_result);

        // this.launchRefresh({ buttons: true }, false);
        // return vscode.window.showInformationMessage(
        //     ' back from test, called from ' +
        //     (p_fromOutline ? "outline" : "body") +
        //     ', with result: ' +
        //     JSON.stringify(p_result)
        // );
    });
}
</t>
<t tx="felix.20200719025231.8">/**
 * * Initiate a connection to the leoBridge server, then show view title, log pane, and set 'bridge ready' flags.
 */
public connect(): void {
    if (this.leoStates.leoBridgeReady || this._leoIsConnecting) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.ALREADY_CONNECTED);
        return;
    }
    this._leoIsConnecting = true;
    this._leoBridgeReadyPromise = this._leoBridge.initLeoProcess(
        this._serverService.usingPort // This will be zero if no port found
    );
    this._leoBridgeReadyPromise.then(
        (p_package) =&gt; {
            this._leoIsConnecting = false;
            if (p_package.id !== 1) {
                this.cancelConnect(Constants.USER_MESSAGES.CONNECT_ERROR);
            } else {
                const w_lastFiles: string[] =
                    this._context.globalState.get(Constants.LAST_FILES_KEY) || [];
                if (w_lastFiles.length) {
                    // This context flag will trigger 'Connecting...' placeholder
                    utils.setContext(Constants.CONTEXT_FLAGS.AUTO_CONNECT, true);

                    setTimeout(() =&gt; {
                        this._openLastFiles(); // Try to open last opened files, if any
                    }, 0);
                } else {
                    this.leoStates.leoBridgeReady = true;
                    this.finishedStartup = true;
                }

                this.showLogPane();
                if (!this.config.connectToServerAutomatically) {
                    vscode.window.showInformationMessage(Constants.USER_MESSAGES.CONNECTED);
                }
            }

            // TODO : Finish Closing and possibly SAME FOR OPENING AND CONNECTING
            // TODO : #14 @boltex COULD BE SOME FILES ALREADY OPENED OR NONE!
        },
        (p_reason) =&gt; {
            this._leoIsConnecting = false;
            this.cancelConnect(Constants.USER_MESSAGES.CONNECT_FAILED + ': ' + p_reason);
        }
    );
}

</t>
<t tx="felix.20200719025231.9">/**
 * * Cancels websocket connection and reverts context flags.
 * Called from leoBridge.ts when its websocket reports disconnection.
 * @param p_message
 */
public cancelConnect(p_message?: string): void {
    // 'disconnect error' versus 'failed to connect'
    if (this.leoStates.leoBridgeReady) {
        vscode.window.showErrorMessage(
            p_message ? p_message : Constants.USER_MESSAGES.DISCONNECTED
        );
    } else {
        vscode.window.showInformationMessage(
            p_message ? p_message : Constants.USER_MESSAGES.DISCONNECTED
        );
    }

    // to change the 'viewsWelcome' content.
    // bring back to !leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
    utils.setContext(Constants.CONTEXT_FLAGS.AUTO_START_SERVER, false);
    utils.setContext(Constants.CONTEXT_FLAGS.AUTO_CONNECT, false);
    this.finishedStartup = true;

    this.leoStates.fileOpenedReady = false;
    this.leoStates.leoBridgeReady = false;
    this._leoBridgeReadyPromise = undefined;
    this._leoStatusBar.update(false);
    this._refreshOutline(false, RevealType.NoReveal);
}

</t>
<t tx="felix.20200719030811.1"></t>
<t tx="felix.20200719030842.1"></t>
<t tx="felix.20200719030902.1"></t>
<t tx="felix.20200719030909.1"></t>
<t tx="felix.20200719031115.1"></t>
<t tx="felix.20200719031346.1">/**
 * * Send user's configuration through leoBridge to the server script
 * @param p_config A config object containing all the configuration settings
 * @returns promise that will resolves with the package from "applyConfig" call in Leo bridge server
 */
public sendConfigToServer(p_config: ConfigMembers): Promise&lt;LeoBridgePackage&gt; {
    if (this.leoStates.leoBridgeReady) {
        return this.sendAction(Constants.LEOBRIDGE.APPLY_CONFIG, JSON.stringify(p_config));
    } else {
        return Promise.reject('Leo Bridge Not Ready');
    }
}

</t>
<t tx="felix.20200719031802.1"></t>
<t tx="felix.20200719033306.1"></t>
<t tx="felix.20200719033511.1"></t>
<t tx="felix.20200924205439.1">def _get_commander_method(self, p_command):
    """ Return the given method (p_command) in the Commands class or subcommanders."""
    # self.g.trace(p_command)
    #
    # First, try the commands class.
    w_func = getattr(self.commander, p_command, None)
    if w_func:
        return w_func
    #
    # Search all subcommanders for the method.
    table = (  # This table comes from c.initObjectIvars.
        'abbrevCommands',
        'bufferCommands',
        'chapterCommands',
        'controlCommands',
        'convertCommands',
        'debugCommands',
        'editCommands',
        'editFileCommands',
        'evalController',
        'gotoCommands',
        'helpCommands',
        'keyHandler',
        'keyHandlerCommands',
        'killBufferCommands',
        'leoCommands',
        'leoTestManager',
        'macroCommands',
        'miniBufferWidget',
        'printingController',
        'queryReplaceCommands',
        'rectangleCommands',
        'searchCommands',
        'spellCommands',
        'vimCommands',  # Not likely to be useful.
    )
    for ivar in table:
        subcommander = getattr(self.commander, ivar, None)
        if subcommander:
            w_func = getattr(subcommander, p_command, None)
            if w_func:
                ### self.g.trace(f"Found c.{ivar}.{p_command}")
                return w_func
        # else:
            # self.g.trace(f"Not Found: c.{ivar}") # Should never happen.
    return None

</t>
<t tx="felix.20200924205503.1">def leoCommand(self, p_command, param):
    '''
    Generic call to a method in Leo's Commands class or any subcommander class.

    The param["ap"] position is to be selected before having the command run,
    while the param["keep"] parameter specifies wether the original position
    should be re-selected afterward.

    The whole of those operations is to be undoable as one undo step.

    command: a method name (a string).
    param["ap"]: an archived position.
    param["keep"]: preserve the current selection, if possible.
    '''
    w_keepSelection = False  # Set default, optional component of param
    if "keep" in param:
        w_keepSelection = param["keep"]

    w_ap = param["ap"]  # At least node parameter is present
    if not w_ap:
        return self._outputError(f"Error in {p_command}: no param ap")

    w_p = self._ap_to_p(w_ap)
    if not w_p:
        return self._outputError(f"Error in {p_command}: no w_p position found")

    w_func = self._get_commander_method(p_command)
    if not w_func:
        return self._outputError(f"Error in {p_command}: no method found")

    if w_p == self.commander.p:
        w_func(event=None)
    else:
        w_oldPosition = self.commander.p
        self.commander.selectPosition(w_p)
        w_func(event=None)
        if w_keepSelection and self.commander.positionExists(w_oldPosition):
            self.commander.selectPosition(w_oldPosition)

    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924205915.1">def open_files(self, param):
    """
    Opens an array of leo files
    Returns an object that contains the last 'opened' member.
    """
    w_files = []
    if "files" in param:
        w_files = param["files"]

    for i_file in w_files:
        self.commander = None
        w_found = False
        # If not empty string (asking for New file) then check if already opened
        if i_file:
            for w_commander in self.g.app.commanders():
                if w_commander.fileName() == i_file:
                    w_found = True
                    self.commander = w_commander

        if not w_found:
            if os.path.isfile(i_file):
                # create self.commander by opening the file
                self.commander = self.bridge.openLeoFile(i_file)
                self.commander.findCommands.ftm = StringFindTabManager(
                    self.commander)
        if self.commander:
            self.commander.closed = False
            self.commander.frame.body.wrapper = IntegTextWrapper(
                self.commander, "integBody", self.g)
            self.commander.selectPosition(self.commander.p)

    # Done with the last one, it's now the selected commander. Check again just in case.
    if self.commander:
        self._create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self._p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage(w_result)
    else:
        return self._outputError('Error in openFiles')

</t>
<t tx="felix.20200924210020.1">def get_buttons(self, param):
    '''Gets the currently opened file's @buttons list'''
    w_buttons = []
    if self.commander and self.commander.theScriptingController and self.commander.theScriptingController.buttonsDict:
        w_dict = self.commander.theScriptingController.buttonsDict
        for w_key in w_dict:
            w_entry = {"name": w_dict[w_key], "index": str(w_key)}
            w_buttons.append(w_entry)
    return self.sendLeoBridgePackage({"buttons": w_buttons})

</t>
<t tx="felix.20200924210024.1">def remove_button(self, param):
    '''Removes an entry from the buttonsDict by index string'''
    w_index = param['index']
    w_dict = self.commander.theScriptingController.buttonsDict
    w_key = None
    for i_key in w_dict:
        if(str(i_key) == w_index):
            w_key = i_key
    if w_key:
        del(w_dict[w_key])  # delete object member
    # return selected node when done
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924210029.1">def click_button(self, param):
    '''Handles buttons clicked in client from the '@button' panel'''
    w_index = param['index']
    w_dict = self.commander.theScriptingController.buttonsDict
    w_button = None
    for i_key in w_dict:
        if(str(i_key) == w_index):
            w_button = i_key
    if w_button:
        w_button.command()  # run clicked button command
    # return selected node when done
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924210036.1">def get_all_leo_commands(self, param):
    """Return a list of all Leo commands that make sense in leoInteg."""
    c = self.commander
    d = c.commandsDict  # keys are command names, values are functions.
    bad_names = self._bad_commands()  # #92.
    good_names = self._good_commands()
    duplicates = set(bad_names).intersection(set(good_names))
    if duplicates:
        print('duplicate command names...', flush=True)
        for z in sorted(duplicates):
            print(z)
    result = []
    for command_name in sorted(d):
        func = d.get(command_name)
        if not func:
            print('no func:', command_name, flush=True)
            continue
        if command_name in bad_names:  # #92.
            continue
        # Prefer func.__func_name__ to func.__name__: Leo's decorators change func.__name__!
        func_name = getattr(func, '__func_name__', func.__name__)
        if not func_name:
            print('no name', command_name, flush=True)
            continue
        doc = func.__doc__ or ''
        result.append({
            "label": command_name,
            "func":  func_name,
            "detail": doc,
        })
        # This shows up in the bridge log.
        # print(f"__doc__: {len(doc):4} {command_name:40} {func_name} ", flush=True)
        # print(f"{func_name} ", flush=True)

    return self.sendLeoBridgePackage({"commands": result})

</t>
<t tx="felix.20200924210058.1">def _bad_commands(self):
    """Return the list of Leo's command names that leoInteg should ignore."""
    c = self.commander
    bad = []
    d = c.commandsDict  # keys are command names, values are functions.
    #
    # First, remove @button, @command and vim commands.
    for command_name in sorted(d):
        if command_name.startswith((':', '@')):
            # print('ignore', command_name)
            bad.append(command_name)
    # Second, remove other commands.
    # This is a hand-curated list.
    bad_list = [

        # Abbreviations...
        'abbrev-kill-all',
        'abbrev-list',
        'dabbrev-completion',
        'dabbrev-expands',

        # Autocompletion...
        'auto-complete',
        'auto-complete-force',
        'disable-autocompleter',
        'disable-calltips',
        'enable-autocompleter',
        'enable-calltips',

        # Debugger...
        'debug',
        'db-again',
        'db-b',
        'db-c',
        'db-h',
        'db-input',
        'db-l',
        'db-n',
        'db-q',
        'db-r',
        'db-s',
        'db-status',
        'db-w',

        # File operations...
        'directory-make',
        'directory-remove',
        'file-delete',
        'file-diff-files',
        'file-insert',
        'file-new',
        'file-open-by-name',

        # All others...
        'shell-command',
        'shell-command-on-region',
        'cheat-sheet',
        'dehoist',  # Duplicates of de-hoist.
        'find-clone-all',
        'find-clone-all-flattened',
        'find-clone-tag',
        'find-all',
        'find-all-unique-regex',
        'find-character',
        'find-character-extend-selection',
        'find-next',
        'find-prev',
        'find-word',
        'find-word-in-line',

        'global-search',

        'isearch-backward',
        'isearch-backward-regexp',
        'isearch-forward',
        'isearch-forward-regexp',
        'isearch-with-present-options',

        'replace',
        'replace-all',
        'replace-current-character',
        'replace-then-find',

        're-search-backward',
        're-search-forward',

        'search-backward',
        'search-forward',
        'search-return-to-origin',

        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
        'set-replace-string',
        'set-search-string',

        'show-find-options',

        'start-search',

        'toggle-find-collapses-nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',

        'word-search-backward',
        'word-search-forward',

        # Buttons...
        'delete-script-button-button',

        # Clicks...
        'click-click-box',
        'click-icon-box',
        'ctrl-click-at-cursor',
        'ctrl-click-icon',
        'double-click-icon-box',
        'right-click-icon',

        # Editors...
        'add-editor', 'editor-add',
        'delete-editor', 'editor-delete',
        'detach-editor-toggle',
        'detach-editor-toggle-max',

        # Focus...
        'cycle-editor-focus', 'editor-cycle-focus',
        'focus-to-body',
        'focus-to-find',
        'focus-to-log',
        'focus-to-minibuffer',
        'focus-to-nav',
        'focus-to-spell-tab',
        'focus-to-tree',

        'tab-cycle-next',
        'tab-cycle-previous',
        'tab-detach',

        # Headlines..
        'abort-edit-headline',
        'edit-headline',
        'end-edit-headline',

        # Layout and panes...
        'adoc',
        'adoc-with-preview',

        'contract-body-pane',
        'contract-log-pane',
        'contract-outline-pane',

        'edit-pane-csv',
        'edit-pane-test-open',
        'equal-sized-panes',
        'expand-log-pane',
        'expand-body-pane',
        'expand-outline-pane',

        'free-layout-context-menu',
        'free-layout-load',
        'free-layout-restore',
        'free-layout-zoom',

        'zoom-in',
        'zoom-out'

        # Log
        'clear-log',

        # Menus...
        'activate-cmds-menu',
        'activate-edit-menu',
        'activate-file-menu',
        'activate-help-menu',
        'activate-outline-menu',
        'activate-plugins-menu',
        'activate-window-menu',
        'context-menu-open',
        'menu-shortcut',

        # Modes...
        'clear-extend-mode',

        # Outline...
        'contract-or-go-left',
        'contract-node',
        'contract-parent',

        # Scrolling...
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-outline-down-line',
        'scroll-outline-down-page',
        'scroll-outline-left',
        'scroll-outline-right',
        'scroll-outline-up-line',
        'scroll-outline-up-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',

        # Windows...
        'about-leo',

        'cascade-windows',
        'close-others',
        'close-window',

        'iconify-frame',

        'find-tab-hide',
        'find-tab-open',

        'hide-body-dock',
        'hide-body-pane',
        'hide-invisibles',
        'hide-log-pane',
        'hide-outline-dock',
        'hide-outline-pane',
        'hide-tabs-dock',

        'minimize-all',

        'resize-to-screen',

        'show-body-dock',
        'show-hide-body-dock',
        'show-hide-outline-dock',
        'show-hide-render-dock',
        'show-hide-tabs-dock',
        'show-tabs-dock',
        'clean-diff',
        'cm-external-editor',

        'delete-@button-parse-json-button',
        'delete-trace-statements',

        'disable-idle-time-events',
        'do-nothing',

        'enable-idle-time-events',
        'enter-quick-command-mode',
        'exit-named-mode',

        'F6-open-console',

        'flush-lines',
        'full-command',

        'get-child-headlines',

        'history',

        'insert-file-name',

        'justify-toggle-auto',

        'keep-lines',
        'keyboard-quit',

        'line-number',
        'line-numbering-toggle',
        'line-to-headline',

        'marked-list',

        'mode-help',

        'open-python-window',

        'open-with-idle',
        'open-with-open-office',
        'open-with-scite',
        'open-with-word',

        'recolor',
        'redraw',

        'repeat-complex-command',

        'session-clear',
        'session-create',
        'session-refresh',
        'session-restore',
        'session-snapshot-load',
        'session-snapshot-save',

        'set-colors',
        'set-command-state',
        'set-comment-column',
        'set-extend-mode',
        'set-fill-column',
        'set-fill-prefix',
        'set-font',
        'set-insert-state',
        'set-overwrite-state',
        'set-silent-mode',

        'show-buttons',
        'show-calltips',
        'show-calltips-force',
        'show-color-names',
        'show-color-wheel',
        'show-commands',
        'show-file-line',

        'show-focus',
        'show-fonts',

        'show-invisibles',
        'show-next-tip',
        'show-node-uas',
        'show-outline-dock',
        'show-plugin-handlers',
        'show-plugins-info',
        'show-settings',
        'show-settings-outline',
        'show-spell-info',
        'show-stats',

        'style-set-selected',

        'suspend',

        'toggle-abbrev-mode',
        'toggle-active-pane',
        'toggle-angle-brackets',
        'toggle-at-auto-at-edit',
        'toggle-autocompleter',
        'toggle-calltips',
        'toggle-case-region',
        'toggle-extend-mode',
        'toggle-idle-time-events',
        'toggle-input-state',
        'toggle-invisibles',
        'toggle-line-numbering-root',
        'toggle-sparse-move',
        'toggle-split-direction',

        'what-line',
        'eval',
        'eval-block',
        'eval-last',
        'eval-last-pretty',
        'eval-replace',

        'find-quick',
        'find-quick-changed',
        'find-quick-selected',
        'find-quick-test-failures',
        'find-quick-timeline',

        'goto-next-history-node',
        'goto-prev-history-node',

        'preview',
        'preview-body',
        'preview-expanded-body',
        'preview-expanded-html',
        'preview-html',
        'preview-marked-bodies',
        'preview-marked-html',
        'preview-marked-nodes',
        'preview-node',
        'preview-tree-bodies',
        'preview-tree-html',
        'preview-tree-nodes',

        'spell-add',
        'spell-as-you-type-next',
        'spell-as-you-type-toggle',
        'spell-as-you-type-undo',
        'spell-as-you-type-wrap',
        'spell-change',
        'spell-change-then-find',
        'spell-find',
        'spell-ignore',
        'spell-tab-hide',
        'spell-tab-open',

        'tag-children',

        'todo-children-todo',
        'todo-dec-pri',
        'todo-find-todo',
        'todo-fix-datetime',
        'todo-inc-pri',

        'vr',
        'vr-contract',
        'vr-expand',
        'vr-hide',
        'vr-lock',
        'vr-pause-play-movie',
        'vr-show',
        'vr-toggle',
        'vr-unlock',
        'vr-update',
        'vr-zoom',

        'vs-create-tree',
        'vs-dump',
        'vs-reset',
        'vs-update',
        # vs code's text editing commands should cover all of these...
        'add-comments',
        'add-space-to-lines',
        'add-tab-to-lines',
        'align-eq-signs',

        'back-char',
        'back-char-extend-selection',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'back-to-home',
        'back-to-home-extend-selection',
        'back-to-indentation',
        'back-word',
        'back-word-extend-selection',
        'back-word-smart',
        'back-word-smart-extend-selection',
        'backward-delete-char',
        'backward-delete-word',
        'backward-delete-word-smart',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'backward-kill-paragraph',
        'backward-kill-sentence',
        'backward-kill-word',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',

        'capitalize-word',
        'center-line',
        'center-region',
        'clean-all-blank-lines',
        'clean-all-lines',
        'clean-body',
        'clean-lines',
        'clear-kill-ring',
        'clear-selected-text',
        'convert-blanks',
        'convert-tabs',
        'copy-text',
        'cut-text',

        'delete-char',
        'delete-comments',
        'delete-indentation',
        'delete-spaces',
        'delete-word',
        'delete-word-smart',
        'downcase-region',
        'downcase-word',

        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'end-of-line',
        'end-of-line-extend-selection',

        'exchange-point-mark',

        'extend-to-line',
        'extend-to-paragraph',
        'extend-to-sentence',
        'extend-to-word',

        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',

        'finish-of-line',
        'finish-of-line-extend-selection',

        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'forward-word-smart',
        'forward-word-smart-extend-selection',

        'go-anywhere',
        'go-back',
        'go-forward',
        'goto-char',

        'indent-region',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',

        'insert-hard-tab',
        'insert-newline',
        'insert-parentheses',
        'insert-soft-tab',

        'kill-line',
        'kill-paragraph',
        'kill-pylint',
        'kill-region',
        'kill-region-save',
        'kill-sentence',
        'kill-to-end-of-line',
        'kill-word',
        'kill-ws',

        'match-brackets',

        'move-lines-down',
        'move-lines-up',
        'move-past-close',
        'move-past-close-extend-selection',

        'newline-and-indent',
        'next-line',
        'next-line-extend-selection',
        'next-or-end-of-line',
        'next-or-end-of-line-extend-selection',

        'previous-line',
        'previous-line-extend-selection',
        'previous-or-beginning-of-line',
        'previous-or-beginning-of-line-extend-selection',

        'rectangle-clear',
        'rectangle-close',
        'rectangle-delete',
        'rectangle-kill',
        'rectangle-open',
        'rectangle-string',
        'rectangle-yank',

        'remove-blank-lines',
        'remove-newlines',
        'remove-space-from-lines',
        'remove-tab-from-lines',

        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',

        'paste-text',
        'pop-cursor',
        'push-cursor',

        'select-all',
        'select-next-trace-statement',
        'select-to-matching-bracket',

        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',

        'split-defs',
        'split-line',

        'start-of-line',
        'start-of-line-extend-selection',

        'tabify',
        'transpose-chars',
        'transpose-lines',
        'transpose-words',

        'unformat-paragraph',
        'unindent-region',

        'untabify',

        'upcase-region',
        'upcase-word',
        'update-ref-file',

        'yank',
        'yank-pop',

        'zap-to-character',

    ]
    bad.extend(bad_list)
    result = list(sorted(bad))
    return result

</t>
<t tx="felix.20200924210112.1">def _good_commands(self):
    """Defined commands that definitely should be included in leoInteg."""
    good_list = [

        'contract-all',
        'contract-all-other-nodes',
        'clone-node',
        'copy-node',
        'copy-marked-nodes',
        'cut-node',

        'de-hoist',
        'delete-marked-nodes',
        'delete-node',
        'demangle-recent-files',
        'demote',

        'expand-and-go-right',
        'expand-next-level',
        'expand-node',
        'expand-or-go-right',
        'expand-prev-level',
        'expand-to-level-1',
        'expand-to-level-2',
        'expand-to-level-3',
        'expand-to-level-4',
        'expand-to-level-5',
        'expand-to-level-6',
        'expand-to-level-7',
        'expand-to-level-8',
        'expand-to-level-9',
        'expand-all',
        'expand-all-subheads',
        'expand-ancestors-only',

        'find-next-clone',

        'goto-first-node',
        'goto-first-sibling',
        'goto-first-visible-node',
        'goto-last-node',
        'goto-last-sibling',
        'goto-last-visible-node',
        'goto-next-changed',
        'goto-next-clone',
        'goto-next-marked',
        'goto-next-node',
        'goto-next-sibling',
        'goto-next-visible',
        'goto-parent',
        'goto-prev-marked',
        'goto-prev-node',
        'goto-prev-sibling',
        'goto-prev-visible',

        'hoist',

        'insert-node',
        'insert-node-before',
        'insert-as-first-child',
        'insert-as-last-child',
        'insert-child',

        'mark',
        'mark-changed-items',
        'mark-first-parents',
        'mark-subheads',

        'move-marked-nodes',
        'move-outline-down',
        'move-outline-left',
        'move-outline-right',
        'move-outline-up',

        'paste-node',
        'paste-retaining-clones',
        'promote',
        'promote-bodies',
        'promote-headlines',

        'sort-children',
        'sort-siblings',

        'tangle',
        'tangle-all',
        'tangle-marked',

        'unmark-all',
        'unmark-first-parents',
        'clean-main-spell-dict',
        'clean-persistence',
        'clean-recent-files',
        'clean-spellpyx',
        'clean-user-spell-dict',

        'clear-all-caches',
        'clear-all-hoists',
        'clear-all-uas',
        'clear-cache',
        'clear-node-uas',
        'clear-recent-files',

        'delete-first-icon',
        'delete-last-icon',
        'delete-node-icons',

        'dump-caches',
        'dump-clone-parents',
        'dump-expanded',
        'dump-node',
        'dump-outline',

        'insert-icon',

        'set-ua',

        'show-all-uas',
        'show-bindings',
        'show-clone-ancestors',
        'show-clone-parents',
        # Export files...
        'export-headlines',
        'export-jupyter-notebook',
        'outline-to-cweb',
        'outline-to-noweb',
        'remove-sentinels',
        'typescript-to-py',

        # Import files...
        'import-MORE-files',
        'import-file',
        'import-free-mind-files',
        'import-jupyter-notebook',
        'import-legacy-external-files',
        'import-mind-jet-files',
        'import-tabbed-files',
        'import-todo-text-files',
        'import-zim-folder',

        # Open specific files...
        # 'ekr-projects',
        'leo-cheat-sheet',  # These duplicates are useful.
        'leo-dist-leo',
        'leo-docs-leo',
        'leo-plugins-leo',
        'leo-py-leo',
        'leo-quickstart-leo',
        'leo-scripts-leo',
        'leo-settings',
        'leo-unittest-leo',
        'my-leo-settings',
        # 'scripts',
        'settings',

        'open-cheat-sheet-leo',
        'open-desktop-integration-leo',
        'open-leo-dist-leo',
        'open-leo-docs-leo',
        'open-leo-plugins-leo',
        'open-leo-py-leo',
        'open-leo-settings',
        'open-leo-settings-leo',
        'open-local-settings',
        'open-my-leo-settings',
        'open-my-leo-settings-leo',
        'open-quickstart-leo',
        'open-scripts-leo',
        'open-unittest-leo',

        # Open other places...
        'open-offline-tutorial',
        'open-online-home',
        'open-online-toc',
        'open-online-tutorials',
        'open-online-videos',
        'open-recent-file',
        'open-theme-file',
        'open-url',
        'open-url-under-cursor',
        'open-users-guide',

        # Read outlines...
        'read-at-auto-nodes',
        'read-at-file-nodes',
        'read-at-shadow-nodes',
        'read-file-into-node',
        'read-outline-only',
        'read-ref-file',

        # Save Files.
        'file-save',
        'file-save-as',
        'file-save-as-unzipped',
        'file-save-by-name',
        'file-save-to',
        'save',  # Some may not be needed.
        'save-all',
        'save-as',
        'save-file',
        'save-file-as',
        'save-file-as-unzipped',
        'save-file-as-zipped',
        'save-file-by-name',
        'save-file-to',
        'save-to',

        # Write parts of outlines...
        'write-at-auto-nodes',
        'write-at-file-nodes',
        'write-at-shadow-nodes',
        'write-dirty-at-auto-nodes',
        'write-dirty-at-file-nodes',
        'write-dirty-at-shadow-nodes',
        'write-edited-recent-files',
        'write-file-from-node',
        'write-missing-at-file-nodes',
        'write-outline-only',

        'clone-find-all',  # Should be overridden by leointeg
        'clone-find-all-flattened',   # Should be overridden by leointeg
        'clone-find-all-flattened-marked',
        'clone-find-all-marked',
        'clone-find-parents',
        'clone-find-tag',
        'clone-marked-nodes',
        'clone-node-to-last-node',
        'clone-to-at-spot',

        'edit-setting',
        'edit-shortcut',

        'execute-pytest',
        'execute-script',
        'extract',
        'extract-names',

        'goto-any-clone',
        'goto-global-line',
        'goto-line',
        'git-diff', 'gd',

        'log-kill-listener', 'kill-log-listener',
        'log-listen', 'listen-to-log',

        'make-stub-files',

        'pdb',

        'redo',  # Should be overridden by leointeg
        'rst3',
        'run-all-unit-tests-externally',
        'run-all-unit-tests-locally',
        'run-marked-unit-tests-externally',
        'run-marked-unit-tests-locally',
        'run-selected-unit-tests-externally',
        'run-selected-unit-tests-locally',
        'run-tests',

        'undo',  # Should be overridden by leointeg

        'xdb',
        # Beautify, blacken, fstringify...
        'beautify-files',
        'beautify-files-diff',
        'blacken-files',
        'blacken-files-diff',
        'diff-and-open-leo-files',
        'diff-beautify-files',
        'diff-fstringify-files',
        'diff-leo-files',
        'diff-marked-nodes',
        'fstringify-files',
        'fstringify-files-diff',
        'fstringify-files-silent',
        'pretty-print-c',
        'silent-fstringify-files',

        # All other commands...
        'at-file-to-at-auto',

        'beautify-c',

        'cls',
        'c-to-python',
        'c-to-python-clean-docs',
        'check-derived-file',
        'check-outline',
        'code-to-rst',
        'compare-two-leo-files',
        'convert-all-blanks',
        'convert-all-tabs',
        'count-children',
        'count-pages',
        'count-region',

        'desktop-integration-leo',

        'edit-recent-files',
        'exit-leo',

        'file-compare-two-leo-files',
        'find-def',
        'find-long-lines',
        'find-missing-docstrings',
        'flake8',
        'flatten-outline',
        'flatten-outline-to-node',
        'flatten-script',

        'gc-collect-garbage',
        'gc-dump-all-objects',
        'gc-dump-new-objects',
        'gc-dump-objects-verbose',
        'gc-show-summary',

        'help',  # To do.
        'help-for-abbreviations',
        'help-for-autocompletion',
        'help-for-bindings',
        'help-for-command',
        'help-for-creating-external-files',
        'help-for-debugging-commands',
        'help-for-drag-and-drop',
        'help-for-dynamic-abbreviations',
        'help-for-find-commands',
        'help-for-keystroke',
        'help-for-minibuffer',
        'help-for-python',
        'help-for-regular-expressions',
        'help-for-scripting',
        'help-for-settings',

        'insert-body-time',  # ?
        'insert-headline-time',
        'insert-jupyter-toc',
        'insert-markdown-toc',

        'find-var',

        'join-leo-irc',
        'join-node-above',
        'join-node-below',
        'join-selection-to-node-below',

        'move-lines-to-next-node',

        'new',

        'open-outline',

        'parse-body',
        'parse-json',
        'pandoc',
        'pandoc-with-preview',
        'paste-as-template',

        'print-body',
        'print-cmd-docstrings',
        'print-expanded-body',
        'print-expanded-html',
        'print-html',
        'print-marked-bodies',
        'print-marked-html',
        'print-marked-nodes',
        'print-node',
        'print-sep',
        'print-tree-bodies',
        'print-tree-html',
        'print-tree-nodes',
        'print-window-state',

        'pyflakes',
        'pylint',
        'pylint-kill',
        'python-to-coffeescript',

        'quit-leo',

        'reformat-body',
        'reformat-paragraph',
        'refresh-from-disk',
        'reload-all-settings',
        'reload-settings',
        'reload-style-sheets',
        'revert',

        'save-buffers-kill-leo',
        'screen-capture-5sec',
        'screen-capture-now',
        'script-button',  # ?
        'set-reference-file',
        'show-style-sheet',
        'sort-recent-files',
        'sphinx',
        'sphinx-with-preview',
        'style-reload',  # ?

        'untangle',
        'untangle-all',
        'untangle-marked',

        'view-lossage',  # ?

        'weave',

        # Dubious commands (to do)...
        'act-on-node',

        'cfa',  # Do we need abbreviations?
        'cfam',
        'cff',
        'cffm',
        'cft',

        'buffer-append-to',
        'buffer-copy',
        'buffer-insert',
        'buffer-kill',
        'buffer-prepend-to',
        'buffer-switch-to',
        'buffers-list',
        'buffers-list-alphabetically',

        'chapter-back',
        'chapter-next',
        'chapter-select',
        'chapter-select-main',
        'create-def-list',  # ?
    ]
    return good_list

</t>
<t tx="felix.20200924210952.1">def _getDocstringForCommand(self, command_name):
    """get docstring for the given command."""
    func = self._get_commander_method(command_name)
    docstring = func.__doc__ if func else ''
    return docstring

</t>
<t tx="felix.20200924211032.1">def setActionId(self, p_id):
    self.currentActionId = p_id

</t>
<t tx="felix.20200924211034.1">async def asyncOutput(self, p_json):
    '''Output json string to the websocket'''
    if self.webSocket:
        await self.webSocket.send(p_json)
    else:
        print("websocket not ready yet", flush=True)

</t>
<t tx="felix.20200924211037.1">def sendLeoBridgePackage(self, p_package={}):
    p_package["id"] = self.currentActionId
    return(json.dumps(p_package, separators=(',', ':')))  # send as json

</t>
<t tx="felix.20200924211041.1">def _outputError(self, p_message="Unknown Error"):
    # Output to this server's running console
    print("ERROR: " + p_message, flush=True)
    w_package = {"id": self.currentActionId}
    w_package["error"] = p_message
    return p_message

</t>
<t tx="felix.20200924211048.1">def _outputBodyData(self, p_bodyText=""):
    return self.sendLeoBridgePackage({"body": p_bodyText})

</t>
<t tx="felix.20200924211051.1">def _outputPNode(self, p_node=False):
    if p_node:
        # Single node, singular
        return self.sendLeoBridgePackage({"node": self._p_to_ap(p_node)})
    else:
        return self.sendLeoBridgePackage({"node": None})

</t>
<t tx="felix.20200924211054.1">def _outputPNodes(self, p_pList):
    w_apList = []
    for p in p_pList:
        w_apList.append(self._p_to_ap(p))
    # Multiple nodes, plural
    return self.sendLeoBridgePackage({"children": w_apList})

</t>
<t tx="felix.20200924211057.1">def mark_node(self, param):
    '''Mark a node, don't select it'''
    w_ap = param["ap"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            w_p.setMarked()
            # return selected node when done (not w_p)
            return self._outputPNode(self.commander.p)
        else:
            return self._outputError("Error in markPNode no w_p node found")
    else:
        return self._outputError("Error in markPNode no param node")

</t>
<t tx="felix.20200924211100.1">def unmark_node(self, param):
    '''Unmark a node, don't select it'''
    w_ap = param["ap"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            w_p.clearMarked()
            # return selected node when done (not w_p)
            return self._outputPNode(self.commander.p)
        else:
            return self._outputError("Error in unmarkPNode no w_p node found")
    else:
        return self._outputError("Error in unmarkPNode no param node")

</t>
<t tx="felix.20200924211104.1">def clone_node(self, param):
    '''Clone a node, return it, if it was also the current selection, otherwise try not to select it'''
    w_ap = param["ap"]
    if not w_ap:
        return self._outputError("Error in clonePNode function, no param p_ap")
    w_p = self._ap_to_p(w_ap)
    if not w_p:
        # default empty
        return self._outputError("Error in clonePNode function, no w_p node found")
    if w_p == self.commander.p:
        self.commander.clone()
    else:
        oldPosition = self.commander.p
        self.commander.selectPosition(w_p)
        self.commander.clone()
        if self.commander.positionExists(oldPosition):
            self.commander.selectPosition(oldPosition)
    # return selected node either ways
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924211121.1">def cut_node(self, param):
    '''Cut a node, don't select it. Try to keep selection, then return the selected node that remains'''
    w_ap = param["ap"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            if w_p == self.commander.p:
                self.commander.cutOutline()  # already on this node, so cut it
            else:
                oldPosition = self.commander.p  # not same node, save position to possibly return to
                self.commander.selectPosition(w_p)
                self.commander.cutOutline()
                if self.commander.positionExists(oldPosition):
                    # select if old position still valid
                    self.commander.selectPosition(oldPosition)
                else:
                    oldPosition._childIndex = oldPosition._childIndex-1
                    # Try again with childIndex decremented
                    if self.commander.positionExists(oldPosition):
                        # additional try with lowered childIndex
                        self.commander.selectPosition(oldPosition)
            # in both cases, return selected node
            return self._outputPNode(self.commander.p)
        else:
            # default empty
            return self._outputError("Error in cutPNode no w_p node found")
    else:
        return self._outputError("Error in cutPNode no param node")

</t>
<t tx="felix.20200924211125.1">def delete_node(self, param):
    '''Delete a node, don't select it. Try to keep selection, then return the selected node that remains'''
    w_ap = param["ap"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            if w_p == self.commander.p:
                self.commander.deleteOutline()  # already on this node, so delete it
            else:
                oldPosition = self.commander.p  # not same node, save position to possibly return to
                self.commander.selectPosition(w_p)
                self.commander.deleteOutline()
                if self.commander.positionExists(oldPosition):
                    # select if old position still valid
                    self.commander.selectPosition(oldPosition)
                else:
                    oldPosition._childIndex = oldPosition._childIndex-1
                    # Try again with childIndex decremented
                    if self.commander.positionExists(oldPosition):
                        # additional try with lowered childIndex
                        self.commander.selectPosition(oldPosition)
            # in both cases, return selected node
            return self._outputPNode(self.commander.p)
        else:
            # default empty
            return self._outputError("Error in deletePNode no w_p node found")
    else:
        return self._outputError("Error in deletePNode no param node")

</t>
<t tx="felix.20200924211127.1">def insert_node(self, param):
    '''Insert a node at given node, then select it once created, and finally return it'''
    w_ap = param["ap"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            w_bunch = self.commander.undoer.beforeInsertNode(w_p)
            w_newNode = w_p.insertAfter()
            w_newNode.setDirty()
            self.commander.undoer.afterInsertNode(
                w_newNode, 'Insert Node', w_bunch)
            self.commander.selectPosition(w_newNode)
            # in both cases, return selected node
            return self._outputPNode(self.commander.p)
        else:
            # default empty
            return self._outputError("Error in insertPNode no w_p node found")
    else:
        return self._outputError("Error in insertPNode no param node")

</t>
<t tx="felix.20200924211132.1">def insert_named_node(self, param):
    '''Insert a node at given node, set its headline, select it and finally return it'''
    w_newHeadline = param['name']
    w_ap = param["ap"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            w_bunch = self.commander.undoer.beforeInsertNode(w_p)
            w_newNode = w_p.insertAfter()
            # set this node's new headline
            w_newNode.h = w_newHeadline
            w_newNode.setDirty()
            self.commander.undoer.afterInsertNode(
                w_newNode, 'Insert Node', w_bunch)
            self.commander.selectPosition(w_newNode)
            # in any case, return selected node
            return self._outputPNode(self.commander.p)
        else:
            # default empty
            return self._outputError("Error in insertNamedPNode no w_p node found")
    else:
        return self._outputError("Error in insertNamedPNode no param node")

</t>
<t tx="felix.20200924211135.1">def undo(self, param):
    '''Undo last un-doable operation'''
    if self.commander.undoer.canUndo():
        self.commander.undoer.undo()
    # return selected node when done
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924211138.1">def redo(self, param):
    '''Undo last un-doable operation'''
    if self.commander.undoer.canRedo():
        self.commander.undoer.redo()
    # return selected node when done
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924223845.1"></t>
<t tx="felix.20200924223910.1"></t>
<t tx="felix.20200924223945.1"></t>
<t tx="felix.20200924224017.1"></t>
<t tx="felix.20200924224100.1"></t>
<t tx="felix.20200927213534.1">def _getScript(self, c, p,
               useSelectedText=True,
               forcePythonSentinels=True,
               useSentinels=True,
               ):
    """
    Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if
    p is not the current node or if there is no text selection.
    """
    w = c.frame.body.wrapper
    if not p:
        p = c.p
    try:
        if w and p == c.p and useSelectedText and w.hasSelection():
            s = w.getSelectedText()
        else:
            s = p.b
        # Remove extra leading whitespace so the user may execute indented code.
        s = self.g.removeExtraLws(s, c.tab_width)
        s = self.g.extractExecutableString(c, p, s)
        script = self.g.composeScript(c, p, s,
                                      forcePythonSentinels=forcePythonSentinels,
                                      useSentinels=useSentinels)
    except Exception:
        self.g.es_print("unexpected exception in g.getScript")
        self.g.es_exception()
        script = ''
    return script

</t>
<t tx="felix.20200927224639.1">def _outputSelectionData(self, p_bodySelection):
    return self.sendLeoBridgePackage({"bodySelection": p_bodySelection})

</t>
<t tx="felix.20200928004727.1">/**
 * * Handles detection of the active editor's selection change or cursor position
 * @param p_event a change event containing the active editor's selection, if any.
 */
private _onChangeEditorSelection(p_event: vscode.TextEditorSelectionChangeEvent): void {
    if (p_event.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        if (p_event.selections.length) {
            this._selectionDirty = true;
            this._selection = p_event.selections[0];
            this._selectionGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20200928133238.1">/**
 * * Saves the cursor position along with the text selection range and scroll position
 * @returns Promise that resolves when the "setSelection" action returns from Leo's side
 */
private _bodySaveSelection(): Promise&lt;boolean&gt; {
    if (this._selectionDirty &amp;&amp; this._selection) {
        // Prepare scroll data separately
        // ! TEST NEW SCROLL WITH SINGLE LINE NUMBER
        let w_scroll: number;
        if (this._selectionGnx === this._scrollGnx &amp;&amp; this._scrollDirty) {
            w_scroll = this._scroll?.start.line || 0;
        } else {
            w_scroll = 0;
        }
        // let w_scroll: { start: BodyPosition; end: BodyPosition; };
        // if (this._selectionGnx === this._scrollGnx &amp;&amp; this._scrollDirty) {
        //     w_scroll = {
        //         start: {
        //             line: this._scroll?.start.line || 0,
        //             col: this._scroll?.start.character || 0
        //         },
        //         end: {
        //             line: this._scroll?.end.line || 0,
        //             col: this._scroll?.end.character || 0
        //         }
        //     };
        // } else {
        //     w_scroll = {
        //         start: {
        //             line: 0, col: 0
        //         },
        //         end: {
        //             line: 0, col: 0
        //         }
        //     };
        // }
        // Send whole
        const w_param: BodySelectionInfo = {
            gnx: this._selectionGnx,
            scroll: w_scroll,
            insert: {
                line: this._selection.active.line || 0,
                col: this._selection.active.character || 0,
            },
            start: {
                line: this._selection.start.line || 0,
                col: this._selection.start.character || 0,
            },
            end: {
                line: this._selection.end.line || 0,
                col: this._selection.end.character || 0,
            },
        };
        // console.log("set scroll to leo: " + w_scroll + " start:" + this._selection.start.line);

        this._scrollDirty = false;
        this._selectionDirty = false; // don't wait for return of this call
        return this.sendAction(Constants.LEOBRIDGE.SET_SELECTION, JSON.stringify(w_param)).then(
            (p_result) =&gt; {
                return Promise.resolve(true);
            }
        );
    } else {
        return Promise.resolve(true);
    }
}

</t>
<t tx="felix.20200928174406.1">class IntegTextWrapper:
    """
    A class that represents text as a Python string.
    Modified from Leo's StringTextWrapper class source
    """

    @others

</t>
<t tx="felix.20200928174406.10">def getAllText(self):
    """IntegTextWrapper getAllText"""
    s = self.s
    # print("WRAPPER getAllText  " + s)
    return self.g.checkUnicode(s)

</t>
<t tx="felix.20200928174406.11">def getInsertPoint(self):
    """IntegTextWrapper getInsertPoint"""
    i = self.ins
    if i is None:
        if self.virtualInsertPoint is None:
            i = 0
        else:
            i = self.virtualInsertPoint
    self.virtualInsertPoint = i
    return i

</t>
<t tx="felix.20200928174406.12">def getSelectedText(self):
    """IntegTextWrapper getSelectedText"""
    i, j = self.sel
    s = self.s[i:j]
    # print("WRAPPER getSelectedText with self.s[i:j]: " + s)
    return self.g.checkUnicode(s)

</t>
<t tx="felix.20200928174406.13">def getSelectionRange(self, sort=True):
    """Return the selected range of the widget."""
    sel = self.sel
    if len(sel) == 2 and sel[0] &gt;= 0 and sel[1] &gt;= 0:
        i, j = sel
        if sort and i &gt; j:
            sel = j, i  # Bug fix: 10/5/07
        return sel
    i = self.ins
    return i, i

</t>
<t tx="felix.20200928174406.14">def hasSelection(self):
    """IntegTextWrapper hasSelection"""
    i, j = self.getSelectionRange()
    return i != j

</t>
<t tx="felix.20200928174406.15">def insert(self, i, s):
    """IntegTextWrapper insert"""
    i = self.toPythonIndex(i)
    s1 = s
    self.s = self.s[:i] + s1 + self.s[i:]
    i += len(s1)
    self.ins = i
    self.sel = i, i

</t>
<t tx="felix.20200928174406.16">def selectAllText(self, insert=None):
    """IntegTextWrapper selectAllText"""
    self.setSelectionRange(0, 'end', insert=insert)

</t>
<t tx="felix.20200928174406.17">def setAllText(self, s):
    """IntegTextWrapper setAllText"""
    # print("WRAPPER setAllText: " + s)
    self.s = s
    i = len(self.s)
    self.ins = i
    self.sel = i, i

</t>
<t tx="felix.20200928174406.18">def setInsertPoint(self, pos, s=None):
    """IntegTextWrapper setInsertPoint"""
    self.virtualInsertPoint = i = self.toPythonIndex(pos)
    self.ins = i
    self.sel = i, i

</t>
<t tx="felix.20200928174406.19">def setSelectionRange(self, i, j, insert=None):
    """IntegTextWrapper setSelectionRange"""
    i, j = self.toPythonIndex(i), self.toPythonIndex(j)
    self.sel = i, j
    self.ins = j if insert is None else self.toPythonIndex(insert)

</t>
<t tx="felix.20200928174406.2">def __init__(self, c, name, g):
    """Ctor for the IntegTextWrapper class."""
    self.c = c
    self.name = name
    self.g = g  # Should g be totally global across all leoIntegration classes?
    self.ins = 0
    self.sel = 0, 0
    self.s = ''
    self.yScroll = 0
    self.supportsHighLevelInterface = True
    self.widget = None  # This ivar must exist, and be None.

def __repr__(self):
    return f"&lt;IntegTextWrapper: {id(self)} {self.name}&gt;"

def getName(self):
    """IntegTextWrapper."""
    return self.name  # Essential.

</t>
<t tx="felix.20200928174406.20">def toPythonIndex(self, index):
    """IntegTextWrapper toPythonIndex"""
    return self.g.toPythonIndex(self.s, index)

</t>
<t tx="felix.20200928174406.21">def toPythonIndexRowCol(self, index):
    """IntegTextWrapper toPythonIndexRowCol"""
    s = self.getAllText()
    i = self.toPythonIndex(index)
    row, col = self.g.convertPythonIndexToRowCol(s, i)
    return i, row, col

</t>
<t tx="felix.20200928174406.3">def clipboard_clear(self):
    self.g.app.gui.replaceClipboardWith('')

def clipboard_append(self, s):
    s1 = self.g.app.gui.getTextFromClipboard()
    self.g.app.gui.replaceClipboardWith(s1 + s)

</t>
<t tx="felix.20200928174406.4">def flashCharacter(self, i, bg='white', fg='red',
                   flashes=3, delay=75): pass

def see(self, i): pass

def seeInsertPoint(self): pass

def setFocus(self): pass

def setStyleClass(self, name): pass

def tag_configure(self, colorName, **keys): pass

</t>
<t tx="felix.20200928174406.5"></t>
<t tx="felix.20200928174406.6">def appendText(self, s):
    """IntegTextWrapper appendText"""
    self.s = self.s + self.g.toUnicode(s)
    # defensive
    self.ins = len(self.s)
    self.sel = self.ins, self.ins

</t>
<t tx="felix.20200928174406.7">def delete(self, i, j=None):
    """IntegTextWrapper delete"""
    i = self.toPythonIndex(i)
    if j is None:
        j = i + 1
    j = self.toPythonIndex(j)
    # This allows subclasses to use this base class method.
    if i &gt; j:
        i, j = j, i
    s = self.getAllText()
    self.setAllText(s[:i] + s[j:])
    # Bug fix: 2011/11/13: Significant in external tests.
    self.setSelectionRange(i, i, insert=i)

</t>
<t tx="felix.20200928174406.8">def deleteTextSelection(self):
    """IntegTextWrapper."""
    i, j = self.getSelectionRange()
    self.delete(i, j)

</t>
<t tx="felix.20200928174406.9">def get(self, i, j=None):
    """IntegTextWrapper get"""
    i = self.toPythonIndex(i)
    if j is None:
        j = i + 1
    j = self.toPythonIndex(j)
    s = self.s[i:j]
    # print("WRAPPER GET with self.s[i:j]: " + s)
    return self.g.toUnicode(s)

</t>
<t tx="felix.20200929215102.3">def page_up(self, param):
    """Selects a node a couple of steps up in the tree to simulate page up"""
    n = param.get("n", 3)
    for z in range(n):
        self.commander.selectVisBack()
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200929215102.4">def page_down(self, param):
    """Selects a node a couple of steps down in the tree to simulate page down"""
    n = param.get("n", 3)
    for z in range(n):
        self.commander.selectVisNext()
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200929215102.5">def get_body_states(self, p_ap):
    """
    Finds the language in effect at top of body for position p,
    return type is lowercase 'language' non-empty string.
    Also returns the saved cursor position from last time node was accessed.

    The cursor positions are given as {"line": line, "col": col, "index": i}
    with line and col along with a redundant index for convenience and flexibility.
    """
    if not p_ap:
        return self._outputError("Error in getLanguage, no param p_ap")

    w_p = self._ap_to_p(p_ap)
    if not w_p:
        print(
            "in GBS -&gt; P NOT FOUND gnx:" + p_ap['gnx'] + " using self.commander.p gnx: " + self.commander.p.v.gnx)
        w_p = self.commander.p

    w_wrapper = self.commander.frame.body.wrapper

    defaultPosition = {"line": 0, "col": 0, "index": 0}
    states = {
        'language': 'plain',
        # See BodySelectionInfo interface in types.d.ts
        'selection': {
            "gnx": w_p.v.gnx,
            "scroll": 0,
            # "scroll": {
            #     "start": defaultPosition,
            #     "end": defaultPosition
            # },
            "insert": defaultPosition,
            "start": defaultPosition,
            "end": defaultPosition
        }
    }

    if w_p:
        c, g = self.commander, self.g
        aList = g.get_directives_dict_list(w_p)
        d = g.scanAtCommentAndAtLanguageDirectives(aList)

        language = (
            d and d.get('language') or
            g.getLanguageFromAncestorAtFileNode(w_p) or
            c.config.getString('target-language') or
            'plain'
        )

        if w_p.v.scrollBarSpot is None:
            w_scroll = 0
        else:
            w_scroll = w_p.v.scrollBarSpot

        if w_p.v.insertSpot is None:
            w_active = 0
        else:
            w_active = w_p.v.insertSpot
        if w_p.v.selectionStart is None:
            w_start = 0
        else:
            w_start = w_p.v.selectionStart

        if w_p.v.selectionLength is None:
            w_length = 0
        else:
            w_length = w_p.v.selectionLength

        w_end = w_start + w_length

        # get selection from wrapper instead if its the selected node
        if self.commander.p.v.gnx == w_p.v.gnx:
            # print("in GBS -&gt; SAME AS self.commander.p SO USING FROM WRAPPER")
            w_active = w_wrapper.getInsertPoint()
            w_start, w_end = w_wrapper.getSelectionRange(True)
            w_scroll = w_wrapper.getYScrollPosition()

            w_activeI, w_activeRow, w_activeCol = c.frame.body.wrapper.toPythonIndexRowCol(
                w_active)
            w_startI, w_startRow, w_startCol = c.frame.body.wrapper.toPythonIndexRowCol(
                w_start)
            w_endI, w_endRow, w_endCol = c.frame.body.wrapper.toPythonIndexRowCol(
                w_end)
        else:
            print("NOT SAME AS self.commander.p SO USING FROM w_p.v")
            w_activeI, w_startI, w_endI = w_active, w_start, w_end
            w_activeRow, w_activeCol = g.convertPythonIndexToRowCol(
                w_p.v.b, w_active)
            w_startRow, w_startCol = g.convertPythonIndexToRowCol(
                w_p.v.b, w_start)
            w_endRow, w_endCol = g.convertPythonIndexToRowCol(
                w_p.v.b, w_end)

        states = {
            'language': language.lower(),
            'selection': {
                "gnx": w_p.v.gnx,
                "scroll": w_scroll,  # w_scroll was kept as-is ?
                "insert": {"line": w_activeRow, "col": w_activeCol, "index": w_activeI},
                "start": {"line": w_startRow, "col": w_startCol, "index": w_startI},
                "end": {"line": w_endRow, "col": w_endCol, "index": w_endI}
            }
        }
    return self.sendLeoBridgePackage(states)

</t>
<t tx="felix.20200929230231.1">def set_selection(self, param):
    '''
    Set cursor position and scroll position along with selection start and end.

    Positions can be sent as {"col":int, "line" int} dict
    or as numbers directly for convenience.

    (For the currently selected node's body, if gnx matches only)
    Save those values on the commander's body "wrapper"
    See BodySelectionInfo interface in types.d.ts
    '''
    w_same = False  # Flag for actually setting values in the wrapper, if same gnx.
    w_wrapper = self.commander.frame.body.wrapper
    w_gnx = param['gnx']
    w_body = ""
    w_v = None
    if self.commander.p.v.gnx == w_gnx:
        # print('Set Selection! OK SAME GNX: ' + self.commander.p.v.gnx)
        w_same = True
        w_v = self.commander.p.v
    else:
        # ? When navigating rapidly - Check if this is a bug - how to improve
        print('Set Selection! NOT SAME GNX: selected:' +
              self.commander.p.v.gnx + ', package:' + w_gnx)
        w_v = self.commander.fileCommands.gnxDict.get(w_gnx)

    if not w_v:
        print('ERROR : Set Selection! NOT SAME Leo Document')
        # ! FAILED (but return as normal)
        return self._outputPNode(self.commander.p)

    w_body = w_v.b
    f_convert = self.g.convertRowColToPythonIndex
    w_active = param['insert']
    w_start = param['start']
    w_end = param['end']

    # no convertion necessary, its given back later
    w_scroll = param['scroll']

    # IF sent as number use as is - no conversion needed
    if type(w_active) == int:
        w_insert = w_active
        w_startSel = w_start
        w_endSel = w_end
    else:
        w_insert = f_convert(
            w_body, w_active['line'], w_active['col'])
        w_startSel = f_convert(
            w_body, w_start['line'], w_start['col'])
        w_endSel = f_convert(
            w_body, w_end['line'], w_end['col'])

    # print("setSelection (same as selected): " + str(w_same) + " w_insert " + str(w_insert) +
    #       " w_startSel " + str(w_startSel) + " w_endSel " + str(w_endSel))

    # If it's the currently selected node set the wrapper's states too

    if w_same:
        w_wrapper.setSelectionRange(w_startSel, w_endSel, w_insert)
        w_wrapper.setYScrollPosition(w_scroll)
    else:
        pass

    # Set for v node no matter what
    w_v.scrollBarSpot = w_scroll
    w_v.insertSpot = w_insert
    w_v.selectionStart = w_startSel
    w_v.selectionLength = (
        w_endSel - w_startSel) if w_endSel &gt; w_startSel else 0

    # When switching nodes, Leo's core saves the insert point, selection,
    # and vertical scroll position in the old (unselected) vnode. From v.init:

    # self.insertSpot = None
    #     # Location of previous insert point.
    # self.scrollBarSpot = None
    #     # Previous value of scrollbar position.
    # self.selectionLength = 0
    #     # The length of the selected body text.
    # self.selectionStart = 0
    #         # The start of the selected body text.

    # output selected node as 'ok'
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20201006195046.1">/**
 * * LeoBody cursor active position and text selection state, along with gnx
 */
export interface BodySelectionInfo {
    gnx: string;
    // scroll is stored as-is as the 'scrollBarSpot' in Leo
    // ! TEST scroll as single number only (for Leo vertical scroll value)
    scroll: number;
    // scroll: {
    //     start: BodyPosition;
    //     end: BodyPosition;
    // }
    insert: BodyPosition;
    start: BodyPosition;
    end: BodyPosition;
}

</t>
<t tx="felix.20201014020145.1">/**
 * * Handles detection of the active editor's scroll position changes
 * @param p_event a change event containing the active editor's visible range, if any.
 */
private _onChangeEditorScroll(p_event: vscode.TextEditorVisibleRangesChangeEvent): void {
    if (p_event.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        if (p_event.visibleRanges.length) {
            this._scrollDirty = true;
            this._scroll = p_event.visibleRanges[0];
            this._scrollGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20201017224340.1">/**
 * * Structure for configuration settings changes used along with welcome/settings webview.
 */
export interface ConfigSetting {
    code: string;
    value: any;
}

</t>
<t tx="felix.20201018163510.1">/**
 * * Returns the milliseconds between a given starting process.hrtime tuple and the current call to process.hrtime
 * @param p_start starting process.hrtime to subtract from current immediate time
 * @returns number of milliseconds passed since the given start hrtime
 */
export function getDurationMs(p_start: [number, number]): number {
    const [w_secs, w_nanosecs] = process.hrtime(p_start);
    return w_secs * 1000 + Math.floor(w_nanosecs / 1000000);
}

</t>
<t tx="felix.20201025144113.1">def test(self, param):
    '''Utility test function for debugging'''
    print("Called test")
    return self.sendLeoBridgePackage({'testReturnedKey': 'testReturnedValue'})
    # return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20201028223434.1">def setXScrollPosition(self, i):
    pass
    # X axis ignored

</t>
<t tx="felix.20201028223533.1">def getXScrollPosition(self):
    return 0
    # X axis ignored

</t>
<t tx="felix.20201102223046.1">def setYScrollPosition(self, i):
    self.yScroll = i
    # print("wrapper set y scroll" + str(self.yScroll))

</t>
<t tx="felix.20201102223052.1">def getYScrollPosition(self):
    # print("wrapper get y scroll" + str(self.yScroll))
    return self.yScroll

</t>
<t tx="felix.20201103000337.1">/**
 * * Table for converting Leo languages names for the currently opened body pane
 * Used in showBody method of leoIntegration.ts
 */
public static LANGUAGE_CODES: { [key: string]: string | undefined } = {
    cplusplus: 'cpp',
    md: 'markdown'
};

</t>
<t tx="felix.20201105010253.1">{
  "command": "leointeg.extract",
  "key": "ctrl+shift+d",
  "mac": "cmd+shift+d",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.extract",
  "key": "ctrl+shift+d",
  "mac": "cmd+shift+d",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.extractNames",
  "key": "ctrl+shift+n",
  "mac": "cmd++shift+n",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.extractNames",
  "key": "ctrl+shift+n",
  "mac": "cmd+shift+n",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
</t>
<t tx="felix.20201105010614.1">{
  "command": "leointeg.extract",
  "category": "Leo",
  "title": "Extract"
},
{
  "command": "leointeg.extractNames",
  "category": "Leo",
  "title": "Extract Names"
},
</t>
<t tx="felix.20201106200100.1">/**
 * * Performs the actual addition into globalState context
 * @param p_context Needed to get to vscode global storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the global storage modification is done
 */
export function addFileToGlobal(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Just push that string into the context.globalState.&lt;something&gt; array
    const w_contextEntry: string[] = p_context.globalState.get(p_key) || [];
    if (w_contextEntry) {
        if (!w_contextEntry.includes(p_file)) {
            w_contextEntry.push(p_file);
            if (w_contextEntry.length &gt; 10) {
                w_contextEntry.shift();
            }
        }
        return p_context.globalState.update(p_key, w_contextEntry); // Added file
    } else {
        // First so create key entry with an array of single file
        return p_context.globalState.update(p_key, [p_file]);
    }
}

</t>
<t tx="felix.20201106200109.1">/**
 * * Removes file entry from globalState context
 * @param p_context Needed to get to vscode global storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the global storage modification is done
  */
export function removeFileFromGlobal(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Check if exist in context.globalState.&lt;something&gt; and remove if found
    const w_files: string[] = p_context.globalState.get(p_key) || [];
    if (w_files &amp;&amp; w_files.includes(p_file)) {
        w_files.splice(w_files.indexOf(p_file), 1); // Splice and update
        return p_context.globalState.update(p_key, w_files);
    }
    return Promise.resolve(); // not even in list so just resolve
}

</t>
<t tx="felix.20201107224112.1">/**
 * * Promise that triggers body save (rejects if busy), and resolves when done
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the possible saving process is finished
 */
private _isBusyTriggerSave(p_all: boolean, p_forcedVsCodeSave?: boolean): Promise&lt;boolean&gt; {
    if (this._isBusy(p_all)) {
        return Promise.reject('Command stack busy'); // Warn user to wait for end of busy state
    }
    return this.triggerBodySave(p_forcedVsCodeSave);
}

</t>
<t tx="felix.20201114185218.1">/**
 * * Sets the outline pane top bar string message or refreshes with existing title if no title passed
 * @param p_title new string to replace the current title
 */
public setTreeViewTitle(p_title?: string): void {
    if (p_title) {
        this._currentOutlineTitle = p_title;
    }
    // * Set/Change outline pane title e.g. "INTEGRATION", "OUTLINE"
    if (this._leoTreeView) {
        this._leoTreeView.title = this._currentOutlineTitle;
    }
    if (this._leoTreeExView) {
        this._leoTreeExView.title =
            Constants.GUI.EXPLORER_TREEVIEW_PREFIX + this._currentOutlineTitle;
    }
}

</t>
<t tx="felix.20201114185813.1">/**
 * * Opens quickPick minibuffer pallette to choose from all commands in this file's commander
 * @returns Promise that resolves when the chosen command is placed on the front-end command stack
 */
public minibuffer(): Thenable&lt;LeoBridgePackage | undefined&gt; {
    // Wait for _isBusyTriggerSave resolve because the full body save may change available commands
    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {
            const q_commandList: Thenable&lt;MinibufferCommand[]&gt; = this.sendAction(
                Constants.LEOBRIDGE.GET_COMMANDS,
                JSON.stringify({ name: '' })
            ).then((p_result: LeoBridgePackage) =&gt; {
                if (p_result.commands &amp;&amp; p_result.commands.length) {
                    return p_result.commands;
                } else {
                    return [];
                }
            });
            const w_options: vscode.QuickPickOptions = {
                placeHolder: Constants.USER_MESSAGES.MINIBUFFER_PROMPT,
                matchOnDetail: true,
            };
            return vscode.window.showQuickPick(q_commandList, w_options);
        })
        .then((p_picked) =&gt; {
            if (
                p_picked &amp;&amp;
                p_picked.label &amp;&amp;
                Constants.MINIBUFFER_OVERRIDDEN_COMMANDS[p_picked.label]
            ) {
                return vscode.commands.executeCommand(
                    Constants.MINIBUFFER_OVERRIDDEN_COMMANDS[p_picked.label]
                );
            }
            if (p_picked &amp;&amp; p_picked.func) {
                const w_commandResult = this.nodeCommand({
                    action: p_picked.func,
                    node: undefined,
                    refreshType: {
                        tree: true,
                        body: true,
                        documents: true,
                        buttons: true,
                        states: true,
                    },
                    fromOutline: false, // true // TODO : Differentiate from outline?
                });
                return w_commandResult ? w_commandResult : Promise.reject('Command not added');
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20201119002510.1">/**
 * * Body position
 * Used in BodySelectionInfo interface
 */
export interface BodyPosition {
    line: number;
    col: number;
}

</t>
<t tx="felix.20201126235315.1">/**
 * * Strings used in 'at-button' panel display in LeoButtonNode
 */
public static BUTTON_STRINGS = {
    NULL_WIDGET: "nullButtonWidget",
    SCRIPT_BUTTON: "script-button",
    ADD_BUTTON: "leoButtonAdd",
    NORMAL_BUTTON: "leoButtonNode"
};

</t>
<t tx="felix.20201129184357.1">def printAction(param):
    '''Debugging tool that prints out called action if not in 'common-action' array'''
    w_action = param["action"]
    # print action if not getChild or getChildren or some other very common action
    if w_action in commonActions:
        pass
    else:
        print(f"*ACTION* {w_action}, id {param['id']}", flush=True)


</t>
<t tx="felix.20201208235246.1">/**
 * * Command strings to be used with vscode.commands.executeCommand
 * See https://code.visualstudio.com/api/extension-guides/command#programmatically-executing-a-command
 */
public static VSCODE_COMMANDS = {
    SET_CONTEXT: "setContext",
    CLOSE_ACTIVE_EDITOR: "workbench.action.closeActiveEditor",
    QUICK_OPEN: "workbench.action.quickOpen"
};

</t>
<t tx="felix.20201215210439.1">"view/title": [
  {
    "command": "leointeg.openLeoFile",
    "when": "view =~ /leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "view =~ /leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.showSettingsPage",
    "when": "view =~ /leoIntegration/ &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.clearRecentFiles",
    "when": "view =~ /leoIntegration/ &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.connectToServer",
    "when": "view =~ /leoIntegration/ &amp;&amp; !leoBridgeReady &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.openLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoTreeTitled &amp;&amp; leoChanged",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.undoFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanUndo",
    "group": "navigation@3"
  },
  {
    "command": "leointeg.undoDisabled",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoCanUndo",
    "group": "navigation@3"
  },
  {
    "command": "leointeg.redoFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanRedo",
    "group": "navigation@4"
  },
  {
    "command": "leointeg.redoDisabled",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoCanRedo",
    "group": "navigation@4"
  },
  {
    "command": "leointeg.deHoistFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanDehoist",
    "group": "navigation@5"
  },
  {
    "command": "leointeg.contractAllFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened",
    "group": "navigation@6"
  }
],
</t>
<t tx="felix.20201215210510.1">"view/item/context": [
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "viewItem =~ /leoDocumentSelectedTitled/ &amp;&amp; leoChanged",
    "group": "inline@1"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "viewItem =~ /leoDocumentSelectedUntitled/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.closeLeoFile",
    "when": "viewItem =~ /leoDocumentSelected/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.editHeadline",
    "when": "showEditOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.insertNode",
    "when": "showAddOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.moveOutlineDown",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineLeft",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineRight",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineUp",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.copyNode",
    "when": "showCopyOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "showCloneOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.mark",
    "when": "showMarkOnNodes &amp;&amp; viewItem =~ /leoNodeUnmarked/",
    "group": "inline@5"
  },
  {
    "command": "leointeg.unmark",
    "when": "showMarkOnNodes &amp;&amp; viewItem =~ /leoNodeMarked/",
    "group": "inline@5"
  },
  {
    "command": "leointeg.openAside",
    "when": "showOpenAside &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext1@1"
  },
  {
    "command": "leointeg.hoistNode",
    "when": "viewItem =~ /leoNodeNotRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.deHoist",
    "when": "leoCanDehoist &amp;&amp; viewItem =~ /leoNodeRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.refreshFromDisk",
    "when": "viewItem =~ /leoNodeAtFile/",
    "group": "leoNodeContext1@3"
  },
  {
    "command": "leointeg.mark",
    "when": "viewItem =~ /leoNodeUnmarked/",
    "group": "leoNodeContext2@1"
  },
  {
    "command": "leointeg.unmark",
    "when": "viewItem =~ /leoNodeMarked/",
    "group": "leoNodeContext2@2"
  },
  {
    "command": "leointeg.copyNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@3"
  },
  {
    "command": "leointeg.cutNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@4"
  },
  {
    "command": "leointeg.pasteNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@5"
  },
  {
    "command": "leointeg.pasteNodeAsClone",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@6"
  },
  {
    "command": "leointeg.delete",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@7"
  },
  {
    "command": "leointeg.insertNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext3@1"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext3@2"
  },
  {
    "command": "leointeg.gotoNextClone",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNodeCloned/",
    "group": "leoNodeContext3@3"
  },
  {
    "command": "leointeg.removeButton",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoButtonNode/",
    "group": "leoButtonContext1@1"
  }
]
</t>
<t tx="felix.20210418013332.1">private _hideDeleteBody(p_textEditor: vscode.TextEditor): void {
    console.log('DELETE EXTRANEOUS:', p_textEditor.document.uri.fsPath);
    const w_edit = new vscode.WorkspaceEdit();
    w_edit.deleteFile(p_textEditor.document.uri, { ignoreIfNotExists: true });
    if (p_textEditor.hide) {
        p_textEditor.hide();
    }
    vscode.commands.executeCommand(
        'vscode.removeFromRecentlyOpened',
        p_textEditor.document.uri.path
    );
}

</t>
<t tx="felix.20210418014039.1">/**
 * * Moved a document to another column
 */
public _changedTextEditorViewColumn(
    p_columnChangeEvent: vscode.TextEditorViewColumnChangeEvent
): void {
    if (p_columnChangeEvent &amp;&amp; p_columnChangeEvent.textEditor.document.uri.scheme === 'more') {
        this._checkPreviewMode(p_columnChangeEvent.textEditor);
    }
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20210418014040.1">/**
 * * Tabbed on another editor
 */
public _changedVisibleTextEditors(p_editors: vscode.TextEditor[]): void {
    if (p_editors &amp;&amp; p_editors.length) {
        p_editors.forEach((p_textEditor) =&gt; {
            if (p_textEditor &amp;&amp; p_textEditor.document.uri.scheme === 'more') {
                if (this.bodyUri.fsPath !== p_textEditor.document.uri.fsPath) {
                    this._hideDeleteBody(p_textEditor);
                }
                this._checkPreviewMode(p_textEditor);
            }
        });
    }
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20210418014040.2">/**
 * * Whole window has been minimized/restored
 */
public _changedWindowState(p_windowState: vscode.WindowState): void {
    // no other action
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20210418220343.1">private _checkPreviewMode(p_editor: vscode.TextEditor): void {
    // if selected gnx but in another column
    if (
        p_editor.document.uri.fsPath === this.bodyUri.fsPath &amp;&amp;
        p_editor.viewColumn !== this._bodyMainSelectionColumn
    ) {
        this._bodyPreviewMode = false;
        this._bodyMainSelectionColumn = p_editor.viewColumn;
    }
}

</t>
<t tx="felix.20210418230204.1">private _findUriColumn(p_uri: vscode.Uri): vscode.ViewColumn | undefined {
    let w_column: vscode.ViewColumn | undefined;
    vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
        if (p_textEditor.document.uri.fsPath === p_uri.fsPath) {
            w_column = p_textEditor.viewColumn;
        }
    });
    return w_column;
}

</t>
<t tx="felix.20210418230204.2">private findGnxColumn(p_gnx: string): vscode.ViewColumn | undefined {
    let w_column: vscode.ViewColumn | undefined;
    vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
        if (p_textEditor.document.uri.fsPath.substr(1) === p_gnx) {
            w_column = p_textEditor.viewColumn;
        }
    });
    return w_column;
}

</t>
<t tx="felix.20210509210502.1">## 0.1.13

- Added support for precise focus placement, focus switch between tree/body.
- Made the extension more aware of the current selection state, to have strictly relevant buttons visible shown only.
- Made the 'edit headline' hover icon removable, in order to enable 'Tab' keybinding to go from tree to body directly.
- Added commands and keybindings for 'goto' operations 'hoist/dehoist' [#25](https://github.com/boltex/leointeg/issues/25) and other commands. [#30](https://github.com/boltex/leointeg/issues/30)
- Added support for Leo-Style outline navigation. [#43](https://github.com/boltex/leointeg/issues/43) Has to be enabled with an option in the config settings: "Use Leo Tree Browsing" which makes the arrow keys, pgUp/pgDn, home/end move the selection instead of a cursor when focus is on Leo's outline.
- Implemented @buttons in it's own panel, visible where the already existing 'outline' and 'opened leo documents' panels reside.
- Added (basic) unknown attributes support as hover tooltip and small description on node headlines.
- Added a 'leoBridge Server Terminal Panel' to gather output of the leoBridge stdOut pipe. It's displayed among the 'output panels', along with the standard 'leo log window', when the server is started by leoInteg. (either with the auto-start config setting, or by calling the 'start server' command via buttons or the command-palette.)
- Syntax coloring and Snippets are now enabled for those languages : C, C++, CSS, HTML, Java, Javascript, json, Markdown, PHP, Python, Rust and Typescript. They are taken from the default extension for that language, or if non-existent, from the most popular extension for that language
- Recent files are now remembered and restored upon re-opening vscode.
- Leo files can be opened from the explorer pane directly.
- Added 'minibuffer' feature with the usual alt-x command from Leo.
- Added cursor position, selected range and scrolling position to be captured and restored when navigating the outline. [#39](https://github.com/boltex/leointeg/issues/39) This allows for commands that use the currently selected text, [#61](https://github.com/boltex/leointeg/issues/61) such as run script and extract/extract name, etc.
- Redid the body display and switching logic to support new vscode API features. (vscode now does not block 'undo' operations between file-rename operations, which were used to switch body pane content.)

</t>
<t tx="felix.20210512000301.1">def get_focus(self, param):
    """
    Return a representation of the focused widget,
    one of ("body", "tree", "headline", repr(the_widget)).
    """
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    return self.sendLeoBridgePackage({"focus": focus})

</t>
<t tx="felix.20210516004048.1"># Found 3 marked nodes</t>
<t tx="felix.20210516004048.10">def open_file(self, param):
    """
    Open a leo file with the given filename.
    Create a new document if no name.
    """
    found, tag = False, 'open_file'
    filename = param.get('filename')  # Optional.
    if filename:
        for c in g.app.commanders():
             if c.fileName() == filename:
                found = True
    if not found:
        c = self.bridge.openLeoFile(filename)
        c.findCommands.ftm = StringFindTabManager(c)
    if not c:  # pragma: no cover
        raise ServerError(f"{tag}: bridge did not open {filename!r}")
    if not c.frame.body.wrapper:  # pragma: no cover
        raise ServerError(f"{tag}: no wrapper")
    # Assign self.c
    self.c = c
    c.selectPosition(c.rootPosition())  # Required.
    # Check the outline!
    self._check_outline(c)
    if self.log_flag:  # pragma: no cover
        self._dump_outline(c)

    result = {"total": len(g.app.commanders()), "filename": self.c.fileName()}

    return self._make_response(result)
</t>
<t tx="felix.20210516004048.11">def open_files(self, param):
    """
    Opens an array of leo files.
    Returns an object with total opened files
    and name of currently last opened &amp; selected document.
    """
    tag = 'open_files'
    files = param.get('files')  # Optional.
    if files:
        for i_file in files:
            if os.path.isfile(i_file):
                self.open_file({"filename": i_file})
    total = len(g.app.commanders())
    filename = self.c.fileName() if total else ""
    result = {"total": total, "filename": filename}
    return self._make_response(result)
</t>
<t tx="felix.20210516004048.12">def set_opened_file(self, param):
    '''
    Choose the new active commander from array of opened files.
    Returns an object with total opened files
    and name of currently last opened &amp; selected document.
    '''
    tag = 'set_opened_file'
    index = param.get('index')
    total = len(g.app.commanders())
    if total and w_index &lt; total:
        self.c = g.app.commanders()[w_index]
        # maybe needed for frame wrapper
        self.c.selectPosition(self.c.p)
        self._check_outline(self.c)
        result = {"total": total, "filename": self.c.fileName()}
        return self._make_response(result)
    else:
        raise ServerError(f"{tag}: commander at index {index} does not exist")
</t>
<t tx="felix.20210516004048.13">def close_file(self, param):
    """
    Closes an outline opened with open_file.
    Use a 'forced' flag to force close.
    Returns a 'total' member in the package if close is successful.
    """
    tag = 'close_file'
    c = self._check_c()
    if c:
        # First, revert to prevent asking user.
        if param["forced"] and c.changed:
            c.revert()
        # Then, if still possible, close it.
        if param["forced"] or not c.changed:
            # c.closed = True # maybe useless flag from leobridgeserver,py
            c.close()
        else:
            # Cannot close, return empty response without 'total' (ask to save, ignore or cancel) 
            return self._make_response()

    # Select the first open outline, if any.
    commanders = g.app.commanders()
    self.c = commanders and commanders[0] or None

    if self.c:
        w_result = {"total": len(g.app.commanders()), "filename": self.c.fileName()}
    else:
        w_result = {"total": 0}
    return self._make_response(w_result)
</t>
<t tx="felix.20210516004048.14">def save_file(self, param):  # pragma: no cover (too dangerous).
    """Save the leo outline."""
    tag = 'close_file'
    c = self._check_c()
    if c:
        try:
            if "name" in param:
                c.save(fileName=param['name'])
            else:
                c.save()
        except Exception as e:
            print("Error while saving", param['name'], flush=True)

    return self._make_response()  # Just send empty as 'ok'
</t>
<t tx="felix.20210516004048.15"></t>
<t tx="felix.20210516004048.16">def _get_find_settings(self, c):
    """Return a g.Bunch containing the present find settings settings."""
    return c.findCommands.ftm.get_settings()
    ###
        # # For now, return EKR defaults.
        # return g.Bunch(
            # find_text=None, change_text=None,
            # search_body=True, search_headline=True,
            # ignore_case=True, pattern_match=False, whole_word=True,
            # mark_changes=False, mark_finds=False,
            # node_only=False, suboutline_only=False,
            # entry_focus=None,
        # )  
</t>
<t tx="felix.20210516004048.17">def find_all(self, param):
    """Run Leo's find-all command and return results."""
    tag = 'find_all'
    c = self._check_c()
    fc = c.findCommands
    find_text = param.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_find_all(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="felix.20210516004048.18">def change_all(self, param):
    """Run Leo's change-all command and return results."""
    tag = 'change_all'
    c = self._check_c()
    fc = c.findCommands
    find_text = param.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    change_text = param.get("change_text")
    if change_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no change text")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    settings.change_text = change_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_change_all(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="felix.20210516004048.19">def change_then_find(self, param):
    """Run Leo's change-then-find command and return results."""
    tag = 'change_then_find'
    c = self._check_c()
    fc = c.findCommands
    find_text = param.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_change_then_find(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="felix.20210516004048.2">def __init__(self, testing=False):

    import leo.core.leoApp as leoApp
    import leo.core.leoBridge as leoBridge
    import leo.core.leoExternalFiles as leoExternalFiles
    global g
    t1 = time.process_time()
    #
    # Init ivars first.
    self.c = None  # Currently Selected Commander.
    self.dummy_c = None  # Set below, after we set g.
    self.action = None
    self.bad_commands_list = []  # Set below.
    self.config = None
    self.current_id = 0  # Id of action being processed.
    self.log_flag = False  # set by "log" key
    #
    # Start the bridge.
    self.bridge = leoBridge.controller(
        gui='nullGui',
        loadPlugins=False,   # True: attempt to load plugins.
        readSettings=False,  # True: read standard settings files.
        silent=True,         # True: don't print signon messages.
        verbose=False,       # True: prints messages that would be sent to the log pane.
    )
    self.g = g = self.bridge.globals()
    self.dummy_c = g.app.newCommander(fileName=None)  # To inspect commands
    self.bad_commands_list = self._bad_commands(self.dummy_c)
    #
    # Complete the initialization, as in LeoApp.initApp.
    g.app.idleTimeManager = leoApp.IdleTimeManager()
    g.app.idleTimeManager.start()
    g.app.externalFilesController = leoExternalFiles.ExternalFilesController(None)
    t2 = time.process_time()
    print(f"LeoServer: init leoBridge in {t2-t1:4.2} sec.")
</t>
<t tx="felix.20210516004048.20">def clone_find_all(self, param):
    """Run Leo's clone-find-all command and return results."""
    tag = 'clone_find_all'
    c = self._check_c()
    fc = c.findCommands
    find_text = param.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_clone_find_all(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="felix.20210516004048.21">def clone_find_all_flattened(self, param):
    """Run Leo's clone-find-all-flattened command and return results."""
    tag = 'clone_find_all_flattened'
    c = self._check_c()
    fc = c.findCommands
    find_text = param.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    answer = fc.do_clone_find_all_flattened(settings)
    if self.log_flag:  # pragma: no cover
        g.printObj(answer, tag=f"{tag}: answer")
    return self._make_response({"answer": answer})
</t>
<t tx="felix.20210516004048.22">def clone_find_tag(self, param):
    """Run Leo's clone-find-tag command and return results."""
    tag = 'clone_find_tag'
    c = self._check_c()
    fc = c.findCommands
    the_tag = param.get("tag")
    if not the_tag:  # pragma: no cover
        raise ServerError(f"{tag}: no tag")
    settings = self._get_find_settings(c)
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    n, p = fc.do_clone_find_tag(settings)
    if self.log_flag:  # pragma: no cover
        g.trace("tag: {the_tag} n: {n} p: {p and p.h!r}")
    return self._make_response({"n": n, "p": p})
</t>
<t tx="felix.20210516004048.23">def find_def(self, param):
    """Run Leo's find-def command and return results."""
    tag = 'find_def'
    c = self._check_c()
    fc = c.findCommands
    find_text = param.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    p, pos, newpos = fc.do_find_def(settings, word=find_text, strict=False)
    if self.log_flag:  # pragma: no cover
        g.trace(f"p: {p and p.h!r} pos: {pos!r} newpos {newpos!r}")
    return self._make_response({"p": p, "pos": pos, "newpos": newpos})
</t>
<t tx="felix.20210516004048.24">def find_next(self, param):
    """Run Leo's find-next command and return results."""
    tag = 'find_next'
    c = self._check_c()
    fc = c.findCommands
    find_text = param.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    p, pos, newpos = fc.do_find_next(settings)
    if self.log_flag:  # pragma: no cover
        g.trace(f"p: {p and p.h!r} pos: {pos!r} newpos {newpos!r}")
    return self._make_response({"p": p, "pos": pos, "newpos": newpos})
</t>
<t tx="felix.20210516004048.25">def find_previous(self, param):
    """Run Leo's find-previous command and return results."""
    tag = 'find_previous'
    c = self._check_c()
    fc = c.findCommands
    find_text = param.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    p, pos, newpos = fc.do_find_prev(settings)
    if self.log_flag:  # pragma: no cover
        g.trace(f"p: {p and p.h!r} pos: {pos!r} newpos {newpos!r}")
    return self._make_response({"p": p, "pos": pos, "newpos": newpos})
</t>
<t tx="felix.20210516004048.26">def find_var(self, param):
    """Run Leo's find-var command and return results."""
    tag = 'find_var'
    c = self._check_c()
    fc = c.findCommands
    find_text = param.get("find_text")
    if find_text is None:  # pragma: no cover
        raise ServerError(f"{tag}: no find pattern")
    settings = self._get_find_settings(c)
    settings.find_text = find_text
    if self.log_flag:  # pragma: no cover
        g.printObj(settings, tag=f"{tag}: settings for {c.shortFileName()}")
    p, pos, newpos = fc.do_find_var(settings, word=find_text)
    if self.log_flag:  # pragma: no cover
        g.trace(f"p: {p and p.h!r} pos: {pos!r} newpos {newpos!r}")
    return self._make_response({"p": p, "pos": pos, "newpos": newpos})
</t>
<t tx="felix.20210516004048.27">def tag_children(self, param):
    """Run Leo's tag-children command and return results."""
    # This is not a find command!
    tag = 'tag_children'
    c = self._check_c()
    fc = c.findCommands
    the_tag = param.get("tag")
    if the_tag is None:  # pragma: no cover
        raise ServerError(f"{tag}: no tag")
    # Unlike find commands, do_tag_children does not use a settings dict.
    fc.do_tag_children(c.p, the_tag)
    return self._make_response({})
</t>
<t tx="felix.20210516004048.28"></t>
<t tx="felix.20210516004048.29">def get_all_open_commanders(self, param):
    """Return array describing each commander in g.app.commanders()."""
    files = [
        {
            "changed": c.isChanged(),
            "name": c.fileName(),
            "selected": c == self.c,
        } for c in g.app.commanders()
    ]
    return self._make_minimal_response({"files": files})
</t>
<t tx="felix.20210516004048.3"></t>
<t tx="felix.20210516004048.30">def get_all_positions(self, param):
    """
    Return a list of position data for all positions.
    
    Useful as a sanity check for debugging.
    """
    c = self._check_c()
    result = [
        self._get_position_d(p) for p in c.all_positions(copy=False)
    ]
    return self._make_minimal_response({"position-data-list": result})
</t>
<t tx="felix.20210516004048.31">def get_all_gnx(self, param):
    '''Get gnx array from all unique nodes'''    
    if self.log_flag:  # pragma: no cover
        print(f"\nget_all_gnx\n")
    
    c = self._check_c()
    all_gnx = [p.v.gnx for p in c.all_unique_positions(copy=False)]
    return self._make_minimal_response({"gnx": all_gnx}, True)
</t>
<t tx="felix.20210516004048.32">def get_body(self, param):
    """
    Return p.b, where p is c.p if param["ap"] is missing.
    
    Note: There is no need for a separate get_body_length command,
          because _make_response always adds "body-length": len(p.b)
    """
    self._check_c()
    p = self._get_p(param)
    # _make_response adds all the cheap redraw data, including "body-length"
    return self._make_minimal_response({"body": p.b})
</t>
<t tx="felix.20210516004048.33">def get_body_length(self, param):
    """
    Return p.b's length in bytes, where p is c.p if param["ap"] is missing.
    """
    self._check_c()
    p = self._get_p(param)
    if p and p.b:
        # Length in bytes, not just by character count.
        return self._make_minimal_response({"len": len(p.b.encode('utf-8'))}, True)
    return self._make_minimal_response({"len": 0}, True)  # empty as default
</t>
<t tx="felix.20210516004048.34">def get_body_states(self, param):
    """
    Return body data for p, where p is c.p if param["ap"] is missing.
    The cursor positions are given as {"line": line, "col": col, "index": i} 
    with line and col along with a redundant index for conveniance and flexibility.
    """
    c = self._check_c()
    p = self._get_p(param)
    wrapper = c.frame.body.wrapper
    
    def row_col_wrapper_dict(i):  
        # BUG: this uses current selection wrapper only, use 
        # g.convertPythonIndexToRowCol instead !
        junk, line, col = wrapper.toPythonIndexRowCol(i)
        return {"line": line, "col": col, "index": i}
        
    def row_col_pv_dict(i, s):  
        # BUG: this uses current selection wrapper only, use 
        # g.convertPythonIndexToRowCol instead !
        line, col = g.convertPythonIndexToRowCol(s, i)
        return {"line": line, "col": col, "index": i}
        
    # Get the language.
    aList = g.get_directives_dict_list(p)
    d = g.scanAtCommentAndAtLanguageDirectives(aList)
    language = (
        d and d.get('language')
        or g.getLanguageFromAncestorAtFileNode(p)
        or c.config.getLanguage('target-language')
        or 'plain'
    )
    # get values from wrapper if it's the selected node.
    if c.p.v.gnx == p.v.gnx:
        active = wrapper.getInsertPoint()
        start, end = wrapper.getSelectionRange(True)
        scroll = wrapper.getYScrollPosition()
        states = {
            'language': language.lower(),
            'selection': {
                "gnx": p.v.gnx,
                "scroll": scroll,
                "active": row_col_wrapper_dict(active),
                "start": row_col_wrapper_dict(start),
                "end": row_col_wrapper_dict(end)
            }
        }
    else:  # pragma: no cover
        active = p.v.insertSpot
        start = p.v.selectionStart
        end = p.v.selectionStart + p.v.selectionLength
        scroll = p.v.scrollBarSpot
        states = {
            'language': language.lower(),
            'selection': {
                "gnx": p.v.gnx,
                "scroll": scroll,
                "active": row_col_pv_dict(active, p.v.b),
                "start": row_col_pv_dict(start, p.v.b),
                "end": row_col_pv_dict(end, p.v.b)
            }
        }
    return self._make_minimal_response(states)
</t>
<t tx="felix.20210516004048.35">def get_children(self, param):
    """
    Return the node data for children of p, where p is c.p if param["ap"] is missing.
    """
    self._check_c()
    p = self._get_p(param)
    return self._make_minimal_response({
        # "children": [self._p_to_ap(child) for child in p.children()]
        "children": [self._get_position_d(child) for child in p.children()]
    })
</t>
<t tx="felix.20210516004048.36">def get_focus(self, param):
    """
    Return a representation of the focused widget,
    one of ("body", "tree", "headline", repr(the_widget)).
    """
    w = g.app.gui.get_focus()
    focus = g.app.gui.widget_name(w)
    return self._make_minimal_response({"focus": focus})
</t>
<t tx="felix.20210516004048.37">def get_parent(self, param):
    """Return the node data for the parent of position p, where p is c.p if param["ap"] is missing."""
    self._check_c()
    p = self._get_p(param)
    parent = p.parent()
    data = self._get_position_d(parent) if parent else None
    return self._make_minimal_response({"node": data})
</t>
<t tx="felix.20210516004048.38">def get_position_data_dict(self, param):
    """
    Return a dict of position data for all positions.
    
    Useful as a sanity check for debugging.
    """
    c = self._check_c()
    result = {
        p.v.gnx: self._get_position_d(p)
            for p in c.all_unique_positions(copy=False)
    }
    return self._make_minimal_response({"position-data-dict": result})
</t>
<t tx="felix.20210516004048.39">def get_ua(self, param):
    """Return p.v.u, making sure it can be serialized."""
    self._check_c()
    p = self._get_p(param)
    try:
        ua = {"ua": p.v.u}
        json.dumps(ua, separators=(',', ':'))
        response = {"p": p, "ua": p.v.u} 
    except Exception:  # pragma: no cover
        response = {"p": p, "bad-ua": repr(p.v.u)} 
    # _make_response adds all the cheap redraw data.
    return self._make_minimal_response(response)
</t>
<t tx="felix.20210516004048.4"># These will fail unless the open_file inits c.theScriptingController.
</t>
<t tx="felix.20210516004048.40">def get_sign_on(self, param):
    """Synchronous version of _sign_on"""
    g.app.computeSignon()
    signon = []
    for z in (g.app.signon, g.app.signon1):
        for z2 in z.split('\n'):
            signon.append(z2.strip())
    return self._make_minimal_response({"sign-on": "\n".join(signon)})
</t>
<t tx="felix.20210516004048.41">def get_ui_states(self, param):
    """
    Return the enabled/disabled UI states for the open commander, or defaults if None.
    """
    c = self._check_c()
    tag = 'get_ui_states'
    try:
        states = {
            "changed": c and c.changed,
            "canUndo": c and c.canUndo(),
            "canRedo": c and c.canRedo(),
            "canDemote": c and c.canDemote(),
            "canPromote": c and c.canPromote(),
            "canDehoist": c and c.canDehoist(),
        }
    except Exception as e:  # pragma: no cover
        raise ServerError(f"{tag}: Exception setting state: {e}")
    return self._make_minimal_response({"states": states})
</t>
<t tx="felix.20210516004048.42"></t>
<t tx="felix.20210516004048.43">def clone_node(self, param):
    """
    Clone the node at position p, where p is c.p if param["ap"] is missing.
    Try to restore selection on the node that was originally selected

    """
    c = self._check_c()
    p = self._get_p(param)
    if p == c.p:
        c.clone()
    else:
        oldPosition = c.p
        c.selectPosition(p)
        c.clone()
        if c.positionExists(oldPosition):
            c.selectPosition(oldPosition)
    return self._make_response()
</t>
<t tx="felix.20210516004048.44">def contract_node(self, param):
    """
    Contract the node at position p, where p is c.p if param["ap"] is missing.

    """
    self._check_c()
    p = self._get_p(param)
    p.contract()
    return self._make_response()
</t>
<t tx="felix.20210516004048.45">def cut_node(self, param):  # pragma: no cover (too dangerous, for now)
    """
    Cut the node (and its descendants) at position p, where p is c.p if param["ap"] is missing.
    Try to restore selection on the node that was originally selected
    """
    c = self._check_c()
    p = self._get_p(param)
    if p == c.p:
        c.cutOutline()
    else:
        oldPosition = c.p
        c.selectPosition(p)
        c.cutOutline()
        if c.positionExists(oldPosition):
            c.selectPosition(oldPosition)
        else:
            oldPosition._childIndex = oldPosition._childIndex-1
            if c.positionExists(oldPosition):
                c.selectPosition(oldPosition)
    return self._make_response()
</t>
<t tx="felix.20210516004048.46">def delete_node(self, param):  # pragma: no cover (too dangerous, for now)
    """
    Delete the node (and its descendants) at position p, where p is c.p if param["ap"] is missing.
    Try to restore selection on the node that was originally selected
    """
    c = self._check_c()
    p = self._get_p(param)
    if p == c.p:
        c.deleteOutline()
    else:
        oldPosition = c.p
        c.selectPosition(p)
        c.deleteOutline()
        if c.positionExists(oldPosition):
            c.selectPosition(oldPosition)
        else:
            oldPosition._childIndex = oldPosition._childIndex-1
            if c.positionExists(oldPosition):
                c.selectPosition(oldPosition)
    return self._make_response()
</t>
<t tx="felix.20210516004048.47">def expand_node(self, param):
    """
    Expand the node at position p, where p is c.p if param["ap"] is missing.
    """
    self._check_c()
    p = self._get_p(param)
    p.expand()
    return self._make_response()
</t>
<t tx="felix.20210516004048.48">def insert_node(self, param):
    """
    Insert a new node at position p, where p is c.p if param["ap"] is missing.

    This node has 'newHeadline' as its headline.
    
    Use the 'set_headline' method to undoably set any node's headlines.
    """
    c = self._check_c()
    p = self._get_p(param)
    c.selectPosition(p)
    c.insertHeadline()  # Handles undo, sets c.p
    return self._make_response()
</t>
<t tx="felix.20210516004048.49">def insert_named_node(self, param):
    """
    Insert a new node at position p, where p is c.p if param["ap"] is missing.
    Also set its headline, select it and finally return it
    """
    c = self._check_c()
    p = self._get_p(param)
    headline = param.get('name')
    # We're going to have to handle the undo ourselves
    bunch = c.undoer.beforeInsertNode(w_p)
    newNode = p.insertAfter()
    # set this node's new headline
    newNode.h = headline
    newNode.setDirty()
    c.undoer.afterInsertNode(newNode, 'Insert Node', bunch)
    c.selectPosition(newNode)
    return self._make_response()
</t>
<t tx="felix.20210516004048.5">def _check_button_command(self, tag):  # pragma: no cover (no scripting controller)
    """
    Check that a button command is possible.
    Raise ServerError if not. Otherwise, return sc.buttonsDict.
    
    """
    c = self._check_c()
    sc = getattr(c, "theScriptingController", None)
    if not sc:
        # This will happen unless mod_scripting is loaded!
        raise ServerError(f"{tag}: no scripting controller")
    return sc.buttonsDict
</t>
<t tx="felix.20210516004048.50">def page_down(self, param):
    """
    Selects a node "n" steps down in the tree to simulate page down.
    """
    c = self._check_c()
    n = param.get("n", 3)
    for z in range(n):
        c.selectVisNext()
    return self._make_response()
</t>
<t tx="felix.20210516004048.51">def page_up(self, param):
    """
    Selects a node "N" steps up in the tree to simulate page up.
    """
    c = self._check_c()
    n = param.get("n", 3)
    for z in range(n):
        c.selectVisBack()
    return self._make_response()
</t>
<t tx="felix.20210516004048.52">def redo(self, param):
    """Undo last un-doable operation"""
    c = self._check_c()
    u = c.undoer
    if u.canRedo():
        u.redo()
    return self._make_response()
</t>
<t tx="felix.20210516004048.53">def set_body(self, param):
    """
    Undoably set body of a v node from a gnx parameter.
    """
    tag = 'set_body'
    c = self._check_c()
    u, wrapper = c.undoer, c.frame.body.wrapper
    body = param.get('body')
    gnx = param.get('gnx')
    if body is None:  # pragma: no cover
        raise ServerError(f"{tag}: no body given")
    if gnx is None:  # pragma: no cover
        raise ServerError(f"{tag}: no gnx given")

    for p in c.all_positions():
        if p.v.gnx == gnx:
            bunch = u.beforeChangeNodeContents(p)
            p.v.setBodyString(body)
            u.afterChangeNodeContents(p, "Body Text", bunch)
            if c.p.v.gnx == gnx:
                wrapper.setAllText(body)
            if not self.c.isChanged():  # pragma: no cover
                c.setChanged()
            if not p.v.isDirty():  # pragma: no cover
                p.setDirty()
            break  # one is enough
    return self._make_response()
</t>
<t tx="felix.20210516004048.54">def set_current_position(self, param):
    """Select position p, where p is c.p if param["ap"] is missing."""
    c = self._check_c()
    p = self._get_p(param)
    c.selectPosition(p)
    return self._make_response()
</t>
<t tx="felix.20210516004048.55">def set_headline(self, param):
    """
    Undoably set p.h, where p is c.p if param["ap"] is missing.
    """
    tag = 'set_headline'
    c = self._check_c()
    p = self._get_p(param)
    u = c.undoer
    h = param.get('name')
    if not h:  # pragma: no cover
        raise ServerError(f"{tag}: no headline")
    bunch = u.beforeChangeNodeContents(p)
    p.h = h
    u.afterChangeNodeContents(p, 'Change Headline', bunch)
    return self._make_response()
</t>
<t tx="felix.20210516004048.56">def set_selection(self, param):
    """
    Set the selection range for p.b, where p is c.p if param["ap"] is missing.
    
    Set the selection in the wrapper if p == c.p
    
    param has these keys:
        
    - "ap":     An archived position for position p.
    - "start":  The start of the selection.
    - "end":    The end of the selection.
    - "insert": The insert point. Must be either start or end.
    - "scroll": An optional scroll position.
    
    Positions can be sent as {"col":int, "line" int} dict
    or as numbers directly for convenience.
    
    Two functions in leoGlobals.py support conversions
    from Python indices to the row/column indices used by Tkinter.
    
    - g.convertPythonIndexToRowCol converts a Python index to a row/column
      index used by Tkinter.
    
    - g.convertRowColToPythonIndex does the reverse.
    """
    g = self.g
    c = self._check_c()
    p = self._get_p(param)  # Will raise ServerError if p does not exist.
    v = p.v
    body = p.v.b
    wrapper = c.frame.body.wrapper
    
    scroll = param.get('scroll') # kept as vertical scroll integer

    start = param.get('start')  # as integer or {"col":int, "line" int} dict
    end = param.get('end')  # as integer or {"col":int, "line" int} dict
    insert = param.get('insert')  # as integer or {"col":int, "line" int} dict
    
    if type(start)==int:
        pass # keep all as number
    else:
        w_insert = g.convertRowColToPythonIndex(
            body, insert.get('line', 0), insert.get('col', 0))
        w_startSel = g.convertRowColToPythonIndex(
            body, start.get('line', 0), start.get('col', 0))
        w_endSel = g.convertRowColToPythonIndex(
            body, end.get('line', 0), end.get('col', 0))

    if p == c.p:
        wrapper.setSelectionRange(start, end, insert)
        wrapper.setYScrollPosition(scroll)
    # Always set vnode attrs.
    v.scrollBarSpot = scroll
    v.insertSpot = insert
    v.selectionStart = start
    v.selectionLength = abs(start - end)
    return self._make_response()
</t>
<t tx="felix.20210516004048.57">def mark_node(self, param):
    """
    Mark a node, don't select it
    """
    self._check_c()
    p = self._get_p(param)
    p.setMarked()
    return self._make_response()
</t>
<t tx="felix.20210516004048.58">def unmark_node(self, param):
    """
    Unmark a node, don't select it
    """
    self._check_c()
    p = self._get_p(param)
    if p.isMarked():
        p.clearMarked()
    return self._make_response()
</t>
<t tx="felix.20210516004048.59">def undo(self, param):
    """Undo last un-doable operation"""
    c = self._check_c()
    u = c.undoer
    if u.canUndo():
        u.undo()
    # Flix: Caller can get focus using other calls.
    return self._make_response()
</t>
<t tx="felix.20210516004048.6">def click_button(self, param):  # pragma: no cover (no scripting controller)
    """Handles buttons clicked in client from the '@button' panel"""
    tag = 'click_button'
    index = param.get("index")
    if not index:
        raise ServerError(f"{tag}: no button index given")
    d = self._check_button_command(tag)
    button = None
    for key in d:
        # Some button keys are objects so we have to convert first
        if(str(key) == index):
            button = key

    if not button:
        raise ServerError(f"{tag}: button {index!r} does not exist")

    try:
        button.command()
    except Exception as e:
        raise ServerError(f"{tag}: exception clicking button {index!r}: {e}")
    # Tag along a possible return value with info sent back by _make_response
    return self._make_response()
</t>
<t tx="felix.20210516004048.60"></t>
<t tx="felix.20210516004048.61">def error(self, param):
    """For unit testing. Raise ServerError"""
    raise ServerError("error called")
</t>
<t tx="felix.20210516004048.62">def get_all_leo_commands(self, param):
    """Return a list of all Leo commands that make sense in leoInteg."""
    tag = 'get_all_leo_commands'
    c = self.dummy_c  # Use the dummy commander.
    d = c.commandsDict  # keys are command names, values are functions.
    bad_names = self._bad_commands(c)  # #92.
    good_names = self._good_commands()
    duplicates = set(bad_names).intersection(set(good_names))
    if duplicates:  # pragma: no cover
        print('duplicate command names...')
        for z in sorted(duplicates):
            print(z)
    result = []
    for command_name in sorted(d):
        func = d.get(command_name)
        if not func:  # pragma: no cover
            print('no func:', command_name)
            continue
        if command_name in bad_names:  # #92.
            continue
        # Prefer func.__func_name__ to func.__name__: Leo's decorators change func.__name__!
        func_name = getattr(func, '__func_name__', func.__name__)
        if not func_name:  # pragma: no cover
            print('no name', command_name)
            continue
        doc = func.__doc__ or ''
        result.append({
            "command-name": command_name,
            "func":  func_name,
            "detail": doc,
        })
    if self.log_flag:  # pragma: no cover
        print(f"\n{tag}: {len(result)} leo commands\n")
        g.printObj([z.get("command-name") for z in result], tag=tag)
    return self._make_response({"commands": result})
</t>
<t tx="felix.20210516004048.63">def _bad_commands(self, c):
    """Return the list of Leo's command names that leoInteg should ignore."""
    d = c.commandsDict  # keys are command names, values are functions.
    bad = []
    #
    # First, remove @button, @command and vim commands.
    for command_name in sorted(d):
        if command_name.startswith((':', '@')):
            # print('ignore', command_name)
            bad.append(command_name)
    # Second, remove other commands.
    # This is a hand-curated list.
    bad_list = [

        # Abbreviations...
        'abbrev-kill-all',
        'abbrev-list',
        'dabbrev-completion',
        'dabbrev-expands',

        # Autocompletion...
        'auto-complete',
        'auto-complete-force',
        'disable-autocompleter',
        'disable-calltips',
        'enable-autocompleter',
        'enable-calltips',

        # Debugger...
        'debug',
        'db-again',
        'db-b',
        'db-c',
        'db-h',
        'db-input',
        'db-l',
        'db-n',
        'db-q',
        'db-r',
        'db-s',
        'db-status',
        'db-w',

        # File operations...
        'directory-make',
        'directory-remove',
        'file-delete',
        'file-diff-files',
        'file-insert',
        'file-new',
        'file-open-by-name',

        # All others...
        'shell-command',
        'shell-command-on-region',
        'cheat-sheet',
        'dehoist',  # Duplicates of de-hoist.
        'find-clone-all',
        'find-clone-all-flattened',
        'find-clone-tag',
        'find-all',
        'find-all-unique-regex',
        'find-character',
        'find-character-extend-selection',
        'find-next',
        'find-prev',
        'find-word',
        'find-word-in-line',

        'global-search',

        'isearch-backward',
        'isearch-backward-regexp',
        'isearch-forward',
        'isearch-forward-regexp',
        'isearch-with-present-options',

        'replace',
        'replace-all',
        'replace-current-character',
        'replace-then-find',

        're-search-backward',
        're-search-forward',

        'search-backward',
        'search-forward',
        'search-return-to-origin',

        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
        'set-replace-string',
        'set-search-string',

        'show-find-options',

        'start-search',

        'toggle-find-collapses-nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',

        'word-search-backward',
        'word-search-forward',

        # Buttons...
        'delete-script-button-button',

        # Clicks...
        'click-click-box',
        'click-icon-box',
        'ctrl-click-at-cursor',
        'ctrl-click-icon',
        'double-click-icon-box',
        'right-click-icon',

        # Editors...
        'add-editor', 'editor-add',
        'delete-editor', 'editor-delete',
        'detach-editor-toggle',
        'detach-editor-toggle-max',

        # Focus...
        'cycle-editor-focus', 'editor-cycle-focus',
        'focus-to-body',
        'focus-to-find',
        'focus-to-log',
        'focus-to-minibuffer',
        'focus-to-nav',
        'focus-to-spell-tab',
        'focus-to-tree',

        'tab-cycle-next',
        'tab-cycle-previous',
        'tab-detach',

        # Headlines..
        'abort-edit-headline',
        'edit-headline',
        'end-edit-headline',

        # Layout and panes...
        'adoc',
        'adoc-with-preview',

        'contract-body-pane',
        'contract-log-pane',
        'contract-outline-pane',

        'edit-pane-csv',
        'edit-pane-test-open',
        'equal-sized-panes',
        'expand-log-pane',
        'expand-body-pane',
        'expand-outline-pane',

        'free-layout-context-menu',
        'free-layout-load',
        'free-layout-restore',
        'free-layout-zoom',

        'zoom-in',
        'zoom-out'

        # Log
        'clear-log',

        # Menus...
        'activate-cmds-menu',
        'activate-edit-menu',
        'activate-file-menu',
        'activate-help-menu',
        'activate-outline-menu',
        'activate-plugins-menu',
        'activate-window-menu',
        'context-menu-open',
        'menu-shortcut',

        # Modes...
        'clear-extend-mode',

        # Outline...
        'contract-or-go-left',
        'contract-node',
        'contract-parent',

        # Scrolling...
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-outline-down-line',
        'scroll-outline-down-page',
        'scroll-outline-left',
        'scroll-outline-right',
        'scroll-outline-up-line',
        'scroll-outline-up-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',

        # Windows...
        'about-leo',

        'cascade-windows',
        'close-others',
        'close-window',

        'iconify-frame',

        'find-tab-hide',
        'find-tab-open',

        'hide-body-dock',
        'hide-body-pane',
        'hide-invisibles',
        'hide-log-pane',
        'hide-outline-dock',
        'hide-outline-pane',
        'hide-tabs-dock',

        'minimize-all',

        'resize-to-screen',

        'show-body-dock',
        'show-hide-body-dock',
        'show-hide-outline-dock',
        'show-hide-render-dock',
        'show-hide-tabs-dock',
        'show-tabs-dock',
        'clean-diff',
        'cm-external-editor',

        'delete-@button-parse-json-button',
        'delete-trace-statements',

        'disable-idle-time-events',
        'do-nothing',

        'enable-idle-time-events',
        'enter-quick-command-mode',
        'exit-named-mode',

        'F6-open-console',

        'flush-lines',
        'full-command',

        'get-child-headlines',

        'history',

        'insert-file-name',

        'justify-toggle-auto',

        'keep-lines',
        'keyboard-quit',

        'line-number',
        'line-numbering-toggle',
        'line-to-headline',

        'marked-list',

        'mode-help',

        'open-python-window',

        'open-with-idle',
        'open-with-open-office',
        'open-with-scite',
        'open-with-word',

        'recolor',
        'redraw',

        'repeat-complex-command',

        'session-clear',
        'session-create',
        'session-refresh',
        'session-restore',
        'session-snapshot-load',
        'session-snapshot-save',

        'set-colors',
        'set-command-state',
        'set-comment-column',
        'set-extend-mode',
        'set-fill-column',
        'set-fill-prefix',
        'set-font',
        'set-insert-state',
        'set-overwrite-state',
        'set-silent-mode',

        'show-buttons',
        'show-calltips',
        'show-calltips-force',
        'show-color-names',
        'show-color-wheel',
        'show-commands',
        'show-file-line',

        'show-focus',
        'show-fonts',

        'show-invisibles',
        'show-next-tip',
        'show-node-uas',
        'show-outline-dock',
        'show-plugin-handlers',
        'show-plugins-info',
        'show-settings',
        'show-settings-outline',
        'show-spell-info',
        'show-stats',

        'style-set-selected',

        'suspend',

        'toggle-abbrev-mode',
        'toggle-active-pane',
        'toggle-angle-brackets',
        'toggle-at-auto-at-edit',
        'toggle-autocompleter',
        'toggle-calltips',
        'toggle-case-region',
        'toggle-extend-mode',
        'toggle-idle-time-events',
        'toggle-input-state',
        'toggle-invisibles',
        'toggle-line-numbering-root',
        'toggle-sparse-move',
        'toggle-split-direction',

        'what-line',
        'eval',
        'eval-block',
        'eval-last',
        'eval-last-pretty',
        'eval-replace',

        'find-quick',
        'find-quick-changed',
        'find-quick-selected',
        'find-quick-test-failures',
        'find-quick-timeline',

        'goto-next-history-node',
        'goto-prev-history-node',

        'preview',
        'preview-body',
        'preview-expanded-body',
        'preview-expanded-html',
        'preview-html',
        'preview-marked-bodies',
        'preview-marked-html',
        'preview-marked-nodes',
        'preview-node',
        'preview-tree-bodies',
        'preview-tree-html',
        'preview-tree-nodes',

        'spell-add',
        'spell-as-you-type-next',
        'spell-as-you-type-toggle',
        'spell-as-you-type-undo',
        'spell-as-you-type-wrap',
        'spell-change',
        'spell-change-then-find',
        'spell-find',
        'spell-ignore',
        'spell-tab-hide',
        'spell-tab-open',

        'tag-children',

        'todo-children-todo',
        'todo-dec-pri',
        'todo-find-todo',
        'todo-fix-datetime',
        'todo-inc-pri',

        'vr',
        'vr-contract',
        'vr-expand',
        'vr-hide',
        'vr-lock',
        'vr-pause-play-movie',
        'vr-show',
        'vr-toggle',
        'vr-unlock',
        'vr-update',
        'vr-zoom',

        'vs-create-tree',
        'vs-dump',
        'vs-reset',
        'vs-update',
        # vs code's text editing commands should cover all of these...
        'add-comments',
        'add-space-to-lines',
        'add-tab-to-lines',
        'align-eq-signs',

        'back-char',
        'back-char-extend-selection',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'back-to-home',
        'back-to-home-extend-selection',
        'back-to-indentation',
        'back-word',
        'back-word-extend-selection',
        'back-word-smart',
        'back-word-smart-extend-selection',
        'backward-delete-char',
        'backward-delete-word',
        'backward-delete-word-smart',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'backward-kill-paragraph',
        'backward-kill-sentence',
        'backward-kill-word',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',

        'capitalize-word',
        'center-line',
        'center-region',
        'clean-all-blank-lines',
        'clean-all-lines',
        'clean-body',
        'clean-lines',
        'clear-kill-ring',
        'clear-selected-text',
        'convert-blanks',
        'convert-tabs',
        'copy-text',
        'cut-text',

        'delete-char',
        'delete-comments',
        'delete-indentation',
        'delete-spaces',
        'delete-word',
        'delete-word-smart',
        'downcase-region',
        'downcase-word',

        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'end-of-line',
        'end-of-line-extend-selection',

        'exchange-point-mark',

        'extend-to-line',
        'extend-to-paragraph',
        'extend-to-sentence',
        'extend-to-word',

        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',

        'finish-of-line',
        'finish-of-line-extend-selection',

        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'forward-word-smart',
        'forward-word-smart-extend-selection',

        'go-anywhere',
        'go-back',
        'go-forward',
        'goto-char',

        'indent-region',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',

        'insert-hard-tab',
        'insert-newline',
        'insert-parentheses',
        'insert-soft-tab',

        'kill-line',
        'kill-paragraph',
        'kill-pylint',
        'kill-region',
        'kill-region-save',
        'kill-sentence',
        'kill-to-end-of-line',
        'kill-word',
        'kill-ws',

        'match-brackets',

        'move-lines-down',
        'move-lines-up',
        'move-past-close',
        'move-past-close-extend-selection',

        'newline-and-indent',
        'next-line',
        'next-line-extend-selection',
        'next-or-end-of-line',
        'next-or-end-of-line-extend-selection',

        'previous-line',
        'previous-line-extend-selection',
        'previous-or-beginning-of-line',
        'previous-or-beginning-of-line-extend-selection',

        'rectangle-clear',
        'rectangle-close',
        'rectangle-delete',
        'rectangle-kill',
        'rectangle-open',
        'rectangle-string',
        'rectangle-yank',

        'remove-blank-lines',
        'remove-newlines',
        'remove-space-from-lines',
        'remove-tab-from-lines',

        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',

        'paste-text',
        'pop-cursor',
        'push-cursor',

        'select-all',
        'select-next-trace-statement',
        'select-to-matching-bracket',

        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',

        'split-defs',
        'split-line',

        'start-of-line',
        'start-of-line-extend-selection',

        'tabify',
        'transpose-chars',
        'transpose-lines',
        'transpose-words',

        'unformat-paragraph',
        'unindent-region',

        'untabify',

        'upcase-region',
        'upcase-word',
        'update-ref-file',

        'yank',
        'yank-pop',

        'zap-to-character',

    ]
    bad.extend(bad_list)
    result = list(sorted(bad))
    return result

</t>
<t tx="felix.20210516004048.64">def _good_commands(self):
    """Defined commands that definitely should be included in leoInteg."""
    good_list = [

        'contract-all',
        'contract-all-other-nodes',
        'clone-node',
        'copy-node',
        'copy-marked-nodes',
        'cut-node',

        'de-hoist',
        'delete-marked-nodes',
        'delete-node',
        'demangle-recent-files',
        'demote',

        'expand-and-go-right',
        'expand-next-level',
        'expand-node',
        'expand-or-go-right',
        'expand-prev-level',
        'expand-to-level-1',
        'expand-to-level-2',
        'expand-to-level-3',
        'expand-to-level-4',
        'expand-to-level-5',
        'expand-to-level-6',
        'expand-to-level-7',
        'expand-to-level-8',
        'expand-to-level-9',
        'expand-all',
        'expand-all-subheads',
        'expand-ancestors-only',

        'find-next-clone',

        'goto-first-node',
        'goto-first-sibling',
        'goto-first-visible-node',
        'goto-last-node',
        'goto-last-sibling',
        'goto-last-visible-node',
        'goto-next-changed',
        'goto-next-clone',
        'goto-next-marked',
        'goto-next-node',
        'goto-next-sibling',
        'goto-next-visible',
        'goto-parent',
        'goto-prev-marked',
        'goto-prev-node',
        'goto-prev-sibling',
        'goto-prev-visible',

        'hoist',

        'insert-node',
        'insert-node-before',
        'insert-as-first-child',
        'insert-as-last-child',
        'insert-child',

        'mark',
        'mark-changed-items',
        'mark-first-parents',
        'mark-subheads',

        'move-marked-nodes',
        'move-outline-down',
        'move-outline-left',
        'move-outline-right',
        'move-outline-up',

        'paste-node',
        'paste-retaining-clones',
        'promote',
        'promote-bodies',
        'promote-headlines',

        'sort-children',
        'sort-siblings',

        'tangle',
        'tangle-all',
        'tangle-marked',

        'unmark-all',
        'unmark-first-parents',
        'clean-main-spell-dict',
        'clean-persistence',
        'clean-recent-files',
        'clean-spellpyx',
        'clean-user-spell-dict',

        'clear-all-caches',
        'clear-all-hoists',
        'clear-all-uas',
        'clear-cache',
        'clear-node-uas',
        'clear-recent-files',

        'delete-first-icon',
        'delete-last-icon',
        'delete-node-icons',

        'dump-caches',
        'dump-clone-parents',
        'dump-expanded',
        'dump-node',
        'dump-outline',

        'insert-icon',

        'set-ua',

        'show-all-uas',
        'show-bindings',
        'show-clone-ancestors',
        'show-clone-parents',
        # Export files...
        'export-headlines',
        'export-jupyter-notebook',
        'outline-to-cweb',
        'outline-to-noweb',
        'remove-sentinels',
        'typescript-to-py',

        # Import files...
        'import-MORE-files',
        'import-file',
        'import-free-mind-files',
        'import-jupyter-notebook',
        'import-legacy-external-files',
        'import-mind-jet-files',
        'import-tabbed-files',
        'import-todo-text-files',
        'import-zim-folder',

        # Open specific files...
        # 'ekr-projects',
        'leo-cheat-sheet',  # These duplicates are useful.
        'leo-dist-leo',
        'leo-docs-leo',
        'leo-plugins-leo',
        'leo-py-leo',
        'leo-quickstart-leo',
        'leo-scripts-leo',
        'leo-settings',
        'leo-unittest-leo',
        'my-leo-settings',
        # 'scripts',
        'settings',

        'open-cheat-sheet-leo',
        'open-desktop-integration-leo',
        'open-leo-dist-leo',
        'open-leo-docs-leo',
        'open-leo-plugins-leo',
        'open-leo-py-leo',
        'open-leo-settings',
        'open-leo-settings-leo',
        'open-local-settings',
        'open-my-leo-settings',
        'open-my-leo-settings-leo',
        'open-quickstart-leo',
        'open-scripts-leo',
        'open-unittest-leo',

        # Open other places...
        'open-offline-tutorial',
        'open-online-home',
        'open-online-toc',
        'open-online-tutorials',
        'open-online-videos',
        'open-recent-file',
        'open-theme-file',
        'open-url',
        'open-url-under-cursor',
        'open-users-guide',

        # Read outlines...
        'read-at-auto-nodes',
        'read-at-file-nodes',
        'read-at-shadow-nodes',
        'read-file-into-node',
        'read-outline-only',
        'read-ref-file',

        # Save Files.
        'file-save',
        'file-save-as',
        'file-save-as-unzipped',
        'file-save-by-name',
        'file-save-to',
        'save',  # Some may not be needed.
        'save-all',
        'save-as',
        'save-file',
        'save-file-as',
        'save-file-as-unzipped',
        'save-file-as-zipped',
        'save-file-by-name',
        'save-file-to',
        'save-to',

        # Write parts of outlines...
        'write-at-auto-nodes',
        'write-at-file-nodes',
        'write-at-shadow-nodes',
        'write-dirty-at-auto-nodes',
        'write-dirty-at-file-nodes',
        'write-dirty-at-shadow-nodes',
        'write-edited-recent-files',
        'write-file-from-node',
        'write-missing-at-file-nodes',
        'write-outline-only',

        'clone-find-all',
        'clone-find-all-flattened',
        'clone-find-all-flattened-marked',
        'clone-find-all-marked',
        'clone-find-parents',
        'clone-find-tag',
        'clone-marked-nodes',
        'clone-node-to-last-node',
        'clone-to-at-spot',

        'edit-setting',
        'edit-shortcut',

        'execute-pytest',
        'execute-script',
        'extract',
        'extract-names',

        'goto-any-clone',
        'goto-global-line',
        'goto-line',
        'git-diff', 'gd',

        'log-kill-listener', 'kill-log-listener',
        'log-listen', 'listen-to-log',

        'make-stub-files',

        'pdb',

        'redo',
        'rst3',
        'run-all-unit-tests-externally',
        'run-all-unit-tests-locally',
        'run-marked-unit-tests-externally',
        'run-marked-unit-tests-locally',
        'run-selected-unit-tests-externally',
        'run-selected-unit-tests-locally',
        'run-tests',

        'undo',

        'xdb',
        # Beautify, blacken, fstringify...
        'beautify-files',
        'beautify-files-diff',
        'blacken-files',
        'blacken-files-diff',
        'diff-and-open-leo-files',
        'diff-beautify-files',
        'diff-fstringify-files',
        'diff-leo-files',
        'diff-marked-nodes',
        'fstringify-files',
        'fstringify-files-diff',
        'fstringify-files-silent',
        'pretty-print-c',
        'silent-fstringify-files',

        # All other commands...
        'at-file-to-at-auto',

        'beautify-c',

        'cls',
        'c-to-python',
        'c-to-python-clean-docs',
        'check-derived-file',
        'check-outline',
        'code-to-rst',
        'compare-two-leo-files',
        'convert-all-blanks',
        'convert-all-tabs',
        'count-children',
        'count-pages',
        'count-region',

        'desktop-integration-leo',

        'edit-recent-files',
        'exit-leo',

        'file-compare-two-leo-files',
        'find-def',
        'find-long-lines',
        'find-missing-docstrings',
        'flake8',
        'flatten-outline',
        'flatten-outline-to-node',
        'flatten-script',

        'gc-collect-garbage',
        'gc-dump-all-objects',
        'gc-dump-new-objects',
        'gc-dump-objects-verbose',
        'gc-show-summary',

        'help',  # To do.
        'help-for-abbreviations',
        'help-for-autocompletion',
        'help-for-bindings',
        'help-for-command',
        'help-for-creating-external-files',
        'help-for-debugging-commands',
        'help-for-drag-and-drop',
        'help-for-dynamic-abbreviations',
        'help-for-find-commands',
        'help-for-keystroke',
        'help-for-minibuffer',
        'help-for-python',
        'help-for-regular-expressions',
        'help-for-scripting',
        'help-for-settings',

        'insert-body-time',  # ?
        'insert-headline-time',
        'insert-jupyter-toc',
        'insert-markdown-toc',

        'find-var',

        'join-leo-irc',
        'join-node-above',
        'join-node-below',
        'join-selection-to-node-below',

        'move-lines-to-next-node',

        'new',

        'open-outline',

        'parse-body',
        'parse-json',
        'pandoc',
        'pandoc-with-preview',
        'paste-as-template',

        'print-body',
        'print-cmd-docstrings',
        'print-expanded-body',
        'print-expanded-html',
        'print-html',
        'print-marked-bodies',
        'print-marked-html',
        'print-marked-nodes',
        'print-node',
        'print-sep',
        'print-tree-bodies',
        'print-tree-html',
        'print-tree-nodes',
        'print-window-state',

        'pyflakes',
        'pylint',
        'pylint-kill',
        'python-to-coffeescript',

        'quit-leo',

        'reformat-body',
        'reformat-paragraph',
        'refresh-from-disk',
        'reload-settings',
        'reload-style-sheets',
        'revert',

        'save-buffers-kill-leo',
        'screen-capture-5sec',
        'screen-capture-now',
        'script-button',  # ?
        'set-reference-file',
        'show-style-sheet',
        'sort-recent-files',
        'sphinx',
        'sphinx-with-preview',
        'style-reload',  # ?

        'untangle',
        'untangle-all',
        'untangle-marked',

        'view-lossage',  # ?

        'weave',

        # Dubious commands (to do)...
        'act-on-node',

        'cfa',  # Do we need abbreviations?
        'cfam',
        'cff',
        'cffm',
        'cft',

        'buffer-append-to',
        'buffer-copy',
        'buffer-insert',
        'buffer-kill',
        'buffer-prepend-to',
        'buffer-switch-to',
        'buffers-list',
        'buffers-list-alphabetically',

        'chapter-back',
        'chapter-next',
        'chapter-select',
        'chapter-select-main',
        'create-def-list',  # ?
    ]
    return good_list

</t>
<t tx="felix.20210516004048.65">def get_all_server_commands(self, param):
    """
    Public server method:
    Return the names of all callable public methods of the server.
    """
    tag = 'get_all_server_commands'
    names = self._get_all_server_commands()
    if self.log_flag:  # pragma: no cover
        print(f"\n{tag}: {len(names)} server commands\n")
        g.printObj(names, tag=tag)
    return self._make_response({"server-commands": names})

def _get_all_server_commands(self):
    """
    Private server method:
    Return the names of all callable public methods of the server.
    """
    members = inspect.getmembers(self, inspect.ismethod)
    return sorted([name for (name, value) in members if not name.startswith('_')])
</t>
<t tx="felix.20210516004048.66">def _init_connection(self, web_socket):  # pragma: no cover (tested in client).
    """Begin the connection."""
    self.web_socket = web_socket
    self.loop = asyncio.get_event_loop()
</t>
<t tx="felix.20210516004048.67">def set_ask_result(self, param):
    if self.log_flag:  # pragma: no cover
        print(f"\nask result\n")
    return self._make_response()
</t>
<t tx="felix.20210516004048.68">def set_config(self, param):
    if self.log_flag:  # pragma: no cover
        print(f"\nset gonfig\n")
    return self._make_response()
</t>
<t tx="felix.20210516004048.69">def shut_down(self, param):
    """Shut down the server."""
    tag = 'shut_down'
    n = len(g.app.commanders())
    if n:  # pragma: no cover
        raise ServerError(f"{tag}: {n} open outlines")
    raise TerminateServer("client requested shut down")
</t>
<t tx="felix.20210516004048.7">def get_buttons(self, param):  # pragma: no cover (no scripting controller)
    """
    Gets the currently opened file's @buttons list
    as an array of dict. 
    
    Typescript interface:
        {
            name: string;
            index: string;
        }[]
    """
    d = self._check_button_command('get_buttons')
    buttons = []
    # Some button keys are objects so we have to convert first
    for key in d:
        entry = {"name": d[key], "index": str(key)}
        buttons.append(entry)
    return self._make_minimal_response({
        "buttons": buttons
    })
</t>
<t tx="felix.20210516004048.70"></t>
<t tx="felix.20210516004048.71">def _ap_to_p(self, ap):
    """
    Convert ap (archived position, a dict) to a valid Leo position.
    Raise ServerError on any kind of error.
    """
    tag = '_ap_to_p'
    c = self._check_c()
    gnx_d = c.fileCommands.gnxDict
    outer_stack = ap.get('stack')
    if outer_stack is None:  # pragma: no cover.
        raise ServerError(f"{tag}: no stack in ap: {ap!r}")
    if not isinstance(outer_stack, (list, tuple)):  # pragma: no cover.
        raise ServerError(f"{tag}: stack must be tuple or list: {outer_stack}")
    
    def d_to_childIndex_v (d):
        """Helper: return childIndex and v from d ["childIndex"] and d["gnx"]."""
        childIndex = d.get('childIndex')
        if childIndex is None:  # pragma: no cover.
            raise ServerError(f"{tag}: no childIndex in {d}")
        try:
            childIndex = int(childIndex)
        except Exception:  # pragma: no cover.
            raise ServerError(f"{tag}: bad childIndex: {childIndex!r}")
        gnx = d.get('gnx')
        if gnx is None:  # pragma: no cover.
            raise ServerError(f"{tag}: no gnx in {d}.")
        v = gnx_d.get(gnx)
        if v is None:  # pragma: no cover.
            raise ServerError(f"{tag}: gnx not found: {gnx!r}")
        return childIndex, v
    #
    # Compute p.childIndex and p.v.
    childIndex, v = d_to_childIndex_v(ap)
    #
    # Create p.stack.
    stack = []
    for stack_d in outer_stack:
        stack_childIndex, stack_v = d_to_childIndex_v(stack_d)
        stack.append((stack_v, stack_childIndex))
    #
    # Make p and check p.
    p = Position(v, childIndex, stack)
    if not c.positionExists(p):  # pragma: no cover.
        print(
            f"{tag}: Bad ap: {ap!r}\n"
            # f"{tag}: position: {p!r}\n"
            f"{tag}: v {v!r} childIndex: {childIndex!r}\n"
            f"{tag}: stack: {stack!r}")
        raise ServerError(f"{tag}: p does not exist in {c.shortFileName()}")
    return p
</t>
<t tx="felix.20210516004048.72">def _check_c(self):
    """Return self.c or raise ServerError if self.c is None."""
    tag = '_check_c'
    c = self.c
    if not c:  # pragma: no cover
        raise ServerError(f"{tag}: no open commander")
    return c
</t>
<t tx="felix.20210516004048.73">def _check_outline(self, c):
    """Check self.c for consistency."""
    # Check that all positions exist.
    self._check_outline_positions(c)
    # Test round-tripping.
    self._test_round_trip_positions(c)
</t>
<t tx="felix.20210516004048.74">def _check_outline_positions(self, c):
    """Verify that all positions in c exist."""
    tag = '_check_outline_positions'
    for p in c.all_positions(copy=False):
        if not c.positionExists(p):  # pragma: no cover
            message = f"{tag}: position {p!r} does not exist in {c.shortFileName()}"
            print(message)
            self._dump_position(p)
            raise ServerError(message)
</t>
<t tx="felix.20210516004048.75">def _do_leo_command(self, command, param):
    """
    Generic call to a method in Leo's Commands class or any subcommander class.
    
    The param["ap"] position is to be selected before having the command run,
    while the param["keep"] parameter specifies wether the original position
    should be re-selected afterward.
    
    TODO: The whole of those operations is to be undoable as one undo step.

    command: a method name (a string).
    param["ap"]: an archived position.
    param["keep"]: preserve the current selection, if possible.
    
    """
    tag = '_do_leo_command'
    c = self._check_c()
        
    if command in self.bad_commands_list:  # pragma: no cover
        raise ServerError(f"{tag}: disallowed command: {command_name!r}")
        
    keepSelection = False  # Set default, optional component of param
    if "keep" in param:
        keepSelection = param["keep"]
        
    func = c.commandsDict.get(command)
    
    if not func:  # pragma: no cover
        raise ServerError(f"{tag}: Leo command not found: {command!r}")

    p = self._get_p(param)
    
    if p == c.p:
        value = func(event={"c":c})  # no need for re-selection
    else:
        old_p = c.p
        c.selectPosition(p)
        value = func(event={"c":c})
        if keepSelection and c.positionExists(old_p):
            c.selectPosition(old_p)

    value = func(event={"c":c})
    
    # Tag along a possible return value with info sent back by _make_response
    return self._make_response({"return-value": value})
</t>
<t tx="felix.20210516004048.76">def _do_message(self, d):
    """
    Handle d, a python dict representing the incoming request.
    The d dict must have the three (3) following keys:
    
    "id": A positive integer.
    
    "action": A string, which is either:
        - The name of public method of this class, prefixed with a '!'.
        - The name of a leo command, without prefix, to be run by _do_leo_command
        
    "param": A dict to be passed to the called "action" method. 
        (Passed to the public method, or the _do_leo_command. Often contains ap, text &amp; keep)
    
    Return a dict, created by _make_response or _make_minimal_response
    that contains at least an 'id' key.
    
    """
    tag = '_do_message'
    
    # Require "id" and "action" keys
    id_ = d.get("id")
    if id_ is None:  # pragma: no cover
        raise ServerError(f"{tag}: no id")
    action = d.get("action")
    if action is None:  # pragma: no cover
        raise ServerError("f{tag}: no action")
        
    param = d.get('param', {})
    # Set log flag.
    self.log_flag = param.get("log")
    
    # Set the current_id and action ivars for _make_response.
    self.current_id = id_
    self.action = action
    
    # Execute the requested action.
    if action[0] == "!":
        func = self._do_server_command  # Server has this method.
    else:
        func = self._do_leo_command  # No prefix, so it's a Leo command.
        
    result = func(action, param)
    if result is None:  # pragma: no cover
        raise ServerError(f"{tag}: no response: {action!r}")
    return result
</t>
<t tx="felix.20210516004048.77">def _do_server_command(self, action, param):
    tag = '_do_server_command'
    # Disallow hidden methods.
    if action.startswith('_'):  # pragma: no cover
        raise ServerError(f"{tag}: action starts with '_': {action!r}")
    # Find and execute the server method.
    func = getattr(self, action, None)
    if not func:
        raise ServerError(f"{tag}: action not found: {action!r}")  # pragma: no cover
    if not callable(func):
        raise ServerError(f"{tag}: not callable: {func!r}")  # pragma: no cover
    return func(param)
</t>
<t tx="felix.20210516004048.78">def _dump_outline(self, c):  # pragma: no cover
    """Dump the outline."""
    tag = '_dump_outline'
    print(f"{tag}: {c.shortFileName()}...\n")
    for p in c.all_positions():
        self._dump_position(p)
    print('')

def _dump_position(self, p):  # pragma: no cover
    level_s = ' ' * 2 * p.level()
    print(f"{level_s}{p.childIndex():2} {p.v.gnx} {p.h}")
</t>
<t tx="felix.20210516004048.79">def _es(self, s):  # pragma: no cover (tested in client).
    """
    Send a response that does not correspond to a request.
    
    The response *must* have an "async" key, but *not* an "id" key.
    """
    tag = '_es'
    message = g.toUnicode(s)
    package = {"async": "", "s": message}
    response = json.dumps(package, separators=(',', ':'))
    if self.loop:
        self.loop.create_task(self._async_output(response))
    else:
        print(f"{tag}: Error loop not ready {message}")
</t>
<t tx="felix.20210516004048.8">def remove_button(self, param):  # pragma: no cover (no scripting controller)
    """Remove button by index 'key string'."""
    tag = 'remove_button'
    index = param.get("index")
    if not index:
        raise ServerError(f"{tag}: no button index given")
    d = self._check_button_command(tag)
    
    # Some button keys are objects so we have to convert first
    key = None
    for i_key in d:
        if(str(i_key) == index):
            key = i_key
    if key:
        try:
            del d [index]
        except Exception as e:
            raise ServerError(f"{tag}: exception removing button {index!r}: {e}")
    else:
        raise ServerError(f"{tag}: button {index!r} does not exist")

    return self._make_response()
</t>
<t tx="felix.20210516004048.80">async def _async_output(self, json):  # pragma: no cover (tested in server)
    """Output json string to the web_socket"""
    tag = '_async_output'
    if self.web_socket:
        await self.web_socket.send(bytes(json, 'utf-8'))
    else:
        g.trace(f"{tag}: no web socket. json: {json!r}")
</t>
<t tx="felix.20210516004048.81">def _get_p(self, param):
    """Return _ap_to_p(param["ap"]) or c.p."""
    
    tag = '_get_ap'
    c = self.c
    if not c:  # pragma: no cover
        raise ServerError(f"{tag}: no c")
        
    ap = param.get("ap")
    if ap:
        p = self._ap_to_p(ap)  # Convertion
        if p:
            if not c.positionExists(p):  # pragma: no cover
                raise ServerError(f"{tag}: position does not exist. ap: {ap!r}")
            return p  # Return the position 

    # Fallback to c.p
    if not c.p:  # pragma: no cover
        raise ServerError(f"{tag}: no c.p")
        
    return c.p
</t>
<t tx="felix.20210516004048.82">def _get_position_d(self, p):
    """
    Return a python dict containing:
    - "node": self._p_to_ap(p).
    - All *cheap* redraw data..
    
    Use get_ua to get p.ua *plus* all this redraw data.
    
    Note: v.computeIcon sets iconVal as follows:
        v, val = self, 0
        if v.hasBody(): val += 1
        if v.isMarked(): val += 2
        if v.isCloned(): val += 4
        if v.isDirty(): val += 8
    """
    return {
        "node": self._p_to_ap(p), # Contains p.gnx, p.childIndex and p.stack.
        # The cheap redraw data...
        "body-length": len(p.b),  # *Not* p.b.
        "has-children": p.hasChildren(),  # *Not* p.children().
        "has-ua": bool(p.v.u),  # *Not* p.v.u.
        "headline": p.h,
        "icon-val": p.v.iconVal,  # An int between 0 and 15.
        "is-at-file": p.isAnyAtFileNode(),
        "level": p.level(),  # Useful for debugging.
    }
</t>
<t tx="felix.20210516004048.83">def _make_response(self, package=None):
    """
    Return a json string representing a response dict.
    
    The 'package' kwarg, if present, must be a python dict describing a
    response. package may be an empty dict or None.
    
    The 'p' kwarg, if present, must be a position.
    
    First, this method creates a response (a python dict) containing all
    the keys in the 'package' dict, with the following added keys:
        
    - "id":         The incoming id.
    - "commander":  A dict describing self.c.
    - "node":       None, or an archived position describing self.c.p.
    
    Finally, this method returns the json string corresponding to the
    response.
    """
    tag = '_make_response'
    c = self.c  # It is valid for c to be None.
    if package is None:
        package = {}
    p = package.get("p")
    if p:
        del package ["p"]
    # Raise an *internal* error if checks fail.
    if isinstance(package, str):  # pragma: no cover
        raise InternalServerError(f"{tag}: bad package kwarg: {package!r}")
    if p and not isinstance(p, Position):  # pragma: no cover
        raise InternalServerError(f"{tag}: bad p kwarg: {p!r}")
    if p and not c:  # pragma: no cover
        raise InternalServerError(f"{tag}: p but not c")
    if p and not c.positionExists(p):  # pragma: no cover
        raise InternalServerError(f"{tag}: p does not exist: {p!r}")
    if c and not c.p:  # pragma: no cover
        raise InternalServerError(f"{tag}: empty c.p")

    # Always add id
    package ["id"] = self.current_id

    # The following keys are relevant only if there is an open commander.
    if c:
        # Allow commands, especially _get_redraw_d, to specify p!
        p = p or c.p
        package ["commander"] = {
            "changed": c.isChanged(),
            "file_name": c.fileName(), # Can be None for new files.
        }
        # Add all the node data, including:
        # - "node": self._p_to_ap(p) # Contains p.gnx, p.childIndex and p.stack.
        # - All the *cheap* redraw data for p.
        redraw_d = self._get_position_d(p)
        package ["node"] = redraw_d
    if self.log_flag:  # pragma: no cover
        g.printObj(package, tag=f"{tag} returns")
    return json.dumps(package, separators=(',', ':')) 
</t>
<t tx="felix.20210516004048.84">def _make_minimal_response(self, package=None, minimal=False):
    """
    Return a json string representing a response dict.
    
    The 'package' kwarg, if present, must be a python dict describing a
    response. package may be an empty dict or None.
    
    The 'p' kwarg, if present, must be a position.
    
    First, this method creates a response (a python dict) containing all
    the keys in the 'package' dict.
    
    Then it adds 'id' to the package.
    
    Finally, this method returns the json string corresponding to the
    response.
    """
    tag = '_make_response'
    c = self.c  # It is valid for c to be None.
    if package is None:
        package = {}

    # Always add id.        
    package ["id"] = self.current_id

    return json.dumps(package, separators=(',', ':'))
</t>
<t tx="felix.20210516004048.85">def _p_to_ap(self, p):
    """
    Convert Leo position p to a serializable archived position.
    
    This returns only position-related data.
    get_position_data returns all data needed to redraw the screen.
    """
    self._check_c()
    stack = [{'gnx': v.gnx, 'childIndex': childIndex}
        for (v, childIndex) in p.stack]
    return {
        'childIndex': p._childIndex,
        'gnx': p.v.gnx,
        'stack': stack,
    }
</t>
<t tx="felix.20210516004048.86">def _test_round_trip_positions(self, c):  # pragma: no cover (tested in client).
    """Test the round tripping of p_to_ap and ap_to_p."""
    tag = '_test_round_trip_positions'
    for p in c.all_unique_positions():
        ap = self._p_to_ap(p)
        p2 = self._ap_to_p(ap)
        if p != p2:
            self._dump_outline(c)
            raise ServerError(f"{tag}: round-trip failed: ap: {ap!r}, p: {p!r}, p2: {p2!r}")
</t>
<t tx="felix.20210516004048.9"></t>
<t tx="felix.20210516233931.1">/**
 * * Opens the find panel and selects all &amp; focuses on the find field.
 */
public startSearch(): void {
    let w_panelID = '';
    let w_panel: vscode.WebviewView | undefined;
    if (this._lastTreeView === this._leoTreeExView) {
        w_panelID = Constants.FIND_EXPLORER_ID;
        w_panel = this._findPanelWebviewExplorerView;
    } else {
        w_panelID = Constants.FIND_ID;
        w_panel = this._findPanelWebviewView;
    }
    vscode.commands.executeCommand(w_panelID + '.focus').then((p_result) =&gt; {
        if (w_panel &amp;&amp; w_panel.show &amp;&amp; !w_panel.visible) {
            w_panel.show(false);
        }
        w_panel?.webview.postMessage({ type: 'selectFind' });
    });
}

</t>
<t tx="felix.20210516234059.1">/**
 * * Find next / previous commands
 * @param p_fromOutline
 * @param p_reverse
 * @returns Promise that resolves when the "launch refresh" is started
 */
public find(p_fromOutline: boolean, p_reverse: boolean): Promise&lt;any&gt; {
    const w_action: string = p_reverse
        ? Constants.LEOBRIDGE.FIND_PREVIOUS
        : Constants.LEOBRIDGE.FIND_NEXT;
    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(w_action, JSON.stringify({ fromOutline: !!p_fromOutline }));
        })
        .then((p_findResult: LeoBridgePackage) =&gt; {
            if (!p_findResult.found || !p_findResult.focus) {
                vscode.window.showInformationMessage('Not found');
            } else {
                let w_focusOnOutline = false;
                const w_focus = p_findResult.focus.toLowerCase();
                if (w_focus.includes('tree') || w_focus.includes('head')) {
                    // tree
                    w_focusOnOutline = true;
                }
                this.launchRefresh(
                    {
                        tree: true,
                        body: true,
                        scroll: p_findResult.found &amp;&amp; !w_focusOnOutline,
                        documents: false,
                        buttons: false,
                        states: true,
                    },
                    w_focusOnOutline
                );
            }
        });
}

</t>
<t tx="felix.20210517001143.1">{
  "command": "leointeg.startSearch",
  "category": "Leo",
  "title": "Start Search"
},
{
  "command": "leointeg.findAll",
  "category": "Leo",
  "title": "Find All"
},
{
  "command": "leointeg.findNext",
  "category": "Leo",
  "title": "Find Next"
},
{
  "command": "leointeg.findNextFromOutline",
  "category": "Leo",
  "title": "Find Next"
},
{
  "command": "leointeg.findPrevious",
  "category": "Leo",
  "title": "Find Previous"
},
{
  "command": "leointeg.findPreviousFromOutline",
  "category": "Leo",
  "title": "Find Previous"
},
{
  "command": "leointeg.replace",
  "category": "Leo",
  "title": "Replace"
},
{
  "command": "leointeg.replaceFromOutline",
  "category": "Leo",
  "title": "Replace"
},
{
  "command": "leointeg.replaceThenFind",
  "category": "Leo",
  "title": "Replace Then Find"
},
{
  "command": "leointeg.replaceThenFindFromOutline",
  "category": "Leo",
  "title": "Replace Then Find"
},
{
  "command": "leointeg.replaceAll",
  "category": "Leo",
  "title": "Replace All"
},
{
  "command": "leointeg.gotoGlobalLine",
  "category": "Leo",
  "title": "Goto Global Line"
},
{
  "command": "leointeg.cloneFindAll",
  "category": "Leo",
  "title": "Clone Find All"
},
{
  "command": "leointeg.cloneFindAllFlattened",
  "category": "Leo",
  "title": "Clone Find All Flattened"
},
{
  "command": "leointeg.cloneFindMarked",
  "category": "Leo",
  "title": "cfam - Clone Find All Marked Nodes"
},
{
  "command": "leointeg.cloneFindFlattenedMarked",
  "category": "Leo",
  "title": "cffm - Clone Find All Flattened Marked"
},
{
  "command": "leointeg.setFindEverywhereOption",
  "category": "Leo",
  "title": "Set Find Everywhere Option"
},
{
  "command": "leointeg.setFindNodeOnlyOption",
  "category": "Leo",
  "title": "Set Find in Node Only Option"
},
{
  "command": "leointeg.setFindSuboutlineOnlyOption",
  "category": "Leo",
  "title": "Set Find in SubOutline Only Option"
},
{
  "command": "leointeg.toggleFindIgnoreCaseOption",
  "category": "Leo",
  "title": "Toggle Find Ignore Case Option"
},
{
  "command": "leointeg.toggleFindMarkChangesOption",
  "category": "Leo",
  "title": "Toggle Find Mark Changes Option"
},
{
  "command": "leointeg.toggleFindMarkFindsOption",
  "category": "Leo",
  "title": "Toggle Find Mark Finds Option"
},
{
  "command": "leointeg.toggleFindRegexpOption",
  "category": "Leo",
  "title": "Toggle Find RegExp Option"
},
{
  "command": "leointeg.toggleFindWordOption",
  "category": "Leo",
  "title": "Toggle Find Whole Word Option"
},
{
  "command": "leointeg.toggleFindSearchBodyOption",
  "category": "Leo",
  "title": "Toggle Find Search Body Option"
},
{
  "command": "leointeg.toggleFindSearchHeadlineOption",
  "category": "Leo",
  "title": "Toggle Find Search Headline Option"
},
</t>
<t tx="felix.20210517001459.1">{
  "command": "leointeg.mark",
  "category": "Leo",
  "title": "Mark",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leointeg.markSelection",
  "category": "Leo",
  "title": "Mark"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "category": "Leo",
  "title": "Mark"
},
{
  "command": "leointeg.unmark",
  "category": "Leo",
  "title": "Unmark",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leointeg.unmarkSelection",
  "category": "Leo",
  "title": "Unmark"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "category": "Leo",
  "title": "Unmark"
},
{
  "command": "leointeg.unmarkAll",
  "category": "Leo",
  "title": "Unmark All"
},
{
  "command": "leointeg.markSubheads",
  "category": "Leo",
  "title": "Mark Subheads"
},
{
  "command": "leointeg.markChangedItems",
  "category": "Leo",
  "title": "Mark Changed Items"
},
{
  "command": "leointeg.copyMarked",
  "category": "Leo",
  "title": "Copy Marked"
},
{
  "command": "leointeg.cloneMarkedNodes",
  "category": "Leo",
  "title": "Clone Marked Nodes"
},
{
  "command": "leointeg.diffMarkedNodes",
  "category": "Leo",
  "title": "Diff Marked Nodes"
},
{
  "command": "leointeg.deleteMarkedNodes",
  "category": "Leo",
  "title": "Delete Marked Nodes"
},
{
  "command": "leointeg.moveMarkedNodes",
  "category": "Leo",
  "title": "Move Marked Nodes"
}
</t>
<t tx="felix.20210517004335.1">{
  "command": "leointeg.startSearch",
  "key": "ctrl+f",
  "mac": "cmd+f",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.startSearch",
  "key": "ctrl+f",
  "mac": "cmd+f",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.findNextFromOutline",
  "key": "f3",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.findNext",
  "key": "f3",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.findPreviousFromOutline",
  "key": "f2",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.findPrevious",
  "key": "f2",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.replace",
  "key": "ctrl+=",
  "mac": "cmd+=",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.replaceFromOutline",
  "key": "ctrl+=",
  "mac": "cmd+=",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.replaceThenFind",
  "key": "ctrl+-",
  "mac": "cmd+-",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.replaceThenFindFromOutline",
  "key": "ctrl+-",
  "mac": "cmd+-",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.gotoGlobalLine",
  "key": "alt+g",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.gotoGlobalLine",
  "key": "alt+g",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.setFindEverywhereOption",
  "key": "ctrl+alt+e",
  "mac": "cmd+alt+e",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.setFindEverywhereOption",
  "key": "ctrl+alt+e",
  "mac": "cmd+alt+e",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.setFindNodeOnlyOption",
  "key": "ctrl+alt+n",
  "mac": "cmd+alt+n",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.setFindNodeOnlyOption",
  "key": "ctrl+alt+n",
  "mac": "cmd+alt+n",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.setFindSuboutlineOnlyOption",
  "key": "ctrl+alt+s",
  "mac": "cmd+alt+s",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.setFindSuboutlineOnlyOption",
  "key": "ctrl+alt+s",
  "mac": "cmd+alt+s",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindIgnoreCaseOption",
  "key": "ctrl+alt+i",
  "mac": "cmd+alt+i",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.toggleFindIgnoreCaseOption",
  "key": "ctrl+alt+i",
  "mac": "cmd+alt+i",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindMarkChangesOption",
  "key": "ctrl+alt+c",
  "mac": "cmd+alt+c",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.toggleFindMarkChangesOption",
  "key": "ctrl+alt+c",
  "mac": "cmd+alt+c",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindMarkFindsOption",
  "key": "ctrl+alt+f",
  "mac": "cmd+alt+f",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.toggleFindMarkFindsOption",
  "key": "ctrl+alt+f",
  "mac": "cmd+alt+f",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindRegexpOption",
  "key": "ctrl+alt+x",
  "mac": "cmd+alt+x",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.toggleFindRegexpOption",
  "key": "ctrl+alt+x",
  "mac": "cmd+alt+x",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindWordOption",
  "key": "ctrl+alt+w",
  "mac": "cmd+alt+w",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.toggleFindWordOption",
  "key": "ctrl+alt+w",
  "mac": "cmd+alt+w",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindSearchBodyOption",
  "key": "ctrl+alt+b",
  "mac": "cmd+alt+b",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.toggleFindSearchBodyOption",
  "key": "ctrl+alt+b",
  "mac": "cmd+alt+b",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindSearchHeadlineOption",
  "key": "ctrl+alt+h",
  "mac": "cmd+alt+h",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.toggleFindSearchHeadlineOption",
  "key": "ctrl+alt+h",
  "mac": "cmd+alt+h",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
}
</t>
<t tx="felix.20210522001751.1">import * as vscode from 'vscode';
import { Constants } from '../constants';
import { LeoIntegration } from '../leoIntegration';

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20210522001814.1">/**
 * Leo Find Panel provider
 */
export class LeoFindPanelProvider implements vscode.WebviewViewProvider {
    private _view?: vscode.WebviewView;

    constructor(
        private readonly _extensionUri: vscode.Uri,
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {}

    @others
}
</t>
<t tx="felix.20210522152739.1">/**
 * * LeoInteg search settings structure for use with the 'find' webview
 */
export interface LeoSearchSettings {
    //Find/change strings...
    findText: string;
    replaceText: string;
    // Find options...
    wholeWord: boolean;
    ignoreCase: boolean;
    regExp: boolean;
    markFinds: boolean;
    markChanges: boolean;
    searchHeadline: boolean;
    searchBody: boolean;
    searchScope: LeoSearchScope; // 0, 1 or 2 for outline, sub-outline, or node.
}

</t>
<t tx="felix.20210522152922.1">/**
 * * LeoInteg's Enum type for the search scope radio buttons of the find panel.
 */
export const enum LeoSearchScope {
    entireOutline = 0,
    subOutlineOnly,
    nodeOnly
}

</t>
<t tx="felix.20210522233604.1"></t>
<t tx="felix.20210522233744.1">{
  "view": "leoFindPanel",
  "contents": "Not connected",
  "when": "!leoTreeOpened"
},
{
  "view": "leoFindPanelExplorer",
  "contents": "Not connected",
  "when": "!leoTreeOpened"
}
</t>
<t tx="felix.20210523154200.1">def get_ui_states(self, param):
    """
    Gets the currently opened file's general states for UI enabled/disabled states
    such as undo available, file changed/unchanged
    """
    w_states = {}
    if self.commander:
        try:
            # 'dirty/changed' member
            w_states["changed"] = self.commander.changed
            w_states["canUndo"] = self.commander.canUndo()
            w_states["canRedo"] = self.commander.canRedo()
            w_states["canDemote"] = self.commander.canDemote()
            w_states["canPromote"] = self.commander.canPromote()
            w_states["canDehoist"] = self.commander.canDehoist()

        except Exception as e:
            self.g.trace('Error while getting states')
            print("Error while getting states", flush=True)
            print(str(e), flush=True)
    else:
        w_states["changed"] = False
        w_states["canUndo"] = False
        w_states["canRedo"] = False
        w_states["canDemote"] = False
        w_states["canPromote"] = False
        w_states["canDehoist"] = False

    return self.sendLeoBridgePackage({"states": w_states})

</t>
<t tx="felix.20210523154320.1"></t>
<t tx="felix.20210523154326.1">def get_search_settings(self, param):
    """
    Gets search options
    """
    w_result = self.commander.findCommands.ftm.get_settings()
    return self.sendLeoBridgePackage({"searchSettings": w_result.__dict__})

</t>
<t tx="felix.20210523154352.1">def set_search_settings(self, param):
    """
    Sets search options. Init widgets and ivars from param.searchSettings
    """
    c = self.commander
    find = c.findCommands
    ftm = c.findCommands.ftm
    searchSettings = param['searchSettings']
    # Find/change text boxes.
    table = (
        ('find_findbox', 'find_text', ''),
        ('find_replacebox', 'change_text', ''),
    )
    for widget_ivar, setting_name, default in table:
        w = getattr(ftm, widget_ivar)
        s = searchSettings.get(setting_name) or default
        w.clear()
        w.insert(s)
    # Check boxes.
    table = (
        ('ignore_case', 'check_box_ignore_case'),
        ('mark_changes', 'check_box_mark_changes'),
        ('mark_finds', 'check_box_mark_finds'),
        ('pattern_match', 'check_box_regexp'),
        ('search_body', 'check_box_search_body'),
        ('search_headline', 'check_box_search_headline'),
        ('whole_word', 'check_box_whole_word'),
    )
    for setting_name, widget_ivar in table:
        w = getattr(ftm, widget_ivar)
        val = searchSettings.get(setting_name)
        setattr(find, setting_name, val)
        if val != w.isChecked():
            w.toggle()
    # Radio buttons
    table = (
        ('node_only', 'node_only', 'radio_button_node_only'),
        ('entire_outline', None, 'radio_button_entire_outline'),
        ('suboutline_only', 'suboutline_only', 'radio_button_suboutline_only'),
    )
    for setting_name, ivar, widget_ivar in table:
        w = getattr(ftm, widget_ivar)
        val = searchSettings.get(setting_name, False)
        if ivar is not None:
            assert hasattr(find, setting_name), setting_name
            setattr(find, setting_name, val)
            if val != w.isChecked():
                w.toggle()
    # Ensure one radio button is set.
    w = ftm.radio_button_entire_outline
    if not searchSettings.get('node_only', False) and not searchSettings.get('suboutline_only', False):
        setattr(find, 'entire_outline', True)
        if not w.isChecked():
            w.toggle()
    else:
        setattr(find, 'entire_outline', False)
        if w.isChecked():
            w.toggle()

    # Confirm by sending back the settings to leointeg
    w_result = ftm.get_settings()
    return self.sendLeoBridgePackage({"searchSettings": w_result.__dict__})

</t>
<t tx="felix.20210523162125.1">/**
 * * Leo's GUI search settings internal structure
 */
export interface LeoGuiFindTabManagerSettings {
    //Find/change strings...
    find_text: string,
    change_text: string,
    // Find options...
    ignore_case: boolean,
    mark_changes: boolean,
    mark_finds: boolean,
    node_only: boolean,
    pattern_match: boolean,
    search_body: boolean,
    search_headline: boolean,
    suboutline_only: boolean,
    whole_word: boolean
}

</t>
<t tx="felix.20210524215215.1">/**
 * * Send the settings to the Leo Bridge Server
 */
public saveSearchSettings(p_settings: LeoSearchSettings): Promise&lt;LeoBridgePackage&gt; {
    this._lastSettingsUsed = p_settings;
    // convert to LeoGuiFindTabManagerSettings
    const w_settings: LeoGuiFindTabManagerSettings = {
        //Find/change strings...
        find_text: p_settings.findText,
        change_text: p_settings.replaceText,
        // Find options...
        ignore_case: p_settings.ignoreCase,
        mark_changes: p_settings.markChanges,
        mark_finds: p_settings.markFinds,
        node_only: !!(p_settings.searchScope === 2),
        pattern_match: p_settings.regExp,
        search_body: p_settings.searchBody,
        search_headline: p_settings.searchHeadline,
        suboutline_only: !!(p_settings.searchScope === 1),
        whole_word: p_settings.wholeWord,
    };
    return this.sendAction(
        Constants.LEOBRIDGE.SET_SEARCH_SETTINGS,
        JSON.stringify({ searchSettings: w_settings })
    );
}

</t>
<t tx="felix.20210524231157.1">/**
 * * Capture instance for further calls on find panel webview
 */
public setFindPanel(p_panel: vscode.WebviewView) {
    if (this._lastTreeView === this._leoTreeExView) {
        this._findPanelWebviewExplorerView = p_panel;
    } else {
        this._findPanelWebviewView = p_panel;
    }
}

</t>
<t tx="felix.20210525232728.1">/**
 * * Get settings from Leo and apply them to the find panel webviews
 */
public loadSearchSettings(): void {
    this.sendAction(Constants.LEOBRIDGE.GET_SEARCH_SETTINGS).then(
        (p_result: LeoBridgePackage) =&gt; {
            const w_searchSettings: LeoGuiFindTabManagerSettings = p_result.searchSettings!;
            const w_settings: LeoSearchSettings = {
                //Find/change strings...
                findText: w_searchSettings.find_text,
                replaceText: w_searchSettings.change_text,
                // Find options...
                wholeWord: w_searchSettings.whole_word,
                ignoreCase: w_searchSettings.ignore_case,
                regExp: w_searchSettings.pattern_match,
                markFinds: w_searchSettings.mark_finds,
                markChanges: w_searchSettings.mark_changes,
                searchHeadline: w_searchSettings.search_headline,
                searchBody: w_searchSettings.search_body,
                // 0, 1 or 2 for outline, sub-outline, or node.
                searchScope:
                    0 +
                    (w_searchSettings.suboutline_only ? 1 : 0) +
                    (w_searchSettings.node_only ? 2 : 0),
            };
            if (w_settings.searchScope &gt; 2) {
                console.error('searchScope SHOULD BE 0,1,2 only: ', w_settings.searchScope);
            }
            this._lastSettingsUsed = w_settings;
            if (this._findPanelWebviewExplorerView) {
                this._findPanelWebviewExplorerView.webview.postMessage({
                    type: 'setSettings',
                    value: w_settings,
                });
            }
            if (this._findPanelWebviewView) {
                this._findPanelWebviewView.webview.postMessage({
                    type: 'setSettings',
                    value: w_settings,
                });
            }
        }
    );
}

</t>
<t tx="felix.20210527225925.1">def find_next(self, param):
    """Run Leo's find-next command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    p, pos, newpos = fc.do_find_next(settings)
    found = True
    if not p:
        found = False
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": found, "pos": pos, "newpos": newpos,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210527225930.1">def find_previous(self, param):
    """Run Leo's find-previous command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    p, pos, newpos = fc.do_find_prev(settings)
    found = True
    if not p:
        found = False
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": found, "pos": pos, "newpos": newpos,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210528000603.1">def _show_find_success(self, c, in_headline, insert, p):
    '''Handle a successful find match.'''
    if in_headline:
        self.g.app.gui.set_focus(c, self.headlineWidget)
    # no return

</t>
<t tx="felix.20210528012836.1">/**
 * * Check if Leo should be focused on outline
 */
public getBridgeFocus(): void {
    this.sendAction(Constants.LEOBRIDGE.GET_FOCUS).then((p_resultFocus: LeoBridgePackage) =&gt; {
        if (p_resultFocus.focus) {
            const w_focus = p_resultFocus.focus.toLowerCase();
            if (w_focus.includes('tree') || w_focus.includes('head')) {
                this._fromOutline = true;
                // this.showOutline(true);
            }
        }
    });
}

</t>
<t tx="felix.20210530153353.1">{
  "command": "leointeg.startSearch",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findNext",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findPrevious",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.replace",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.replaceThenFind",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.replaceAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.setFindEverywhereOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.setFindNodeOnlyOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.setFindSuboutlineOnlyOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindIgnoreCaseOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindMarkChangesOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindMarkFindsOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindRegexpOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindWordOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindSearchBodyOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindSearchHeadlineOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.gotoGlobalLine",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindAllFlattened",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindFlattenedMarked",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20210530153359.1">{
  "command": "leointeg.copyMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.diffMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markChangedItems",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markSubheads",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.unmarkAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.deleteMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveMarkedNodes",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20210530160638.1">{
  "command": "leointeg.extract",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.extractNames",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20210530161800.1">{
  "command": "leointeg.findNextFromOutline",
  "when": "false"
},
{
  "command": "leointeg.findPreviousFromOutline",
  "when": "false"
},
{
  "command": "leointeg.replaceFromOutline",
  "when": "false"
},
{
  "command": "leointeg.replaceThenFindFromOutline",
  "when": "false"
}
</t>
<t tx="felix.20210530223726.1">/**
 * * Replace / Replace-Then-Find commands
 * @param p_fromOutline
 * @param p_thenFind
 * @returns Promise that resolves when the "launch refresh" is started
 */
public replace(p_fromOutline: boolean, p_thenFind: boolean): Promise&lt;any&gt; {
    const w_action: string = p_thenFind
        ? Constants.LEOBRIDGE.REPLACE_THEN_FIND
        : Constants.LEOBRIDGE.REPLACE;
    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(w_action, JSON.stringify({ fromOutline: !!p_fromOutline }));
        })
        .then((p_replaceResult: LeoBridgePackage) =&gt; {
            if (!p_replaceResult.found || !p_replaceResult.focus) {
                vscode.window.showInformationMessage('Not found');
            } else {
                let w_focusOnOutline = false;
                const w_focus = p_replaceResult.focus.toLowerCase();
                if (w_focus.includes('tree') || w_focus.includes('head')) {
                    // tree
                    w_focusOnOutline = true;
                }
                this.launchRefresh(
                    {
                        tree: true,
                        body: true,
                        scroll: true,
                        documents: false,
                        buttons: false,
                        states: true,
                    },
                    w_focusOnOutline
                );
            }
        });
}

</t>
<t tx="felix.20210530225306.1">/**
 * * Set search setting in the search webview
 */
public setSearchSetting(p_id: string): void {
    let w_panel: vscode.WebviewView | undefined;
    if (this._lastTreeView === this._leoTreeExView) {
        w_panel = this._findPanelWebviewExplorerView;
    } else {
        w_panel = this._findPanelWebviewView;
    }
    w_panel!.webview.postMessage({ type: 'setSearchSetting', id: p_id });
}

</t>
<t tx="felix.20210530225640.1"></t>
<t tx="felix.20210530230354.1">/*
 * * Find / Replace All
 */
public findAll(p_replace: boolean): Promise&lt;any&gt; {
    const w_action: string = p_replace
        ? Constants.LEOBRIDGE.REPLACE_ALL
        : Constants.LEOBRIDGE.FIND_ALL;

    let w_searchString: string = this._lastSettingsUsed!.findText;
    let w_replaceString: string = this._lastSettingsUsed!.replaceText;

    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            return this._inputFindPattern()
                .then((p_findString) =&gt; {
                    if (!p_findString) {
                        return true; // Cancelled with escape or empty string.
                    }
                    w_searchString = p_findString;
                    if (p_replace) {
                        return this._inputFindPattern(true).then((p_replaceString) =&gt; {
                            if (p_replaceString === undefined) {
                                return true;
                            }
                            w_replaceString = p_replaceString;
                            return false;
                        });
                    }
                    return false;
                });
        })
        .then((p_cancelled: boolean) =&gt; {
            if (this._lastSettingsUsed &amp;&amp; !p_cancelled) {
                this._lastSettingsUsed.findText = w_searchString;
                this._lastSettingsUsed.replaceText = w_replaceString;
                this.saveSearchSettings(this._lastSettingsUsed); // No need to wait, will be stacked.
                return this.sendAction(w_action)
                    .then((p_findResult: LeoBridgePackage) =&gt; {
                        let w_focusOnOutline = false;
                        const w_focus = p_findResult.focus!.toLowerCase();
                        if (w_focus.includes('tree') || w_focus.includes('head')) {
                            // tree
                            w_focusOnOutline = true;
                        }
                        this.loadSearchSettings();
                        this.launchRefresh(
                            { tree: true, body: true, documents: false, buttons: false, states: true },
                            w_focusOnOutline
                        );
                    });
            }
        });
}

</t>
<t tx="felix.20210530230400.1">/**
 * * Clone Find All / Marked / Flattened
 */
public cloneFind(p_marked: boolean, p_flat: boolean): Promise&lt;any&gt; {
    let w_searchString: string = this._lastSettingsUsed!.findText;
    let w_action: string;
    if (p_marked) {
        w_action = p_flat
            ? Constants.LEOBRIDGE.CLONE_FIND_FLATTENED_MARKED
            : Constants.LEOBRIDGE.CLONE_FIND_MARKED;
    } else {
        w_action = p_flat
            ? Constants.LEOBRIDGE.CLONE_FIND_ALL_FLATTENED
            : Constants.LEOBRIDGE.CLONE_FIND_ALL;
    }
    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            if (p_marked) {
                return false;
            }
            return this._inputFindPattern()
                .then((p_findString) =&gt; {
                    if (!p_findString) {
                        return true; // Cancelled with escape or empty string.
                    }
                    w_searchString = p_findString;
                    return false;
                });
        })
        .then((p_cancelled: boolean) =&gt; {
            if (this._lastSettingsUsed &amp;&amp; !p_cancelled) {
                let q_action: Promise&lt;LeoBridgePackage&gt;;
                if (!p_marked) {
                    this._lastSettingsUsed.findText = w_searchString;
                    this.saveSearchSettings(this._lastSettingsUsed); // No need to wait, will be stacked.
                    q_action = this.sendAction(w_action);
                } else {
                    q_action = this.nodeCommand({
                        action: w_action,
                        node: undefined,
                        refreshType: {},
                        fromOutline: false
                    })!;
                }
                return q_action
                    .then((p_cloneFindResult: LeoBridgePackage) =&gt; {
                        let w_focusOnOutline = false;
                        const w_focus = p_cloneFindResult.focus!.toLowerCase();
                        if (w_focus.includes('tree') || w_focus.includes('head')) {
                            // tree
                            w_focusOnOutline = true;
                        }
                        this.loadSearchSettings();
                        this.launchRefresh(
                            { tree: true, body: true, documents: false, buttons: false, states: true },
                            w_focusOnOutline
                        );
                    });
            }
        });
}

</t>
<t tx="felix.20210530233134.1">/**
 * * Find panel controls ids
 */
public static FIND_INPUTS_IDS = {
    FIND_TEXT: "findText",
    REPLACE_TEXT: "replaceText",
    ENTIRE_OUTLINE: "entireOutline",
    NODE_ONLY: "nodeOnly",
    SUBOUTLINE_ONLY: "subOutlineOnly",
    IGNORE_CASE: "ignoreCase",
    MARK_CHANGES: "markChanges",
    MARK_FINDS: "markFinds",
    REG_EXP: "regExp",
    WHOLE_WORD: "wholeWord",
    SEARCH_BODY: "searchBody",
    SEARCH_HEADLINE: "searchHeadline"
};

</t>
<t tx="felix.20210531011702.1">def replace(self, param):
    """Run Leo's replace command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    fc.change(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": True,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210531011713.1">def replace_then_find(self, param):
    """Run Leo's replace then find next command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    result = fc.do_change_then_find(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": result,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210531011822.1">def replace_all(self, param):
    """Run Leo's replace all command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    result = fc.do_change_all(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": result,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210531214057.1">def clone_find_all(self, param):
    """Run Leo's clone-find-all command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    result = fc.do_clone_find_all(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": result,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210531214103.1">def clone_find_all_flattened(self, param):
    """Run Leo's clone-find-all-flattened command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    result = fc.do_clone_find_all_flattened(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": result,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)
</t>
<t tx="felix.20210601005209.1">def find_all(self, param):
    """Run Leo's find all command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    result = fc.do_find_all(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": result,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210601151758.1">
def find_var(self, param):
    """Run Leo's find-var command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    # todo : find var implementation
    print("todo : find var implementation")
    # result = fc.do_clone_find_all_flattened(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210601151804.1">def find_def(self, param):
    """Run Leo's find-def command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    # todo : find def implementation
    print("todo : find def implementation")
    # result = fc.do_clone_find_all_flattened(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210601152841.1">def goto_global_line(self, param):
    """Run Leo's goto-global-line command and return results."""
    c = self.commander
    junk_p, junk_offset, found = c.gotoCommands.find_file_line(
        n=int(param['line']))
    w_result = {"found": found, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210601164915.1">/**
 * * Goto Global Line
 */
public gotoGlobalLine(): void {
    this.triggerBodySave(false)
        .then((p_saveResult: boolean) =&gt; {
            return vscode.window.showInputBox({
                title: Constants.USER_MESSAGES.TITLE_GOTO_GLOBAL_LINE,
                placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_GOTO_GLOBAL_LINE,
                prompt: Constants.USER_MESSAGES.PROMPT_GOTO_GLOBAL_LINE,
            });
        })
        .then((p_inputResult?: string) =&gt; {
            if (p_inputResult) {
                const w_line = parseInt(p_inputResult);
                if (!isNaN(w_line)) {
                    this.sendAction(
                        Constants.LEOBRIDGE.GOTO_GLOBAL_LINE,
                        JSON.stringify({ line: w_line })
                    ).then((p_resultGoto: LeoBridgePackage) =&gt; {
                        if (!p_resultGoto.found) {
                            // Not found
                        }
                        this.launchRefresh(
                            {
                                tree: true,
                                body: true,
                                documents: false,
                                buttons: false,
                                states: true,
                            },
                            false
                        );
                    });
                }
            }
        });
}

</t>
<t tx="felix.20210602151654.1">/**
 * * Overridden 'good' minibuffer commands
 */
public static MINIBUFFER_OVERRIDDEN_COMMANDS: { [key: string]: string } = {
    "import-file": Constants.COMMANDS.IMPORT_ANY_FILE,
    "redo": Constants.COMMANDS.REDO,
    "undo": Constants.COMMANDS.UNDO,
    "clone-find-all": Constants.COMMANDS.CLONE_FIND_ALL,
    "clone-find-all-flattened": Constants.COMMANDS.CLONE_FIND_ALL_FLATTENED
};

</t>
<t tx="felix.20210602155312.1">/**
 * * Import any File(s)
 */
public importAnyFile(p_leoFileUri?: vscode.Uri): Thenable&lt;unknown&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            let q_importFile: Promise&lt;LeoBridgePackage | undefined&gt;; // Promise for opening a file
            if (p_leoFileUri &amp;&amp; p_leoFileUri.fsPath.trim()) {
                const w_fixedFilePath: string = p_leoFileUri.fsPath.replace(/\\/g, '/');
                q_importFile = this.sendAction(
                    Constants.LEOBRIDGE.IMPORT_ANY_FILE,
                    JSON.stringify({ filenames: w_fixedFilePath })
                );
            } else {
                q_importFile = this._leoFilesBrowser.getImportFileUrls().then(
                    (p_chosenLeoFiles) =&gt; {
                        if (p_chosenLeoFiles.length) {
                            return this.sendAction(
                                Constants.LEOBRIDGE.IMPORT_ANY_FILE,
                                JSON.stringify({ filenames: p_chosenLeoFiles })
                            );
                        } else {
                            return Promise.resolve(undefined);
                        }
                    },
                    (p_errorGetFile) =&gt; {
                        return Promise.reject(p_errorGetFile);
                    }
                );
            }
            return q_importFile;
        })
        .then(
            (p_importFileResult: LeoBridgePackage | undefined) =&gt; {
                if (p_importFileResult) {
                    return this.launchRefresh(
                        {
                            tree: true,
                            body: true,
                            documents: true,
                            buttons: false,
                            states: true,
                        },
                        false
                    );
                } else {
                    return Promise.resolve(undefined);
                }
            },
            (p_errorImport) =&gt; {
                console.log('in .then not imported'); // TODO : IS REJECTION BEHAVIOR NECESSARY HERE TOO?
                return Promise.reject(p_errorImport);
            }
        );
}

</t>
<t tx="felix.20210602160216.1">/**
 * * Open a file browser to let user choose file(s) to import
 * @param p_fileType can be used to restrict to a particular file type
 * @returns a promise of an array of filepath+name strings
 */
public getImportFileUrls(p_fileType?: string): Promise&lt;string[]&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve([]);
    }
    this._fileBrowserActive = true;
    let w_types: { [name: string]: string[]; };
    if (p_fileType &amp;&amp; Constants.IMPORT_FILE_TYPES[p_fileType]) {
        w_types = {};
        w_types[p_fileType] = Constants.IMPORT_FILE_TYPES[p_fileType];
    } else {
        w_types = Constants.IMPORT_FILE_TYPES;
    }
    return new Promise((p_resolve, p_reject) =&gt; {
        vscode.window
            .showOpenDialog({
                canSelectMany: true,
                openLabel: "Import File",
                canSelectFolders: false,
                filters: w_types,
                defaultUri: this._getBestOpenFolderUri()
            })
            .then(p_chosenLeoFiles =&gt; {
                this._fileBrowserActive = false;
                if (p_chosenLeoFiles) {
                    // array instead of single string
                    const w_result = p_chosenLeoFiles.map(function (e) {
                        return e.fsPath.replace(/\\/g, "/").trim();
                    });
                    p_resolve(w_result); // Replace backslashes for windows support
                } else {
                    p_resolve([]);
                }
            });
    });
}
</t>
<t tx="felix.20210602203830.1">def import_any_file(self, param):
    """
    Import file(s) from array of file names
    """
    c = self.commander
    g = self.g
    ic = c.importCommands
    names = param.get('filenames')
    if names:
        g.chdir(names[0])
    if not names:
        return self._outputError("Error in import_any_file no filenames found")

    # New in Leo 4.9: choose the type of import based on the extension.
    derived = [z for z in names if c.looksLikeDerivedFile(z)]
    others = [z for z in names if z not in derived]
    if derived:
        ic.importDerivedFiles(parent=c.p, paths=derived)
    for fn in others:
        junk, ext = g.os_path_splitext(fn)
        ext = ext.lower()  # #1522
        if ext.startswith('.'):
            ext = ext[1:]
        if ext == 'csv':
            ic.importMindMap([fn])
        elif ext in ('cw', 'cweb'):
            ic.importWebCommand([fn], "cweb")
        # Not useful. Use @auto x.json instead.
        # elif ext == 'json':
            # ic.importJSON([fn])
        elif fn.endswith('mm.html'):
            ic.importFreeMind([fn])
        elif ext in ('nw', 'noweb'):
            ic.importWebCommand([fn], "noweb")
        elif ext == 'more':
            # (Flix) leoImport Should be on c?
            c.leoImport.MORE_Importer(c).import_file(fn)  # #1522.
        elif ext == 'txt':
            # (Flix) import_txt_file Should be on c?
            # #1522: Create an @edit node.
            c.import_txt_file(c, fn)
        else:
            # Make *sure* that parent.b is empty.
            last = c.lastTopLevel()
            parent = last.insertAfter()
            parent.v.h = 'Imported Files'
            ic.importFilesCommand(
                files=[fn],
                parent=parent,
                treeType='@auto',  # was '@clean'
                # Experimental: attempt to use permissive section ref logic.
            )
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20210602213308.1">/**
 * * Possible import file types
 */
public static IMPORT_FILE_TYPES: { [name: string]: string[]; } = {
    "All files": ["*"],
    "C/C++ files": ["c", "cpp", "h", "hpp"],
    "FreeMind files": ["mm.html"],
    "Java files": ["java"],
    "JavaScript files": ["js"],
    // "JSON files": ["json"],
    "Mindjet files": ["csv"],
    "MORE files": ["MORE"],
    "Lua files": ["lua"],
    "Pascal files": ["pas"],
    "Python files": ["py"],
    "Text files": ["txt"],
};

</t>
<t tx="felix.20210610022645.1">"editor/title": [
  {
    "command": "leointeg.next",
    "when": "resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.prev",
    "when": "resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  }
],
</t>
<t tx="felix.20210610022836.1">/**
 * * Previous / Next Node Buttons
 */
public prevNextNode(p_next: boolean) {
    if (p_next) {
        vscode.window.showInformationMessage("TODO: Command Next");
    } else {
        vscode.window.showInformationMessage("TODO: Command Prev");
    }
}

</t>
<t tx="felix.20210612000127.1">## 0.1.14

- Rewrite of the leobridgeserver.py to be made compatible with the standards in leoserver.py from Leo.
- Added option for specifying server file and path. Defaults to the internal leobridgeserver.py server.
- Fixed cursor position and selection bugs.
- Fixed automatic server startup and connection bugs.
- Added Search functionality along with a 'find' panel.
- Added goto global line and other clone-find related commands from Leo's 'Search' menu.
- Added import-file(s) command - an alias of the import-any-file command form Leo.
- Temporary fix for some minibuffer commands to override the widgets interactions (ex. clone-find-all, etc.)
- Undo and redo icons are now faded out instead of disappearing when unavailable - to help with button shifting when clicking rapidly.
- Many other small bugfixes.

</t>
<t tx="felix.20210612155932.1">/**
 * * Return a promise to a boolean that will tell if port already in use
 */
export function portInUse(p_port: number): Promise&lt;boolean&gt; {
    const q_checkPort: Promise&lt;boolean&gt; = new Promise((p_resolve, p_reject) =&gt; {
        var w_server = net.createServer(function (socket) {
            socket.write('Echo server\r\n');
            socket.pipe(socket);
        });
        w_server.on('error', function (e) {
            p_resolve(true);
        });
        w_server.on('listening', function (e: Event) {
            w_server.close();
            p_resolve(false);
        });
        w_server.listen(
            p_port
        );
    });
    return q_checkPort;
}

</t>
<t tx="felix.20210612214028.1">/**
 * * Find next available port starting with p_startingPort inclusively,
 * * check next (max 5) additional ports and return port number, or 0 if none.
 */
export function findNextAvailablePort(p_startingPort: number): Promise&lt;number&gt; {


    const q_portFinder = portfinder.getPortPromise({
        port: p_startingPort,
        startPort: p_startingPort,
        stopPort: p_startingPort + 5
    })

    return q_portFinder;

    // Only works on linux
    // return asyncFindPort(p_startingPort, 5);
    // return Promise.resolve(32126);
}

</t>
<t tx="felix.20210612230258.1">/**
 * * async function that tries to find open ports starting with a given port#
 * * Tries at most 'p_maxTries' times,
 * * from p_startingPort up to p_startingPort+p_limit
 */
async function asyncFindPort(p_startingPort: number, p_maxTries: number) {
    const w_endPort = p_startingPort + p_maxTries;
    let w_foundPort = 0;
    for (let i = p_startingPort; i &lt; w_endPort; i++) {
        // wait for the promise to resolve before advancing the for loop
        if (!await portInUse(i)) {
            w_foundPort = i;
            break;
        }
    }
    return Promise.resolve(w_foundPort);
}

</t>
<t tx="felix.20210613205741.1">/**
 * * Return a promise for a find pattern string input from the user
 */
private _inputFindPattern(p_replace?: boolean): Thenable&lt;string | undefined&gt; {
    return vscode.window.showInputBox({
        title: p_replace ? "Replace with" : "Search for",
        prompt: p_replace ? "Type text to replace with and press enter." : "Type text to search for and press enter.",
        placeHolder: p_replace ? "Replace pattern here" : "Find pattern here",
    });
}

</t>
<t tx="felix.20210613210351.1">/**
 * * Popup browser to choose Leo-Editor installation folder path
 */
public chooseLeoFolder() {
    //
    console.log('chooseLeoFolder !!');

}

</t>
<t tx="felix.20210613212439.1"></t>
<t tx="fil.20210603195218.1">import * as vscode from "vscode";
import * as path from 'path';
import { LeoIntegration } from "../leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="fil.20210603195319.1">export class LeoSettingsProvider {

    private _panel: vscode.WebviewPanel | undefined;
    private readonly _extensionPath: string;
    private _html: string | undefined;
    private _waitingForUpdate: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._extensionPath = _context.extensionPath;
        vscode.workspace.onDidChangeConfiguration(p_event =&gt; this._onChangeConfiguration(p_event));
    }

    @others
}
</t>
<t tx="fil.20210603195319.2">private _onChangeConfiguration(p_event: vscode.ConfigurationChangeEvent): void {
    if (this._panel &amp;&amp; !this._waitingForUpdate) {
        this._panel.webview.postMessage({ command: 'newConfig', config: this._leoIntegration.config.getConfig() });
    }
}

</t>
<t tx="fil.20210603195319.3">public openWebview(): void {
    if (this._panel) {
        this._panel.reveal();
    } else {
        this._getBaseHtml().then(p_baseHtml =&gt; {
            this._panel = vscode.window.createWebviewPanel(
                'leoSettings', // Identifies the type of the webview. Used internally
                'Leo Integration Settings', // Title of the panel displayed to the user
                { viewColumn: vscode.ViewColumn.Beside, preserveFocus: false }, // Editor column to show the new webview panel in.
                {
                    retainContextWhenHidden: false,
                    enableFindWidget: true,
                    enableCommandUris: true,
                    enableScripts: true
                }
            );
            let w_baseUri = this._panel.webview.asWebviewUri(vscode.Uri.file(
                path.join(this._extensionPath)
            ));
            this._panel.iconPath = vscode.Uri.file(this._context.asAbsolutePath('resources/leoapp128px.png'));
            this._panel.webview.html = p_baseHtml.replace(
                /#{root}/g,
                w_baseUri.toString()
            ).replace(
                /#{endOfBody}/g,
                `&lt;script type="text/javascript" nonce="Z2l0bGV1cy1ib290c3RyYXA="&gt;window.leoConfig = ${JSON.stringify(
                    this._leoIntegration.config.getConfig()
                )};&lt;/script&gt;`
            );
            this._panel.webview.onDidReceiveMessage(
                message =&gt; {
                    switch (message.command) {
                        case 'alert':
                            vscode.window.showErrorMessage(message.text);
                            break;
                        case 'chooseLeoEditorPath':
                            vscode.window.showOpenDialog(
                                {
                                    title: "Locate Leo-Editor Installation Folder",
                                    canSelectMany: false,
                                    openLabel: "Choose Folder",
                                    canSelectFiles: false,
                                    canSelectFolders: true

                                }
                            ).then(p_chosenFile =&gt; {
                                if (p_chosenFile &amp;&amp; p_chosenFile.length) {
                                    this._panel!.webview.postMessage(
                                        {
                                            command: 'newEditorPath',
                                            editorPath: p_chosenFile[0].fsPath
                                        }
                                    );
                                }
                            });
                            break;
                        case 'getNewConfig':
                            if (this._panel &amp;&amp; !this._waitingForUpdate) {
                                this._panel.webview.postMessage(
                                    {
                                        command: 'newConfig',
                                        config: this._leoIntegration.config.getConfig()
                                    }
                                );
                            }
                            break;
                        case 'config':
                            this._waitingForUpdate = true;
                            this._leoIntegration.config.setLeoIntegSettings(message.changes).then(() =&gt; {
                                this._panel!.webview.postMessage(
                                    {
                                        command: 'vscodeConfig',
                                        config: this._leoIntegration.config.getConfig()
                                    }
                                );
                                this._waitingForUpdate = false;
                            });
                            break;
                    }
                },
                null,
                this._context.subscriptions
            );
            this._panel.onDidDispose(() =&gt; {
                // console.log('disposed');
                this._panel = undefined;
            },
                null,
                this._context.subscriptions);
        });
    }
}

</t>
<t tx="fil.20210603195319.4">private async _getBaseHtml(): Promise&lt;string&gt; {
    if (this._html !== undefined) {
        return this._html;
    } else {
        const w_filename = this._context.asAbsolutePath(path.join('dist/webviews/', 'settings.html'));
        const w_doc = await vscode.workspace.openTextDocument(w_filename);

        this._html = w_doc.getText();

        return this._html;
    }
}
</t>
<t tx="fil.20210603195851.1">public resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken
) {
    this._view = webviewView;

    webviewView.webview.options = {
        // Allow scripts in the webview
        enableScripts: true,

        localResourceRoots: [this._extensionUri],
    };

    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    webviewView.webview.onDidReceiveMessage((data) =&gt; {
        switch (data.type) {
            case 'leoFindNext': {
                vscode.commands.executeCommand(Constants.COMMANDS.FIND_NEXT);
                break;
            }
            case 'leoFindPrevious': {
                vscode.commands.executeCommand(Constants.COMMANDS.FIND_PREVIOUS);
                break;
            }
            case 'searchConfig': {
                this._leoIntegration.saveSearchSettings(data.value);
                break;
            }
            case 'replace': {
                this._leoIntegration.replace(true, false);
                break;
            }
            case 'replaceThenFind': {
                this._leoIntegration.replace(true, true);
                break;
            }
            case 'refreshSearchConfig': {
                // Leave a cycle before getting settings
                setTimeout(() =&gt; {
                    this._leoIntegration.loadSearchSettings();
                }, 0);
                break;
            }
        }
    });
    this._leoIntegration.setFindPanel(this._view);
}

</t>
<t tx="fil.20210603195902.1">private _getHtmlForWebview(webview: vscode.Webview) {
    // Get the local path to main script run in the webview, then convert it to a uri we can use in the webview.
    const scriptUri = webview.asWebviewUri(
        vscode.Uri.joinPath(this._extensionUri, 'src', 'webviews', 'findPanel', 'main.js')
    );

    // Do the same for the stylesheet.
    const styleResetUri = webview.asWebviewUri(
        vscode.Uri.joinPath(this._extensionUri, 'src', 'webviews', 'findPanel', 'reset.css')
    );
    const styleVSCodeUri = webview.asWebviewUri(
        vscode.Uri.joinPath(this._extensionUri, 'src', 'webviews', 'findPanel', 'vscode.css')
    );
    const styleMainUri = webview.asWebviewUri(
        vscode.Uri.joinPath(this._extensionUri, 'src', 'webviews', 'findPanel', 'main.css')
    );

    // Use a nonce to only allow a specific script to be run.
    const nonce = this.getNonce();

    return `&lt;!DOCTYPE html&gt;
        &lt;html lang="en"&gt;
        &lt;head&gt;
            &lt;meta charset="UTF-8"&gt;
            &lt;meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource}; script-src 'nonce-${nonce}';"&gt;
            &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
            &lt;link href="${styleResetUri}" rel="stylesheet"&gt;
            &lt;link href="${styleVSCodeUri}" rel="stylesheet"&gt;
            &lt;link href="${styleMainUri}" rel="stylesheet"&gt;

            &lt;title&gt;Leo Find Panel&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;label for="findText"&gt;Find:&lt;/label&gt;
            &lt;input type="text" id="findText" name="findText" placeholder="&lt;find pattern here&gt;" &gt;
            &lt;label for="replaceText"&gt;Replace:&lt;/label&gt;
            &lt;input type="text" id="replaceText" name="replaceText" &gt;
            &lt;div class="row"&gt;
                &lt;div class="col"&gt;
                    &lt;input type="checkbox" id="wholeWord" name="wholeWord" &gt;
                    &lt;label for="wholeWord"&gt;Whole &lt;u&gt;w&lt;/u&gt;ord&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="ignoreCase" name="ignoreCase" &gt;
                    &lt;label for="ignoreCase"&gt;&lt;u&gt;I&lt;/u&gt;gnore case&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="regExp" name="regExp" &gt;
                    &lt;label for="regExp"&gt;Rege&lt;u&gt;x&lt;/u&gt;p&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="markFinds" name="markFinds" &gt;
                    &lt;label for="markFinds"&gt;Mark &lt;u&gt;f&lt;/u&gt;inds&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="markChanges" name="markChanges" &gt;
                    &lt;label for="markChanges"&gt;Mark &lt;u&gt;c&lt;/u&gt;hanges&lt;/label&gt;
                &lt;/div&gt;
                &lt;div class="col"&gt;
                    &lt;input type="radio" id="entireOutline" name="searchScope" value="0"&gt;
                    &lt;label for="entireOutline"&gt;&lt;u&gt;E&lt;/u&gt;ntire outline&lt;/label&gt;&lt;br&gt;
                    &lt;input type="radio" id="subOutlineOnly" name="searchScope" value="1"&gt;
                    &lt;label for="subOutlineOnly"&gt;&lt;u&gt;S&lt;/u&gt;uboutline Only&lt;/label&gt;&lt;br&gt;
                    &lt;input type="radio" id="nodeOnly" name="searchScope" value="2"&gt;
                    &lt;label for="nodeOnly"&gt;&lt;u&gt;N&lt;/u&gt;ode only&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="searchHeadline" name="searchHeadline" &gt;
                    &lt;label for="searchHeadline"&gt;Search &lt;u&gt;h&lt;/u&gt;eadline&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="searchBody" name="searchBody" &gt;
                    &lt;label for="searchBody"&gt;Search &lt;u&gt;b&lt;/u&gt;ody&lt;/label&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;script nonce="${nonce}" src="${scriptUri}"&gt;&lt;/script&gt;
        &lt;/body&gt;
        &lt;/html&gt;`;
}

</t>
<t tx="fil.20210603195909.1">private getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i &lt; 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}
</t>
<t tx="fil.20210603223013.1"></t>
<t tx="fil.20210603223013.10">checkboxIds.forEach((p_inputId) =&gt; {
            //@ts-expect-error
    document.getElementById(p_inputId).checked = p_settings[p_inputId];
    searchSettings[p_inputId] = p_settings[p_inputId];
});
        //@ts-expect-error
document.getElementById(radioIds[p_settings['searchScope']]).checked = true;
searchSettings.searchScope = p_settings['searchScope'];
</t>
<t tx="fil.20210603223013.11">function sendSearchConfig() {
    dirty = false; // clear dirty flag
    vscode.postMessage({ type: 'searchConfig', value: searchSettings });
}

let timer; // for debouncing sending the settings from this webview to leointeg
let dirty = false;
</t>
<t tx="fil.20210603223013.12">function processChange() {
    clearTimeout(timer);
    dirty = true;
    timer = setTimeout(() =&gt; {
        sendSearchConfig();
    }, 300);
}

</t>
<t tx="fil.20210603223013.13"></t>
<t tx="fil.20210603223013.14">inputIds.forEach((p_inputId) =&gt; {
    @others
});
</t>
<t tx="fil.20210603223013.15">document.getElementById(p_inputId).onkeypress = function (p_event) {
            //@ts-expect-error
    if (!p_event) p_event = window.event;
    var keyCode = p_event.code || p_event.key;
    if (keyCode == 'Enter') {
        if (timer) {
            clearTimeout(timer);
            sendSearchConfig();
        }
        vscode.postMessage({ type: 'leoFindNext' });
        return false;
    }
};
</t>
<t tx="fil.20210603223013.16">document.getElementById(p_inputId).addEventListener('input', function (p_event) {
            //@ts-expect-error
    searchSettings[p_inputId] = this.value;
    processChange();
});
</t>
<t tx="fil.20210603223013.17">checkboxIds.forEach((p_inputId) =&gt; {
    document.getElementById(p_inputId).addEventListener('change', function (p_event) {
            //@ts-expect-error
        searchSettings[p_inputId] = this.checked;
        processChange();
    });
});
</t>
<t tx="fil.20210603223013.18"></t>
<t tx="fil.20210603223013.19">radioIds.forEach((p_inputId) =&gt; {
    document.getElementById(p_inputId).addEventListener('change', function (p_event) {
        searchSettings['searchScope'] = parseInt(
                //@ts-expect-error
            document.querySelector('input[name="searchScope"]:checked').value
        );
        processChange();
    });
});

</t>
<t tx="fil.20210603223013.2">@language css
body {
	background-color: transparent;
}

div.row {
	overflow-x: hidden;
	white-space: nowrap;
}

div.col {
	width: 9.5em;
	display: inline-block;
}</t>
<t tx="fil.20210603223013.20"></t>
<t tx="fil.20210603223013.21">/**
 * @param {string} p_inputId
 */
function toggleCheckbox(p_inputId) {
    let w_checkbox = document.getElementById(p_inputId);
    let w_setTo = true;
        //@ts-expect-error
    if (w_checkbox.checked) {
        w_setTo = false;
    }
        //@ts-expect-error
    w_checkbox.checked = w_setTo;
    searchSettings[p_inputId] = w_setTo;
    if (timer) {
        clearTimeout(timer);
    }
    sendSearchConfig();
}

</t>
<t tx="fil.20210603223013.22">/**
 * @param {string} p_inputId
 */
function setRadio(p_inputId) {
        //@ts-expect-error
    document.getElementById(p_inputId).checked = true;
    searchSettings['searchScope'] = parseInt(
            //@ts-expect-error
        document.querySelector('input[name="searchScope"]:checked').value
    );
    if (timer) {
        clearTimeout(timer);
    }
    sendSearchConfig();
}

</t>
<t tx="fil.20210603223013.23">/**
 *
 * @param {KeyboardEvent} p_event
 */
function checkKeyDown(p_event) {
        //@ts-expect-error
    if (!p_event) p_event = window.event;
    var keyCode = p_event.code || p_event.key;

    console.log('got keycode:', keyCode);

    if (keyCode === 'F2') {
        p_event.preventDefault();
        p_event.stopPropagation();
        p_event.stopImmediatePropagation();
        vscode.postMessage({ type: 'leoFindPrevious' });
        return;
    }
    if (keyCode === 'F3') {
        p_event.preventDefault();
        p_event.stopPropagation();
        p_event.stopImmediatePropagation();
        vscode.postMessage({ type: 'leoFindNext' });
        return;
    }

    if ((keyCode === 'f' || keyCode === 'KeyF') &amp;&amp; p_event.ctrlKey) {
        p_event.preventDefault();
        p_event.stopPropagation();
        p_event.stopImmediatePropagation();
        focusOnField('findText');
        return;
    }
    if ((keyCode === 't' || keyCode === 'KeyT') &amp;&amp; p_event.ctrlKey) {
        p_event.preventDefault();
        p_event.stopPropagation();
        p_event.stopImmediatePropagation();
        vscode.postMessage({ type: 'focusOnTree' });
        return;
    }
    if ((keyCode === '=' || keyCode === 'Equal') &amp;&amp; p_event.ctrlKey) {
        p_event.preventDefault();
        p_event.stopPropagation();
        p_event.stopImmediatePropagation();
        vscode.postMessage({ type: 'replace' });
        return;
    }
    if ((keyCode === '-' || keyCode === 'Minus') &amp;&amp; p_event.ctrlKey) {
        p_event.preventDefault();
        p_event.stopPropagation();
        p_event.stopImmediatePropagation();
        vscode.postMessage({ type: 'replaceThenFind' });
        return;
    }

    if (keyCode === 'Tab') {
        var actEl = document.activeElement;
        if (p_event.shiftKey) {
            var firstEl = document.getElementById('findText');
            if (actEl === firstEl) {
                p_event.preventDefault();
                p_event.stopPropagation();
                p_event.stopImmediatePropagation();
                document.getElementById('searchBody').focus();
                return;
            }
        } else {
            var lastEl = document.getElementById('searchBody');
            if (actEl === lastEl) {
                p_event.preventDefault();
                p_event.stopPropagation();
                p_event.stopImmediatePropagation();
                focusOnField('findText');
                return;
            }
        }
    }

    if (p_event.ctrlKey &amp;&amp; p_event.altKey) {
        switch (keyCode) {
            case 'w':
            case 'KeyW':
                toggleCheckbox('wholeWord');
                return;
            case 'i':
            case 'KeyI':
                toggleCheckbox('ignoreCase');
                return;
            case 'x':
            case 'KeyX':
                toggleCheckbox('regExp');
                return;
            case 'f':
            case 'KeyF':
                toggleCheckbox('markFinds');
                return;
            case 'c':
            case 'KeyC':
                toggleCheckbox('markChanges');
                return;
            case 'h':
            case 'KeyH':
                toggleCheckbox('searchHeadline');
                return;
            case 'b':
            case 'KeyB':
                toggleCheckbox('searchBody');
                return;
            case 'e':
            case 'KeyE':
                setRadio('entireOutline');
                return;
            case 's':
            case 'KeyS':
                setRadio('subOutlineOnly');
                return;
            case 'n':
            case 'KeyN':
                setRadio('nodeOnly');
                return;
            default:
                break;
        }
    }
}

// TODO :  CAPTURE FOCUS IN OVERALL PANEL AND SET CONTEXT-VAR OF 'FOCUSED PANEL'

// TODO : ALSO CYCLE TABS !!
// TODO : ALSO CAPTURE CTRL+T TO FOCUS OUT OF HERE

// TODO : CHECK FOR ALT+CTRL+SHORTCUTS FOR TOGGLES AND RADIOS
// document.addEventListener ("keydown", function (zEvent) {
//     if (zEvent.ctrlKey  &amp;&amp;  zEvent.altKey  &amp;&amp;  zEvent.key === "e") {  // case sensitive
//         // DO YOUR STUFF HERE
//     }
// } );

document.onkeydown = checkKeyDown;

</t>
<t tx="fil.20210603223013.24">/**
 * @param {string} p_id
 */
function focusOnField(p_id) {
    const inputField = document.querySelector('#' + p_id);
        //@ts-expect-error
    inputField.select();
    // TODO : TEST IF NEEDED TO PREVENT FLICKER ON FIRST TRY?
    setTimeout(() =&gt; {
            //@ts-expect-error
        inputField.select();
    }, 0);
}

</t>
<t tx="fil.20210603223013.25"></t>
<t tx="fil.20210603223013.26">function getSettings() {
    // clear dirty, clear timer,
    if (dirty) {
        dirty = false;
        clearTimeout(timer);
        sendSearchConfig(); // just trigger send settings
    }
}

// FINISH STARTUP
vscode.postMessage({ type: 'refreshSearchConfig' });
</t>
<t tx="fil.20210603223013.4">//@ts-check

// This script will be run within the webview itself
// It cannot access the main VS Code APIs directly.
// Send message to leoInteg with vscode.postMessage({ keyNameEx1: someValue, ... });
// Receive messages from leoInteg with window.addEventListener('message', event =&gt; { ... });
@others
@language javascript
@tabwidth -4
</t>
<t tx="fil.20210603223013.5">(function () {
    //@ts-expect-error
    const vscode = acquireVsCodeApi();

    // * LeoSearchSettings Type
    let searchSettings = {
        findText: '',
        replaceText: '',
        wholeWord: false,
        ignoreCase: true,
        regExp: false,
        markFinds: false,
        markChanges: false,
        searchHeadline: true,
        searchBody: true,
        searchScope: 0, // 0 is entire outline (1: sub-outline, 2: node only)
    };

    // Handle messages sent from the extension to the webview
    @others
})();
</t>
<t tx="fil.20210603223013.6">window.addEventListener('message', (event) =&gt; {
    const message = event.data; // The json data that the extension sent
    switch (message.type) {
        // Focus and select all text in 'find' field
        case 'selectFind': {
            focusOnField('findText');
            break;
        }
        // Focus and select all text in 'replace' field
        case 'selectReplace': {
            focusOnField('replaceText');
            break;
        }
        case 'getSettings': {
            getSettings();
            break;
        }
        case 'setSettings': {
            setSettings(message.value);
            break;
        }
        case 'setSearchSetting': {
            setSearchSetting(message.id);
            break;
        }
    }
});

let inputIds = ['findText', 'replaceText'];
let checkboxIds = [
    'wholeWord',
    'ignoreCase',
    'regExp',
    'markFinds',
    'markChanges',
    'searchHeadline',
    'searchBody',
];
let radioIds = ['entireOutline', 'subOutlineOnly', 'nodeOnly'];

</t>
<t tx="fil.20210603223013.7">/**
 * @param {string} p_id
 */
function setSearchSetting(p_id) {
    if (checkboxIds.includes(p_id)) {
        toggleCheckbox(p_id);
    } else if (radioIds.includes(p_id)) {
        setRadio(p_id);
    }
}

</t>
<t tx="fil.20210603223013.8">/**
 * @param {any} p_settings
 */
function setSettings(p_settings) {
    // When opening a Leo document, set default values of fields
    @others
}

</t>
<t tx="fil.20210603223013.9">inputIds.forEach((p_inputId) =&gt; {
            //@ts-expect-error
    document.getElementById(p_inputId).value = p_settings[p_inputId];
    searchSettings[p_inputId] = p_settings[p_inputId];
});
</t>
<t tx="fil.20210603223014.2">@language css
html {
	box-sizing: border-box;
	font-size: 13px;
}

*,
*:before,
*:after {
	box-sizing: inherit;
}

body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
ol,
ul {
	margin: 0;
	padding: 0;
	font-weight: normal;
}

img {
	max-width: 100%;
	height: auto;
}
</t>
<t tx="fil.20210603223014.4">@language css
:root {
	--container-padding: 20px;
	--input-padding-vertical: 6px;
	--input-padding-horizontal: 4px;
	--input-margin-vertical: 4px;
	--input-margin-horizontal: 0;
}

body {
	padding: 0 var(--container-padding);
	color: var(--vscode-foreground);
	font-size: var(--vscode-font-size);
	font-weight: var(--vscode-font-weight);
	font-family: var(--vscode-font-family);
	background-color: var(--vscode-editor-background);
}

ol,
ul {
	padding-left: var(--container-padding);
}

body &gt; *,
form &gt; * {
	margin-block-start: var(--input-margin-vertical);
	margin-block-end: var(--input-margin-vertical);
}

*:focus {
	outline-color: var(--vscode-focusBorder) !important;
}

a {
	color: var(--vscode-textLink-foreground);
}

a:hover,
a:active {
	color: var(--vscode-textLink-activeForeground);
}

code {
	font-size: var(--vscode-editor-font-size);
	font-family: var(--vscode-editor-font-family);
}

button {
	border: none;
	padding: var(--input-padding-vertical) var(--input-padding-horizontal);
	width: 100%;
	text-align: center;
	outline: 1px solid transparent;
	outline-offset: 2px !important;
	color: var(--vscode-button-foreground);
	background: var(--vscode-button-background);
}

button:hover {
	cursor: pointer;
	background: var(--vscode-button-hoverBackground);
}

button:focus {
	outline-color: var(--vscode-focusBorder);
}

button.secondary {
	color: var(--vscode-button-secondaryForeground);
	background: var(--vscode-button-secondaryBackground);
}

button.secondary:hover {
	background: var(--vscode-button-secondaryHoverBackground);
}

input:not([type="radio"]):not([type="checkbox"]),
textarea {
	display: block;
	width: 100%;
	border: none;
	font-family: var(--vscode-font-family);
	padding: var(--input-padding-vertical) var(--input-padding-horizontal);
	color: var(--vscode-input-foreground);
	outline-color: var(--vscode-input-border);
	background-color: var(--vscode-input-background);
}

input[type="checkbox"]:focus + label {
	border: 1px solid var(--vscode-button-background);
  }
input[type="radio"]:focus + label {
	border: 1px solid var(--vscode-button-background);
  }

input::placeholder,
textarea::placeholder {
	color: var(--vscode-input-placeholderForeground);
}

u {
	color:var(--vscode-editor-foreground);
	text-decoration-color: var(--vscode-foreground);
	text-underline-offset: 0.04em;
}</t>
<t tx="fil.20210603223933.1"></t>
<t tx="fil.20210603223933.10">&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
&lt;/head&gt;

&lt;body class="preload"&gt;
  &lt;div class="container"&gt;

    &lt;header&gt;
      &lt;a class="header__link"
         title="Learn more about Leo Integration"
         href="https://github.com/boltex/leointeg#literate-programming"&gt;
        &lt;div class="header__logo"&gt;
          &lt;img class="image__logo"
               src="#{root}/resources/leoapp128px.png" /&gt;
          &lt;div&gt;
            &lt;h1&gt;Leo&lt;span class="header__logo--highlight"&gt;Integ&lt;/span&gt;&lt;/h1&gt;
            &lt;p class="header__subtitle"&gt;Leo for VS Code&lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/a&gt;
      &lt;p class="header__blurb"&gt;
        Use &lt;b&gt;Leo&lt;/b&gt;, the Literate Editor with Outlines, to program with &lt;b&gt;directed acyclic graphs&lt;/b&gt;,
        along with section-references, '@others' and clones to generate (and read from) external files.
      &lt;/p&gt;
    &lt;/header&gt;

    &lt;div class="hero__area"&gt;
      &lt;p&gt;
        &lt;a class="bold"
           title="Learn more about LeoInteg"
           href="https://github.com/boltex/leointeg#-leo-editor-integration-with-visual-studio-code"&gt;LeoInteg&lt;/a&gt;
        is an open-source extension created by
        &lt;a class="bold"
           title="My github user page"
           href="https://github.com/boltex"&gt;Flix&lt;/a&gt; that integrates &lt;a class="bold"
           title="Learn more about Leo"
           href="https://leoeditor.com/"&gt;Leo&lt;/a&gt; into Visual Studio
        Code.
      &lt;/p&gt;
      &lt;!-- &lt;div class="cta is-sidebar-hidden center"&gt;
        &lt;div class="cta--primary"&gt;
          &lt;a class="button button--flat-primary button--big" title="Support LeoInteg"
            href="https://github.com/boltex/leointeg"&gt;Support LeoInteg &amp;#x2764;&lt;/a&gt;
          &lt;p&gt;
            LeoInteg is built by the support of generous open source users and programmers like &lt;b&gt;you&lt;/b&gt;!
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt; --&gt;
    &lt;/div&gt;

    &lt;div class="content__area"&gt;
      &lt;section id="welcome"
               class="section--full mb-0"&gt;
        &lt;h2 class="section__title section__title--primary"&gt;
          Welcome to &lt;span class="highlight"&gt;LeoInteg 0.1.15&lt;/span&gt;
        &lt;/h2&gt;
        &lt;div class="center mt-1"&gt;
          &lt;a class="button button--flat"
             title="LeoInteg's Features"
             href="https://github.com/boltex/leointeg#features"&gt;
            See What's New in LeoInteg 0.1.15
          &lt;/a&gt;
        &lt;/div&gt;
        &lt;p class="blurb center ml-0 mr-0"&gt;
          LeoInteg is designed to &lt;b&gt;provide Leo's functionality&lt;/b&gt;
          and can be &lt;b&gt;customized&lt;/b&gt; to meet your needs.
        &lt;/p&gt;
        &lt;h2 class="section__title section__title--break"&gt;&lt;/h2&gt;
        &lt;p class="section__hint mt-0 center"&gt;
          Automate the &lt;a href="#leobridge-options"&gt;leoBridge startup&lt;/a&gt;,
          auto-refresh when &lt;a href="#external-files"&gt;external files change&lt;/a&gt;,
          or choose which &lt;a href="#node-commands"&gt;node icons&lt;/a&gt;
          are shown and more with the options below.
        &lt;/p&gt;
      &lt;/section&gt;

      &lt;section id="leobridge-options"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Leo Bridge Options
            &lt;/h2&gt;
          &lt;/div&gt;
          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="startServerAutomatically"
                       name="startServerAutomatically"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="startServerAutomatically"&gt;Start&amp;nbsp;Server&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Run the leobridgeserver.py server script at startup&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="connectToServerAutomatically"
                       name="connectToServerAutomatically"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="connectToServerAutomatically"&gt;Connect&amp;nbsp;to&amp;nbsp;Server&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Connects automatically to a LeoBridge server&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="leoEditorPath"&gt;Leo&amp;#8209;Editor&amp;nbsp;Path&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/label&gt;
                &lt;input id="leoEditorPath"
                       name="leoEditorPath"
                       type="text"
                       maxlength="256"
                       placeholder="C:/leo-editor"
                       data-setting /&gt;
                &lt;button type="button"
                        id="chooseLeoEditorPath"
                        name="chooseLeoEditorPath"
                        class="button btn button--flat button--flat-primary button--choose-path"&gt;
                  Browse For Folder...
                &lt;/button&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Location of your Leo-Editor installation&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="leoPythonCommand"&gt;Python&amp;nbsp;Command&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/label&gt;
                &lt;input id="leoPythonCommand"
                       name="leoPythonCommand"
                       type="text"
                       maxlength="256"
                       placeholder="Empty for default"
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Command for starting python (Defaults to 'py' on windows, or
                'python3' otherwise)&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="connectionAddress"&gt;Connection&amp;nbsp;Address&lt;/label&gt;
                &lt;input id="connectionAddress"
                       name="connectionAddress"
                       type="text"
                       maxlength="256"
                       placeholder="Host Name, IP Address or localhost"
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Connection host&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="connectionPort"&gt;Connection&amp;nbsp;Port&lt;/label&gt;
                &lt;input id="connectionPort"
                       name="connectionPort"
                       type="number"
                       min="0"
                       max="65535"
                       max-length="5"
                       placeholder="Port Number"
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Connection host port number&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="external-files"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              External Files Change Detection
            &lt;/h2&gt;
          &lt;/div&gt;
          &lt;div class="settings"&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="checkForChangeExternalFiles"&gt;Check changes to external files&lt;/label&gt;
                &lt;select id="checkForChangeExternalFiles"
                        name="checkForChangeExternalFiles"
                        data-setting&gt;
                  &lt;option value="none"&gt;Default from Leo's config&lt;/option&gt;
                  &lt;option value="force-check"&gt;Check for changes&lt;/option&gt;
                  &lt;option value="force-ignore"&gt;Ignore all changes&lt;/option&gt;
                &lt;/select&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Use Leo's defaults, or force either to check changes or not&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="defaultReloadIgnore"&gt;Force reload or ignore changes&lt;/label&gt;
                &lt;select id="defaultReloadIgnore"
                        name="defaultReloadIgnore"
                        data-setting&gt;
                  &lt;option value="none"&gt;Choose each time&lt;/option&gt;
                  &lt;option value="yes-all"&gt;Reload All&lt;/option&gt;
                  &lt;option value="no-all"&gt;Ignore All&lt;/option&gt;
                &lt;/select&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Choose yourself, or set default to reload or ignore changes&lt;/span&gt;
            &lt;/div&gt;

          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="interface-behavior"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Interface Behavior
            &lt;/h2&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="leoTreeBrowse"
                       name="leoTreeBrowse"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="leoTreeBrowse"&gt;Use Leo Tree Browsing&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Navigate Leo's outline with Leo's shortcuts and behavior instead of the
                default vscode
                method&lt;br&gt;(Arrow keys move selection instead of moving a cursor when focus is on Leo's outline)&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="treeKeepFocus"
                       name="treeKeepFocus"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="treeKeepFocus"&gt;Keep focus on Outline&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Keep focus in the outline when selecting a node - overridden by "&lt;strong&gt;Leo
                  Tree
                  Browsing"&lt;/strong&gt;&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="treeKeepFocusWhenAside"
                       name="treeKeepFocusWhenAside"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="treeKeepFocusWhenAside"&gt;Keep focus when opening on the side&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Keep focus in the outline when opening a body pane on the side&lt;/span&gt;
            &lt;/div&gt;

          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="tree-in-explorer"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;div class="setting__input setting__input--big"&gt;
              &lt;input id="treeInExplorer"
                     name="treeInExplorer"
                     type="checkbox"
                     data-setting /&gt;
              &lt;label for="treeInExplorer"&gt;Show&amp;nbsp;Leo&amp;nbsp;Outline&amp;nbsp;in&amp;nbsp;Explorer&lt;/label&gt;
            &lt;/div&gt;
            &lt;p class="section__header-hint"&gt;
              Adds an instance of the outline pane in the explorer view
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="section__preview"&gt;
          &lt;img class="image__preview"
               src="#{root}/resources/treeInExplorerDisabled.png" /&gt;
          &lt;img class="image__preview--overlay hidden"
               src="#{root}/resources/treeInExplorerEnabled.png"
               data-visibility="treeInExplorer" /&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="show-open-aside"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;div class="setting__input setting__input--big"&gt;
              &lt;input id="showOpenAside"
                     name="showOpenAside"
                     type="checkbox"
                     data-setting /&gt;
              &lt;label for="showOpenAside"&gt;Show&amp;nbsp;'Open&amp;nbsp;to&amp;nbsp;the&amp;nbsp;Side'&lt;/label&gt;
            &lt;/div&gt;
            &lt;p class="section__header-hint"&gt;
              Adds the command in the node's context menu
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="section__preview"&gt;
          &lt;img class="image__preview"
               src="#{root}/resources/showOpenAsideDisabled.png" /&gt;
          &lt;img class="image__preview--overlay hidden"
               src="#{root}/resources/showOpenAsideEnabled.png"
               data-visibility="showOpenAside" /&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="invert-contrast"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;div class="setting__input setting__input--big"&gt;
              &lt;input id="invertNodeContrast"
                     name="invertNodeContrast"
                     type="checkbox"
                     data-setting /&gt;
              &lt;label for="invertNodeContrast"&gt;Invert Node Contrast&lt;/label&gt;
            &lt;/div&gt;
            &lt;p class="section__header-hint"&gt;
              Inverts the dirty/clean border of tree nodes
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="section__preview"&gt;
          &lt;img class="image__preview"
               src="#{root}/resources/invertedDisabled.png" /&gt;
          &lt;img class="image__preview--overlay hidden"
               src="#{root}/resources/invertedEnabled.png"
               data-visibility="invertNodeContrast" /&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="node-commands"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Node Commands
            &lt;/h2&gt;
            &lt;p class="section__header-hint"&gt;
              Hovering tree nodes displays an edit icon - Choose more commands to display when hovering
            &lt;/p&gt;
          &lt;/div&gt;
          &lt;div class="section__preview"&gt;

            &lt;img class="image__preview"
                 src="#{root}/resources/allIconsDisabled.png" /&gt;

            &lt;div class="image__preview--float-container"&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/bookmark.png"
                   data-visibility="showMarkOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/copy.png"
                   data-visibility="showCopyOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/clone.png"
                   data-visibility="showCloneOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/arrows.png"
                   data-visibility="showArrowsOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/add.png"
                   data-visibility="showAddOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/editHeadline.png"
                   data-visibility="showEditOnNodes" /&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showEditOnNodes"
                       name="showEditOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showEditOnNodes"&gt;Edit&amp;nbsp;Headline&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Edit Headline' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showMarkOnNodes"
                       name="showMarkOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showMarkOnNodes"&gt;Mark&amp;nbsp;/&amp;nbsp;Unmark&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Mark/Unmark' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showCopyOnNodes"
                       name="showCopyOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showCopyOnNodes"&gt;Copy&amp;nbsp;Node&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Copy' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showCloneOnNodes"
                       name="showCloneOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showCloneOnNodes"&gt;Clone&amp;nbsp;Node&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Clone' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showArrowsOnNodes"
                       name="showArrowsOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showArrowsOnNodes"&gt;Move&amp;nbsp;arrow&amp;nbsp;commands&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Move' arrows on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showAddOnNodes"
                       name="showAddOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showAddOnNodes"&gt;Add&amp;nbsp;Node&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Insert' on hover&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;

        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="statusbar-indicator"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Statusbar Indicator
            &lt;/h2&gt;
            &lt;p class="section__header-hint"&gt;
              Keyboard icon can also include a label and be displayed in a specific color
            &lt;/p&gt;
          &lt;/div&gt;

          &lt;div class="section__preview"&gt;
            &lt;img class="image__preview"
                 src="#{root}/resources/statusbar.png" /&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="statusBarString"&gt;Status Bar Keyboard indicator&lt;/label&gt;
                &lt;input id="statusBarString"
                       name="statusBarString"
                       type="text"
                       maxlength="8"
                       placeholder="Status bar indicator text "
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Keybindings 'on/off' indicator text message&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="statusBarColor"&gt;Status Bar Color&lt;/label&gt;
                &lt;input id="statusBarColor"
                       name="statusBarColor"
                       type="text"
                       maxlength="6"
                       placeholder="RrGgBb"
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Keybindings 'on' indicator 6 hex digits color code&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;
    &lt;/div&gt;

    &lt;div class="sidebar"&gt;
      &lt;!-- &lt;div class="sidebar__group"&gt;
        &lt;a class="button button--flat-primary" title="Support LeoInteg"
          href="https://github.com/boltex/leointeg"&gt;Support
          LeoInteg &amp;#x2764;&lt;/a&gt;
        &lt;p&gt;
          LeoInteg is built by the support of generous open source users and programmers like &lt;b&gt;you&lt;/b&gt;!
        &lt;/p&gt;
      &lt;/div&gt; --&gt;

      &lt;div class="sidebar__group"&gt;
        &lt;h2&gt;Configuration&lt;/h2&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href="#leobridge-options"&gt;LeoBridge Options&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#external-files"&gt;External Files&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#interface-behavior"&gt;Interface Behavior&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#tree-in-explorer"&gt;Outline in Explorer&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#show-open-aside"&gt;Open to the Side&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#invert-contrast"&gt;Invert Contrast&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#node-commands"&gt;Node Hover Commands&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#statusbar-indicator"&gt;Statusbar Indicator&lt;/a&gt;
          &lt;/li&gt;

        &lt;/ul&gt;
      &lt;/div&gt;

      &lt;!-- &lt;div class="sidebar__group"&gt;
        &lt;h2&gt;Help&lt;/h2&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href="https://github.com/boltex/leointeg#requirements"&gt;Documentation&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://github.com/boltex/leointeg/blob/master/CHANGELOG.md#change-log"&gt;Changelog&lt;/a&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt; --&gt;

      &lt;div class="sidebar__group"&gt;
        &lt;h2&gt;About Leo&lt;/h2&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href="https://leoeditor.com/"&gt;Home Page&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://leoeditor.com/leo_toc.html"&gt;Documentation&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://groups.google.com/forum/#!forum/leo-editor"&gt;Forum&lt;/a&gt;
            &lt;small&gt; &amp;nbsp;&amp;nbsp;&amp;mdash;&amp;nbsp; #Google Group&lt;/small&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://github.com/leo-editor/leo-editor"&gt;Source&lt;/a&gt;
            &lt;small&gt; &amp;nbsp;&amp;nbsp;&amp;mdash;&amp;nbsp; #GitHub&lt;/small&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;

  &lt;/div&gt;
  &lt;div id="dirty-config-toast"&gt;Saving...&lt;/div&gt;
  &lt;div id="saved-config-toast"&gt;Settings Saved&lt;/div&gt;
  #{endOfBody}
&lt;/body&gt;

&lt;/html&gt;
</t>
<t tx="fil.20210603223933.165">import { initializeAndWatchThemeColors } from './theme';
import { debounce } from "debounce";
import { ConfigSetting } from '../../types';

interface VsCodeApi {
    postMessage(msg: {}): void;
    setState(state: {}): void;
    getState(): { [key: string]: any };
}

declare function acquireVsCodeApi(): VsCodeApi;

@others
@language typescript
@tabwidth -4
</t>
<t tx="fil.20210603223933.166">(function () {
    const vscode = acquireVsCodeApi();
    initializeAndWatchThemeColors();

    const toast = document.getElementById("saved-config-toast");
    const dirty = document.getElementById("dirty-config-toast");

    // * TEST
    const oldState = vscode.getState();
    let currentCount: number = (oldState &amp;&amp; oldState.count) || 0;
    if (currentCount) {
        // Already opened! Get fresh and recent config!
        vscode.postMessage({
            command: "getNewConfig"
        });
    }
    currentCount = currentCount + 1;
    vscode.setState({ count: currentCount });

    // * SETUP
    // Global variable config
    let frontConfig: { [key: string]: any } = {};
    let vscodeConfig: { [key: string]: any } = {};

    vscodeConfig = (window as any).leoConfig; // ! PRE SET BY leoSettingsWebview
    frontConfig = JSON.parse(JSON.stringify(vscodeConfig));

    // Handle messages sent from the extension to the webview
    window.addEventListener("message", event =&gt; {
        const message = event.data; // The json data that the extension sent
        if (message.command) {
            switch (message.command) {
                case "test":
                    console.log("got test message");
                    break;
                case "newConfig":
                    vscodeConfig = message.config;
                    frontConfig = JSON.parse(JSON.stringify(message.config));
                    setControls();
                    break;
                case "vscodeConfig":
                    dirty!.className = dirty!.className.replace("show", "");
                    toast!.className = "show";
                    setTimeout(function () { toast!.className = toast!.className.replace("show", ""); }, 1500);
                    vscodeConfig = message.config; // next changes will be confronted to those settings
                    break;
                case "newEditorPath":
                    const w_element: HTMLElement | null = document.getElementById("leoEditorPath");
                    if (w_element) {
                        (w_element as HTMLInputElement).value = message.editorPath;
                        onInputChanged(w_element as HTMLInputElement);
                    }
                    break;
                default:
                    console.log("got message: ", message.command);
                    break;
            }
        } else {
            console.log('got object without command:', message);
        }
    });

    @others

    var applyChanges = debounce(function () {
        var w_changes: ConfigSetting[] = [];
        if (frontConfig) {
            for (var prop in frontConfig) {
                if (Object.prototype.hasOwnProperty.call(frontConfig, prop)) {
                    // console.log(prop);
                    if (frontConfig[prop] !== vscodeConfig[prop]) {
                        w_changes.push({ code: prop, value: frontConfig[prop] });
                    }
                }
            }
        }
        if (w_changes.length) {
            // ok replace!
            vscodeConfig = frontConfig;
            frontConfig = JSON.parse(JSON.stringify(frontConfig));
            vscode.postMessage({
                command: "config",
                changes: w_changes
            });
        } else {
            // Still have to remove 'modified' popup
            dirty!.className = dirty!.className.replace("show", "");
        }
    }, 1500);

    // * START
    setControls();
    setVisibility(frontConfig);
    onBind();

})();
</t>
<t tx="fil.20210603223933.2">const cssColorRegex = /^(?:(#?)([0-9a-f]{3}|[0-9a-f]{6})|((?:rgb|hsl)a?)\((-?\d+%?)[,\s]+(-?\d+%?)[,\s]+(-?\d+%?)[,\s]*(-?[\d.]+%?)?\))$/i;

@others
@language typescript
@tabwidth -4
</t>
<t tx="fil.20210603223933.3">function adjustLight(color: number, amount: number) {
    const cc = color + amount;
    const c = amount &lt; 0 ? (cc &lt; 0 ? 0 : cc) : cc &gt; 255 ? 255 : cc;

    return Math.round(c);
}

</t>
<t tx="fil.20210603223933.4">export function darken(color: string, percentage: number) {
    return lighten(color, -percentage);
}

</t>
<t tx="fil.20210603223933.5">export function lighten(color: string, percentage: number) {
    const rgba = toRgba(color);
    // tslint:disable-next-line: triple-equals
    if (rgba == null) { return color; }

    const [r, g, b, a] = rgba;
    const amount = (255 * percentage) / 100;
    return `rgba(${adjustLight(r, amount)}, ${adjustLight(g, amount)}, ${adjustLight(b, amount)}, ${a})`;
}

</t>
<t tx="fil.20210603223933.6">export function opacity(color: string, percentage: number) {
    const rgba = toRgba(color);
    // tslint:disable-next-line: triple-equals
    if (rgba == null) { return color; }

    const [r, g, b, a] = rgba;
    return `rgba(${r}, ${g}, ${b}, ${a * (percentage / 100)})`;
}

</t>
<t tx="fil.20210603223933.7">export function toRgba(color: string) {
    color = color.trim();

    const result = cssColorRegex.exec(color);
    // tslint:disable-next-line: triple-equals
    if (result == null) { return null; }

    if (result[1] === '#') {
        const hex = result[2];
        switch (hex.length) {
            case 3:
                return [parseInt(hex[0] + hex[0], 16), parseInt(hex[1] + hex[1], 16), parseInt(hex[2] + hex[2], 16), 1];
            case 6:
                return [
                    parseInt(hex.substring(0, 2), 16),
                    parseInt(hex.substring(2, 4), 16),
                    parseInt(hex.substring(4, 6), 16),
                    1
                ];
        }

        return null;
    }

    switch (result[3]) {
        case 'rgb':
            return [parseInt(result[4], 10), parseInt(result[5], 10), parseInt(result[6], 10), 1];
        case 'rgba':
            return [parseInt(result[4], 10), parseInt(result[5], 10), parseInt(result[6], 10), parseFloat(result[7])];
        default:
            return null;
    }
}
</t>
<t tx="fil.20210603223933.9">&lt;!DOCTYPE html&gt;
@others
@language xml
@tabwidth -2
</t>
<t tx="fil.20210603223934.1">function listenAll(selector: string, name: string, listener: EventListener) {
    const els = (document.querySelectorAll(selector) as unknown) as Element[];
    for (const el of els) {
        el.addEventListener(name, listener, false);
    }
}

</t>
<t tx="fil.20210603223934.10">function setVisibility(state: { [key: string]: string | boolean }) {
    for (const el of document.querySelectorAll&lt;HTMLElement&gt;('[data-visibility]')) {
        el.classList.toggle('hidden', !evaluateStateExpression(el.dataset.visibility!, state));
    }
}
</t>
<t tx="fil.20210603223934.11">function parseStateExpression(expression: string): [string, string, string | boolean | undefined] {
    const [lhs, op, rhs] = expression.trim().split(/([=+!])/);
    return [lhs.trim(), op !== undefined ? op.trim() : '=', rhs !== undefined ? rhs.trim() : rhs];
}

</t>
<t tx="fil.20210603223934.12">function evaluateStateExpression(expression: string, changes: { [key: string]: string | boolean }): boolean {
    let state = false;

    for (const expr of expression.trim().split('&amp;')) {
        const [lhs, op, rhs] = parseStateExpression(expr);

        switch (op) {
            case '=': {
                // Equals
                let value = changes[lhs];
                if (value === undefined) {
                    value = getSettingValue(lhs) || false;
                }
                state = rhs !== undefined ? rhs === String(value) : Boolean(value);
                break;
            }
            case '!': {
                // Not equals
                let value = changes[lhs];
                if (value === undefined) {
                    value = getSettingValue(lhs) || false;
                }
                state = rhs !== undefined ? rhs !== String(value) : !value;
                break;
            }
            case '+': {
                // Contains
                if (rhs !== undefined) {
                    const setting = getSettingValue(lhs);
                    state = setting !== undefined ? setting.includes(rhs.toString()) : false;
                }
                break;
            }
        }

        if (!state) { break; }
    }
    return state;
}

</t>
<t tx="fil.20210603223934.13">function getSettingValue(p_setting: string): any {
    return frontConfig[p_setting];
}


</t>
<t tx="fil.20210603223934.15">import { darken, lighten, opacity } from './colors';

@others
@language typescript
@tabwidth -4
</t>
<t tx="fil.20210603223934.16">export function initializeAndWatchThemeColors() {
    const onColorThemeChanged = () =&gt; {
        const body = document.body;
        const computedStyle = window.getComputedStyle(body);

        const bodyStyle = body.style;

        const font = computedStyle.getPropertyValue('--vscode-font-family').trim();
        if (font) {
            bodyStyle.setProperty('--font-family', font);
            bodyStyle.setProperty('--font-size', computedStyle.getPropertyValue('--vscode-font-size').trim());
            bodyStyle.setProperty('--font-weight', computedStyle.getPropertyValue('--vscode-font-weight').trim());
        } else {
            bodyStyle.setProperty(
                '--font-family',
                computedStyle.getPropertyValue('--vscode-editor-font-family').trim()
            );
            bodyStyle.setProperty('--font-size', computedStyle.getPropertyValue('--vscode-editor-font-size').trim());
            bodyStyle.setProperty(
                '--font-weight',
                computedStyle.getPropertyValue('--vscode-editor-font-weight').trim()
            );
        }

        let color = computedStyle.getPropertyValue('--vscode-editor-background').trim();
        bodyStyle.setProperty('--color-background', color);
        bodyStyle.setProperty('--color-background--lighten-05', lighten(color, 5));
        bodyStyle.setProperty('--color-background--darken-05', darken(color, 5));
        bodyStyle.setProperty('--color-background--lighten-075', lighten(color, 7.5));
        bodyStyle.setProperty('--color-background--darken-075', darken(color, 7.5));
        bodyStyle.setProperty('--color-background--lighten-15', lighten(color, 15));
        bodyStyle.setProperty('--color-background--darken-15', darken(color, 15));
        bodyStyle.setProperty('--color-background--lighten-30', lighten(color, 30));
        bodyStyle.setProperty('--color-background--darken-30', darken(color, 30));
        bodyStyle.setProperty('--color-background--lighten-50', lighten(color, 50));
        bodyStyle.setProperty('--color-background--darken-50', darken(color, 50));

        color = computedStyle.getPropertyValue('--vscode-button-background').trim();
        bodyStyle.setProperty('--color-button-background', color);
        bodyStyle.setProperty('--color-button-background--darken-30', darken(color, 30));

        color = computedStyle.getPropertyValue('--vscode-button-foreground').trim();
        bodyStyle.setProperty('--color-button-foreground', color);

        color = computedStyle.getPropertyValue('--vscode-editor-foreground').trim();
        if (!color) {
            color = computedStyle.getPropertyValue('--vscode-foreground').trim();
        }
        bodyStyle.setProperty('--color-foreground', color);
        bodyStyle.setProperty('--color-foreground--85', opacity(color, 85));
        bodyStyle.setProperty('--color-foreground--75', opacity(color, 75));
        bodyStyle.setProperty('--color-foreground--65', opacity(color, 65));
        bodyStyle.setProperty('--color-foreground--50', opacity(color, 50));

        color = computedStyle.getPropertyValue('--vscode-focusBorder').trim();
        bodyStyle.setProperty('--color-focus-border', color);

        color = computedStyle.getPropertyValue('--vscode-textLink-foreground').trim();
        bodyStyle.setProperty('--color-link-foreground', color);
        bodyStyle.setProperty('--color-link-foreground--darken-20', darken(color, 20));
        bodyStyle.setProperty('--color-link-foreground--lighten-20', lighten(color, 20));
    };

    const observer = new MutationObserver(onColorThemeChanged);
    observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });

    onColorThemeChanged();
    return observer;
}
</t>
<t tx="fil.20210603223934.2">function chooseLeoEditorPath() {
    vscode.postMessage({
        command: "chooseLeoEditorPath"
    });
}

</t>
<t tx="fil.20210603223934.3">function onBind() {
    listenAll('input[type=checkbox][data-setting]', 'change', function (this: HTMLInputElement) {
        return onInputChecked(this);
    });
    listenAll('input[type=text][data-setting], input:not([type])[data-setting]', 'blur', function (
        this: HTMLInputElement
    ) {
        return onInputBlurred(this);
    });
    listenAll('input[type=text][data-setting], input:not([type])[data-setting]', 'focus', function (
        this: HTMLInputElement
    ) {
        return onInputFocused(this);
    });
    listenAll('input[type=text][data-setting], input[type=number][data-setting]', 'input', function (
        this: HTMLInputElement
    ) {
        return onInputChanged(this);
    });
    listenAll('select[data-setting]', 'change', function (this: HTMLSelectElement) {
        return onInputSelected(this);
    });
}

</t>
<t tx="fil.20210603223934.4">function onInputSelected(element: HTMLSelectElement) {
    if (element) {
        const w_value = element.options[element.selectedIndex].value;
        frontConfig[element.id] = w_value;
    }
    applyChanges();
}

</t>
<t tx="fil.20210603223934.5">function onInputChecked(element: HTMLInputElement) {
    frontConfig[element.id] = element.checked;
    setVisibility(frontConfig);
    dirty!.className = "show";
    applyChanges();
}
</t>
<t tx="fil.20210603223934.6">function onInputBlurred(element: HTMLInputElement) {
    // console.log('onInputBlurred', element);
}
</t>
<t tx="fil.20210603223934.7">function onInputFocused(element: HTMLInputElement) {
    // console.log('onInputFocused', element);
}
</t>
<t tx="fil.20210603223934.8">function onInputChanged(element: HTMLInputElement) {
    if (element.type === 'number' &amp;&amp; Number(element.value) &lt; Number(element.max) &amp;&amp; Number(element.value) &gt; Number(element.min)) {
        frontConfig[element.id] = Number(element.value);
        element.classList.remove("is-invalid");
    } else if (element.type === 'number' &amp;&amp; (Number(element.value) &gt; Number(element.max) || Number(element.value) &lt; Number(element.min))) {
        // make red
        element.classList.add("is-invalid");
    } else if (element.type === 'text' &amp;&amp; element.value.length &lt;= element.maxLength) {
        frontConfig[element.id] = element.value;
    }
    dirty!.className = "show";
    applyChanges();
}

</t>
<t tx="fil.20210603223934.9">function setControls(): void {
    for (const key in frontConfig) {
        if (frontConfig.hasOwnProperty(key)) {
            const w_element = document.getElementById(key);
            if (w_element &amp;&amp; w_element.getAttribute('type') === 'checkbox') {
                (w_element as HTMLInputElement).checked = frontConfig[key];
            } else if (w_element) {
                (w_element as HTMLInputElement).value = frontConfig[key];
            } else {
                console.log('ERROR : w_element', key, ' is ', w_element);
            }
        }
    }
    const w_button: HTMLElement | null = document.getElementById('chooseLeoEditorPath');
    if (w_button) {
        w_button.onclick = chooseLeoEditorPath;
    }
}

</t>
<t tx="fil.20210603223956.2">@language css
html {
  height: 100%;
  font-size: 62.5%;
  box-sizing: border-box;
  scroll-behavior: smooth;
}

body {
  background-color: var(--color-background);
  color: var(--color-foreground);
  font-family: var(--font-family);
  height: 100%;
  line-height: 1.4;
  font-size: 100% !important;

  &amp;.vscode-light {
    background-color: var(--color-background--darken-075);
  }
}

a {
  border: 0;
  color: var(--color-link-foreground);
  font-weight: 400;
  outline: none;
  text-decoration: none;

  &amp;:not([href]):not([tabindex]):focus,
  &amp;:not([href]):not([tabindex]):hover {
    color: inherit;
    text-decoration: none;
  }

  &amp;:focus {
    outline-color: var(--color-focus-border);
  }
  &amp;:hover {
    color: var(--color-link-foreground--lighten-20);
  }
}

b {
  font-weight: 600;
}

code,
.shortcut-key {
  border-radius: 4px;
  color: var(--color-foreground);
  padding: 2px 6px 0 6px;
  vertical-align: baseline;

  .vscode-dark &amp; {
    background-color: var(--color-background--lighten-15);
    border-bottom: 2px solid var(--color-background--lighten-15);
  }

  .vscode-light &amp; {
    background-color: var(--color-background--darken-15);
    border-bottom: 2px solid var(--color-background--darken-15);
  }
}

h1 {
  border: none;
  font-size: 4rem;
  font-weight: 400;
  margin: 0;
  padding: 0;
  white-space: nowrap;
}

h2 {
  font-size: 2.2rem;
  font-weight: 200;
  line-height: normal;
  margin: 1em 0 0.3em 0;
  white-space: nowrap;
}

h3 {
  font-size: 1.8rem;
  font-weight: 200;
  line-height: normal;
  margin: 1em 0 0.3em 0;
  white-space: nowrap;
}

h4 {
  font-size: 1rem;
  font-weight: 200;
  line-height: normal;
  margin: 1em 0 0.3em 0;
  white-space: nowrap;
}

header {
  grid-area: header;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(265px, 1fr));
  grid-gap: 1em 3em;
  align-items: center;
  justify-items: center;
  margin: 0 3em;
}

input,
select,
button {
  font-family: var(--font-family);
  font-size: inherit;
  margin: 0;
}

input[type="checkbox"] {
  background: none;
  border: none;
  cursor: pointer;
  margin: 0;
  padding: 0 10px;

  &amp;:focus {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 5px;
    outline: none;
  }

  &amp;[disabled] {
    color: var(--color-foreground--75);
    cursor: default;
  }
}

input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  margin: 0;
}

input[type="number"],
input[type="text"],
input:not([type]) {
  background: none;
  color: var(--color-foreground);
  margin: 0 10px;
  max-width: 300px;
  padding: 4px;
  // width: 100%;

  .vscode-dark &amp; {
    border: 1px solid rgba(255, 255, 255, 0.3);
  }

  .vscode-light &amp; {
    border: 1px solid rgba(0, 0, 0, 0.3);
  }

  &amp;:focus {
    outline-color: var(--color-focus-border);

    .vscode-light &amp; {
      background-color: rgba(255, 255, 255, 0.4);
    }

    .vscode-dark &amp; {
      background-color: rgba(0, 0, 0, 0.2);
    }
  }

  &amp;.is-invalid {
    outline-color: red !important;
    border-color: red !important;
  }

  &amp;[disabled] {
    color: var(--color-foreground--75);
    cursor: default;
  }

  &amp;::placeholder {
    color: var(--vscode-input-placeholderForeground);
  }
}

label {
  cursor: pointer;
}

select {
  background: none;
  color: var(--color-foreground);
  cursor: pointer;
  margin: 0 0.75em;
  padding: 2px;
  min-width: 14em;

  .vscode-light &amp; {
    border: 1px solid rgba(0, 0, 0, 0.3);
  }

  .vscode-dark &amp; {
    border: 1px solid rgba(255, 255, 255, 0.3);
  }

  &amp;:focus {
    outline-color: var(--color-focus-border);
    .vscode-light &amp; {
      background-color: rgba(255, 255, 255, 0.4);
    }

    .vscode-dark &amp; {
      background-color: rgba(0, 0, 0, 0.2);
    }
  }

  &amp;[disabled] {
    color: var(--color-foreground--75);
    cursor: default;
  }
}

select option {
  .vscode-light &amp; {
    background-color: var(--color-background--darken-05);
  }

  .vscode-dark &amp; {
    background-color: var(--color-background--lighten-05);
  }

  &amp;:focus {
    outline-color: var(--color-focus-border);
    .vscode-light &amp; {
      background-color: rgba(255, 255, 255, 0.4);
    }

    .vscode-dark &amp; {
      background-color: rgba(0, 0, 0, 0.2);
    }
  }
}

ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

.button {
  background: none;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  display: inline-block;
  font-size: 1.1rem;
  letter-spacing: 0.25em;
  margin: 1em 0.5em;
  padding: 1em 1.75em;
  text-decoration: none;
  text-transform: uppercase;
  user-select: none;
  white-space: nowrap;

  &amp;:focus {
    outline: none;
  }
}

.button--big {
  font-size: 1.5rem;
}

.button--flat {
  .vscode-light &amp; {
    border: 1px solid rgba(0, 0, 0, 0.6);
    color: black;
  }
  .vscode-dark &amp; {
    border: 1px solid rgba(255, 255, 255, 0.6);
    color: white !important;
  }
  transition: background-color 250ms, border-color 250ms, color 250ms;

  &amp;:hover {
    .vscode-light &amp; {
      background-color: var(--color-button-background--darken-30);
      border-color: var(--color-button-background--darken-30);
      color: white !important;
    }
    .vscode-dark &amp; {
      background-color: white;
      border-color: white;
      color: black !important;
    }
  }

  .preload &amp; {
    transition-duration: 0s !important;
  }
}

.button--flat-inverse {
  background-color: white;
  border: 1px solid white;
  color: black !important;
  font-weight: 600;
  transition: background-color 250ms, border-color 250ms, color 250ms;

  &amp;:hover {
    background: rgba(0, 0, 0, 0.2);
    border-color: rgba(255, 255, 255, 0.6);
    color: white !important;
  }

  .preload &amp; {
    transition-duration: 0s !important;
  }
}

.button--flat-primary {
  background-color: var(--color-button-background);
  border: 1px solid var(--color-button-background);
  color: var(--color-button-foreground) !important;
  font-weight: 600;
  transition: background-color 250ms, border-color 250ms, color 250ms;

  &amp;:hover {
    .vscode-dark &amp; {
      background-color: white;
      border-color: white;
      color: black !important;
    }

    .vscode-light &amp; {
      background-color: var(--color-button-background--darken-30);
      border-color: var(--color-button-background--darken-30);
      color: white !important;
    }
  }

  .preload &amp; {
    transition-duration: 0s !important;
  }
}

.button--choose-path {
  padding: 0.6em 0.7em;
  margin-left: 0.2rem;
  margin-bottom: 0;
}

.blurb {
  font-size: 1.5rem;
  font-weight: 200;
  color: var(--color-foreground--65);
  margin: 1em;

  b {
    color: var(--color-foreground--85);
  }

  .vscode-light &amp; {
    color: var(--color-foreground--75);
  }
}

.command {
  font-weight: 600;
  padding: 1px 3px;
}

.container {
  display: grid;
  grid-template-areas: "header header" "hero hero" "content sidebar";
  grid-template-columns: repeat(1, 1fr min-content);
  margin: 1em auto;
  grid-gap: 1em 3em;
  max-width: 1200px;
  min-width: 450px;

  @media all and (max-width: 768px) {
    grid-gap: 1em 0;
  }
}

.content__area {
  grid-area: content;
  font-size: 1.4rem;
  // border-radius: 8x;

  .vscode-dark &amp; {
    background-color: var(--color-background--lighten-05);
  }

  .vscode-light &amp; {
    background-color: var(--color-background);
  }

  @media all and (max-width: 768px) {
    grid-column: span 1;
  }
}

.content__area--full-scroll {
  background-color: unset !important;
  margin-bottom: 90vh;

  .section--settings {
    margin: 0 0 1em 0;
  }
}

.cta {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  font-size: 1.3rem;
  margin: 0;

  &amp; p {
    margin-left: 10%;
    margin-right: 10%;
    margin-top: -0.5em;
    opacity: 0.6;
  }
}

.cta--primary {
  margin: 0 1em;
}

.cta--secondary {
  margin: 0 1em;
}

.header__blurb {
  color: var(--color-foreground--75);
  flex: 2 1 55%;
  font-size: 1.5rem;
  font-weight: 200;
  margin: 0;
  min-width: 345px;

  @media all and (max-width: 880px) {
    margin: 0 2em;
  }
}

.header__link {
  color: var(--color-foreground);
  outline: none;

  &amp;:hover,
  &amp;:active,
  &amp;:focus {
    color: var(--color-foreground);
    outline: none;
  }
}

.header__logo {
  display: flex;
  flex-wrap: nowrap;
}

.header__logo--highlight {
  color: #8d3d17;
}

.header__subtitle {
  color: var(--color-foreground--65);
  font-size: 2rem;
  font-weight: 100;
  margin: -0.2em 0 0 0;
  white-space: nowrap;
}

.hero__area {
  grid-area: hero;
  color: var(--color-foreground--75);
  font-size: 1.5rem;
  font-weight: 200;
  margin: 0 1em;

  b {
    color: var(--color-foreground--85);
  }
}

.hero__area--sticky {
  background: var(--color-background);
  margin: 0;
  padding: 1em 0;
  position: sticky;
  top: -1px;
  z-index: 1;
  grid-column: span 1;

  .vscode-light &amp; {
    background: var(--color-background--darken-075);
  }
}

.hero__row {
  display: flex;
  flex-wrap: nowrap;
  align-items: baseline;
  justify-content: space-between;
}

.hero__subtitle {
  color: var(--color-foreground--75);
  font-size: 1.4rem;
  margin: 0.25em 0 0 0;
}

.hero__title {
  font-size: 4rem;
  margin: 0;
}

.hero__title-actions {
  margin: 0 1em;
}

.hero__toolbar {
  flex: 1 1 auto;

  display: flex;
  justify-content: flex-end;
  white-space: nowrap;

  select,
  option {
    background-color: var(--color-background) !important;
    margin-right: 0;

    @media all and (max-width: 768px) {
      margin-right: unset;
    }
  }
}

.hero__toolbar-scope {
  flex: 0 0 auto;
}

.icon {
  background-color: var(--color-foreground);
  display: inline-block;
  height: 24px;
  margin-right: 3px;
  position: relative;
  width: 19px;
  top: 9px;

  h2 &amp; {
    top: 7px;
  }
}

// .icon__bulb {
//   -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path fill-rule="evenodd" d="M11.67 8.658c-.338.334-.598.705-.781 1.114-.178.407-.268.85-.268 1.329v1.6a1.304 1.304 0 0 1-.794 1.197c-.159.068-.329.102-.509.102H7.712a1.285 1.285 0 0 1-.922-.379 1.303 1.303 0 0 1-.38-.92v-1.6c0-.479-.092-.921-.274-1.329a3.556 3.556 0 0 0-.776-1.114 4.689 4.689 0 0 1-1.006-1.437A4.187 4.187 0 0 1 4 5.5a4.432 4.432 0 0 1 .616-2.27c.197-.336.432-.64.705-.914.274-.272.578-.506.911-.702.338-.196.7-.348 1.084-.454C7.7 1.053 8.1 1 8.516 1a4.476 4.476 0 0 1 2.276.614 4.475 4.475 0 0 1 1.622 1.616 4.438 4.438 0 0 1 .616 2.27c0 .617-.117 1.191-.353 1.721a4.69 4.69 0 0 1-1.006 1.437zM9.623 10.5H7.409v2.201c0 .081.028.15.09.212.062.061.131.09.213.09h1.606a.289.289 0 0 0 .213-.09.286.286 0 0 0 .09-.212V10.5z" clip-rule="evenodd"/&gt;&lt;/svg&gt;');
//   mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path fill-rule="evenodd" d="M11.67 8.658c-.338.334-.598.705-.781 1.114-.178.407-.268.85-.268 1.329v1.6a1.304 1.304 0 0 1-.794 1.197c-.159.068-.329.102-.509.102H7.712a1.285 1.285 0 0 1-.922-.379 1.303 1.303 0 0 1-.38-.92v-1.6c0-.479-.092-.921-.274-1.329a3.556 3.556 0 0 0-.776-1.114 4.689 4.689 0 0 1-1.006-1.437A4.187 4.187 0 0 1 4 5.5a4.432 4.432 0 0 1 .616-2.27c.197-.336.432-.64.705-.914.274-.272.578-.506.911-.702.338-.196.7-.348 1.084-.454C7.7 1.053 8.1 1 8.516 1a4.476 4.476 0 0 1 2.276.614 4.475 4.475 0 0 1 1.622 1.616 4.438 4.438 0 0 1 .616 2.27c0 .617-.117 1.191-.353 1.721a4.69 4.69 0 0 1-1.006 1.437zM9.623 10.5H7.409v2.201c0 .081.028.15.09.212.062.061.131.09.213.09h1.606a.289.289 0 0 0 .213-.09.286.286 0 0 0 .09-.212V10.5z" clip-rule="evenodd"/&gt;&lt;/svg&gt;');
//   -webkit-mask-repeat: no-repeat;
//   mask-repeat: no-repeat;
//   opacity: 0.8;
// }

// .icon__chevron-down {
//   -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path fill-rule="evenodd" clip-rule="evenodd" d="M7.97602 10.0719L12.3333 5.7146L12.952 6.33332L8.28538 11L7.66666 11L3 6.33332L3.61872 5.7146L7.97602 10.0719Z" /&gt;&lt;/svg&gt;');
//   mask-image: url('data:image/svg+xml;utf8,&lt;svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path fill-rule="evenodd" clip-rule="evenodd" d="M7.97602 10.0719L12.3333 5.7146L12.952 6.33332L8.28538 11L7.66666 11L3 6.33332L3.61872 5.7146L7.97602 10.0719Z" /&gt;&lt;/svg&gt;');
//   -webkit-mask-repeat: no-repeat;
//   mask-repeat: no-repeat;
// }

// .icon__gear {
//   -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path d="M9.1 4.4L8.6 2H7.4l-.5 2.4-.7.3-2-1.3-.9.8 1.3 2-.2.7-2.4.5v1.2l2.4.5.3.8-1.3 2 .8.8 2-1.3.8.3.4 2.3h1.2l.5-2.4.8-.3 2 1.3.8-.8-1.3-2 .3-.8 2.3-.4V7.4l-2.4-.5-.3-.8 1.3-2-.8-.8-2 1.3-.7-.2zM9.4 1l.5 2.4L12 2.1l2 2-1.4 2.1 2.4.4v2.8l-2.4.5L14 12l-2 2-2.1-1.4-.5 2.4H6.6l-.5-2.4L4 13.9l-2-2 1.4-2.1L1 9.4V6.6l2.4-.5L2.1 4l2-2 2.1 1.4.4-2.4h2.8zm.6 7c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zM8 9c.6 0 1-.4 1-1s-.4-1-1-1-1 .4-1 1 .4 1 1 1z"/&gt;&lt;/svg&gt;');
//   mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path d="M9.1 4.4L8.6 2H7.4l-.5 2.4-.7.3-2-1.3-.9.8 1.3 2-.2.7-2.4.5v1.2l2.4.5.3.8-1.3 2 .8.8 2-1.3.8.3.4 2.3h1.2l.5-2.4.8-.3 2 1.3.8-.8-1.3-2 .3-.8 2.3-.4V7.4l-2.4-.5-.3-.8 1.3-2-.8-.8-2 1.3-.7-.2zM9.4 1l.5 2.4L12 2.1l2 2-1.4 2.1 2.4.4v2.8l-2.4.5L14 12l-2 2-2.1-1.4-.5 2.4H6.6l-.5-2.4L4 13.9l-2-2 1.4-2.1L1 9.4V6.6l2.4-.5L2.1 4l2-2 2.1 1.4.4-2.4h2.8zm.6 7c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zM8 9c.6 0 1-.4 1-1s-.4-1-1-1-1 .4-1 1 .4 1 1 1z"/&gt;&lt;/svg&gt;');
//   -webkit-mask-repeat: no-repeat;
//   mask-repeat: no-repeat;
// }

// .icon__info {
//   -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path fill-rule="evenodd" d="M8.568 1.031A6.8 6.8 0 0 1 12.76 3.05a7.06 7.06 0 0 1 .46 9.39 6.85 6.85 0 0 1-8.58 1.74 7 7 0 0 1-3.12-3.5 7.12 7.12 0 0 1-.23-4.71 7 7 0 0 1 2.77-3.79 6.8 6.8 0 0 1 4.508-1.149zM9.04 13.88a5.89 5.89 0 0 0 3.41-2.07 6.07 6.07 0 0 0-.4-8.06 5.82 5.82 0 0 0-7.43-.74 6.06 6.06 0 0 0 .5 10.29 5.81 5.81 0 0 0 3.92.58zM8.51 7h-1v4h1V7zm0-2h-1v1h1V5z" clip-rule="evenodd"/&gt;&lt;/svg&gt;');
//   mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path fill-rule="evenodd" d="M8.568 1.031A6.8 6.8 0 0 1 12.76 3.05a7.06 7.06 0 0 1 .46 9.39 6.85 6.85 0 0 1-8.58 1.74 7 7 0 0 1-3.12-3.5 7.12 7.12 0 0 1-.23-4.71 7 7 0 0 1 2.77-3.79 6.8 6.8 0 0 1 4.508-1.149zM9.04 13.88a5.89 5.89 0 0 0 3.41-2.07 6.07 6.07 0 0 0-.4-8.06 5.82 5.82 0 0 0-7.43-.74 6.06 6.06 0 0 0 .5 10.29 5.81 5.81 0 0 0 3.92.58zM8.51 7h-1v4h1V7zm0-2h-1v1h1V5z" clip-rule="evenodd"/&gt;&lt;/svg&gt;');
//   -webkit-mask-repeat: no-repeat;
//   mask-repeat: no-repeat;
// }

.icon--md {
  height: 30px;
  width: 24px;
  top: 12px;
}

.icon--lg {
  height: 36px;
  width: 30px;
  top: 15px;
}

.image__logo {
  margin: 9px 1em 0 0;
  max-height: 64px;
  max-width: 64px;
}

.image__preview {
  display: block;
  border-radius: 8px;
  box-shadow: 0px 0px 1px 0px rgba(0, 0, 0, 0.8), 0px 0px 12px 1px rgba(0, 0, 0, 0.5);
  width: 600px;
}

.image__preview--overlay {
  left: 0;
  position: absolute;
  top: 0;
}

.image__preview--float-container {
  left: 0;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  padding-right: 17%;
}

.image__preview--float {
  float: right;
}

.link__configure,
.link__learn-more {
  margin-left: 10px;
}

.presets {
  align-items: baseline;
  justify-content: center;
  display: flex;
  width: 100%;
  flex-wrap: wrap;
}

section {
  display: flex;
  flex-wrap: wrap;

  margin-bottom: 1em;
  padding: 1em;

  h2 {
    flex: 1 0 auto;

    display: flex;
    margin-top: 0;
    margin-bottom: 1em;
  }
}

.section--full {
  flex-flow: column;
}

.section--settings {
  flex: 0 1 auto;

  display: flex;
  flex-wrap: wrap;

  border-radius: 8px;
  margin: 1em;
  padding: 1em;
  // box-shadow: 0px 0px 6px 1px rgba(0, 0, 0, 0.15);

  .vscode-dark &amp; {
    background: var(--color-background--lighten-075);
  }

  .vscode-light &amp; {
    background: var(--color-background--darken-05);
  }
}

.section--collapsible {
  .vscode-light &amp; {
    background: var(--color-background);
  }

  .section__header {
    cursor: pointer;
    flex: 1 0 100%;
    margin-right: 0;

    &amp;:after {
      background-color: var(--color-foreground--75);
      content: "";
      height: 40px;
      -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125"&gt;&lt;path d="M50 62a3 3 0 0 1-2-1L26 44a3 3 0 0 1 3-5l21 16 21-16a3 3 0 1 1 3 5L52 61a3 3 0 0 1-2 1z"/&gt;&lt;/svg&gt;');
      mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125"&gt;&lt;path d="M50 62a3 3 0 0 1-2-1L26 44a3 3 0 0 1 3-5l21 16 21-16a3 3 0 1 1 3 5L52 61a3 3 0 0 1-2 1z"/&gt;&lt;/svg&gt;');
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-size: 32px 40px;
      mask-size: 32px 40px;
      position: absolute;
      right: 0;
      top: 0;
      transition: transform 250ms ease-in-out;
      width: 32px;
    }
  }

  &amp;.collapsed {
    .section__header {
      margin-bottom: 0;

      &amp;:after {
        transform: translateY(-9px) rotate(-180deg);
      }

      h2 {
        margin-bottom: 0;
      }
    }

    .section__collapsible {
      display: none;
    }
  }
}

.section__collapsible {
  display: flex;
  flex-wrap: wrap;
}

.section__content {
  flex: 1 1 auto;

  display: flex;
  flex-flow: column wrap;
}

.section__group {
  flex: 1 0 100%;

  display: flex;
  flex-flow: wrap-reverse;

  &amp; + .section__group {
    margin-top: 1em;
  }
}

.section__header {
  display: flex;
  align-items: baseline;
  flex: 0 1 auto;
  flex-flow: column;
  margin-bottom: 1em;
  margin-right: 1em;
  position: relative;

  h2 {
    margin-bottom: 0;
  }

  .link__configure,
  .link__learn-more {
    visibility: hidden;
  }

  &amp;:hover {
    .link__configure,
    .link__learn-more {
      visibility: visible;
    }
  }
}

.section__header-hint {
  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0.25em 0;
}

.section__header-info {
  display: grid;
  grid-template-columns: auto auto;
  grid-gap: 1em;
  align-items: center;

  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0.25em 0.5em;

  p {
    margin: 0;
    line-height: 2rem;
  }

  .icon {
    top: 3px;
  }
}

.section__hint {
  flex: 0 0 auto;

  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0;
}

.section__preview {
  flex: 0 1 auto;
  position: relative;
  margin-left: auto;
  margin-right: auto;
  margin-bottom: 0.65rem;

  .section__collapsible &amp; {
    margin-bottom: 1em;
  }
}

.section__preview-hint {
  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0.5em 0.5em 0 0.5em;
  text-align: center;
}

// .section__preview-spacer {
// 	flex-grow: 10;
// 	flex-shrink: 10;
// }

.section__title {
  flex: 1 0 auto;
  margin: 0;
}

.section__title--primary {
  font-size: 3rem;
  margin: 0.3em 0;
  justify-content: center;
}

.section__title--break {
  margin: 0.3em 15% 0 15%;
  padding-top: 1em;
  justify-content: center;

  .vscode-dark &amp; {
    border-top: 1px solid var(--color-background--lighten-30);
  }

  .vscode-light &amp; {
    border-top: 1px solid var(--color-background--darken-30);
  }
}

.setting {
  flex: 0 1 auto;
  position: relative;
  margin-right: 1em;
  min-width: 15em;

  &amp; input[type="checkbox"] {
    flex: 0 0 16px;
    height: 16px;
    margin: 0 10px 0 0;
    position: relative;
    top: 3px;
    width: 16px;
  }

  &amp;[disabled] {
    label {
      color: var(--color-foreground--75);
      cursor: default;
    }
  }
}

#interface-behavior {
  .setting {
    min-width: 29em;
  }
}

// .setting--expandable {
//   .setting__expander {
//     background-color: var(--color-foreground--75);
//     cursor: pointer;
//     height: 16px;
//     -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125"&gt;&lt;path d="M50 62a3 3 0 0 1-2-1L26 44a3 3 0 0 1 3-5l21 16 21-16a3 3 0 1 1 3 5L52 61a3 3 0 0 1-2 1z"/&gt;&lt;/svg&gt;');
//     mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125"&gt;&lt;path d="M50 62a3 3 0 0 1-2-1L26 44a3 3 0 0 1 3-5l21 16 21-16a3 3 0 1 1 3 5L52 61a3 3 0 0 1-2 1z"/&gt;&lt;/svg&gt;');
//     -webkit-mask-repeat: no-repeat;
//     mask-repeat: no-repeat;
//     -webkit-mask-size: 32px 28px;
//     mask-size: 32px 28px;
//     position: relative;
//     margin: 0;
//     transform: translate(-9px, 4px) rotate(-90deg);
//     transition: transform 250ms ease-in-out;
//     width: 32px;
//   }

//   &amp; + .settings {
//     display: none;
//   }

//   &amp;.expanded {
//     .setting__expander {
//       transform: translate(-4px, 0);
//     }

//     &amp; + .settings {
//       display: unset;
//     }
//   }
// }

.setting__input {
  display: inline-flex;
  flex-wrap: nowrap;
  align-items: baseline;
  line-height: normal;
  margin: 0.5em 0;

  input,
  select {
    flex-grow: 1;

    &amp; + .link__configure,
    &amp; + .link__learn-more {
      margin-left: 0;
    }
  }

  input[type="text"],
  input:not([type]) {
    min-width: 150px;
  }

  label {
    flex-grow: 0;

    &gt; select {
      margin-top: 0.25em;
    }
  }

  .link__learn-more,
  .link__configure {
    visibility: hidden;
    max-height: 15px;

    .icon {
      display: block;
      top: unset;
    }
  }

  &amp;:hover {
    .link__learn-more,
    .link__configure {
      visibility: visible;
    }
  }
}

.setting__input--big {
  font-size: 2.2rem;
  font-weight: 200;
  margin: 0;

  &amp; input[type="checkbox"] {
    flex: 0 0 1.5em;
    height: 1em;
    margin: 0;
    position: relative;
    top: 3px;
    left: -5px;
    width: 1em;
  }

  &amp; label {
    white-space: nowrap;
  }

  .link__learn-more,
  .link__configure {
    max-height: 17px;
  }
}

.setting__input--format {
  display: flex;

  input[type="text"],
  input:not([type]) {
    max-width: unset;
  }
}

.setting__hint {
  color: var(--color-foreground--75);
  display: block;
  font-weight: 200;
  font-size: 1.3rem;
  margin: 0 1em 0.5em 1em;
}

.settings {
  flex: 1 0 auto;

  display: flex;
  flex-wrap: wrap;
  // align-items: baseline;
  // justify-content: space-between;
}

.settings--fixed {
  display: block;
}

.sidebar {
  grid-area: sidebar;
  align-self: flex-start;
  font-size: 1.3rem;
  position: sticky;
  top: 0;
  z-index: 2;

  @media all and (max-width: 768px) {
    display: none;
  }

  li {
    white-space: nowrap;
  }

  .button {
    margin: 0;
  }
}

.sidebar__group {
  margin-top: 1em;

  h2 {
    font-size: 2rem;
  }

  p {
    font-weight: 400;
    opacity: 0.5;
    text-align: center;
  }
}

.sidebar__jump-link {
  &amp;.active {
    font-weight: 700;

    &amp;:before {
      content: " ";
      border-left: 4px solid var(--color-link-foreground--darken-20);
      position: absolute;
      left: -1em;
      height: 1em;
      padding-bottom: 4px;

      .vscode-light &amp; {
        border-left-color: var(--color-link-foreground--lighten-20);
      }
    }
  }
}

.sponsor__image {
  opacity: 0.8;
  transition: opacity 250ms;
  transform: scale(0.6);
  margin: -2.5em 0;

  &amp;:hover {
    opacity: 1;
  }
}

.sponsor__tag {
  font-size: 1.1rem;
  margin: -1em 0.5em 0 0.5em;
  opacity: 0.5;
  text-align: center;
}

.bold {
  font-weight: 600;
}

.center {
  text-align: center;
}

.hidden {
  display: none !important;
}

.highlight {
  background-color: #cc5d1a;
  border-bottom: 2px solid #cc5d1a;
  // background-color: #7e3919;
  // border-bottom: 2px solid #85422a;
  border-radius: 3px;
  color: #f2f2f2;
  margin: 0 0.25em;
  padding: 2px 10px;
  text-align: center;
  vertical-align: bottom;
}

.is-sidebar-hidden {
  display: none;

  @media all and (max-width: 768px) {
    display: initial;
  }
}

.mb-0 {
  margin-bottom: 0 !important;
}

.mb-05 {
  margin-bottom: 0.5em !important;
}

.mb-1 {
  margin-bottom: 1em !important;
}

.mb-2 {
  margin-bottom: 2em !important;
}

.ml-0 {
  margin-left: 0 !important;
}

.ml-1 {
  margin-left: 1em !important;
}

.ml-2 {
  margin-left: 2em !important;
}

.ml-3 {
  margin-left: 3em !important;
}

.ml-4 {
  margin-left: 4em !important;
}

.mr-0 {
  margin-right: 0 !important;
}

.mr-1 {
  margin-right: 1em !important;
}

.mr-2 {
  margin-right: 2em !important;
}

.mt-n1 {
  margin-top: -1em !important;
}

.mt-0 {
  margin-top: 0 !important;
}

.mt-05 {
  margin-top: 0.5em !important;
}

.mt-1 {
  margin-top: 1em !important;
}

.mt-2 {
  margin-top: 2em !important;
}

.non-interactive {
  cursor: default !important;
}

.nowrap {
  white-space: nowrap !important;
}

.light {
  .vscode-dark &amp; {
    display: none;
  }
}

.dark {
  .vscode-light &amp; {
    display: none;
  }
}

::-webkit-scrollbar-corner {
  background-color: transparent !important;
}

@import "popup";
</t>
<t tx="fil.20210603223956.4">@language css
#saved-config-toast {
  box-shadow: 0px 0px 28px 0 rgba(0, 0, 0, 0.5);
  // background-color: #000 !important;

  cursor: default;
  display: block;
  padding: 1em 0.5rem;
  position: fixed;
  text-align: center;
  width: 60%;
  // height: 200px;
  top: 50px;
  left: 50%;
  border-radius: 12px;
  // margin-top: -100px; /* Negative half of height. */
  margin-left: -30%; /* Negative half of width. */
  visibility: hidden;
  font-size: 2rem;
  z-index: 100;

  &amp;.show {
    visibility: visible; /* Show the snackbar */
    /* Add animation: Take 0.5 seconds to fade in and out the snackbar.
    However, delay the fade out process for 2.5 seconds */
    // -webkit-animation: fadein 0.3s, fadeout 0.3s 0.5s;
    // animation: fadein 0.3s, fadeout 0.3s 0.4s;
    animation: fadein 0.5s, fadeout 0.5s 1s;
  }

  &amp;:before {
    // background: transparent;
    // border: 12px solid transparent;
    // content: '';
    // left: 50%;
    // position: absolute;
    // pointer-events: none;
    // top: -24px;
    // z-index: 1001;

    .vscode-light &amp; {
      border-bottom-color: var(--color-background--darken-075);
    }

    .vscode-dark &amp; {
      border-bottom-color: var(--color-background--lighten-075);
    }
  }

  .vscode-light &amp; {
    background: var(--color-background--darken-075);
  }

  .vscode-dark &amp; {
    background: var(--color-background--lighten-075);
  }
}

#dirty-config-toast {
  box-shadow: 0px 0px 28px 0 rgba(0, 0, 0, 0.5);
  // background-color: #000 !important;

  cursor: default;
  display: block;
  padding: 1em 0.5rem;
  position: fixed;
  text-align: center;
  width: 60%;
  // height: 200px;
  top: 50px;
  left: 50%;
  border-radius: 12px;
  // margin-top: -100px; /* Negative half of height. */
  margin-left: -30%; /* Negative half of width. */
  visibility: hidden;
  font-size: 2rem;
  z-index: 100;

  &amp;.show {
    visibility: visible; /* Show the snackbar */
  }

  &amp;:before {
    // background: transparent;
    // border: 12px solid transparent;
    // content: '';
    // left: 50%;
    // position: absolute;
    // pointer-events: none;
    // top: -24px;
    // z-index: 1001;

    .vscode-light &amp; {
      border-bottom-color: var(--color-background--darken-075);
    }

    .vscode-dark &amp; {
      border-bottom-color: var(--color-background--lighten-075);
    }
  }
  .vscode-light &amp; {
    background-color: #cc5d1a;
    color: #f2f2f2;
  }

  .vscode-dark &amp; {
    background-color: #cc5d1a;
    color: #f2f2f2;
  }
}

/* Animations to fade the snackbar in and out */
@keyframes fadein {
  from {
    // top: 0;
    opacity: 0.8;
  }
  to {
    // top: 30px;
    opacity: 1;
  }
}

@keyframes fadeout {
  from {
    // top: 30px;
    opacity: 1;
  }
  to {
    // top: 0;
    opacity: 0;
  }
}

.token-popup__scroller {
  margin-right: -0.4em;
  max-height: 35vh;
  overflow-y: scroll;
  padding-right: 0.4em;
}

.token-popup__hint {
  color: var(--color-foreground--75);
  display: inline-block;
  font-weight: 200;
  margin: 1.25em 0.5em 0 0.25em;
}

.token-popup__title {
  color: var(--color-foreground);
  font-weight: 400;
  margin: 0.25em 0 1em 0;
  text-align: center;
}

.token-popup__table {
  border-collapse: collapse;
  color: var(--color-foreground--75);
  table-layout: fixed;

  &amp; tr:nth-child(even) {
    .vscode-light &amp; {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .vscode-dark &amp; {
      background-color: rgba(255, 255, 255, 0.04);
    }
  }

  &amp; td {
    padding: 6px;

    i {
      opacity: 0.6;
    }
  }

  &amp; td:first-child {
    padding: 6px 12px;
  }

  &amp; td:last-child {
    padding-right: 12px;
    text-align: end;
  }
}

.token {
  background: var(--color-link-foreground--darken-20);
  border-bottom: 2px solid var(--color-link-foreground--darken-20);
  border-radius: 3px;
  color: white;
  cursor: pointer;
  display: inline-block;
  padding: 1px 8px !important;

  &amp;:before {
    content: "${";
  }

  &amp;:after {
    content: "}";
  }

  .vscode-light &amp; {
    background: var(--color-link-foreground--lighten-20);
    border-bottom-color: var(--color-link-foreground--lighten-20);
  }
}
</t>
<t tx="fil.20210609233100.1">/**
 * * Clear leointeg's last-opened &amp; recently opened Leo files list
 */
public clearRecentLeoFiles(): void {
    this._context.globalState.update(Constants.LAST_FILES_KEY, undefined);
    this._context.globalState.update(Constants.RECENT_FILES_KEY, undefined);
    vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLEARED_RECENT);
}

</t>
</tnodes>
</leo_file>
