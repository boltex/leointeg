<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20200722190504.1"><vh>Startup</vh>
<v t="ekr.20200724052304.1"><vh>@button backup</vh></v>
<v t="ekr.20200808100711.1"><vh>@settings</vh>
<v t="ekr.20200808100717.1"><vh>@string target-language = plain</vh></v>
</v>
<v t="ekr.20200722125546.1"><vh>script: Print all command names</vh></v>
<v t="ekr.20200815113508.1"><vh>script: Find empty nodes that have no children</vh></v>
</v>
<v t="felix.20200718220811.1"><vh>Documentation</vh>
<v t="felix.20200718220818.1"><vh>@clean README.md</vh>
<v t="felix.20200718221645.1"><vh>Requirements</vh></v>
<v t="felix.20200718222026.1"><vh>Development version installation</vh></v>
<v t="felix.20200718222035.1"><vh>Features</vh></v>
<v t="felix.20200718222043.1"><vh>Keybindings</vh></v>
<v t="felix.20200718222048.1"><vh>Derive External Files</vh></v>
<v t="felix.20200718222053.1"><vh>Automate Synchronization</vh></v>
<v t="felix.20200718222058.1"><vh>Status Bar Indicator</vh></v>
<v t="felix.20200718222102.1"><vh>Extension Settings</vh></v>
<v t="felix.20200718222108.1"><vh>Issues</vh></v>
<v t="felix.20200718222113.1"><vh>How it works</vh></v>
<v t="felix.20200718222118.1"><vh>Acknowledgments</vh></v>
</v>
<v t="felix.20200718220833.1"><vh>@clean CHANGELOG.md</vh>
<v t="felix.20200718222417.1"><vh>0.1.12</vh></v>
<v t="felix.20200718222419.1"><vh>0.1.11</vh></v>
<v t="felix.20200718222422.1"><vh>0.1.10</vh></v>
<v t="felix.20200718222425.1"><vh>0.1.9</vh></v>
<v t="felix.20200718222427.1"><vh>0.1.8</vh></v>
<v t="felix.20200718222429.1"><vh>0.1.7</vh></v>
<v t="felix.20200718222433.1"><vh>0.1.6</vh></v>
<v t="felix.20200718222435.1"><vh>0.1.5</vh></v>
<v t="felix.20200718222437.1"><vh>0.1.4</vh></v>
<v t="felix.20200718222439.1"><vh>0.1.3</vh></v>
<v t="felix.20200718222440.1"><vh>0.1.2</vh></v>
<v t="felix.20200718222442.1"><vh>0.1.1</vh></v>
<v t="felix.20200718222445.1"><vh>0.0.1</vh></v>
</v>
<v t="felix.20200718220833.2"><vh>@clean CONTRIBUTING.md</vh>
<v t="felix.20200718222731.1"><vh>Introduction</vh></v>
<v t="felix.20200718222739.1"><vh>Development requirements</vh></v>
<v t="felix.20200718222741.1"><vh>Getting the source</vh></v>
<v t="felix.20200718222745.1"><vh>Choosing a debug profile</vh></v>
<v t="felix.20200718222748.1"><vh>Starting the extension</vh></v>
<v t="felix.20200718222754.1"><vh>The python server script</vh></v>
<v t="felix.20200718222757.1"><vh>Issues</vh></v>
</v>
</v>
<v t="ekr.20200722190517.1"><vh>Files: Other</vh>
<v t="felix.20191126232434.2"><vh>@clean leobridgeserver.py</vh>
<v t="felix.20191128002414.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="felix.20191128002417.1"><vh>&lt;&lt; constants &gt;&gt;</vh></v>
<v t="felix.20200302204251.1"><vh>class IdleTimeManager</vh>
<v t="felix.20200302204251.2"><vh>itm.add_callback</vh></v>
<v t="felix.20200302204251.3"><vh>itm.on_idle</vh></v>
<v t="felix.20200302204251.4"><vh>itm.start</vh></v>
</v>
<v t="felix.20200302205810.1"><vh>class ExternalFilesController</vh>
<v t="felix.20200302205810.2"><vh>efc.ctor</vh></v>
<v t="felix.20200302205810.7"><vh>efc.on_idle</vh></v>
<v t="felix.20200302205810.8"><vh>efc.idle_check_commander</vh></v>
<v t="felix.20200302205810.9"><vh>efc.idle_check_at_file_node</vh></v>
<v t="felix.20200304221925.1"><vh>efc.integResult</vh></v>
<v t="felix.20200302205810.21"><vh>efc.utilities</vh>
<v t="felix.20200302205810.22"><vh>efc.ask</vh></v>
<v t="felix.20200302205810.23"><vh>efc.checksum</vh></v>
<v t="felix.20200302205810.25"><vh>efc.get_mtime</vh></v>
<v t="felix.20200302205810.26"><vh>efc.get_time</vh></v>
<v t="felix.20200302205810.27"><vh>efc.has_changed</vh></v>
<v t="felix.20200302205810.28"><vh>efc.is_enabled</vh></v>
<v t="felix.20200302205810.29"><vh>efc.join</vh></v>
<v t="felix.20200302205810.30"><vh>efc.set_time</vh></v>
<v t="felix.20200302205810.31"><vh>efc.warn</vh></v>
</v>
<v t="felix.20200308145948.1"><vh>other called methods</vh>
<v t="felix.20200308150856.1"><vh>open_with</vh></v>
<v t="felix.20200308150848.1"><vh>check_overwrite</vh></v>
<v t="felix.20200308150821.1"><vh>shut_down</vh></v>
<v t="felix.20200308150842.1"><vh>destroy_frame</vh></v>
</v>
</v>
<v t="felix.20200928174406.1"><vh>class IntegTextWrapper</vh>
<v t="felix.20200928174406.2"><vh>stw.ctor</vh></v>
<v t="felix.20200928174406.3"><vh>stw.Clipboard</vh></v>
<v t="felix.20200928174406.4"><vh>stw.Do-nothings</vh></v>
<v t="felix.20200928174406.5"><vh>stw.Text</vh>
<v t="felix.20200928174406.6"><vh>stw.appendText</vh></v>
<v t="felix.20200928174406.7"><vh>stw.delete</vh></v>
<v t="felix.20200928174406.8"><vh>stw.deleteTextSelection</vh></v>
<v t="felix.20200928174406.9"><vh>stw.get</vh></v>
<v t="felix.20200928174406.10"><vh>stw.getAllText</vh></v>
<v t="felix.20200928174406.11"><vh>stw.getInsertPoint</vh></v>
<v t="felix.20200928174406.12"><vh>stw.getSelectedText</vh></v>
<v t="felix.20200928174406.13"><vh>stw.getSelectionRange</vh></v>
<v t="felix.20201028223533.1"><vh>stw.getXScrollPosition</vh></v>
<v t="felix.20201102223052.1"><vh>stw.getYScrollPosition</vh></v>
<v t="felix.20200928174406.14"><vh>stw.hasSelection</vh></v>
<v t="felix.20200928174406.15"><vh>stw.insert</vh></v>
<v t="felix.20200928174406.16"><vh>stw.selectAllText</vh></v>
<v t="felix.20200928174406.17"><vh>stw.setAllText</vh></v>
<v t="felix.20200928174406.18"><vh>stw.setInsertPoint</vh></v>
<v t="felix.20201028223434.1"><vh>stw.setXScrollPosition</vh></v>
<v t="felix.20201102223046.1"><vh>stw.setYScrollPosition</vh></v>
<v t="felix.20200928174406.19"><vh>stw.setSelectionRange</vh></v>
<v t="felix.20200928174406.20"><vh>stw.toPythonIndex</vh></v>
<v t="felix.20200928174406.21"><vh>stw.toPythonIndexRowCol</vh></v>
</v>
</v>
<v t="felix.20191126232434.4"><vh>class LeoBridgeIntegController</vh>
<v t="felix.20191126232434.5"><vh>__init__</vh></v>
<v t="felix.20200303214235.1"><vh>_asyncIdleLoop</vh></v>
<v t="felix.20200626012709.1"><vh>_returnNo</vh></v>
<v t="felix.20200626030820.1"><vh>_returnYes</vh></v>
<v t="felix.20200927213534.1"><vh>_getScript</vh></v>
<v t="felix.20200303214255.1"><vh>_idleTime</vh></v>
<v t="felix.20200623201853.1"><vh>_getTotalOpened</vh></v>
<v t="felix.20200623215904.1"><vh>_getFirstOpenedCommander</vh></v>
<v t="felix.20200304224909.1"><vh>sendAsyncOutput</vh></v>
<v t="felix.20200304220844.1"><vh>askResult</vh></v>
<v t="felix.20200312231358.1"><vh>applyConfig</vh></v>
<v t="felix.20200219224515.1"><vh>logSignon</vh></v>
<v t="felix.20200924224017.1"><vh>JSON Output Functions</vh>
<v t="felix.20200924211032.1"><vh>setActionId</vh></v>
<v t="felix.20200924211034.1"><vh>asyncOutput</vh></v>
<v t="felix.20200924211037.1"><vh>sendLeoBridgePackage</vh></v>
<v t="felix.20200924211041.1"><vh>_outputError</vh></v>
<v t="felix.20200924211048.1"><vh>_outputBodyData</vh></v>
<v t="felix.20200927224639.1"><vh>_outputSelectionData</vh></v>
<v t="felix.20200924211051.1"><vh>_outputPNode</vh></v>
<v t="felix.20200924211054.1"><vh>_outputPNodes</vh></v>
</v>
<v t="felix.20200219222712.1"><vh>es</vh></v>
<v t="felix.20200211202929.1"><vh>initConnection</vh></v>
<v t="felix.20200924205439.1"><vh>_get_commander_method</vh></v>
<v t="felix.20200924205503.1"><vh>leoCommand</vh></v>
<v t="felix.20200924223845.1"><vh>Leo Documents</vh>
<v t="felix.20200622230608.1"><vh>getOpenedFiles</vh></v>
<v t="felix.20200624172552.1"><vh>setOpenedFile</vh></v>
<v t="felix.20191126232434.13"><vh>openFile</vh></v>
<v t="felix.20200924205915.1"><vh>openFiles</vh></v>
<v t="felix.20191126232434.14"><vh>closeFile</vh></v>
<v t="felix.20200216160305.1"><vh>saveFile</vh></v>
</v>
<v t="felix.20200924223910.1"><vh>At Buttons</vh>
<v t="felix.20200924210020.1"><vh>getButtons</vh></v>
<v t="felix.20200924210024.1"><vh>removeButton</vh></v>
<v t="felix.20200924210029.1"><vh>clickButton</vh></v>
</v>
<v t="felix.20200924223945.1"><vh>Minibuffer</vh>
<v t="felix.20200924210036.1"><vh>getCommands</vh></v>
<v t="felix.20200924210058.1"><vh>_bad_commands</vh></v>
<v t="felix.20200924210112.1"><vh>_good_commands</vh></v>
<v t="felix.20200924210952.1"><vh>_getDocstringForCommand</vh></v>
</v>
<v t="felix.20200924224100.1"><vh>Overriden Leo Commands</vh>
<v t="felix.20200924211057.1"><vh>markPNode</vh></v>
<v t="felix.20200924211100.1"><vh>unmarkPNode</vh></v>
<v t="felix.20200924211104.1"><vh>clonePNode</vh></v>
<v t="felix.20200924211121.1"><vh>cutPNode</vh></v>
<v t="felix.20200924211125.1"><vh>deletePNode</vh></v>
<v t="felix.20200924211127.1"><vh>insertPNode</vh></v>
<v t="felix.20200924211132.1"><vh>insertNamedPNode</vh></v>
<v t="felix.20200924211135.1"><vh>undo</vh></v>
<v t="felix.20200924211138.1"><vh>redo</vh></v>
<v t="felix.20201025144113.1"><vh>test</vh></v>
</v>
<v t="felix.20191128001054.1"><vh>Outline and Body Interaction</vh>
<v t="felix.20200929215102.2"><vh>getStates</vh></v>
<v t="felix.20200929215102.3"><vh>pageUp</vh></v>
<v t="felix.20200929215102.4"><vh>pageDown</vh></v>
<v t="felix.20200929215102.5"><vh>getBodyStates</vh></v>
<v t="felix.20191126232434.15"><vh>getPNode</vh></v>
<v t="felix.20191126232434.16"><vh>getChildren</vh></v>
<v t="felix.20191126232434.17"><vh>getParent</vh></v>
<v t="felix.20191126232434.18"><vh>getSelectedNode</vh></v>
<v t="felix.20191201194046.1"><vh>getAllGnx</vh></v>
<v t="felix.20191126232434.19"><vh>getBody</vh></v>
<v t="felix.20191126232434.20"><vh>getBodyLength</vh></v>
<v t="felix.20191126232434.22"><vh>setBody</vh></v>
<v t="felix.20200929230231.1"><vh>setSelection</vh></v>
<v t="felix.20191126232434.23"><vh>setNewHeadline</vh></v>
<v t="felix.20191126232434.24"><vh>setSelectedNode</vh></v>
<v t="felix.20191126232434.25"><vh>expandNode</vh></v>
<v t="felix.20191126232434.26"><vh>collapseNode</vh></v>
<v t="felix.20191126232434.29"><vh>_yieldAllRootChildren</vh></v>
<v t="felix.20191216195906.1"><vh>_findPNodeFromGnx</vh></v>
</v>
<v t="felix.20191128003648.1"><vh>leoFlexx Conversion Functions</vh>
<v t="felix.20191126232434.27"><vh>_create_gnx_to_vnode</vh></v>
<v t="felix.20191126232434.28"><vh>_test_round_trip_positions</vh></v>
<v t="felix.20191126232434.30"><vh>_ap_to_p</vh></v>
<v t="felix.20191126232434.31"><vh>_p_to_ap</vh></v>
</v>
</v>
<v t="felix.20201129184357.1"><vh>printAction</vh></v>
<v t="felix.20191126232435.1"><vh>main leoBridgeServer loop</vh></v>
</v>
<v t="ekr.20200815123601.1"><vh>@clean package.json</vh>
<v t="ekr.20200815123601.2"><vh>configuration</vh>
<v t="ekr.20200815123601.3"><vh>External Files Change Detection</vh></v>
<v t="ekr.20200815123601.4"><vh>Interface Behavior</vh></v>
<v t="ekr.20200815123601.5"><vh>Statusbar Indicator</vh></v>
<v t="ekr.20200815123601.6"><vh>Interface Appearance</vh></v>
<v t="ekr.20200815123601.7"><vh>Leo Bridge Options</vh></v>
</v>
<v t="ekr.20200815123601.8"><vh>viewsContainers</vh></v>
<v t="ekr.20200815123601.9"><vh>views</vh></v>
<v t="ekr.20200815123601.10"><vh>languages</vh></v>
<v t="ekr.20200815123601.11"><vh>grammars</vh></v>
<v t="ekr.20200815123601.12"><vh>snippets</vh></v>
<v t="ekr.20200815123601.13"><vh>commands</vh>
<v t="ekr.20200815123601.14"><vh>Tests</vh></v>
<v t="ekr.20200815123601.15"><vh>Show Webviews</vh></v>
<v t="ekr.20200815123601.16"><vh>Server</vh></v>
<v t="ekr.20200815123601.17"><vh>Scripting &amp; @buttons</vh></v>
<v t="ekr.20200815123601.18"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.19"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.20"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.21"><vh>Node Editing</vh></v>
<v t="felix.20201105010614.1"><vh>Text Editing</vh></v>
<v t="ekr.20200815123601.22"><vh>Move Nodes</vh></v>
<v t="ekr.20200815123601.23"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.24"><vh>Goto Nodes</vh></v>
<v t="ekr.20200815123601.25"><vh>Hoist/Dehoist</vh></v>
<v t="ekr.20200815123601.26"><vh>Undo/Redo</vh></v>
<v t="ekr.20200815123601.27"><vh>TODO</vh></v>
</v>
<v t="ekr.20200815123601.28"><vh>viewsWelcome</vh>
<v t="ekr.20200815123601.29"><vh>Leo Integration Panel</vh>
<v t="ekr.20200815123601.30"><vh>Not Ready: [start], [connect] and settings</vh></v>
<v t="ekr.20200815123601.31"><vh>Not Ready Auto Start: [connect] and settings</vh></v>
<v t="ekr.20200815123601.32"><vh>Not Ready Server Started: [connect] and settings</vh></v>
<v t="ekr.20200815123601.33"><vh>Not Ready: Connecting</vh></v>
<v t="ekr.20200815123601.34"><vh>Ready: [open] and settings</vh></v>
</v>
<v t="ekr.20200815123601.35"><vh>Leo Documents</vh>
<v t="ekr.20200815123601.36"><vh>Not Ready</vh></v>
<v t="ekr.20200815123601.37"><vh>Ready: Empty</vh></v>
</v>
<v t="ekr.20200815123601.38"><vh>leoButtons</vh>
<v t="ekr.20200815123601.39"><vh>Not Ready</vh></v>
<v t="ekr.20200815123601.40"><vh>Ready: No Opened Files</vh></v>
<v t="ekr.20200815123601.41"><vh>Ready: No Buttons</vh></v>
</v>
</v>
<v t="ekr.20200815123601.42"><vh>menus</vh>
<v t="ekr.20200815123601.43"><vh>commandPalette</vh>
<v t="ekr.20200815123601.44"><vh>Server</vh></v>
<v t="ekr.20200815123601.45"><vh>Scripting &amp; @buttons</vh></v>
<v t="ekr.20200815123601.46"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.47"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.48"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.49"><vh>Node Editing</vh></v>
<v t="ekr.20200815123601.50"><vh>Move Nodes</vh></v>
<v t="ekr.20200815123601.51"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.52"><vh>Goto Nodes</vh></v>
<v t="ekr.20200815123601.53"><vh>Hoist/Dehoist</vh></v>
<v t="ekr.20200815123601.54"><vh>Undo/Redo</vh></v>
<v t="ekr.20200815123601.55"><vh>TODO</vh></v>
<v t="ekr.20200815123601.56"><vh>Hidden Commands</vh>
<v t="ekr.20200815123601.57"><vh>Tests</vh></v>
<v t="ekr.20200815123601.58"><vh>Scripting &amp; @buttons</vh></v>
<v t="ekr.20200815123601.59"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.60"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.61"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.62"><vh>Node Editing</vh></v>
<v t="ekr.20200815123601.63"><vh>Move Nodes</vh></v>
<v t="ekr.20200815123601.64"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.65"><vh>Goto Nodes</vh></v>
<v t="ekr.20200815123601.66"><vh>Hoist/Dehoist</vh></v>
<v t="ekr.20200815123601.67"><vh>Undo/Redo</vh></v>
</v>
</v>
<v t="ekr.20200815123601.68"><vh>explorer/context</vh></v>
<v t="felix.20201215210439.1"><vh>view/title</vh></v>
<v t="felix.20201215210510.1"><vh>view/item/context</vh></v>
</v>
<v t="ekr.20200815123601.76"><vh>keybindings</vh>
<v t="ekr.20200815123601.77"><vh>Scripting</vh></v>
<v t="ekr.20200815123601.78"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.79"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.80"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.81"><vh>Node Editing</vh></v>
<v t="felix.20201105010253.1"><vh>Text Editing</vh></v>
<v t="ekr.20200815123601.82"><vh>Move Nodes</vh>
<v t="ekr.20200815123601.83"><vh>Move Down</vh></v>
<v t="ekr.20200815123601.84"><vh>Move left</vh></v>
<v t="ekr.20200815123601.85"><vh>Move right</vh></v>
<v t="ekr.20200815123601.86"><vh>Move Up</vh></v>
</v>
<v t="ekr.20200815123601.87"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.88"><vh>Goto Nodes</vh></v>
</v>
<v t="ekr.20200815123601.89"><vh>resourceLabelFormatters</vh></v>
</v>
<v t="ekr.20200722130456.1"><vh>@edit .gitignore</vh></v>
</v>
<v t="felix.20200718165721.1"><vh>Files: Typescript</vh>
<v t="felix.20200718024635.1"><vh>@clean src/commandStack.ts</vh>
<v t="felix.20200718024635.2"><vh>class CommandStack</vh>
<v t="felix.20200718024635.3"><vh>size</vh></v>
<v t="felix.20200718024635.4"><vh>newSelection</vh></v>
<v t="felix.20200718024635.5"><vh>add</vh></v>
<v t="felix.20200718024635.6"><vh>_tryStart</vh></v>
<v t="felix.20200718024635.7"><vh>_runStackCommand</vh></v>
<v t="felix.20200718024635.8"><vh>_resolveResult</vh></v>
</v>
</v>
<v t="felix.20200718030926.1"><vh>@clean src/config.ts</vh>
<v t="felix.20200718030926.2"><vh>class Config</vh>
<v t="felix.20200718030926.3"><vh>getConfig</vh></v>
<v t="felix.20210420215230.1"><vh>chooseLeoServerPath</vh></v>
<v t="felix.20200718030926.4"><vh>setLeoIntegSettings</vh></v>
<v t="felix.20200718030926.5"><vh>buildFromSavedSettings</vh></v>
</v>
</v>
<v t="felix.20200718020912.1"><vh>@clean src/constants.ts</vh>
<v t="felix.20200718020912.2"><vh>class Constants</vh>
<v t="felix.20200718020912.3"><vh>general constants</vh></v>
<v t="felix.20200718020912.5"><vh>workbench interface panels</vh></v>
<v t="felix.20200718020912.6"><vh>user messages</vh></v>
<v t="felix.20200718020912.7"><vh>ask/save buttons</vh></v>
<v t="felix.20201126235315.1"><vh>at-buttons strings</vh></v>
<v t="felix.20200718020912.8"><vh>configuration keys</vh></v>
<v t="ekr.20200815084016.1"><vh>config defaults</vh></v>
<v t="felix.20200718020912.9"><vh>context flags</vh></v>
<v t="felix.20201208235246.1"><vh>vscode commands</vh></v>
<v t="felix.20200718020912.10"><vh>async actions</vh></v>
<v t="felix.20200718020912.11"><vh>async info messages codes</vh></v>
<v t="felix.20200718020912.12"><vh>async ask return codes</vh></v>
<v t="felix.20201103000337.1"><vh>body language code strings</vh></v>
<v t="felix.20200718020912.13"><vh>leoBridge action strings</vh></v>
<v t="felix.20200718020912.15"><vh>commands strings</vh></v>
</v>
</v>
<v t="felix.20200718031424.1"><vh>@clean src/extension.ts</vh>
<v t="felix.20200718031424.2"><vh>activate</vh>
<v t="ekr.20200815113156.1"><vh>&lt;&lt; Define entries for all commands &gt;&gt;</vh></v>
</v>
<v t="felix.20200718031424.24"><vh>deactivate</vh></v>
<v t="felix.20200718031424.25"><vh>showWelcomeIfNewer</vh></v>
</v>
<v t="felix.20200718035737.1"><vh>@clean src/leoAsync.ts</vh>
<v t="ekr.20200815083608.1"><vh>class LeoAsync</vh>
<v t="ekr.20200815083608.2"><vh>log</vh></v>
<v t="ekr.20200815083608.3"><vh>showSaveAsDialog</vh></v>
<v t="ekr.20200815083609.1"><vh>showAskModalDialog</vh></v>
<v t="ekr.20200815083609.2"><vh>showWarnModalMessage</vh></v>
<v t="ekr.20200815083609.3"><vh>showChangesDetectedInfoMessage</vh></v>
<v t="ekr.20200815084550.1"><vh>&lt;&lt; TODO &gt;&gt;</vh></v>
</v>
</v>
<v t="felix.20200718040540.1"><vh>@clean src/leoBody.ts</vh>
<v t="felix.20200718040540.2"><vh>class LeoBodyProvider</vh>
<v t="felix.20200718040540.3"><vh>setBodyTime</vh></v>
<v t="felix.20200718040540.5"><vh>fireRefreshFile</vh></v>
<v t="felix.20200718040540.6"><vh>refreshPossibleGnxList</vh></v>
<v t="felix.20200718040540.8"><vh>watch</vh></v>
<v t="felix.20200718040540.10"><vh>stat</vh></v>
<v t="felix.20200718040540.11"><vh>readFile</vh></v>
<v t="felix.20200718040540.12"><vh>readDirectory</vh></v>
<v t="felix.20200718040540.13"><vh>createDirectory</vh></v>
<v t="felix.20200718040540.14"><vh>writeFile</vh></v>
<v t="felix.20200718040540.15"><vh>rename</vh></v>
<v t="felix.20200718040540.16"><vh>delete</vh></v>
<v t="felix.20200718040540.17"><vh>copy</vh></v>
<v t="felix.20200718040540.18"><vh>_fireSoon</vh></v>
</v>
</v>
<v t="felix.20200718153505.1"><vh>@clean src/leoBridge.ts</vh>
<v t="felix.20200718153505.2"><vh>class LeoBridge</vh>
<v t="felix.20200718153505.3"><vh>action</vh></v>
<v t="felix.20200718155251.1"><vh>isBusy</vh></v>
<v t="felix.20200718153505.4"><vh>_asyncAction</vh></v>
<v t="felix.20200718153505.5"><vh>_buildActionParameter</vh></v>
<v t="felix.20200718153505.6"><vh>_resolveBridgeReady</vh></v>
<v t="felix.20200718153505.7"><vh>_rejectAction</vh></v>
<v t="felix.20200718153505.8"><vh>_callAction</vh></v>
<v t="felix.20200718153505.9"><vh>_tryParseJSON</vh></v>
<v t="felix.20200718153505.11"><vh>_processAnswer</vh></v>
<v t="felix.20200718153505.12"><vh>initLeoProcess</vh></v>
<v t="felix.20200718153505.13"><vh>_send</vh></v>
</v>
</v>
<v t="felix.20200718162303.1"><vh>@clean src/leoButtonNode.ts</vh>
<v t="felix.20200718162303.2"><vh>class LeoButtonNode</vh>
<v t="felix.20200718162435.1"><vh>iconPath</vh></v>
<v t="felix.20200718162442.1"><vh>id</vh></v>
<v t="felix.20200718162452.1"><vh>tooltip</vh></v>
<v t="felix.20200718162459.1"><vh>description</vh></v>
</v>
</v>
<v t="felix.20200718164130.1"><vh>@clean src/leoButtons.ts</vh>
<v t="felix.20200718164130.2"><vh>class LeoButtonsProvider</vh>
<v t="felix.20200718164130.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718164130.4"><vh>getTreeItem</vh></v>
<v t="felix.20200718164130.5"><vh>getChildren</vh></v>
<v t="felix.20200718164130.6"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718164509.1"><vh>@clean src/leoDocumentNode.ts</vh>
<v t="felix.20200718164509.2"><vh>class LeoDocumentNode</vh>
<v t="felix.20200718164635.1"><vh>iconPath</vh></v>
<v t="felix.20200718164638.1"><vh>id</vh></v>
</v>
</v>
<v t="felix.20200718165108.1"><vh>@clean src/leoDocuments.ts</vh>
<v t="felix.20200718165108.2"><vh>class LeoDocumentsProvider</vh>
<v t="felix.20200718165108.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718165108.4"><vh>getTreeItem</vh></v>
<v t="felix.20200718165108.5"><vh>getChildren</vh></v>
<v t="felix.20200718165108.6"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718170429.1"><vh>@clean src/leoFileBrowser.ts</vh>
<v t="felix.20200718170429.2"><vh>class LeoFilesBrowser</vh>
<v t="felix.20200718170429.3"><vh>_getBestOpenFolderUri</vh></v>
<v t="felix.20200718170429.4"><vh>getLeoFileUrl</vh></v>
</v>
</v>
<v t="felix.20200719025231.1"><vh>@clean src/leoIntegration.ts</vh>
<v t="felix.20200719025231.2"><vh>class LeoIntegration</vh>
<v t="felix.20200719025231.3"><vh>Constructor</vh></v>
<v t="felix.20200719025231.4"><vh>Server</vh>
<v t="felix.20200719025231.5"><vh>sendAction</vh></v>
<v t="felix.20200719025231.6"><vh>startNetworkServices</vh></v>
<v t="felix.20200719025231.7"><vh>startServer</vh></v>
<v t="felix.20200719025231.8"><vh>connect</vh></v>
<v t="felix.20200719025231.9"><vh>cancelConnect</vh></v>
<v t="felix.20200719031346.1"><vh>sendConfigToServer</vh></v>
</v>
<v t="felix.20200719025231.10"><vh>Recent files</vh>
<v t="felix.20200719025231.11"><vh>_openLastFiles</vh></v>
<v t="felix.20200719025231.12"><vh>_addRecentAndLastFile</vh></v>
<v t="felix.20200719025231.13"><vh>_removeRecentFile</vh></v>
<v t="felix.20200719025231.14"><vh>_removeLastFile</vh></v>
<v t="felix.20200719025231.15"><vh>showRecentLeoFiles</vh></v>
</v>
<v t="ekr.20200815085229.1"><vh>Log &amp; Terminal panes</vh>
<v t="ekr.20200815085316.1"><vh>showTerminalPane</vh></v>
<v t="ekr.20200815085316.2"><vh>hideTerminalPane</vh></v>
<v t="ekr.20200815085316.3"><vh>addTerminalPaneEntry</vh></v>
<v t="ekr.20200815085316.4"><vh>showLogPane</vh></v>
<v t="ekr.20200815085316.5"><vh>hideLogPane</vh></v>
<v t="ekr.20200815085316.6"><vh>addLogPaneEntry</vh></v>
</v>
<v t="felix.20200719031802.1"><vh>Document States</vh>
<v t="felix.20200719025231.19"><vh>_triggerGetStates</vh></v>
<v t="felix.20200719025231.20"><vh>_isBusy</vh></v>
<v t="felix.20201107224112.1"><vh>_isBusyTriggerSave</vh></v>
<v t="felix.20200719025231.21"><vh>_isCurrentFileNamed</vh></v>
<v t="felix.20200719025231.22"><vh>_setupNoOpenedLeoDocument</vh></v>
<v t="felix.20200719025231.23"><vh>_setupOpenedLeoDocument</vh></v>
</v>
<v t="felix.20200719030811.1"><vh>UI Change Events</vh>
<v t="felix.20200719025231.24"><vh>_onChangeConfiguration</vh></v>
<v t="ekr.20200815085628.1"><vh>_onDidOpenTextDocument</vh></v>
<v t="felix.20200719025231.25"><vh>_onChangeCollapsedState</vh></v>
<v t="felix.20200719025231.26"><vh>_onTreeViewVisibilityChanged</vh></v>
<v t="felix.20200719025231.27"><vh>_onDocTreeViewVisibilityChanged</vh></v>
<v t="ekr.20200815085705.1"><vh>_onButtonsTreeViewVisibilityChanged</vh></v>
<v t="felix.20200719025231.29"><vh>_onActiveEditorChanged</vh></v>
<v t="felix.20210418014039.1"><vh>_changedTextEditorViewColumn</vh></v>
<v t="felix.20210418014040.1"><vh>_changedVisibleTextEditors</vh></v>
<v t="felix.20210418014040.2"><vh>_changedWindowState</vh></v>
<v t="felix.20200928004727.1"><vh>_onChangeEditorSelection</vh></v>
<v t="felix.20201014020145.1"><vh>_onChangeEditorScroll</vh></v>
<v t="felix.20200719025231.31"><vh>_onDocumentChanged</vh></v>
</v>
<v t="felix.20200719030842.1"><vh>Body Editing</vh>
<v t="felix.20200719025231.32"><vh>triggerBodySave</vh></v>
<v t="felix.20200928133238.1"><vh>_bodySaveSelection</vh></v>
<v t="felix.20200719025231.33"><vh>_bodySaveDocument</vh></v>
</v>
<v t="felix.20200719030902.1"><vh>Refresh UI</vh>
<v t="felix.20200719025231.34"><vh>setDocumentSelection</vh></v>
<v t="felix.20200719025231.35"><vh>showOutline</vh></v>
<v t="felix.20201114185218.1"><vh>setTreeViewTitle</vh></v>
<v t="ekr.20200815085806.1"><vh>configTreeRefresh</vh></v>
<v t="ekr.20200815085830.1"><vh>_refreshOutline</vh></v>
<v t="ekr.20200815085830.2"><vh>_revealTreeViewNode</vh></v>
<v t="ekr.20200815085830.3"><vh>launchRefresh</vh></v>
<v t="ekr.20200815085830.4"><vh>_refreshDocumentsPane</vh></v>
<v t="ekr.20200815085830.5"><vh>_gotSelection</vh></v>
</v>
<v t="felix.20200719030909.1"><vh>Conversion</vh>
<v t="felix.20200719025231.38"><vh>apToLeoNode</vh></v>
<v t="felix.20200719025231.39"><vh>_apToLeoNodeConvertReveal</vh></v>
<v t="felix.20200719025231.40"><vh>arrayToLeoNodesArray</vh></v>
</v>
<v t="felix.20200719031115.1"><vh>Body Pane Management</vh>
<v t="ekr.20200815090152.1"><vh>_tryApplyNodeToBody</vh></v>
<v t="felix.20200719025231.47"><vh>_switchBody</vh></v>
<v t="felix.20200719025231.48"><vh>_locateOpenedBody</vh></v>
<v t="felix.20210418230204.1"><vh>_findUriColumn</vh></v>
<v t="felix.20210418230204.2"><vh>_findGnxColumn</vh></v>
<v t="felix.20210418013332.1"><vh>_hideDeleteBody</vh></v>
<v t="felix.20210418220343.1"><vh>_checkPreviewMode</vh></v>
<v t="felix.20200719025231.49"><vh>closeBody</vh></v>
<v t="felix.20200719025231.50"><vh>showBody</vh></v>
<v t="felix.20210420004713.1"><vh>_setLanguageAndSelection</vh></v>
</v>
<v t="felix.20200719025231.51"><vh>Commands</vh>
<v t="felix.20200719025231.52"><vh>selectTreeNode</vh></v>
<v t="ekr.20200815090400.1"><vh>nodeCommand</vh></v>
<v t="felix.20200719025231.54"><vh>changeMark</vh></v>
<v t="felix.20200719025231.55"><vh>editHeadline</vh></v>
<v t="felix.20200719025231.56"><vh>insertNode</vh></v>
<v t="felix.20201114185813.1"><vh>minibuffer</vh></v>
</v>
<v t="felix.20200719025231.57"><vh>Leo Documents</vh>
<v t="felix.20200719025231.58"><vh>saveAsLeoFile</vh></v>
<v t="felix.20200719025231.59"><vh>saveLeoFile</vh></v>
<v t="felix.20200719025231.60"><vh>switchLeoFile</vh></v>
<v t="felix.20200719025231.61"><vh>selectOpenedLeoDocument</vh></v>
<v t="felix.20200719025231.64"><vh>closeLeoFile</vh></v>
<v t="felix.20200719025231.65"><vh>newLeoFile</vh></v>
<v t="felix.20200719025231.66"><vh>openLeoFile</vh></v>
</v>
<v t="felix.20200719033306.1"><vh>AtButtons</vh>
<v t="ekr.20200815090517.1"><vh>clickAtButton</vh></v>
<v t="ekr.20200815090517.2"><vh>removeAtButton</vh></v>
</v>
<v t="felix.20200719033511.1"><vh>Other</vh>
<v t="felix.20200719025231.69"><vh>statusBarOnClick</vh></v>
<v t="felix.20200719025231.70"><vh>test</vh></v>
</v>
</v>
</v>
<v t="felix.20200718170712.1"><vh>@clean src/leoNode.ts</vh>
<v t="felix.20200718170712.2"><vh>class LeoNode</vh>
<v t="felix.20200718170712.3"><vh>copyProperties</vh></v>
<v t="felix.20200718170712.4"><vh>setRoot</vh></v>
<v t="felix.20200718170712.5"><vh>_getNodeContextValue</vh></v>
<v t="felix.20200718171904.1"><vh>get_iconPath</vh></v>
<v t="felix.20200718171854.1"><vh>get_id</vh></v>
<v t="felix.20200718171837.1"><vh>get_description</vh></v>
<v t="felix.20200718171849.1"><vh>get tooltip</vh></v>
</v>
</v>
<v t="felix.20200718180428.1"><vh>@clean src/leoOutline.ts</vh>
<v t="felix.20200718180428.2"><vh>class LeoOutlineProvider</vh>
<v t="felix.20200718180428.3"><vh>refreshTreeNode</vh></v>
<v t="felix.20200718180428.4"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718180428.5"><vh>getTreeItem</vh></v>
<v t="felix.20200718180428.6"><vh>getChildren</vh></v>
<v t="felix.20200718180428.7"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718192351.1"><vh>@clean src/leoStates.ts</vh>
<v t="felix.20200718192411.1"><vh>class LeoStates</vh>
<v t="felix.20200718193719.1"><vh>General State Flags</vh>
<v t="felix.20200718193219.1"><vh>leoBridgeReady &amp; helper</vh></v>
<v t="felix.20200718193222.1"><vh>fileOpenedReady &amp; helper</vh></v>
<v t="felix.20200718193226.1"><vh>leoOpenedFileName</vh></v>
<v t="felix.20200718193230.1"><vh>leoChanged &amp; helper</vh></v>
<v t="felix.20200718193233.1"><vh>leoCanUndo &amp; helper</vh></v>
<v t="felix.20200718193235.1"><vh>leoCanRedo &amp; helper</vh></v>
<v t="felix.20200718193238.1"><vh>leoCanDemote &amp; helper</vh></v>
<v t="felix.20200718193241.1"><vh>leoCanPromote &amp; helper</vh></v>
<v t="felix.20200718193244.1"><vh>leoCanDehoist &amp; helper</vh></v>
</v>
<v t="felix.20200718193731.1"><vh>Selected Node Flags</vh>
<v t="felix.20200718193338.1"><vh>leoMarked</vh></v>
<v t="felix.20200718193341.1"><vh>leoCloned</vh></v>
<v t="felix.20200718193343.1"><vh>leoDirty</vh></v>
<v t="felix.20200718193348.1"><vh>leoEmpty</vh></v>
<v t="felix.20200718193350.1"><vh>leoChild</vh></v>
<v t="felix.20200718193353.1"><vh>leoAtFile</vh></v>
<v t="felix.20200718193403.1"><vh>leoRoot</vh></v>
</v>
<v t="felix.20200718193500.1"><vh>constructor</vh></v>
<v t="felix.20200718192411.2"><vh>selectedNodeFlags</vh></v>
<v t="felix.20200718192411.3"><vh>leoStateFlags</vh></v>
</v>
</v>
<v t="felix.20200718185403.1"><vh>@clean src/leoStatusBar.ts</vh>
<v t="felix.20200718185403.2"><vh>class LeoStatusBar</vh>
<v t="felix.20200718185403.3"><vh>show</vh></v>
<v t="felix.20200718185403.4"><vh>hide</vh></v>
<v t="felix.20200718185403.5"><vh>setString</vh></v>
<v t="felix.20200718185403.6"><vh>update</vh></v>
<v t="felix.20200718185403.7"><vh>_updateLeoObjectIndicatorDebounced</vh></v>
<v t="felix.20200718185403.8"><vh>_updateLeoObjectIndicator</vh></v>
</v>
</v>
<v t="felix.20200718191946.1"><vh>@clean src/serverManager.ts</vh>
<v t="felix.20200718191946.2"><vh>class ServerService</vh>
<v t="ekr.20200815091220.1"><vh>_gotTerminalData</vh></v>
<v t="felix.20200718191946.4"><vh>startServer</vh></v>
</v>
</v>
<v t="felix.20200718194857.1"><vh>@clean src/types.d.ts</vh>
<v t="felix.20200718194857.2"><vh>ConfigMembers</vh></v>
<v t="felix.20201017224340.1"><vh>ConfigSetting</vh></v>
<v t="felix.20200718194857.3"><vh>RevealType</vh></v>
<v t="felix.20200718194857.4"><vh>RefreshType</vh></v>
<v t="felix.20200718194857.5"><vh>UserCommand</vh></v>
<v t="ekr.20200815091346.1"><vh>ShowBodyParam</vh></v>
<v t="felix.20200718194857.6"><vh>LeoAction</vh></v>
<v t="felix.20200718194857.7"><vh>LeoLogEntry</vh></v>
<v t="felix.20200718194857.8"><vh>ArchivedPosition</vh></v>
<v t="ekr.20200815091408.1"><vh>LeoPackageStates</vh></v>
<v t="ekr.20200815091439.1"><vh>LeoBridgePackageOpenedInfo</vh></v>
<v t="felix.20200718194857.10"><vh>LeoBridgePackage</vh></v>
<v t="felix.20200718194857.11"><vh>LeoDocument</vh></v>
<v t="felix.20200718194857.12"><vh>LeoButton</vh></v>
<v t="felix.20200718194857.13"><vh>Icon</vh></v>
<v t="felix.20200718194857.14"><vh>BodyTimeInfo</vh></v>
<v t="felix.20201119002510.1"><vh>BodyPosition</vh></v>
<v t="felix.20201006195046.1"><vh>BodySelectionInfo</vh></v>
<v t="felix.20200718194857.15"><vh>showSaveAsDialogParameters</vh></v>
<v t="felix.20200718194857.16"><vh>runAskYesNoDialogParameters</vh></v>
<v t="felix.20200718194857.17"><vh>runWarnMessageDialogParameters</vh></v>
<v t="felix.20200718194857.18"><vh>runInfoMessageDialogParameters</vh></v>
<v t="felix.20200718194857.19"><vh>AskMessageItem</vh></v>
<v t="felix.20200718194857.20"><vh>ChooseDocumentItem</vh></v>
<v t="ekr.20200815091534.1"><vh>MinibufferCommand</vh></v>
</v>
<v t="felix.20200718195558.1"><vh>@clean src/utils.ts</vh>
<v t="felix.20200718195558.2"><vh>padNumber2</vh></v>
<v t="ekr.20200815091619.1"><vh>hashNode</vh></v>
<v t="felix.20201106200100.1"><vh>addFileToGlobal</vh></v>
<v t="felix.20201106200109.1"><vh>removeFileFromGlobal</vh></v>
<v t="felix.20200718195558.3"><vh>buildNodeIconPaths</vh></v>
<v t="felix.20200718195558.4"><vh>buildDocumentIconPaths</vh></v>
<v t="ekr.20200815091945.1"><vh>buildButtonsIconPaths</vh></v>
<v t="felix.20200718195558.6"><vh>buildNodeAndTextJson</vh></v>
<v t="felix.20201018163510.1"><vh>getDurationMilliseconds</vh></v>
<v t="felix.20200718195558.7"><vh>getFileFromPath</vh></v>
<v t="felix.20200718195558.8"><vh>isIconChangedByEdit</vh></v>
<v t="felix.20200718195558.9"><vh>isHexColor</vh></v>
<v t="felix.20200718195558.10"><vh>strToLeoUri</vh></v>
<v t="felix.20200718195558.11"><vh>leoUriToStr</vh></v>
<v t="felix.20200718195558.12"><vh>setContext</vh></v>
</v>
</v>
<v t="ekr.20200808100339.1"><vh>----- TS Classes</vh>
<v t="felix.20200718024635.2"></v>
<v t="felix.20200718030926.2"></v>
<v t="felix.20200718020912.2"></v>
<v t="ekr.20200815083608.1"></v>
<v t="felix.20200718040540.2"></v>
<v t="felix.20200718153505.2"></v>
<v t="felix.20200718162303.2"></v>
<v t="felix.20200718164130.2"></v>
<v t="felix.20200718164509.2"></v>
<v t="felix.20200718165108.2"></v>
<v t="felix.20200718170429.2"></v>
<v t="felix.20200719025231.2"></v>
<v t="felix.20200718170712.2"></v>
<v t="felix.20200718192411.1"></v>
<v t="felix.20200718180428.2"></v>
<v t="felix.20200718185403.2"></v>
<v t="felix.20200718191946.2"></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20200722125546.1">@language python

g.cls()
d = c.commandsDict  # keys are command names, values are functions.
for command_name in sorted(d):
    if command_name.startswith('@'):
        continue
    func = d.get(command_name)
    # Prefer func.__func_name__ to func.__name__: Leo's decorators change func.__name__!
    func_name = getattr(func, '__func_name__', func.__name__)
    # print(f"{command_name:&gt;40} {func_name}")
    print(command_name)
print('len(d)', len(d))

</t>
<t tx="ekr.20200722190504.1"></t>
<t tx="ekr.20200722190517.1"></t>
<t tx="ekr.20200724052304.1">c.backup_helper(sub_dir='leoInteg')
</t>
<t tx="ekr.20200808100339.1"></t>
<t tx="ekr.20200808100711.1"></t>
<t tx="ekr.20200808100717.1">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20200815083608.1">/**
 * * Handles the functions called by Leo through leoBridge such as adding a log pane entry, runAskYesNoDialog for file changes, etc.
 * * Some config settings affect this behavior, such as defaultReloadIgnore and checkForChangeExternalFiles
 */
export class LeoAsync {

    private _askResult: string = "";

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    /**
     * * Adds message string to leoInteg's log pane, used when leoBridge gets an async 'log' command
     */
    @others
}

&lt;&lt; TODO &gt;&gt;
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200815083608.2">public log(p_message: string): void {
    this._leoIntegration.addLogPaneEntry(p_message);
}

</t>
<t tx="ekr.20200815083608.3">/**
 * * Equivalent to runSaveFileDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * @param p_saveAsArg
 */
public showSaveAsDialog(p_saveAsArg: showSaveAsDialogParameters): void {
    console.log('TODO: SHOW SAVE AS DIALOG!');
}

</t>
<t tx="ekr.20200815083609.1">/**
 * * Equivalent to runAskYesNoDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * * Opens a modal dialog to return one of 'yes', 'yes-all', 'no' or 'no-all' to be sent back with the leoBridge 'ASK_RESULT' action
 * @param p_askArg an async package object {"ask": title, "message": message, "yes_all": yes_all, "no_all": no_all}
 */
public showAskModalDialog(p_askArg: runAskYesNoDialogParameters): void {
    this._askResult = "no"; // defaults to not doing anything, matches isCloseAffordance just to be safe
    // Note: "last line" could be eventually used in the message
    // const w_lastLine = p_askArg.message.substr(p_askArg.message.lastIndexOf("\n") + 1);
    const w_items: AskMessageItem[] = [
        {
            title: Constants.USER_MESSAGES.YES,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES,
            isCloseAffordance: false
        },
        {
            title: Constants.USER_MESSAGES.NO,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO,
            isCloseAffordance: true
        }
    ];
    if (p_askArg.yes_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.YES_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES_ALL,
            isCloseAffordance: false
        });
    }
    if (p_askArg.no_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.NO_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO_ALL,
            isCloseAffordance: false
        });
    }
    const w_askRefreshInfoMessage: Thenable&lt;AskMessageItem | undefined&gt; = vscode.window.showInformationMessage(
        p_askArg.message,
        { modal: true },
        ...w_items
    );
    w_askRefreshInfoMessage.then((p_result: AskMessageItem | undefined) =&gt; {
        if (p_result) {
            this._askResult = p_result.value;
        }
        const w_sendResultPromise = this._leoIntegration.sendAction(Constants.LEOBRIDGE.ASK_RESULT, '"' + this._askResult + '"'); // Quotes in string as a 'JSON parameter'
        if (this._askResult.includes(Constants.ASYNC_ASK_RETURN_CODES.YES)) {
            w_sendResultPromise.then(() =&gt; {
                this._leoIntegration.launchRefresh({ tree: true, body: true, buttons: true, states: true, documents: true }, false);
            });
        }
    });
}

</t>
<t tx="ekr.20200815083609.2">/**
 * * Equivalent to runAskOkDialog from Leo's qt_gui.py, used when leoBridge gets an async 'warn' command
 * @param p_waitArg an async package object {"warn": "", "message": ""}
 */
public showWarnModalMessage(p_waitArg: runWarnMessageDialogParameters): void {
    vscode.window.showInformationMessage(
        p_waitArg.message,
        { modal: true }
    ).then(() =&gt; {
        this._leoIntegration.sendAction(Constants.LEOBRIDGE.ASK_RESULT, Constants.ASYNC_ASK_RETURN_CODES.OK); // Quotes in string as a 'JSON parameter'
    });
}

</t>
<t tx="ekr.20200815083609.3">/**
 * * Show non-blocking info message about detected file changes, used when leoBridge gets an async 'info' command
 * @param p_infoArg an async package object { "message": string; }
 */
public showChangesDetectedInfoMessage(p_infoArg: runInfoMessageDialogParameters): void {
    let w_message = Constants.USER_MESSAGES.CHANGES_DETECTED;
    switch (p_infoArg.message) {
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_REFRESHED:
            w_message += Constants.USER_MESSAGES.REFRESHED;
            // TODO : #34 @boltex Deal with focus placement
            this._leoIntegration.launchRefresh({ tree: true, body: true, states: true, documents: true }, false);
            break;
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_IGNORED:
            w_message += Constants.USER_MESSAGES.IGNORED;
            break;
        default:
            break;
    }
    vscode.window.showInformationMessage(w_message);
}

</t>
<t tx="ekr.20200815084016.1">/**
 * * Configuration Defaults used in config.ts
 * Used when setting itself and getting parameters from vscode
 */
public static CONFIG_DEFAULTS = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "none",  // Used in leoBridge scrip,
    DEFAULT_RELOAD_IGNORE: "none", // Used in leoBridge scrip,
    LEO_TREE_BROWSE: true,
    TREE_KEEP_FOCUS: true,
    TREE_KEEP_FOCUS_WHEN_ASIDE: false,
    STATUSBAR_STRING: "", // Strings like "Literate", "Leo", UTF-8 also supported: \u{1F981}
    STATUSBAR_COLOR: "fb7c47",
    TREE_IN_EXPLORER: true,
    SHOW_OPEN_ASIDE: true,
    SHOW_EDIT: true,
    SHOW_ARROWS: false,
    SHOW_ADD: false,
    SHOW_MARK: false,
    SHOW_CLONE: false,
    SHOW_COPY: false,
    INVERT_NODES: false,
    LEO_PYTHON_COMMAND: "",
    AUTO_START_SERVER: false,
    AUTO_CONNECT: false,
    IP_ADDRESS: "localhost",
    IP_PORT: 32125
};

</t>
<t tx="ekr.20200815084550.1">/*
    TODO : Should Reproduce those interactive controls that may be asked by Leo, and redo a true UI bridge

def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    return self.simulateDialog("aboutLeoDialog", None)

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog", None)

def runAskOkDialog(self, c, title, message=None, text="Ok"):
    return self.simulateDialog("okDialog", "Ok")

def runAskOkCancelNumberDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
):
    return self.simulateDialog("numberDialog", -1)

def runAskOkCancelStringDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
    default="",
    wide=False,
):
    return self.simulateDialog("stringDialog", '')

def runCompareDialog(self, c):
    return self.simulateDialog("compareDialog", '')

def runOpenFileDialog(self, c, title, filetypes, defaultextension,
    multiple=False,
    startpath=None,
):
    return self.simulateDialog("openFileDialog", None)

def runSaveFileDialog(self, c, initialfile, title, filetypes, defaultextension):
    return self.simulateDialog("saveFileDialog", None)

def runAskYesNoDialog(self, c, title,
    message=None,
    yes_all=False,
    no_all=False,
):
    return self.simulateDialog("yesNoDialog", "no")

def runAskYesNoCancelDialog(self, c, title,
    message=None,
    yesMessage="Yes",
    noMessage="No",
    yesToAllMessage=None,
    defaultButton="Yes",
    cancelMessage=None,
):
    return self.simulateDialog("yesNoCancelDialog", "cancel")

def simulateDialog(self, key, defaultVal):
    return defaultVal

*/
</t>
<t tx="ekr.20200815085229.1"></t>
<t tx="ekr.20200815085316.1">/**
 * * Reveals the leoBridge server terminal output if not already visible
 */
public showTerminalPane(): void {
    if (this._leoTerminalPane) {
        this._leoTerminalPane.show(true);
    }
}

</t>
<t tx="ekr.20200815085316.2">/**
 * * Hides the leoBridge server terminal output
 */
public hideTerminalPane(): void {
    if (this._leoTerminalPane) {
        this._leoTerminalPane.hide();
    }
}

</t>
<t tx="ekr.20200815085316.3">/**
 * * Adds a message string to leoInteg's leoBridge server terminal output.
 * @param p_message The string to be added in the log
 */
public addTerminalPaneEntry(p_message: string): void {
    if (this._leoTerminalPane) {
        this._leoTerminalPane.appendLine(p_message);
    }
}

</t>
<t tx="ekr.20200815085316.4">/**
 * * Reveals the log pane if not already visible
 */
public showLogPane(): void {
    this._leoLogPane.show(true);
}

</t>
<t tx="ekr.20200815085316.5">/**
 * * Hides the log pane
 */
public hideLogPane(): void {
    this._leoLogPane.hide();
}

</t>
<t tx="ekr.20200815085316.6">/**
 * * Adds a message string to leoInteg's log pane. Used when leoBridge receives an async 'log' command.
 * @param p_message The string to be added in the log
 */
public addLogPaneEntry(p_message: string): void {
    this._leoLogPane.appendLine(p_message);
}

</t>
<t tx="ekr.20200815085628.1">/**
 * * Handles the opening of a file in vscode, and check if it's a Leo file to suggest opening options
 * @param p_event The opened document event passed by vscode
 */
private _onDidOpenTextDocument(p_document: vscode.TextDocument): void {
    if (this.leoStates.leoBridgeReady &amp;&amp; p_document.uri.scheme === Constants.URI_FILE_SCHEME &amp;&amp; p_document.uri.fsPath.toLowerCase().endsWith(".leo")) {
        if (!this._hasShownContextOpenMessage) {
            vscode.window.showInformationMessage(Constants.USER_MESSAGES.RIGHT_CLICK_TO_OPEN);
            this._hasShownContextOpenMessage = true;
        }
        // vscode.window.showQuickPick(
        //     [Constants.USER_MESSAGES.YES, Constants.USER_MESSAGES.NO],
        //     { placeHolder: Constants.USER_MESSAGES.OPEN_WITH_LEOINTEG }
        // )
        //     .then(p_result =&gt; {
        //         if (p_result &amp;&amp; p_result === Constants.USER_MESSAGES.YES) {
        //             const w_uri = p_document.uri;
        //             vscode.window.showTextDocument(p_document.uri, { preview: true, preserveFocus: false })
        //                 .then(() =&gt; {
        //                     return vscode.commands.executeCommand('workbench.action.closeActiveEditor');
        //                 })
        //                 .then(() =&gt; {
        //                     this.openLeoFile(w_uri);
        //                 });
        //         }
        //     });
    }
}

</t>
<t tx="ekr.20200815085705.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onButtonsTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_explorerView) { } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this._leoButtonsProvider.refreshTreeRoot();
    }
}

</t>
<t tx="ekr.20200815085806.1">/**
 * * Refresh tree for 'node hover icons' to show up properly after changing their settings
 */
public configTreeRefresh(): void {
    if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
        this._preventShowBody = true;
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="ekr.20200815085830.1">/**
 * * Refreshes the outline. A reveal type can be passed along to specify the reveal type for the selected node
 * @param p_revealType Facultative reveal type to specify type of reveal when the 'selected node' is encountered
 */
private _refreshOutline(p_incrementTreeID: boolean, p_revealType?: RevealType): void {
    if (p_incrementTreeID) {
        this._treeId++;
    }
    if (p_revealType !== undefined) { // To check if selected node should self-select while redrawing whole tree
        this._revealType = p_revealType; // To be read/cleared (in arrayToLeoNodesArray instead of directly by nodes)
    }
    // Force showing last used Leo outline first
    if (this.lastSelectedNode &amp;&amp; !(this._leoTreeExView.visible || this._leoTreeView.visible)) {
        this._lastTreeView.reveal(this.lastSelectedNode)
            .then(() =&gt; {
                this._leoTreeProvider.refreshTreeRoot();
            });
    } else {
        this._leoTreeProvider.refreshTreeRoot();
    }
}

</t>
<t tx="ekr.20200815085830.2">/**
 * * 'TreeView.reveal' for any opened leo outline that is currently visible
 * @param p_leoNode The node to be revealed
 * @param p_options Options object for the revealed node to either also select it, focus it, and expand it
 */
private _revealTreeViewNode(p_leoNode: LeoNode, p_options?: { select?: boolean, focus?: boolean, expand?: boolean | number }): Thenable&lt;void&gt; {
    if (this._leoTreeView.visible) {
        return this._leoTreeView.reveal(p_leoNode, p_options);
    }
    if (this._leoTreeExView.visible &amp;&amp; this.config.treeInExplorer) {
        return this._leoTreeExView.reveal(p_leoNode, p_options);
    }
    return Promise.resolve(); // Defaults to resolving even if both are hidden
}

</t>
<t tx="ekr.20200815085830.3">/**
 * * Launches refresh for UI components and states
 * @param p_refreshType choose to refresh the outline, or the outline and body pane along with it
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 */
public launchRefresh(p_refreshType: ReqRefresh, p_fromOutline: boolean, p_ap?: ArchivedPosition): void {
    // Set w_revealType, it will ultimately set this._revealType.
    // Used when finding the OUTLINE's selected node and setting or preventing focus into it
    // Set this._fromOutline. Used when finding the selected node and showing the BODY to set or prevent focus in it
    this._refreshType = Object.assign({}, p_refreshType);
    let w_revealType: RevealType;
    if (p_fromOutline) {
        this._fromOutline = true;
        w_revealType = RevealType.RevealSelectFocus;
    } else {
        this._fromOutline = false;
        w_revealType = RevealType.RevealSelect;
    }
    if (this._refreshType.body &amp;&amp;
        this._bodyLastChangedDocument &amp;&amp; this._bodyLastChangedDocument.isDirty) {
        // When this refresh is launched with 'refresh body' requested, we need to lose any pending edits and save on vscode's side.
        this._bodyLastChangedDocument.save(); // Voluntarily save to 'clean' any pending body
    }
    // * _focusInterrupt insertNode Override
    if (this._focusInterrupt) {
        // this._focusInterrupt = false; // TODO : Test if reverting this in _gotSelection is 'ok'
        w_revealType = RevealType.RevealSelect;
    }
    // * Either the whole tree refreshes, or a single tree node is revealed when just navigating
    if (this._refreshType.tree) {
        this._refreshType.tree = false;
        this._refreshOutline(true, w_revealType);
    } else if (this._refreshType.node &amp;&amp; p_ap) {
        // * Force single node "refresh" by revealing it, instead of "refreshing" it
        this._refreshType.node = false;
        const w_node = this.apToLeoNode(p_ap);
        this.leoStates.setSelectedNodeFlags(w_node);
        this._revealTreeViewNode(w_node, {
            select: true, focus: true // FOCUS FORCED TO TRUE always leave focus on tree when navigating
        });
        if (this._refreshType.body) {
            this._refreshType.body = false;
            this._tryApplyNodeToBody(w_node, false, true); // ! NEEDS STACK AND THROTTLE!
        }
    }
    this.getStates();
}

</t>
<t tx="ekr.20200815085830.4">/**
 * * Refresh the documents pane
 */
private _refreshDocumentsPane(): void {
    this._leoDocumentsProvider.refreshTreeRoot();
}

</t>
<t tx="ekr.20200815085830.5">/**
 * * Handle the selected node that was reached while converting received ap_nodes to LeoNodes
 * @param p_node The selected node that was reached while receiving 'children' from tree view api implementing Leo's outline
 */
private _gotSelection(p_node: LeoNode): void {
    // * Use the 'from outline' concept to decide if focus should be on body or outline after editing a headline
    let w_showBodyKeepFocus: boolean = this._fromOutline; // Will preserve focus where it is without forcing into the body pane if true
    if (this._focusInterrupt) {
        this._focusInterrupt = false; // TODO : Test if reverting this in _gotSelection is 'ok'
        w_showBodyKeepFocus = true;
    }
    this._tryApplyNodeToBody(p_node, false, w_showBodyKeepFocus);
}

</t>
<t tx="ekr.20200815090152.1">/**
 * * Makes sure the body now reflects the selected node.
 * This is called after 'selectTreeNode', or after '_gotSelection' when refreshing.
 * @param p_node Node that was just selected
 * @param p_aside Flag to indicate opening 'Aside' was required
 * @param p_showBodyKeepFocus Flag used to keep focus where it was instead of forcing in body
 * @param p_force_open Flag to force opening the body pane editor
 */
private _tryApplyNodeToBody(p_node: LeoNode, p_aside: boolean, p_showBodyKeepFocus: boolean, p_force_open?: boolean): Thenable&lt;vscode.TextEditor&gt; {

    // console.log('try to apply node -&gt; ', p_node.gnx);

    this.lastSelectedNode = p_node; // Set the 'lastSelectedNode' this will also set the 'marked' node context
    this._commandStack.newSelection(); // Signal that a new selected node was reached and to stop using the received selection as target for next command

    if (this._bodyTextDocument) {
        // if not first time and still opened - also not somewhat exactly opened somewhere.
        if (
            !this._bodyTextDocument.isClosed &amp;&amp;
            !this._locateOpenedBody(p_node.gnx) // LOCATE NEW GNX
        ) {
            // if needs switching by actually having different gnx
            if (utils.leoUriToStr(this.bodyUri) !== p_node.gnx) {
                this._locateOpenedBody(utils.leoUriToStr(this.bodyUri)); // * LOCATE OLD GNX FOR PROPER COLUMN*
                return this._bodyTextDocument.save()
                    .then(() =&gt; {
                        return this._switchBody(p_node.gnx, p_aside, p_showBodyKeepFocus);
                    });
            }
        }
    } else {
        // first time?
        this.bodyUri = utils.strToLeoUri(p_node.gnx);
    }
    return this.showBody(p_aside, p_showBodyKeepFocus);

    /*
        this._showBodyParams = {
            node: p_node,
            aside: p_aside,
            showBodyKeepFocus: p_showBodyKeepFocus,
            force_open: p_force_open // can be undefined
        };
        // Start it if possible, otherwise the last _showBodyParams will be used again right after
        if (!this._showBodyStarted) {
            this._showBodyStarted = true;
            this._applyNodeToBody(this._showBodyParams)
                .then((p_textEditor: vscode.TextEditor) =&gt; {
                    // finished
                    this._showBodyStarted = false;
                    if (this._showBodyParams) {
                        // New node to show again! Call itself faking params from the specified ones.
                        this._tryApplyNodeToBody(
                            this._showBodyParams.node,
                            this._showBodyParams.aside,
                            this._showBodyParams.showBodyKeepFocus,
                            this._showBodyParams.force_open
                        );
                    }
                });
            // Clear global body params, will get refilled if needed
            this._showBodyParams = undefined;
        }
        */
}

</t>
<t tx="ekr.20200815090400.1">/**
 * * Tries to add a command to the frontend stack, returns true if added, false otherwise
 * @param p_action A string commands for leobridgeserver.py, from Constants.LEOBRIDGE,
 * @param p_node Specific node to pass as parameter, or the selected node if omitted
 * @param p_refresh Specifies to either refresh nothing, the tree or body and tree when finished
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_text Specific string to pass along as parameter with the action, similar to p_node parameter
 * @returns Promise back from commands execution on leoBridgeServer if added, undefined otherwise
 * (see command stack 'rules' in commandStack.ts)
 */
public nodeCommand(p_userCommand: UserCommand): Promise&lt;LeoBridgePackage&gt; | undefined {
    this.triggerBodySave(); // No forced vscode save-triggers for direct calls from extension.js
    const q_result = this._commandStack.add(p_userCommand);
    if (q_result) {
        return q_result;
    } else {
        // TODO : Use cleanup message string CONSTANT instead
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.TOO_FAST + p_userCommand.action);
        return undefined;
    }
}

</t>
<t tx="ekr.20200815090517.1">/**
 * * Invoke an '@button' click directly by index string. Used by '@buttons' treeview.
 * @returns the launchRefresh promise started after it's done running the 'atButton' command
 */
public clickAtButton(p_node: LeoButtonNode): Promise&lt;boolean&gt; {
    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.CLICK_BUTTON, JSON.stringify({ "index": p_node.button.index }));
        })
        .then((p_clickButtonResult: LeoBridgePackage) =&gt; {
            this.launchRefresh({ tree: true, body: true, documents: true, buttons: true, states: true }, false);
            return Promise.resolve(true); // TODO launchRefresh should be a returned promise
        });
}

</t>
<t tx="ekr.20200815090517.2">/**
 * * Removes an '@button' from Leo's button dict, directly by index string. Used by '@buttons' treeview.
 * @returns the launchRefresh promise started after it's done removing the button
 */
public removeAtButton(p_node: LeoButtonNode): Promise&lt;boolean&gt; {
    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.REMOVE_BUTTON, JSON.stringify({ "index": p_node.button.index }));
        })
        .then((p_removeButtonResult: LeoBridgePackage) =&gt; {
            this.launchRefresh({ buttons: true }, false);
            return Promise.resolve(true); // TODO launchRefresh should be a returned promise
        });
}

</t>
<t tx="ekr.20200815091220.1">/**
 * * Splits the received data into lines and parses output to detect server start event
 * * Otherwise just outputs lines to the terminal Output
 * @param p_data Data object (not pure string)
 */
private _gotTerminalData(p_data: string): void {
    p_data.toString().split("\n").forEach(p_line =&gt; {
        p_line = p_line.trim();
        if (p_line) { // * std out process line by line: json shouldn't have line breaks
            if (p_line.startsWith(Constants.SERVER_STARTED_TOKEN)) {
                if (this._resolvePromise &amp;&amp; !this._isStarted) {
                    this._isStarted = true;
                    this._resolvePromise(p_line); // * Server confirmed started
                }
            }
            this._leoIntegration.addTerminalPaneEntry(p_line); // Output message anyways
        }
    });
}

</t>
<t tx="ekr.20200815091346.1">/**
 * * Object container for parameters of leoIntegration's "apply-selected-node-to-body" method
 */
export interface ShowBodyParam {
    node: LeoNode,
    aside: boolean,
    showBodyKeepFocus: boolean,
    force_open?: boolean
}
</t>
<t tx="ekr.20200815091408.1">/**
 * * Object sent back from leoInteg's 'getStates' command
 */
export interface LeoPackageStates {
    changed: boolean; // Leo document has changed (is dirty)
    canUndo: boolean; // Leo document can undo the last operation done
    canRedo: boolean; // Leo document can redo the last operation 'undone'
    canDemote: boolean; // Currently selected node can have its siblings demoted
    canPromote: boolean; // Currently selected node can have its children promoted
    canDehoist: boolean; // Leo Document is currently hoisted and can be de-hoisted
}

</t>
<t tx="ekr.20200815091439.1">/**
 * * Returned info about currently opened and editing document
 * Used after opening, switching or setting the opened document
 */
export interface LeoBridgePackageOpenedInfo {
    total: number;
    filename: string;
    node: ArchivedPosition;
}

</t>
<t tx="ekr.20200815091534.1">/**
 * * Used by the minibuffer command pallette
 * Acquired from the getCommands method in leobridgeserver.py
 */
export interface MinibufferCommand extends vscode.QuickPickItem {
    func: string;
}
</t>
<t tx="ekr.20200815091619.1">/**
 * Builds a string hash out of of an archived position, default without taking collapsed state into account
 * @param p_ap Archived position
 * @param p_salt To be added to the hashing process (Change when tree changes)
 */
export function hashNode(p_ap: ArchivedPosition, p_salt: string, p_withCollapse?: boolean): string {
    const w_string1: string = p_ap.headline + p_ap.gnx + p_ap.childIndex.toString(36);
    const w_string2: string = w_string1 + p_ap.childIndex.toString(36) + JSON.stringify(p_ap.stack);
    const w_first: string = murmur.murmur3(w_string2).toString(36);
    if (p_withCollapse) {
        p_salt += p_ap.expanded ? "1" : "0";
    }
    return p_salt + w_string1 + w_first + murmur.murmur3(w_first + w_string2).toString(36);
}

</t>
<t tx="ekr.20200815091945.1">/**
 * * Build all possible strings for buttons icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildButtonsIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON_ADD),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON_ADD)
        }
    ];
}

</t>
<t tx="ekr.20200815113156.1">// * Define entries for all commands
[CMD.MINIBUFFER, () =&gt; w_leo.minibuffer()], // Is referenced in package.json
[CMD.EXECUTE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXECUTE_SCRIPT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],

[CMD.CLICK_BUTTON, (p_node: LeoButtonNode) =&gt; w_leo.clickAtButton(p_node)], // Not referenced in package.json
[CMD.REMOVE_BUTTON, (p_node: LeoButtonNode) =&gt; w_leo.removeAtButton(p_node)],

[CMD.CLOSE_FILE, () =&gt; w_leo.closeLeoFile()],
[CMD.NEW_FILE, () =&gt; w_leo.newLeoFile()],

[CMD.OPEN_FILE, (p_uri?: vscode.Uri) =&gt; w_leo.openLeoFile(p_uri)],

[CMD.RECENT_FILES, () =&gt; w_leo.showRecentLeoFiles()],
[CMD.SAVE_AS_FILE, () =&gt; w_leo.saveAsLeoFile()],
[CMD.SAVE_FILE, () =&gt; w_leo.saveLeoFile()],
[CMD.SAVE_FILE_FO, () =&gt; w_leo.saveLeoFile(true)],
[CMD.SWITCH_FILE, () =&gt; w_leo.switchLeoFile()],

[CMD.SET_OPENED_FILE, (p_index: number) =&gt; w_leo.selectOpenedLeoDocument(p_index)],

[CMD.REFRESH_FROM_DISK, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.REFRESH_FROM_DISK_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: false
})],
[CMD.REFRESH_FROM_DISK_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REFRESH_FROM_DISK_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.REFRESH_FROM_DISK_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REFRESH_FROM_DISK_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.GIT_DIFF, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GIT_DIFF,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],

[CMD.HEADLINE, (p_node: LeoNode) =&gt; w_leo.editHeadline(p_node, true)],
[CMD.HEADLINE_SELECTION, () =&gt; w_leo.editHeadline(U, false)],
[CMD.HEADLINE_SELECTION_FO, () =&gt; w_leo.editHeadline(U, true)],

// cut/copy/paste/delete given node.
[CMD.COPY, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.COPY_PNODE,
    node: p_node,
    refreshType: NO_REFRESH,
    fromOutline: true,
    keepSelection: true
})],
[CMD.CUT, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.CUT_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.DELETE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.PASTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: false
})],
[CMD.PASTE_CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_CLONE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: false
})],

// cut/copy/paste/delete current selection (self.commander.p)
[CMD.COPY_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.COPY_PNODE,
    node: U,
    refreshType: NO_REFRESH,
    fromOutline: false
})],
[CMD.CUT_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CUT_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.CUT_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CUT_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.DELETE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.DELETE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.PASTE_CLONE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.PASTE_CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.PASTE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.PASTE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.CONTRACT_ALL, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.CONTRACT_ALL_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.CONTRACT_OR_GO_LEFT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_OR_GO_LEFT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.EXPAND_AND_GO_RIGHT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXPAND_AND_GO_RIGHT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.GOTO_NEXT_CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: p_node,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_NEXT_CLONE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: false
})],
[CMD.GOTO_NEXT_CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],

[CMD.GOTO_NEXT_MARKED, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_MARKED,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_FIRST_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_FIRST_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_LAST_SIBLING, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_LAST_SIBLING,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_LAST_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_LAST_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_NEXT_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_PREV_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_PREV_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],

[CMD.PAGE_UP, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PAGE_UP,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.PAGE_DOWN, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PAGE_DOWN,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],

[CMD.DEHOIST, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEHOIST,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.DEHOIST_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEHOIST,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.HOIST, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.HOIST_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.HOIST_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.CLONE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.INSERT, (p_node: LeoNode) =&gt; w_leo.insertNode(p_node, true)],
[CMD.INSERT_SELECTION, () =&gt; w_leo.insertNode(U, false)],
[CMD.INSERT_SELECTION_FO, () =&gt; w_leo.insertNode(U, true)],

// Special command for when inserting rapidly more than one node without
// even specifying a headline label, such as spamming CTRL+I rapidly.
[CMD.INSERT_SELECTION_INTERRUPT, () =&gt; w_leo.insertNode(U, false, true)],

[CMD.MARK, (p_node: LeoNode) =&gt; w_leo.changeMark(true, p_node, true)],
[CMD.MARK_SELECTION, () =&gt; w_leo.changeMark(true, U, false)],
[CMD.MARK_SELECTION_FO, () =&gt; w_leo.changeMark(true, U, true)],

[CMD.UNMARK, (p_node: LeoNode) =&gt; w_leo.changeMark(false, p_node, true)],
[CMD.UNMARK_SELECTION, () =&gt; w_leo.changeMark(false, U, false)],
[CMD.UNMARK_SELECTION_FO, () =&gt; w_leo.changeMark(false, U, true)],

[CMD.EXTRACT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXTRACT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.EXTRACT_NAMES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXTRACT_NAMES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],

[CMD.MOVE_DOWN, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_DOWN_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_DOWN_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.MOVE_LEFT, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_LEFT_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_LEFT_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.MOVE_RIGHT, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_RIGHT_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_RIGHT_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.MOVE_UP, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_UP_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_UP_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.DEMOTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.DEMOTE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.DEMOTE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],
[CMD.PROMOTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.PROMOTE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.PROMOTE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.SORT_CHILDREN, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_CHILDREN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false,
    keepSelection: true
})],
[CMD.SORT_SIBLING, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_SIBLINGS,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false,
    keepSelection: true
})],
[CMD.SORT_SIBLING_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_SIBLINGS,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true,
    keepSelection: true
})],

[CMD.REDO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.REDO_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.UNDO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.UNDO_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.CONNECT, () =&gt; w_leo.connect()],
[CMD.START_SERVER, () =&gt; w_leo.startServer()],

// Called by nodes in tree when selected either by mouse, or with enter
[CMD.SELECT_NODE, (p_node: LeoNode) =&gt; w_leo.selectTreeNode(p_node, false, false)],
[CMD.OPEN_ASIDE, (p_node: LeoNode) =&gt; w_leo.selectTreeNode(p_node, false, true)],

[CMD.SHOW_OUTLINE, () =&gt; w_leo.showOutline(true)], // Also focuses on outline

[CMD.SHOW_LOG, () =&gt; w_leo.showLogPane()],
[CMD.SHOW_BODY, () =&gt; w_leo.showBody(false)], // Also focuses on body

[CMD.SHOW_WELCOME, () =&gt; w_leoSettingsWebview.openWebview()],
[CMD.SHOW_SETTINGS, () =&gt; w_leoSettingsWebview.openWebview()], // Same as SHOW_WELCOME

[CMD.COPY_MARKED, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.COPY_MARKED,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.DIFF_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DIFF_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.MARK_CHANGED_ITEMS, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MARK_CHANGED_ITEMS,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.MARK_SUBHEADS, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MARK_SUBHEADS,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.UNMARK_ALL, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNMARK_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.CLONE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.DELETE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.MOVE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

// TODO : @boltex More commands for issue #24
// [CMD.CLONE_FIND_ALL, () =&gt; showInfo("TODO: cloneFindAll command")],
// [CMD.CLONE_FIND_ALL_FLATTENED, () =&gt; showInfo("TODO: cloneFindAllFlattened command")],
// [CMD.CLONE_FIND_MARKED, () =&gt; showInfo("TODO: cloneFindMarked command")],
// [CMD.CLONE_FIND_FLATTENED_MARKED, () =&gt; showInfo("TODO: cloneFindFlattenedMarked command")],

</t>
<t tx="ekr.20200815113508.1">@language python
g.cls()

def is_significant(p):
    s = p.b
    for ch in '()[]{};':
        s = s.replace(ch, '')
    return s.strip()

for p in c.all_unique_positions():
    if not is_significant(p) and not p.hasChildren():
        print(p.h)
print('done')

</t>
<t tx="ekr.20200815123601.1">@language json
@tabwidth -2
{
  "name": "leointeg",
  "displayName": "Leo Editor Integration with Visual Studio Code",
  "description": "Use Leo, the literate editor with outline, directly in vscode.",
  "version": "0.1.13",
  "author": {
    "name": "Félix"
  },
  "publisher": "boltex",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/boltex/leointeg"
  },
  "engines": {
    "vscode": "^1.51.0"
  },
  "keywords": [
    "leo",
    "literate",
    "editor",
    "outline",
    "programming"
  ],
  "categories": [
    "Other"
  ],
  "activationEvents": [
    "onView:leoIntegration",
    "workspaceContains:**/*.leo"
  ],
  "main": "./dist/extension",
  "icon": "resources/leoapp128px.png",
  "galleryBanner": {
    "color": "#fffbdc",
    "theme": "light"
  },
  "contributes": {
    @others
  },
  "scripts": {
    "vscode:prepublish": "webpack --mode production",
    "webpack": "webpack --mode development",
    "webpack-dev": "webpack --mode development --watch",
    "test-compile": "tsc -p ./",
    "lint": "tslint -p ./"
  },
  "devDependencies": {
    "@types/glob": "^7.1.3",
    "@types/mocha": "^7.0.2",
    "@types/node": "^14.11.2",
    "@types/vscode": "^1.51.0",
    "@types/ws": "^7.2.6",
    "clean-webpack-plugin": "^3.0.0",
    "csp-html-webpack-plugin": "^4.0.0",
    "css-loader": "^3.5.3",
    "eslint": "^7.9.0",
    "fork-ts-checker-webpack-plugin": "^4.1.6",
    "glob": "^7.1.6",
    "html-loader": "^1.1.0",
    "html-webpack-exclude-assets-plugin": "0.0.7",
    "html-webpack-plugin": "^3.2.0",
    "imagemin-webpack-plugin": "^2.4.2",
    "mini-css-extract-plugin": "^0.9.0",
    "mocha": "^7.2.0",
    "node-sass": "^4.14.1",
    "sass-loader": "^8.0.2",
    "ts-loader": "^7.0.5",
    "tslint": "^6.1.3",
    "typescript": "^3.9.7",
    "vscode-test": "^1.4.0",
    "webpack": "^4.44.2",
    "webpack-cli": "^3.3.12"
  },
  "dependencies": {
    "@types/debounce": "^1.2.0",
    "@types/murmurhash-js": "^1.0.3",
    "bufferutil": "^4.0.1",
    "debounce": "^1.2.0",
    "hasbin": "^1.2.3",
    "murmurhash-js": "^1.0.0",
    "ws": "^7.3.1"
  }
}
</t>
<t tx="ekr.20200815123601.10">"languages": [
  {
    "id": "leobody.plain",
    "aliases": [
      "Leo Body Plain",
      "leobody"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.plain.language-configuration.json"
  },
  {
    "id": "leobody.python",
    "aliases": [
      "Leo Body Python",
      "leobody.python"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.python.language-configuration.json"
  },
  {
    "id": "leobody.typescript",
    "aliases": [
      "Leo Body Typescript",
      "leobody.typescript"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.typescript.language-configuration.json"
  },
  {
    "id": "leobody.javascript",
    "aliases": [
      "Leo Body Javascript",
      "leobody.javascript"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.javascript.language-configuration.json"
  },
  {
    "id": "leobody.c",
    "aliases": [
      "Leo Body c",
      "leobody.c"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.c.language-configuration.json"
  },
  {
    "id": "leobody.cpp",
    "aliases": [
      "Leo Body C++",
      "leobody.cpp"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.cpp.language-configuration.json"
  },
  {
    "id": "leobody.css",
    "aliases": [
      "Leo Body CSS",
      "leobody.css"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.css.language-configuration.json"
  },
  {
    "id": "leobody.html",
    "aliases": [
      "Leo Body HTML",
      "leobody.html"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.html.language-configuration.json"
  },
  {
    "id": "leobody.java",
    "aliases": [
      "Leo Body Java",
      "leobody.java"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.java.language-configuration.json"
  },
  {
    "id": "leobody.json",
    "aliases": [
      "Leo Body Json",
      "leobody.json"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.json.language-configuration.json"
  },
  {
    "id": "leobody.markdown",
    "aliases": [
      "Leo Body Markdown",
      "leobody.markdown"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.markdown.language-configuration.json"
  },
  {
    "id": "leobody.php",
    "aliases": [
      "Leo Body PHP",
      "leobody.php"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.php.language-configuration.json"
  },
  {
    "id": "leobody.rust",
    "aliases": [
      "Leo Body Rust",
      "leobody.rust"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.rust.language-configuration.json"
  }
],
</t>
<t tx="ekr.20200815123601.11">"grammars": [
  {
    "language": "leobody.plain",
    "scopeName": "source.leobody.plain",
    "path": "./syntaxes/leobody.plain.tmLanguage.json"
  },
  {
    "language": "leobody.python",
    "scopeName": "source.leobody.python",
    "path": "./syntaxes/leobody.python.tmLanguage.json"
  },
  {
    "language": "leobody.typescript",
    "scopeName": "source.leobody.typescript",
    "path": "./syntaxes/leobody.typescript.tmLanguage.json"
  },
  {
    "language": "leobody.javascript",
    "scopeName": "source.leobody.javascript",
    "path": "./syntaxes/leobody.javascript.tmLanguage.json"
  },
  {
    "language": "leobody.c",
    "scopeName": "source.leobody.c",
    "path": "./syntaxes/leobody.c.tmLanguage.json"
  },
  {
    "language": "leobody.cpp",
    "scopeName": "source.leobody.cpp",
    "path": "./syntaxes/leobody.cpp.tmLanguage.json"
  },
  {
    "language": "leobody.css",
    "scopeName": "source.leobody.css",
    "path": "./syntaxes/leobody.css.tmLanguage.json"
  },
  {
    "language": "leobody.html",
    "scopeName": "source.leobody.html",
    "path": "./syntaxes/leobody.html.tmLanguage.json"
  },
  {
    "language": "leobody.java",
    "scopeName": "source.leobody.java",
    "path": "./syntaxes/leobody.java.tmLanguage.json"
  },
  {
    "language": "leobody.json",
    "scopeName": "source.leobody.json",
    "path": "./syntaxes/leobody.json.tmLanguage.json"
  },
  {
    "language": "leobody.markdown",
    "scopeName": "source.leobody.markdown",
    "path": "./syntaxes/leobody.markdown.tmLanguage.json"
  },
  {
    "language": "leobody.php",
    "scopeName": "source.leobody.php",
    "path": "./syntaxes/leobody.php.tmLanguage.json"
  },
  {
    "language": "leobody.rust",
    "scopeName": "source.leobody.rust",
    "path": "./syntaxes/leobody.rust.tmLanguage.json"
  },
  {
    "//TODO 1": "MAKE PHP/HTML/CSS/JS EMBEDDED FUNCTIONALITY WORK TOO",
    "injectTo": [
      "source.leobody.plain",
      "source.leobody.python",
      "source.leobody.typescript",
      "source.leobody.javascript",
      "source.leobody.c",
      "source.leobody.cpp",
      "source.leobody.css",
      "source.leobody.html",
      "source.leobody.java",
      "source.leobody.json",
      "source.leobody.markdown",
      "source.leobody.php",
      "source.leobody.rust"
    ],
    "path": "./syntaxes/leobody.tmLanguage.json",
    "scopeName": "leo.injection",
    "//TODO 2": "MAKE EMBEDDED LANGUAGE SWITCHES WORK",
    "//tokenTypes": {
      "//meta.embedded.block.leobody.python": "other",
      "//meta.embedded.block.leobody.typescript": "other",
      "//...": "..."
    },
    "//embeddedLanguages": {
      "//meta.embedded.block.leobody.python": "leobody.python",
      "//meta.embedded.block.leobody.typescript": "leobody.typescript",
      "//...": "..."
    }
  }
],
</t>
<t tx="ekr.20200815123601.12">"snippets": [
  {
    "language": "leobody.c",
    "path": "./snippets/c.code-snippets"
  },
  {
    "language": "leobody.cpp",
    "path": "./snippets/cpp.code-snippets"
  },
  {
    "language": "leobody.javascript",
    "path": "./snippets/javascript.code-snippets"
  },
  {
    "language": "leobody.typescript",
    "path": "./snippets/typescript.code-snippets"
  },
  {
    "language": "leobody.java",
    "path": "./snippets/java.code-snippets"
  },
  {
    "language": "leobody.php",
    "path": "./snippets/php.code-snippets"
  },
  {
    "language": "leobody.markdown",
    "path": "./snippets/markdown.code-snippets"
  },
  {
    "language": "leobody.rust",
    "path": "./snippets/rust.code-snippets"
  }
],
</t>
<t tx="ekr.20200815123601.13">"commands": [
  @others
],
</t>
<t tx="ekr.20200815123601.14">{
  "command": "leointeg.test",
  "category": "Leo",
  "title": "Test Leo Integration"
},
</t>
<t tx="ekr.20200815123601.15">{
  "command": "leointeg.showSettingsPage",
  "title": "Open Settings",
  "category": "Leo",
  "icon": {
    "light": "resources/light/gear.svg",
    "dark": "resources/dark/gear.svg"
  }
},
{
  "command": "leointeg.showWelcomePage",
  "title": "Welcome",
  "category": "Leo"
},
</t>
<t tx="ekr.20200815123601.16">{
  "command": "leointeg.startServer",
  "category": "Leo",
  "title": "Start Leo Bridge Server"
},
{
  "command": "leointeg.connectToServer",
  "title": "Connect to Leo Bridge Server",
  "category": "Leo",
  "icon": {
    "light": "resources/light/connect.svg",
    "dark": "resources/dark/connect.svg"
  }
},
</t>
<t tx="ekr.20200815123601.17">{
  "command": "leointeg.executeScript",
  "category": "Leo",
  "title": "Execute Script"
},
{
  "command": "leointeg.minibuffer",
  "category": "Leo",
  "title": "Minibuffer"
},
{
  "command": "leointeg.removeButton",
  "category": "Leo",
  "title": "Remove Button"
},
</t>
<t tx="ekr.20200815123601.18">{
  "command": "leointeg.showBody",
  "category": "Leo",
  "title": "Focus to Body"
},
{
  "command": "leointeg.showOutline",
  "category": "Leo",
  "title": "Focus to Tree"
},
{
  "command": "leointeg.showLogPane",
  "category": "Leo",
  "title": "Show Log Pane"
},
</t>
<t tx="ekr.20200815123601.19">{
  "command": "leointeg.openLeoFile",
  "title": "Open Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/folder.svg",
    "dark": "resources/dark/folder.svg"
  }
},
{
  "command": "leointeg.recentLeoFiles",
  "category": "Leo",
  "title": "Recent Files"
},
{
  "command": "leointeg.switchLeoFile",
  "title": "Switch Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/switch.svg",
    "dark": "resources/dark/switch.svg"
  }
},
{
  "command": "leointeg.newLeoFile",
  "title": "New Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/new-file.svg",
    "dark": "resources/dark/new-file.svg"
  }
},
{
  "command": "leointeg.closeLeoFile",
  "title": "Close Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leointeg.saveLeoFile",
  "category": "Leo",
  "title": "Save Leo File",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leointeg.saveLeoFileFromOutline",
  "category": "Leo",
  "title": "Save Leo File",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leointeg.saveAsLeoFile",
  "category": "Leo",
  "title": "Save Leo File as...",
  "icon": {
    "light": "resources/light/save-as.svg",
    "dark": "resources/dark/save-as.svg"
  }
},
{
  "command": "leointeg.refreshFromDisk",
  "category": "Leo",
  "title": "Refresh from Disk"
},
{
  "command": "leointeg.refreshFromDiskSelection",
  "category": "Leo",
  "title": "Refresh from Disk"
},
{
  "command": "leointeg.refreshFromDiskSelectionFromOutline",
  "category": "Leo",
  "title": "Refresh from Disk"
},
{
  "command": "leointeg.gitDiff",
  "category": "Leo",
  "title": "Git Diff"
},
</t>
<t tx="ekr.20200815123601.2">"configuration": {
  "title": "Leo Integration",
  "properties": {
    @others
  }
},
</t>
<t tx="ekr.20200815123601.20">{
  "command": "leointeg.selectTreeNode",
  "category": "Leo",
  "title": "Select Node"
},
{
  "command": "leointeg.openAside",
  "category": "Leo",
  "title": "Open to the Side"
},
{
  "command": "leointeg.contractAll",
  "category": "Leo",
  "title": "Contract All",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
{
  "command": "leointeg.contractAllFromOutline",
  "category": "Leo",
  "title": "Contract All",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
</t>
<t tx="ekr.20200815123601.21">{
  "command": "leointeg.editHeadline",
  "category": "Leo",
  "title": "Edit Headline",
  "icon": {
    "light": "resources/light/edit.svg",
    "dark": "resources/dark/edit.svg"
  }
},
{
  "command": "leointeg.editSelectedHeadline",
  "category": "Leo",
  "title": "Edit Headline"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "category": "Leo",
  "title": "Edit Headline"
},
{
  "command": "leointeg.mark",
  "category": "Leo",
  "title": "Mark",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leointeg.markSelection",
  "category": "Leo",
  "title": "Mark"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "category": "Leo",
  "title": "Mark"
},
{
  "command": "leointeg.unmark",
  "category": "Leo",
  "title": "Unmark",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leointeg.unmarkSelection",
  "category": "Leo",
  "title": "Unmark"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "category": "Leo",
  "title": "Unmark"
},
{
  "command": "leointeg.copyNode",
  "category": "Leo",
  "title": "Copy Node",
  "icon": {
    "light": "resources/light/clipboard.svg",
    "dark": "resources/dark/clipboard.svg"
  }
},
{
  "command": "leointeg.copyNodeSelection",
  "category": "Leo",
  "title": "Copy Node"
},
{
  "command": "leointeg.cutNode",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.cutNodeSelection",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.pasteNode",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAsClone",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelection",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.delete",
  "category": "Leo",
  "title": "Delete",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leointeg.deleteSelection",
  "category": "Leo",
  "title": "Delete Node"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "category": "Leo",
  "title": "Delete Node"
},
</t>
<t tx="ekr.20200815123601.22">{
  "command": "leointeg.moveOutlineDown",
  "category": "Leo",
  "title": "Move Outline Down",
  "icon": {
    "light": "resources/light/arrow-down.svg",
    "dark": "resources/dark/arrow-down.svg"
  }
},
{
  "command": "leointeg.moveOutlineDownSelection",
  "category": "Leo",
  "title": "Move Outline Down"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Down"
},
{
  "command": "leointeg.moveOutlineLeft",
  "category": "Leo",
  "title": "Move Outline Left",
  "icon": {
    "light": "resources/light/arrow-left.svg",
    "dark": "resources/dark/arrow-left.svg"
  }
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "category": "Leo",
  "title": "Move Outline Left"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Left"
},
{
  "command": "leointeg.moveOutlineRight",
  "category": "Leo",
  "title": "Move Outline Right",
  "icon": {
    "light": "resources/light/arrow-right.svg",
    "dark": "resources/dark/arrow-right.svg"
  }
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "category": "Leo",
  "title": "Move Outline Right"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Right"
},
{
  "command": "leointeg.moveOutlineUp",
  "category": "Leo",
  "title": "Move Outline Up",
  "icon": {
    "light": "resources/light/arrow-up.svg",
    "dark": "resources/dark/arrow-up.svg"
  }
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "category": "Leo",
  "title": "Move Outline Up"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Up"
},
</t>
<t tx="ekr.20200815123601.23">{
  "command": "leointeg.insertNode",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.insertNodeSelection",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.cloneNode",
  "category": "Leo",
  "title": "Clone Node",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leointeg.cloneNodeSelection",
  "category": "Leo",
  "title": "Clone Node"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Clone Node"
},
{
  "command": "leointeg.promote",
  "category": "Leo",
  "title": "Promote Children"
},
{
  "command": "leointeg.promoteSelection",
  "category": "Leo",
  "title": "Promote Children"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "category": "Leo",
  "title": "Promote Children"
},
{
  "command": "leointeg.demote",
  "category": "Leo",
  "title": "Demote Siblings"
},
{
  "command": "leointeg.demoteSelection",
  "category": "Leo",
  "title": "Demote Siblings"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "category": "Leo",
  "title": "Demote Siblings"
},
{
  "command": "leointeg.sortChildrenSelection",
  "category": "Leo",
  "title": "Sort Children"
},
{
  "command": "leointeg.sortSiblingsSelection",
  "category": "Leo",
  "title": "Sort Siblings"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "category": "Leo",
  "title": "Sort Siblings"
},
</t>
<t tx="ekr.20200815123601.24">{
  "command": "leointeg.gotoFirstVisible",
  "category": "Leo",
  "title": "Goto First Visible"
},
{
  "command": "leointeg.gotoLastVisible",
  "category": "Leo",
  "title": "Goto Last Visible"
},
{
  "command": "leointeg.pageUp",
  "category": "Leo",
  "title": "Page Up"
},
{
  "command": "leointeg.pageDown",
  "category": "Leo",
  "title": "Page Down"
},
{
  "command": "leointeg.gotoLastSibling",
  "category": "Leo",
  "title": "Goto Last Sibling"
},
{
  "command": "leointeg.gotoNextVisible",
  "category": "Leo",
  "title": "Goto Next Visible"
},
{
  "command": "leointeg.gotoPrevVisible",
  "category": "Leo",
  "title": "Goto Prev Visible"
},
{
  "command": "leointeg.contractOrGoLeft",
  "category": "Leo",
  "title": "Contract Or Go Left"
},
{
  "command": "leointeg.expandAndGoRight",
  "category": "Leo",
  "title": "Expand And Go Right"
},
</t>
<t tx="ekr.20200815123601.25">{
  "command": "leointeg.hoistNode",
  "category": "Leo",
  "title": "Hoist"
},
{
  "command": "leointeg.hoistSelection",
  "category": "Leo",
  "title": "Hoist"
},
{
  "command": "leointeg.hoistSelectionFromOutline",
  "category": "Leo",
  "title": "Hoist"
},
{
  "command": "leointeg.deHoist",
  "category": "Leo",
  "title": "De-Hoist",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
{
  "command": "leointeg.deHoistFromOutline",
  "category": "Leo",
  "title": "De-Hoist",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
</t>
<t tx="ekr.20200815123601.26">{
  "command": "leointeg.undo",
  "category": "Leo",
  "title": "Undo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leointeg.undoFromOutline",
  "category": "Leo",
  "title": "Undo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leointeg.redo",
  "category": "Leo",
  "title": "Redo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
{
  "command": "leointeg.redoFromOutline",
  "category": "Leo",
  "title": "Redo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
</t>
<t tx="ekr.20200815123601.27">{
  "command": "leointeg.cloneFindAll",
  "category": "Leo",
  "title": "Clone Find All"
},
{
  "command": "leointeg.cloneFindAllFlattened",
  "category": "Leo",
  "title": "Clone Find All Flattened"
},
{
  "command": "leointeg.cloneFindMarked",
  "category": "Leo",
  "title": "Clone Find Marked"
},
{
  "command": "leointeg.cloneFindFlattenedMarked",
  "category": "Leo",
  "title": "cffm - Clone Find Flattened Marked"
},
{
  "command": "leointeg.copyMarked",
  "category": "Leo",
  "title": "Copy Marked"
},
{
  "command": "leointeg.diffMarkedNodes",
  "category": "Leo",
  "title": "Diff Marked Nodes"
},
{
  "command": "leointeg.gotoNextMarked",
  "category": "Leo",
  "title": "Goto Next Marked"
},
{
  "command": "leointeg.gotoNextClone",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.markChangedItems",
  "category": "Leo",
  "title": "Mark Changed Items"
},
{
  "command": "leointeg.markSubheads",
  "category": "Leo",
  "title": "Mark Subheads"
},
{
  "command": "leointeg.unmarkAll",
  "category": "Leo",
  "title": "Unmark All"
},
{
  "command": "leointeg.cloneMarkedNodes",
  "category": "Leo",
  "title": "Clone Marked Nodes"
},
{
  "command": "leointeg.deleteMarkedNodes",
  "category": "Leo",
  "title": "Delete Marked Nodes"
},
{
  "command": "leointeg.moveMarkedNodes",
  "category": "Leo",
  "title": "Move Marked Nodes"
}
</t>
<t tx="ekr.20200815123601.28">"viewsWelcome": [
  @others
],
</t>
<t tx="ekr.20200815123601.29"></t>
<t tx="ekr.20200815123601.3">"leoIntegration.checkForChangeExternalFiles": {
  "scope": "application",
  "default": "none",
  "type": "string",
  "description": "Set default for checking changes to external files",
  "enum": [
    "none",
    "force-check",
    "force-ignore"
  ],
  "enumDescriptions": [
    "Default from Leo's config",
    "Check for changes",
    "Ignore all changes"
  ]
},
"leoIntegration.defaultReloadIgnore": {
  "scope": "application",
  "default": "none",
  "type": "string",
  "description": "Set default for derived files to always reload, or always ignore, when changes are detected",
  "enum": [
    "none",
    "yes-all",
    "no-all"
  ],
  "enumDescriptions": [
    "Choose each time",
    "Reload All",
    "Ignore All"
  ]
},
</t>
<t tx="ekr.20200815123601.30">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nStart a local server\n[Start Server](command:leointeg.startServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nStart a local server\n[Start Server](command:leointeg.startServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="ekr.20200815123601.31">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="ekr.20200815123601.32">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="ekr.20200815123601.33">{
  "view": "leoIntegration",
  "contents": "Connecting...",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Connecting...",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; connectToServerAutomatically"
},
</t>
<t tx="ekr.20200815123601.34">{
  "view": "leoIntegration",
  "contents": "leoBridge Connected\n[Open Leo File](command:leointeg.openLeoFile)\nView LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "leoBridge Connected\n[Open Leo File](command:leointeg.openLeoFile)\nView LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.35"></t>
<t tx="ekr.20200815123601.36">{
  "view": "leoDocuments",
  "contents": "LeoInteg is not connected",
  "when": "!leoBridgeReady"
},
{
  "view": "leoDocumentsExplorer",
  "contents": "LeoInteg is not connected",
  "when": "!leoBridgeReady"
},
</t>
<t tx="ekr.20200815123601.37">{
  "view": "leoDocuments",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoDocumentsExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.38"></t>
<t tx="ekr.20200815123601.39">{
  "view": "leoButtons",
  "contents": "LeoInteg is not connected",
  "when": "!leoBridgeReady"
},
{
  "view": "leoButtonsExplorer",
  "contents": "LeoInteg is not connected",
  "when": "!leoBridgeReady"
},
</t>
<t tx="ekr.20200815123601.4">"leoIntegration.leoTreeBrowse": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Specifies whether to use Leo's style of tree browsing with the arrow keys"
},
"leoIntegration.treeKeepFocus": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Specifies whether to keep focus in the outline when selecting a node - overridden by \"leoTreeBrowse\""
},
"leoIntegration.treeKeepFocusWhenAside": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Specifies whether to keep focus in the outline when opening a body pane on the side"
},
</t>
<t tx="ekr.20200815123601.40">{
  "view": "leoButtons",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoButtonsExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.41">{
  "view": "leoButtons",
  "contents": "There are no @buttons in this outline",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "view": "leoButtonsExplorer",
  "contents": "There are no @buttons in this outline",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
}
</t>
<t tx="ekr.20200815123601.42">"menus": {
  @others
},
</t>
<t tx="ekr.20200815123601.43">"commandPalette": [
  @others
],
</t>
<t tx="ekr.20200815123601.44">{
  "command": "leointeg.startServer",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; !leoServerStarted"
},
{
  "command": "leointeg.connectToServer",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.45">{
  "command": "leointeg.executeScript",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.minibuffer",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.46">{
  "command": "leointeg.showLogPane",
  "when": "leoBridgeReady"
},
</t>
<t tx="ekr.20200815123601.47">{
  "command": "leointeg.openLeoFile",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.recentLeoFiles",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.switchLeoFile",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "command": "leointeg.newLeoFile",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.closeLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.saveLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.saveAsLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.refreshFromDiskSelection",
  "when": "leoTreeOpened &amp;&amp; leoAtFile"
},
{
  "command": "leointeg.gitDiff",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.48">{
  "command": "leointeg.contractAll",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.49">{
  "command": "leointeg.editSelectedHeadline",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markSelection",
  "when": "leoTreeOpened &amp;&amp; !leoMarked"
},
{
  "command": "leointeg.unmarkSelection",
  "when": "leoTreeOpened &amp;&amp; leoMarked"
},
{
  "command": "leointeg.copyNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cutNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.deleteSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.5">"leoIntegration.statusBarString": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Sets the message string of the Status Bar Indicator"
},
"leoIntegration.statusBarColor": {
  "scope": "application",
  "default": "fb7c47",
  "type": "string",
  "description": "Specifies the hexadecimal color string for the Status Bar Indicator"
},
</t>
<t tx="ekr.20200815123601.50">{
  "command": "leointeg.moveOutlineDownSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.51">{
  "command": "leointeg.insertNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.promoteSelection",
  "when": "leoTreeOpened &amp;&amp; leoCanPromote"
},
{
  "command": "leointeg.demoteSelection",
  "when": "leoTreeOpened &amp;&amp; leoCanDemote"
},
{
  "command": "leointeg.sortChildrenSelection",
  "when": "leoTreeOpened &amp;&amp; leoChild"
},
{
  "command": "leointeg.sortSiblingsSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.52">{
  "command": "leointeg.gotoNextMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "when": "leoTreeOpened &amp;&amp; leoCloned"
},
</t>
<t tx="ekr.20200815123601.53">{
  "command": "leointeg.hoistSelection",
  "when": "leoTreeOpened &amp;&amp; !leoRoot"
},
{
  "command": "leointeg.deHoist",
  "when": "leoTreeOpened &amp;&amp; leoCanDehoist"
},
</t>
<t tx="ekr.20200815123601.54">{
  "command": "leointeg.undo",
  "when": "leoTreeOpened &amp;&amp; leoCanUndo"
},
{
  "command": "leointeg.redo",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.55">{
  "command": "leointeg.cloneFindAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindAllFlattened",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindFlattenedMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.extract",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.extractNames",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.copyMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.diffMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markChangedItems",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markSubheads",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.unmarkAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.deleteMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveMarkedNodes",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.56"></t>
<t tx="ekr.20200815123601.57">{
  "command": "leointeg.test",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.58">{
  "command": "leointeg.removeButton",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.59">{
  "command": "leointeg.showBody",
  "when": "false"
},
{
  "command": "leointeg.showOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.6">"leoIntegration.treeInExplorer": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Show the outline tree in the explorer view"
},
"leoIntegration.showOpenAside": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Offer 'Open to the Side' in nodes context menu"
},
"leoIntegration.showEditOnNodes": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Edit Headline' button on tree nodes"
},
"leoIntegration.showArrowsOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Move Node' arrow buttons on tree nodes"
},
"leoIntegration.showAddOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Insert' button on tree nodes"
},
"leoIntegration.showMarkOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Mark/Unmark' buttons on tree nodes"
},
"leoIntegration.showCloneOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Clone' button on tree nodes"
},
"leoIntegration.showCopyOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Copy' button on tree nodes"
},
"leoIntegration.invertNodeContrast": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Inverts the contrast of the dirty/clean border aspect of tree nodes"
},
</t>
<t tx="ekr.20200815123601.60">{
  "command": "leointeg.saveLeoFileFromOutline",
  "when": "false"
},
{
  "command": "leointeg.refreshFromDisk",
  "when": "false"
},
{
  "command": "leointeg.refreshFromDiskSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.61">{
  "command": "leointeg.selectTreeNode",
  "when": "false"
},
{
  "command": "leointeg.openAside",
  "when": "false"
},
{
  "command": "leointeg.contractAllFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.62">{
  "command": "leointeg.editHeadline",
  "when": "false"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "when": "false"
},
{
  "command": "leointeg.mark",
  "when": "false"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.unmark",
  "when": "false"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.copyNode",
  "when": "false"
},
{
  "command": "leointeg.cutNode",
  "when": "false"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.pasteNode",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAsClone",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.delete",
  "when": "false"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.63">{
  "command": "leointeg.moveOutlineDown",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineLeft",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineRight",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineUp",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.64">{
  "command": "leointeg.insertNode",
  "when": "false"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "when": "false"
},
{
  "command": "leointeg.cloneNode",
  "when": "false"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.promote",
  "when": "false"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.demote",
  "when": "false"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.65">{
  "command": "leointeg.gotoNextClone",
  "when": "false"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.gotoFirstVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoLastVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoLastSibling",
  "when": "false"
},
{
  "command": "leointeg.gotoNextVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoPrevVisible",
  "when": "false"
},
{
  "command": "leointeg.contractOrGoLeft",
  "when": "false"
},
{
  "command": "leointeg.expandAndGoRight",
  "when": "false"
},
{
  "command": "leointeg.pageUp",
  "when": "false"
},
{
  "command": "leointeg.pageDown",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.66">{
  "command": "leointeg.hoistNode",
  "when": "false"
},
{
  "command": "leointeg.hoistSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.deHoistFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.67">{
  "command": "leointeg.undoFromOutline",
  "when": "false"
},
{
  "command": "leointeg.redoFromOutline",
  "when": "false"
}
</t>
<t tx="ekr.20200815123601.68">"explorer/context": [
  {
    "command": "leointeg.openLeoFile",
    "when": "resourceScheme == file &amp;&amp; resourceExtname == .leo",
    "group": "navigation@1"
  }
],
</t>
<t tx="ekr.20200815123601.7">"leoIntegration.leoPythonCommand": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Specifies the command to start python (Defaults to 'py' on windows and 'python3' otherwise)"
},
"leoIntegration.startServerAutomatically": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Starts a LeoBridge server automatically, by running the leobridgeserver.py python script"
},
"leoIntegration.connectToServerAutomatically": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Connect automatically to a Leo server on specified 'Connection Port' upon activation of this extension"
},
"leoIntegration.connectionAddress": {
  "default": "localhost",
  "scope": "application",
  "type": "string",
  "description": "Connection host"
},
"leoIntegration.connectionPort": {
  "default": 32125,
  "scope": "application",
  "minimum": 0,
  "maximum": 65535,
  "type": "number",
  "description": "Connection port"
}
</t>
<t tx="ekr.20200815123601.76">"keybindings": [
  @others
],
</t>
<t tx="ekr.20200815123601.77">{
  "command": "leointeg.executeScript",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.executeScript",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.minibuffer",
  "key": "alt+x",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.78">{
  "command": "leointeg.showOutline",
  "key": "alt+t",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.showOutline",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.showBody",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "alt+d",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "tab",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "enter",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.79">{
  "command": "leointeg.saveLeoFileFromOutline",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments/"
},
{
  "command": "leointeg.saveLeoFile",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
</t>
<t tx="ekr.20200815123601.8">"viewsContainers": {
  "activitybar": [
    {
      "id": "leoIntegrationView",
      "title": "Leo",
      "icon": "resources/icon.svg"
    }
  ]
},
</t>
<t tx="ekr.20200815123601.80">{
  "command": "leointeg.contractAll",
  "key": "alt+-",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.contractAllFromOutline",
  "key": "alt+-",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
</t>
<t tx="ekr.20200815123601.81">{
  "command": "leointeg.editSelectedHeadline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.markSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.unmarkSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.82"></t>
<t tx="ekr.20200815123601.83">{
  "command": "leointeg.moveOutlineDownSelection",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineDownSelection",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "shift+down",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.84">{
  "command": "leointeg.moveOutlineLeftSelection",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "shift+left",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.85">{
  "command": "leointeg.moveOutlineRightSelection",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "shift+right",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.86">{
  "command": "leointeg.moveOutlineUpSelection",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "shift+up",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.87">{
  "command": "leointeg.sortSiblingsSelection",
  "key": "alt+a",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "key": "alt+a",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.promoteSelection",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.demoteSelection",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelection",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; !sideBarFocus &amp;&amp; !editorTextFocus"
},
{
  "command": "leointeg.cloneNodeSelection",
  "key": "ctrl+[Backquote]",
  "win": "ctrl+oem_7",
  "linux": "ctrl+'",
  "mac": "cmd+[Backquote]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "key": "ctrl+[Backquote]",
  "win": "ctrl+oem_7",
  "linux": "ctrl+'",
  "mac": "cmd+[Backquote]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.cutNodeSelection",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.deleteSelection",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.88">{
  "command": "leointeg.gotoFirstVisible",
  "key": "alt+home",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoLastSibling",
  "key": "alt+end",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoFirstVisible",
  "key": "home",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoLastVisible",
  "key": "end",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.pageUp",
  "key": "pageup",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.pageDown",
  "key": "pagedown",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "key": "alt+n",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "key": "alt+n",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "down",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "alt+down",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "up",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "alt+up",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection  &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "left",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "alt+left",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "right",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "alt+right",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
}
</t>
<t tx="ekr.20200815123601.89">"resourceLabelFormatters": [
  {
    "scheme": "leo",
    "formatting": {
      "label": "LEO: BODY",
      "separator": "/",
      "workspaceSuffix": ""
    }
  }
]
</t>
<t tx="ekr.20200815123601.9">"views": {
  "explorer": [
    {
      "id": "leoIntegrationExplorer",
      "name": "Leo Integration",
      "contextualTitle": "Leo",
      "when": "treeInExplorer"
    },
    {
      "id": "leoDocumentsExplorer",
      "name": "Leo Documents",
      "contextualTitle": "Leo",
      "when": "treeInExplorer"
    },
    {
      "id": "leoButtonsExplorer",
      "name": "Leo Buttons",
      "contextualTitle": "Leo",
      "when": "treeInExplorer"
    }
  ],
  "leoIntegrationView": [
    {
      "id": "leoIntegration",
      "contextualTitle": "Leo",
      "name": "Integration"
    },
    {
      "id": "leoDocuments",
      "contextualTitle": "Leo",
      "name": "Documents"
    },
    {
      "id": "leoButtons",
      "contextualTitle": "Leo",
      "name": "Buttons"
    }
  ]
},
</t>
<t tx="felix.20191126232434.13">def openFile(self, p_file):
    """
    Open a leo file via leoBridge controller, or create a new document if empty string.
    Returns an object that contains a 'opened' member.
    """
    w_found = False

    # If not empty string (asking for New file) then check if already opened
    if p_file:
        for w_commander in self.g.app.commanders():
            if w_commander.fileName() == p_file:
                w_found = True
                self.commander = w_commander

    if not w_found:
        self.commander = self.bridge.openLeoFile(
            p_file)  # create self.commander

    # Leo at this point has done this too: g.app.windowList.append(c.frame)
    # and so, now, app.commanders() yields this: return [f.c for f in g.app.windowList]

    if self.commander:
        self.commander.closed = False
        if not w_found:
            # is new so also replace wrapper
            self.commander.frame.body.wrapper = IntegTextWrapper(
                self.commander, "integBody", self.g)
            self.commander.selectPosition(self.commander.p)

        self._create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self._p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage("opened", w_result)
    else:
        return self._outputError('Error in openFile')

</t>
<t tx="felix.20191126232434.14">def closeFile(self, p_package):
    """
    Closes a leo file. A file can then be opened with "openFile"
    Returns an object that contains a 'closed' member
    """
    # TODO : Specify which file to support multiple opened files
    if self.commander:
        if p_package["forced"] and self.commander.changed:
            # return "no" g.app.gui.runAskYesNoDialog  and g.app.gui.runAskYesNoCancelDialog
            self.commander.revert()
        if p_package["forced"] or not self.commander.changed:
            self.commander.closed = True
            self.commander.close()
        else:
            # Cannot close, ask to save, ignore or cancel
            return self.sendLeoBridgePackage('closed', False)

    # Switch commanders to first available
    w_total = self._getTotalOpened()
    if w_total:
        self.commander = self._getFirstOpenedCommander()
    else:
        self.commander = None

    if self.commander:
        self._create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self._p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage("closed", w_result)
    else:
        w_result = {"total": 0}
        return self.sendLeoBridgePackage("closed", w_result)

</t>
<t tx="felix.20191126232434.15">def getPNode(self, p_ap):
    '''EMIT OUT a node, don't select it'''
    if p_ap:
        w_p = self._ap_to_p(p_ap)
        if w_p:
            return self._outputPNode(w_p)
        else:
            return self._outputError("Error in getPNode no w_p node found")
    else:
        return self._outputError("Error in getPNode no param p_ap")

</t>
<t tx="felix.20191126232434.16">def getChildren(self, p_ap):
    '''EMIT OUT list of children of a node'''
    if p_ap:
        w_p = self._ap_to_p(p_ap)
        if w_p and w_p.hasChildren():
            return self._outputPNodes(w_p.children())
        else:
            return self._outputPNodes([])  # default empty array
    else:
        if self.commander.hoistStack:
            return self._outputPNodes([self.commander.hoistStack[-1].p])
        else:
            # this outputs all Root Children
            return self._outputPNodes(self._yieldAllRootChildren())

</t>
<t tx="felix.20191126232434.17">def getParent(self, p_ap):
    '''EMIT OUT the parent of a node, as an array, even if unique or empty'''
    if p_ap:
        w_p = self._ap_to_p(p_ap)
        if w_p and w_p.hasParent():
            return self._outputPNode(w_p.getParent())  # if not root
    return self._outputPNode()  # default empty for root as default

</t>
<t tx="felix.20191126232434.18">def getSelectedNode(self, p_unused):
    '''EMIT OUT Selected Position as an array, even if unique'''
    if self.commander.p:
        return self._outputPNode(self.commander.p)
    else:
        return self._outputPNode()

</t>
<t tx="felix.20191126232434.19">def getBody(self, p_gnx):
    '''EMIT OUT body of a node'''
    # TODO : if not found, send code to prevent unresolved promise if 'document switch' occurred shortly before
    if p_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(p_gnx)  # vitalije
        if w_v:
            if w_v.b:
                return self._outputBodyData(w_v.b)
            else:
                return self._outputBodyData()  # default "" empty string
    # Send as empty to fix unresolved promise if 'document switch' occurred shortly before
    return self._outputBodyData()
    # return self.sendLeoBridgePackage()  # default as inexistent

</t>
<t tx="felix.20191126232434.2">#! python3
@language python
@tabwidth -4
&lt;&lt; imports &gt;&gt;
&lt;&lt; constants &gt;&gt;
@others
if __name__ == '__main__':
    # Startup
    try:
        main()
    except KeyboardInterrupt:
        print("\nKeyboard Interupt: Stopping leobridge server", flush=True)
        sys.exit()
</t>
<t tx="felix.20191126232434.20">def getBodyLength(self, p_gnx):
    '''EMIT OUT body string length of a node'''
    if p_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(p_gnx)  # vitalije
        if w_v and w_v.b:
            # Length in bytes, not just by character count.
            return self.sendLeoBridgePackage("bodyLength", len(w_v.b.encode('utf-8')))
    # TODO : May need to signal inexistent by self.sendLeoBridgePackage()
    return self.sendLeoBridgePackage("bodyLength", 0)  # empty as default

</t>
<t tx="felix.20191126232434.22">def setBody(self, p_package):
    '''Change Body text of a node'''
    w_gnx = p_package['gnx']
    w_body = p_package['body']
    for w_p in self.commander.all_positions():
        if w_p.v.gnx == w_gnx:
            # TODO : Before setting undo and trying to set body, first check if different than existing body
            w_bunch = self.commander.undoer.beforeChangeNodeContents(
                w_p)  # setup undoable operation
            w_p.v.setBodyString(w_body)
            self.commander.undoer.afterChangeNodeContents(
                w_p, "Body Text", w_bunch)
            if self.commander.p.v.gnx == w_gnx:
                self.commander.frame.body.wrapper.setAllText(w_body)
            if not self.commander.isChanged():
                self.commander.setChanged()
            if not w_p.v.isDirty():
                w_p.setDirty()
            break
    # additional forced string setting
    if w_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(w_gnx)  # vitalije
        if w_v:
            w_v.b = w_body
    return self._outputPNode(self.commander.p)  # return selected node
    # return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.23">def setNewHeadline(self, p_package):
    '''Change Headline of a node'''
    w_newHeadline = p_package['text']
    w_ap = p_package['node']
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            # set this node's new headline
            w_bunch = self.commander.undoer.beforeChangeNodeContents(w_p)
            w_p.h = w_newHeadline
            self.commander.undoer.afterChangeNodeContents(
                w_p, 'Change Headline', w_bunch)
            return self._outputPNode(w_p)
    return self._outputError("Error in setNewHeadline")

</t>
<t tx="felix.20191126232434.24">def setSelectedNode(self, p_ap):
    '''Select a node, or the first one found with its GNX'''
    if p_ap:
        w_p = self._ap_to_p(p_ap)
        if w_p:
            if self.commander.positionExists(w_p):
                # set this node as selection
                self.commander.selectPosition(w_p)
            else:
                w_foundPNode = self._findPNodeFromGnx(p_ap['gnx'])
                if w_foundPNode:
                    self.commander.selectPosition(w_foundPNode)
                else:
                    print("Set Selection node does not exist! ap was:" +
                          json.dumps(p_ap), flush=True)
    # * return the finally selected node
    if self.commander.p:
        return self._outputPNode(self.commander.p)
    else:
        return self._outputPNode()

</t>
<t tx="felix.20191126232434.25">def expandNode(self, p_ap):
    '''Expand a node'''
    if p_ap:
        w_p = self._ap_to_p(p_ap)
        if w_p:
            w_p.expand()
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.26">def collapseNode(self, p_ap):
    '''Collapse a node'''
    if p_ap:
        w_p = self._ap_to_p(p_ap)
        if w_p:
            w_p.contract()
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.27">def _create_gnx_to_vnode(self):
    '''Make the first gnx_to_vnode array with all unique nodes'''
    t1 = time.process_time()
    self.gnx_to_vnode = {
        v.gnx: v for v in self.commander.all_unique_nodes()}
    # This is likely the only data that ever will be needed.
    if 0:
        print('app.create_all_data: %5.3f sec. %s entries' % (
            (time.process_time()-t1), len(list(self.gnx_to_vnode.keys()))), flush=True)
    self._test_round_trip_positions()

</t>
<t tx="felix.20191126232434.28">def _test_round_trip_positions(self):
    '''(From Leo plugin leoflexx.py) Test the round tripping of p_to_ap and ap_to_p.'''
    # Bug fix: p_to_ap updates app.gnx_to_vnode. Save and restore it.
    old_d = self.gnx_to_vnode.copy()
    old_len = len(list(self.gnx_to_vnode.keys()))
    # t1 = time.process_time()
    qtyAllPositions = 0
    for p in self.commander.all_positions():
        qtyAllPositions += 1
        ap = self._p_to_ap(p)
        p2 = self._ap_to_p(ap)
        assert p == p2, (repr(p), repr(p2), repr(ap))
    gnx_to_vnode = old_d
    new_len = len(list(gnx_to_vnode.keys()))
    assert old_len == new_len, (old_len, new_len)
    # print('Leo file opened. Its outline contains ' + str(qtyAllPositions) + " nodes positions.", flush=True)
    # print(('Testing app.test_round_trip_positions for all nodes: Total time: %5.3f sec.' % (time.process_time()-t1)), flush=True)

</t>
<t tx="felix.20191126232434.29">def _yieldAllRootChildren(self):
    '''Return all root children P nodes'''
    p = self.commander.rootPosition()
    while p:
        yield p
        p.moveToNext()

</t>
<t tx="felix.20191126232434.30">def _ap_to_p(self, ap):
    '''
    (From Leo plugin leoflexx.py) Convert an archived position to a true Leo position.
    Return false if no key
    '''
    childIndex = ap['childIndex']

    try:
        v = self.gnx_to_vnode[ap['gnx']]  # Trap this
        stack = [
            (self.gnx_to_vnode[d['gnx']], d['childIndex'])
            for d in ap['stack']
        ]
    except Exception:
        return False

    return leoNodes.position(v, childIndex, stack)

</t>
<t tx="felix.20191126232434.31">def _p_to_ap(self, p):
    '''(From Leo plugin leoflexx.py) Converts Leo position to a serializable archived position.'''
    if not p.v:
        print('app.p_to_ap: no p.v: %r %s' % (p), flush=True)
        assert False
    p_gnx = p.v.gnx
    # * Expand gnx-vnode translation table for any new node encountered
    if p_gnx not in self.gnx_to_vnode:
        self.gnx_to_vnode[p_gnx] = p.v
    # * necessary properties for outline
    w_ap = {
        'childIndex': p._childIndex,
        'gnx': p.v.gnx,
        'level': p.level(),
        'headline': p.h,
        'stack': [{
            'gnx': stack_v.gnx,
            'childIndex': stack_childIndex,
            'headline': stack_v.h,
        } for (stack_v, stack_childIndex) in p.stack],
    }
    # TODO : Convert all those booleans into an 8 bit integer 'status' flag
    if p.v.u:
        w_ap['u'] = p.v.u
    if bool(p.b):
        w_ap['hasBody'] = True
    if p.hasChildren():
        w_ap['hasChildren'] = True
    if p.isCloned():
        w_ap['cloned'] = True
    if p.isDirty():
        w_ap['dirty'] = True
    if p.isExpanded():
        w_ap['expanded'] = True
    if p.isMarked():
        w_ap['marked'] = True
    if p.isAnyAtFileNode():
        w_ap['atFile'] = True
    if p == self.commander.p:
        w_ap['selected'] = True
    return w_ap


</t>
<t tx="felix.20191126232434.4">class LeoBridgeIntegController:
    '''Leo Bridge Controller'''
    # pylint: disable=no-else-return

    @others
</t>
<t tx="felix.20191126232434.5">def __init__(self):
    # TODO : @boltex #74 need gnx_to_vnode for each opened file/commander
    self.gnx_to_vnode = []  # utility array - see leoflexx.py in leoPluginsRef.leo
    self.bridge = leoBridge.controller(
        gui='nullGui',
        loadPlugins=True,   # True: attempt to load plugins.
        readSettings=True,  # True: read standard settings files.
        silent=True,        # True: don't print signon messages.
        # True: prints messages that would be sent to the log pane.
        verbose=False,
    )
    self.g = self.bridge.globals()

    # * Trace outputs to pythons stdout, also prints the function call stack
    # self.g.trace('test trace')

    # * Intercept Log Pane output: Sends to client's log pane
    self.g.es = self.es  # pointer - not a function call

    # print(dir(self.g), flush=True)
    self.currentActionId = 1  # Id of action being processed, STARTS AT 1 = Initial 'ready'

    # * Currently Selected Commander (opened from leo.core.leoBridge or chosen via the g.app.windowList 2 list)
    self.commander = None

    self.leoIntegConfig = None
    self.webSocket = None
    self.loop = None

    # * Replacement instances to Leo's codebase : getScript, IdleTime, idleTimeManager and externalFilesController
    self.g.getScript = self._getScript
    self.g.IdleTime = self._idleTime
    self.g.app.idleTimeManager = IdleTimeManager(self.g)
    # attach instance to g.app for calls to set_time, etc.
    self.g.app.externalFilesController = ExternalFilesController(self)
    # TODO : Maybe use those yes/no replacement right before actual usage instead of in init. (to allow re-use/switching)
    # override for "revert to file" operation
    self.g.app.gui.runAskYesNoDialog = self._returnYes

    # * setup leoBackground to get messages from leo
    try:
        self.g.app.idleTimeManager.start()  # To catch derived file changes
    except Exception:
        print('ERROR with idleTimeManager')

</t>
<t tx="felix.20191126232435.1">def main():
    '''python script for leo integration via leoBridge'''
    global wsHost, wsPort
    print("Starting LeoBridge... (Launch with -h for help)", flush=True)
    # replace default host address and port if provided as arguments

    args = None
    try:
        opts, args = getopt.getopt(sys.argv[1:], "ha:p:", [
                                   "help", "address=", "port="])
    except getopt.GetoptError:
        print('leobridgeserver.py -a &lt;address&gt; -p &lt;port&gt;')
        print('defaults to localhost on port 32125', flush=True)
        if args:
            print("unused args: " + str(args), flush=True)
        sys.exit(2)
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            print('leobridgeserver.py -a &lt;address&gt; -p &lt;port&gt;')
            print('defaults to localhost on port 32125', flush=True)
            sys.exit()
        elif opt in ("-a", "--address"):
            wsHost = arg
        elif opt in ("-p", "--port"):
            wsPort = arg

    # * start Server
    integController = LeoBridgeIntegController()

    # * This is a basic example loop
    # async def asyncInterval(timeout):
    #     dummyCounter = 0
    #     strTimeout = str(timeout) + ' sec interval'
    #     while True:
    #         await asyncio.sleep(timeout)
    #         dummyCounter = dummyCounter+1
    #         await integController.asyncOutput("{\"interval\":" + str(timeout+dummyCounter) + "}")  # as number
    #         print(strTimeout)

    async def leoBridgeServer(websocket, path):
        try:
            integController.initConnection(websocket)
            # * Start by sending empty as 'ok'
            await websocket.send(integController.sendLeoBridgePackage())
            integController.logSignon()
            async for w_message in websocket:
                w_param = json.loads(w_message)
                if w_param and w_param['action']:
                    w_action = w_param['action']
                    w_actionParam = w_param['param']
                    # printAction(w_param)  # Debug output
                    # * Storing id of action in global var instead of passing as parameter
                    integController.setActionId(w_param['id'])
                    # ! functions called this way need to accept at least a parameter other than 'self'
                    # ! See : getSelectedNode and getAllGnx
                    # TODO : Block attempts to call functions starting with underscore or reserved
                    #
                    w_func = getattr(integController, w_action, None)  # crux
                    if w_func:
                        # Is Filtered by Leo Bridge Integration Controller
                        w_answer = w_func(w_actionParam)
                    else:
                        # Attempt to execute the command directly on the commander/subcommander
                        w_answer = integController.leoCommand(
                            w_action, w_actionParam)
                else:
                    w_answer = "Error in processCommand"
                    print(w_answer, flush=True)
                await websocket.send(w_answer)
        except websockets.exceptions.ConnectionClosedError:
            print("Websocket connection closed", flush=True)
        except Exception:
            print('Exception in leobridgeserver.py!', flush=True)
            # Like g.es_exception()...
            typ, val, tb = sys.exc_info()
            for line in traceback.format_exception(typ, val, tb):
                print(line.rstrip(), flush=True)
        finally:
            asyncio.get_event_loop().stop()

    localLoop = asyncio.get_event_loop()
    start_server = websockets.serve(leoBridgeServer, wsHost, wsPort)
    # localLoop.create_task(asyncInterval(5)) # Starts a test loop of async communication
    localLoop.run_until_complete(start_server)
    print("LeoBridge started at " + wsHost + " on port: " +
          str(wsPort) + " [ctrl+c] to break", flush=True)
    localLoop.run_forever()
    print("Stopping leobridge server", flush=True)


</t>
<t tx="felix.20191128001054.1"></t>
<t tx="felix.20191128002414.1">import leo.core.leoBridge as leoBridge
import leo.core.leoNodes as leoNodes
import asyncio
import getopt
import json
import os.path
import sys
import time
import traceback
import websockets
</t>
<t tx="felix.20191128002417.1"># server defaults
wsHost = "localhost"
wsPort = 32125

commonActions = ["getChildren", "getBody", "getBodyLength"]


</t>
<t tx="felix.20191128003648.1"></t>
<t tx="felix.20191201194046.1">def getAllGnx(self, p_unused):
    '''Get gnx array from all unique nodes'''
    w_all_gnx = [
        p.v.gnx for p in self.commander.all_unique_positions(copy=False)]
    return self.sendLeoBridgePackage("allGnx", w_all_gnx)

</t>
<t tx="felix.20191216195906.1">def _findPNodeFromGnx(self, p_gnx):
    '''Return first p node with this gnx or false'''
    for p in self.commander.all_unique_positions():
        if p.v.gnx == p_gnx:
            return p
    return False

</t>
<t tx="felix.20200211202929.1">def initConnection(self, p_webSocket):
    self.webSocket = p_webSocket
    self.loop = asyncio.get_event_loop()

</t>
<t tx="felix.20200216160305.1">def saveFile(self, p_package):
    '''Saves the leo file. New or dirty derived files are rewritten'''
    if self.commander:
        try:
            if "text" in p_package:
                self.commander.save(fileName=p_package['text'])
            else:
                self.commander.save()
        except Exception as e:
            self.g.trace('Error while saving')
            print("Error while saving", flush=True)
            print(str(e), flush=True)

    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200219222712.1">def es(self, * args, **keys):
    '''Output to the Log Pane'''
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
        'nodeLink': None,
    }
    d = self.g.doKeywordArgs(keys, d)
    s = self.g.translateArgs(args, d)
    w_package = {"async": "log", "log": s}
    self.sendAsyncOutput(w_package)

</t>
<t tx="felix.20200219224515.1">def logSignon(self):
    '''Simulate the Initial Leo Log Entry'''
    if self.loop:
        self.g.app.computeSignon()
        self.g.es(str(self.g.app.signon))
        self.g.es(str(self.g.app.signon1))
    else:
        print('no loop in logSignon', flush=True)

</t>
<t tx="felix.20200302204251.1">class IdleTimeManager:
    """
    A singleton class to manage idle-time handling. This class handles all
    details of running code at idle time, including running 'idle' hooks.

    Any code can call g.app.idleTimeManager.add_callback(callback) to cause
    the callback to be called at idle time forever.
    """
    # TODO : REVISE/REPLACE WITH OWN SYSTEM

    def __init__(self, g):
        """Ctor for IdleTimeManager class."""
        self.g = g
        self.callback_list = []
        self.timer = None
        self.on_idle_count = 0

    @others

</t>
<t tx="felix.20200302204251.2">def add_callback(self, callback):
    """Add a callback to be called at every idle time."""
    self.callback_list.append(callback)

</t>
<t tx="felix.20200302204251.3">def on_idle(self, timer):
    """IdleTimeManager: Run all idle-time callbacks."""
    if not self.g.app:
        return
    if self.g.app.killed:
        return
    if not self.g.app.pluginsController:
        self.g.trace('No g.app.pluginsController', self.g.callers())
        timer.stop()
        return  # For debugger.
    self.on_idle_count += 1
    # Handle the registered callbacks.
    # print("list length : ", len(self.callback_list))
    for callback in self.callback_list:
        try:
            callback()
        except Exception:
            self.g.es_exception()
            self.g.es_print(f"removing callback: {callback}")
            self.callback_list.remove(callback)
    # Handle idle-time hooks.
    self.g.app.pluginsController.on_idle()

</t>
<t tx="felix.20200302204251.4">def start(self):
    """Start the idle-time timer."""
    self.timer = self.g.IdleTime(
        self.on_idle,
        delay=500,  # Milliseconds
        tag='IdleTimeManager.on_idle')
    if self.timer:
        self.timer.start()

</t>
<t tx="felix.20200302205810.1">class ExternalFilesController:
    '''EFC Modified from Leo's sources'''
    # pylint: disable=no-else-return

    @others

</t>
<t tx="felix.20200302205810.2">def __init__(self, integController):
    '''Ctor for ExternalFiles class.'''
    self.on_idle_count = 0
    self.integController = integController
    self.checksum_d = {}
    # Keys are full paths, values are file checksums.
    self.enabled_d = {}
    # For efc.on_idle.
    # Keys are commanders.
    # Values are cached @bool check-for-changed-external-file settings.
    self.has_changed_d = {}
    # Keys are commanders. Values are boolean.
    # Used only to limit traces.
    self.unchecked_commanders = []
    # Copy of g.app.commanders()
    self.unchecked_files = []
    # Copy of self file. Only one files is checked at idle time.
    self._time_d = {}
    # Keys are full paths, values are modification times.
    # DO NOT alter directly, use set_time(path) and
    # get_time(path), see set_time() for notes.
    self.yesno_all_time = 0  # previous yes/no to all answer, time of answer
    self.yesno_all_answer = None  # answer, 'yes-all', or 'no-all'

    # if yesAll/noAll forced, then just show info message after idle_check_commander
    self.infoMessage = None
    # False or "detected", "refreshed" or "ignored"

    self.integController.g.app.idleTimeManager.add_callback(self.on_idle)

    self.waitingForAnswer = False
    self.lastPNode = None  # last p node that was asked for if not set to "AllYes\AllNo"
    self.lastCommander = None

</t>
<t tx="felix.20200302205810.21"></t>
<t tx="felix.20200302205810.22">def ask(self, c, path, p=None):
    '''
    Ask user whether to overwrite an @&lt;file&gt; tree.
    Return True if the user agrees.
    '''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["defaultReloadIgnore"].lower(
        )
        if not bool('none' in w_check_config):
            if bool('yes' in w_check_config):
                self.infoMessage = "refreshed"
                return True
            else:
                self.infoMessage = "ignored"
                return False
    # let original function resolve

    if self.yesno_all_time + 3 &gt;= time.time() and self.yesno_all_answer:
        self.yesno_all_time = time.time()  # Still reloading?  Extend time.
        # if yesAll/noAll forced, then just show info message
        w_yesno_all_bool = bool('yes' in self.yesno_all_answer.lower())

        return w_yesno_all_bool
    if not p:
        where = 'the outline node'
    else:
        where = p.h

    _is_leo = path.endswith(('.leo', '.db'))

    if _is_leo:
        s = '\n'.join([
            f'{self.integController.g.splitLongFileName(path)} has changed outside Leo.',
            'Overwrite it?'
        ])
    else:
        s = '\n'.join([
            f'{self.integController.g.splitLongFileName(path)} has changed outside Leo.',
            f"Reload {where} in Leo?",
        ])

    w_package = {"async": "ask", "ask": 'Overwrite the version in Leo?',
                 "message": s, "yes_all": not _is_leo, "no_all": not _is_leo}

    self.integController.sendAsyncOutput(w_package)
    self.waitingForAnswer = True
    return False
    # result = self.integController.g.app.gui.runAskYesNoDialog(c, 'Overwrite the version in Leo?', s,
    # yes_all=not _is_leo, no_all=not _is_leo)

    # if result and "-all" in result.lower():
    # self.yesno_all_time = time.time()
    # self.yesno_all_answer = result.lower()

    # return bool(result and 'yes' in result.lower())

</t>
<t tx="felix.20200302205810.23">def checksum(self, path):
    '''Return the checksum of the file at the given path.'''
    import hashlib
    return hashlib.md5(open(path, 'rb').read()).hexdigest()

</t>
<t tx="felix.20200302205810.25">def get_mtime(self, path):
    '''Return the modification time for the path.'''
    return self.integController.g.os_path_getmtime(self.integController.g.os_path_realpath(path))

</t>
<t tx="felix.20200302205810.26">def get_time(self, path):
    '''
    return timestamp for path

    see set_time() for notes
    '''
    return self._time_d.get(self.integController.g.os_path_realpath(path))

</t>
<t tx="felix.20200302205810.27">def has_changed(self, c, path):
    '''Return True if p's external file has changed outside of Leo.'''
    if not self.integController.g.os_path_exists(path):
        return False
    if self.integController.g.os_path_isdir(path):
        return False
    #
    # First, check the modification times.
    old_time = self.get_time(path)
    new_time = self.get_mtime(path)
    if not old_time:
        # Initialize.
        self.set_time(path, new_time)
        self.checksum_d[path] = self.checksum(path)
        return False
    if old_time == new_time:
        return False
    #
    # Check the checksums *only* if the mod times don't match.
    old_sum = self.checksum_d.get(path)
    new_sum = self.checksum(path)
    if new_sum == old_sum:
        # The modtime changed, but it's contents didn't.
        # Update the time, so we don't keep checking the checksums.
        # Return False so we don't prompt the user for an update.
        self.set_time(path, new_time)
        return False
    # The file has really changed.
    assert old_time, path
    # #208: external change overwrite protection only works once.
    # If the Leo version is changed (dirtied) again,
    # overwrite will occur without warning.
    # self.set_time(path, new_time)
    # self.checksum_d[path] = new_sum
    return True

</t>
<t tx="felix.20200302205810.28">def is_enabled(self, c):
    '''Return the cached @bool check_for_changed_external_file setting.'''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["checkForChangeExternalFiles"].lower(
        )
        if bool('check' in w_check_config):
            return True
        if bool('ignore' in w_check_config):
            return False
    # let original function resolve
    d = self.enabled_d
    val = d.get(c)
    if val is None:
        val = c.config.getBool(
            'check-for-changed-external-files', default=False)
        d[c] = val
    return val

</t>
<t tx="felix.20200302205810.29">def join(self, s1, s2):
    '''Return s1 + ' ' + s2'''
    return f"{s1} {s2}"

</t>
<t tx="felix.20200302205810.30">def set_time(self, path, new_time=None):
    '''
    Implements c.setTimeStamp.

    Update the timestamp for path.

    NOTE: file paths with symbolic links occur with and without those links
    resolved depending on the code call path.  This inconsistency is
    probably not Leo's fault but an underlying Python issue.
    Hence the need to call realpath() here.
    '''

    # print("called set_time for " + str(path), flush=True)

    t = new_time or self.get_mtime(path)
    self._time_d[self.integController.g.os_path_realpath(path)] = t

</t>
<t tx="felix.20200302205810.31">def warn(self, c, path, p):
    '''
    Warn that an @asis or @nosent node has been changed externally.

    There is *no way* to update the tree automatically.
    '''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["defaultReloadIgnore"].lower(
        )

        if w_check_config != "none":
            # if not 'none' then do not warn, just infoMessage 'warn' at most
            if not self.infoMessage:
                self.infoMessage = "warn"
            return

    # let original function resolve
    if self.integController.g.unitTesting or c not in self.integController.g.app.commanders():
        return
    if not p:
        self.integController.g.trace('NO P')
        return

    s = '\n'.join([
        '%s has changed outside Leo.\n' % self.integController.g.splitLongFileName(
            path),
        'Leo can not update this file automatically.\n',
        'This file was created from %s.\n' % p.h,
        'Warning: refresh-from-disk will destroy all children.'
    ])

    w_package = {"async": "warn",
                 "warn": 'External file changed', "message": s}

    self.integController.sendAsyncOutput(w_package)
    self.waitingForAnswer = True

</t>
<t tx="felix.20200302205810.7">def on_idle(self):
    '''
    Check for changed open-with files and all external files in commanders
    for which @bool check_for_changed_external_file is True.
    '''
    # Fix for flushing the terminal console to traverse
    # python through node.js when using start server in leoInteg
    sys.stdout.flush()

    if not self.integController.g.app or self.integController.g.app.killed:
        return
    if self.waitingForAnswer:
        return

    self.on_idle_count += 1

    if self.unchecked_commanders:
        # Check the next commander for which
        # @bool check_for_changed_external_file is True.
        c = self.unchecked_commanders.pop()
        self.lastCommander = c
        self.idle_check_commander(c)
    else:
        # Add all commanders for which
        # @bool check_for_changed_external_file is True.
        self.unchecked_commanders = [
            z for z in self.integController.g.app.commanders() if self.is_enabled(z)
        ]

</t>
<t tx="felix.20200302205810.8">def idle_check_commander(self, c):
    '''
    Check all external files corresponding to @&lt;file&gt; nodes in c for
    changes.
    '''
    # #1100: always scan the entire file for @&lt;file&gt; nodes.
    # #1134: Nested @&lt;file&gt; nodes are no longer valid, but this will do no harm.

    self.infoMessage = None  # reset infoMessage
    # False or "detected", "refreshed" or "ignored"

    for p in c.all_unique_positions():
        if self.waitingForAnswer:
            break
        if p.isAnyAtFileNode():
            self.idle_check_at_file_node(c, p)

    # if yesAll/noAll forced, then just show info message
    if self.infoMessage:
        w_package = {"async": "info", "message": self.infoMessage}
        self.integController.sendAsyncOutput(w_package)

</t>
<t tx="felix.20200302205810.9">def idle_check_at_file_node(self, c, p):
    '''Check the @&lt;file&gt; node at p for external changes.'''
    trace = False
    # Matt, set this to True, but only for the file that interests you.\
    # trace = p.h == '@file unregister-leo.leox'
    path = self.integController.g.fullPath(c, p)
    has_changed = self.has_changed(c, path)
    if trace:
        self.integController.g.trace('changed', has_changed, p.h)
    if has_changed:
        self.lastPNode = p  # can be set here because its the same process for ask/warn
        if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
            # Fix #1081: issue a warning.
            self.warn(c, path, p=p)
        elif self.ask(c, path, p=p):
            self.lastCommander.selectPosition(self.lastPNode)
            c.refreshFromDisk()

        # Always update the path &amp; time to prevent future warnings.
        self.set_time(path)
        self.checksum_d[path] = self.checksum(path)

</t>
<t tx="felix.20200303214235.1">async def _asyncIdleLoop(self, p_seconds, p_fn):
    while True:
        await asyncio.sleep(p_seconds)
        p_fn(self)

</t>
<t tx="felix.20200303214255.1">def _idleTime(self, fn, delay, tag):
    # TODO : REVISE/REPLACE WITH OWN SYSTEM
    asyncio.get_event_loop().create_task(self._asyncIdleLoop(delay/1000, fn))

</t>
<t tx="felix.20200304220844.1">def askResult(self, p_result):
    '''Got the result to an asked question/warning from client'''
    self.g.app.externalFilesController.integResult(p_result)
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200304221925.1">def integResult(self, p_result):
    '''Received result from client'''
    # Got the result to an asked question/warning from the client
    if not self.waitingForAnswer:
        print("ERROR: Received Result but no Asked Dialog", flush=True)
        return
    # check if p_resultwas from a warn (ok) or an ask ('yes','yes-all','no','no-all')
    # act accordingly

    path = self.integController.g.fullPath(
        self.lastCommander, self.lastPNode)

    # 1- if ok, unblock 'warn'
    # 2- if no, unblock 'ask'
    # ------------------------------------------ Nothing special to do

    # 3- if noAll, set noAll, and unblock 'ask'
    if p_result and "-all" in p_result.lower():
        self.yesno_all_time = time.time()
        self.yesno_all_answer = p_result.lower()
    # ------------------------------------------ Also covers setting yesAll in #5

    # 4- if yes, REFRESH self.lastPNode, and unblock 'ask'
    # 5- if yesAll,REFRESH self.lastPNode, set yesAll, and unblock 'ask'
    if bool(p_result and 'yes' in p_result.lower()):
        self.lastCommander.selectPosition(self.lastPNode)
        self.lastCommander.refreshFromDisk()

    # Always update the path &amp; time to prevent future warnings for this PNode.
    self.set_time(path)
    self.checksum_d[path] = self.checksum(path)

    self.waitingForAnswer = False  # unblock
    # unblock: run the loop as if timer had hit
    self.idle_check_commander(self.lastCommander)

</t>
<t tx="felix.20200304224909.1">def sendAsyncOutput(self, p_package):
    if "async" not in p_package:
        print('[sendAsyncOutput] Error async member missing in package parameter')
        print(json.dumps(p_package, separators=(',', ':')), flush=True)
        return
    if self.loop:
        self.loop.create_task(self.asyncOutput(
            json.dumps(p_package, separators=(',', ':'))))
    else:
        print('[sendAsyncOutput] Error loop not ready' +
              json.dumps(p_package, separators=(',', ':')))

</t>
<t tx="felix.20200308145948.1"># Some methods are called in the usual (non-leoBridge without 'efc') save process.
# Those may be called by the 'save' function, like check_overwrite,
# or by any other functions from the instance of leo.core.leoBridge that's running.

</t>
<t tx="felix.20200308150821.1">def shut_down(self):
    return

</t>
<t tx="felix.20200308150842.1">def destroy_frame(self, f):
    return

</t>
<t tx="felix.20200308150848.1">def check_overwrite(self, c, fn):
    # print("check_overwrite!! ", flush=True)
    return True

</t>
<t tx="felix.20200308150856.1">def open_with(self, c, d):
    return

</t>
<t tx="felix.20200312231358.1">def applyConfig(self, p_config):
    '''Got leoInteg's config from client'''
    self.leoIntegConfig = p_config
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200622230608.1">def getOpenedFiles(self, p_package):
    '''Return array of opened file path/names to be used as openFile parameters to switch files'''
    w_files = []
    w_index = 0
    w_indexFound = 0
    for w_commander in self.g.app.commanders():
        if not w_commander.closed:
            w_isSelected = False
            w_isChanged = w_commander.changed
            if self.commander == w_commander:
                w_indexFound = w_index
                w_isSelected = True
            w_entry = {"name": w_commander.mFileName, "index": w_index,
                       "changed": w_isChanged, "selected": w_isSelected}
            w_files.append(w_entry)
            w_index = w_index + 1

    w_openedFiles = {"files": w_files, "index": w_indexFound}

    return self.sendLeoBridgePackage("openedFiles", w_openedFiles)

</t>
<t tx="felix.20200623201853.1">def _getTotalOpened(self):
    '''Get total of opened commander (who have closed == false)'''
    w_total = 0
    for w_commander in self.g.app.commanders():
        if not w_commander.closed:
            w_total = w_total + 1
    return w_total

</t>
<t tx="felix.20200623215904.1">def _getFirstOpenedCommander(self):
    '''Get first opened commander, or False if there are none.'''
    for w_commander in self.g.app.commanders():
        if not w_commander.closed:
            return w_commander
    return False

</t>
<t tx="felix.20200624172552.1">def setOpenedFile(self, p_package):
    '''Choose the new active commander from array of opened file path/names by numeric index'''
    w_openedCommanders = []

    for w_commander in self.g.app.commanders():
        if not w_commander.closed:
            w_openedCommanders.append(w_commander)

    w_index = p_package['index']

    if w_openedCommanders[w_index]:
        self.commander = w_openedCommanders[w_index]

    if self.commander:
        self.commander.closed = False
        self._create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self._p_to_ap(self.commander.p)}
        # maybe needed for frame wrapper
        self.commander.selectPosition(self.commander.p)
        return self.sendLeoBridgePackage("setOpened", w_result)
    else:
        return self._outputError('Error in setOpenedFile')

</t>
<t tx="felix.20200626012709.1">def _returnNo(self, *arguments, **kwargs):
    '''Used to override g.app.gui.ask[XXX] dialogs answers'''
    return "no"

</t>
<t tx="felix.20200626030820.1">def _returnYes(self, *arguments, **kwargs):
    '''Used to override g.app.gui.ask[XXX] dialogs answers'''
    return "yes"

</t>
<t tx="felix.20200718020912.1">import * as vscode from "vscode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718020912.10">/**
 * * Actions that can be invoked by Leo through leobridge
 */
public static ASYNC_ACTIONS = {
    ASYNC_LOG: "log",
    ASYNC_ASK: "ask",
    ASYNC_WARN: "warn",
    ASYNC_INFO: "info",
    ASYNC_INTERVAL: "interval"
};

</t>
<t tx="felix.20200718020912.11">/**
 * * When async action was ASYNC_INFO
 */
public static ASYNC_INFO_MESSAGE_CODES = {
    ASYNC_REFRESHED: "refreshed",
    ASYNC_IGNORED: "ignored"
};

</t>
<t tx="felix.20200718020912.12">/**
 * * runAskYesNoDialog or runAskOkDialog result codes, used when async action requires a response
 */
public static ASYNC_ASK_RETURN_CODES = {
    YES: "yes",
    NO: "no",
    YES_ALL: "yes-all",
    NO_ALL: "no-all",
    OK: '"ok"' // Quotes in string as a 'JSON parameter'
};

</t>
<t tx="felix.20200718020912.13">/**
 * * Commands for leobridgeserver.py
 */
public static LEOBRIDGE = {
    TEST: "test",
    APPLY_CONFIG: "applyConfig",
    ASK_RESULT: "askResult",
    GET_ALL_GNX: "getAllGnx",
    GET_BODY_LENGTH: "getBodyLength",
    GET_BODY_STATES: "getBodyStates",
    GET_BODY: "getBody",
    GET_PNODE: "getPNode",
    GET_PARENT: "getParent",
    GET_CHILDREN: "getChildren",
    GET_SELECTED_NODE: "getSelectedNode",
    SET_SELECTED_NODE: "setSelectedNode",
    SET_BODY: "setBody",
    SET_SELECTION: "setSelection",
    SET_HEADLINE: "setNewHeadline",
    EXPAND_NODE: "expandNode",
    COLLAPSE_NODE: "collapseNode",
    CONTRACT_ALL: "contractAllHeadlines",
    GET_OPENED_FILES: "getOpenedFiles",
    SET_OPENED_FILE: "setOpenedFile",
    OPEN_FILE: "openFile",
    OPEN_FILES: "openFiles", // Sends an array of paths instead: for opening many files at once
    CLOSE_FILE: "closeFile",
    SAVE_FILE: "saveFile",
    SAVE_CLOSE_FILE: "saveCloseFile", // Save and close current document
    GET_BUTTONS: "getButtons",
    REMOVE_BUTTON: "removeButton",
    CLICK_BUTTON: "clickButton",
    GET_COMMANDS: "getCommands", // ask leoBridge for the list of known commands, (starting with text string)
    GIT_DIFF: "gitDiff", // TODO : Proof of concept leoCommand
    // * Goto operations
    PAGE_UP: "pageUp",
    PAGE_DOWN: "pageDown",
    GOTO_FIRST_VISIBLE: "goToFirstVisibleNode",
    GOTO_LAST_VISIBLE: "goToLastVisibleNode",
    GOTO_LAST_SIBLING: "goToLastSibling",
    GOTO_NEXT_VISIBLE: "selectVisNext",
    GOTO_PREV_VISIBLE: "selectVisBack",
    GOTO_NEXT_MARKED: "goToNextMarkedHeadline",
    GOTO_NEXT_CLONE: "goToNextClone",
    CONTRACT_OR_GO_LEFT: "contractNodeOrGoToParent",
    EXPAND_AND_GO_RIGHT: "expandNodeAndGoToFirstChild",
    // * Leo Operations
    MARK_PNODE: "markPNode",
    UNMARK_PNODE: "unmarkPNode",
    COPY_PNODE: "copyOutline", // was overridden as "copyPNode"
    CUT_PNODE: "cutPNode",
    PASTE_PNODE: "pasteOutline", // was overridden as "pastePNode"
    PASTE_CLONE_PNODE: "pasteOutlineRetainingClones", // was overridden as "pasteAsClonePNode"
    DELETE_PNODE: "deletePNode",
    MOVE_PNODE_DOWN: "moveOutlineDown", // was overridden as "movePNodeDown"
    MOVE_PNODE_LEFT: "moveOutlineLeft", // was overridden as "movePNodeLeft"
    MOVE_PNODE_RIGHT: "moveOutlineRight", // was overridden as "movePNodeRight"
    MOVE_PNODE_UP: "moveOutlineUp", // was overridden as "movePNodeUp"
    INSERT_PNODE: "insertPNode",
    INSERT_NAMED_PNODE: "insertNamedPNode",
    CLONE_PNODE: "clonePNode",
    PROMOTE_PNODE: "promote", // was overridden as "promotePNode"
    DEMOTE_PNODE: "demote", // was overridden as "demotePNode"
    REFRESH_FROM_DISK_PNODE: "refreshFromDisk", // was overridden as "refreshFromDiskPNode"
    SORT_CHILDREN: "sortChildren", // was overridden as "sortChildrenPNode"
    SORT_SIBLINGS: "sortSiblings", // was overridden as "sortSiblingsPNode"
    UNDO: "undo",
    REDO: "redo",
    EXECUTE_SCRIPT: "executeScript",
    GET_STATES: "getStates",
    HOIST_PNODE: "hoist",
    DEHOIST: "dehoist",
    EXTRACT: "extract",
    EXTRACT_NAMES: "extractNames",
    COPY_MARKED: "copyMarked",
    DIFF_MARKED_NODES: "deleteMarked",
    MARK_CHANGED_ITEMS: "markChangedHeadlines",
    MARK_SUBHEADS: "markSubheads",
    UNMARK_ALL: "unmarkAll",
    CLONE_MARKED_NODES: "cloneMarked",
    DELETE_MARKED_NODES: "deleteMarked",
    MOVE_MARKED_NODES: "moveMarked",
    // TODO : @boltex More commands to implement #24
    CLONE_FIND_ALL: "cloneFindAll", // #24 @boltex
    CLONE_FIND_ALL_FLATTENED: "cloneFindAllFlattened", // #24 @boltex
    CLONE_FIND_MARKED: "cloneFindMarked", // #24 @boltex
    CLONE_FIND_FLATTENED_MARKED: "cloneFindFlattenedMarked", // #24 @boltex
};

</t>
<t tx="felix.20200718020912.15">/**
 * * All commands this expansion exposes (in package.json, contributes &gt; commands)
 */
public static COMMANDS = {
    SHOW_WELCOME: Constants.NAME + ".showWelcomePage", // Always available: not in the commandPalette section of package.json
    SHOW_SETTINGS: Constants.NAME + ".showSettingsPage", // Always available: not in the commandPalette section of package.json
    // * LeoBridge
    START_SERVER: Constants.NAME + ".startServer",
    CONNECT: Constants.NAME + ".connectToServer",
    SET_OPENED_FILE: Constants.NAME + ".setOpenedFile",
    OPEN_FILE: Constants.NAME + ".openLeoFile", // sets focus on BODY
    RECENT_FILES: Constants.NAME + ".recentLeoFiles", // shows recent Leo files, opens one on selection
    SWITCH_FILE: Constants.NAME + ".switchLeoFile",
    NEW_FILE: Constants.NAME + ".newLeoFile",
    SAVE_FILE: Constants.NAME + ".saveLeoFile", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
    SAVE_FILE_FO: Constants.NAME + ".saveLeoFileFromOutline", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
    SAVE_AS_FILE: Constants.NAME + ".saveAsLeoFile",
    CLOSE_FILE: Constants.NAME + ".closeLeoFile",
    CLICK_BUTTON: Constants.NAME + ".clickButton",
    REMOVE_BUTTON: Constants.NAME + ".removeButton",
    MINIBUFFER: Constants.NAME + ".minibuffer",
    GIT_DIFF: Constants.NAME + ".gitDiff", // TODO : Proof of concept leoCommand
    // * Outline selection
    SELECT_NODE: Constants.NAME + ".selectTreeNode",
    OPEN_ASIDE: Constants.NAME + ".openAside",
    // * Goto operations that always finish with focus in outline
    PAGE_UP: Constants.NAME + ".pageUp",
    PAGE_DOWN: Constants.NAME + ".pageDown",
    GOTO_FIRST_VISIBLE: Constants.NAME + ".gotoFirstVisible",
    GOTO_LAST_VISIBLE: Constants.NAME + ".gotoLastVisible",
    GOTO_LAST_SIBLING: Constants.NAME + ".gotoLastSibling",
    GOTO_NEXT_VISIBLE: Constants.NAME + ".gotoNextVisible",
    GOTO_PREV_VISIBLE: Constants.NAME + ".gotoPrevVisible",
    GOTO_NEXT_MARKED: Constants.NAME + ".gotoNextMarked",
    GOTO_NEXT_CLONE: Constants.NAME + ".gotoNextClone",
    GOTO_NEXT_CLONE_SELECTION: Constants.NAME + ".gotoNextCloneSelection",
    GOTO_NEXT_CLONE_SELECTION_FO: Constants.NAME + ".gotoNextCloneSelectionFromOutline",
    CONTRACT_OR_GO_LEFT: Constants.NAME + ".contractOrGoLeft",
    EXPAND_AND_GO_RIGHT: Constants.NAME + ".expandAndGoRight",
    // * Leo Operations
    UNDO: Constants.NAME + ".undo", // From command Palette
    UNDO_FO: Constants.NAME + ".undoFromOutline", // from button, return focus on OUTLINE
    REDO: Constants.NAME + ".redo", // From command Palette
    REDO_FO: Constants.NAME + ".redoFromOutline", // from button, return focus on OUTLINE
    EXECUTE: Constants.NAME + ".executeScript",
    SHOW_BODY: Constants.NAME + ".showBody",
    SHOW_OUTLINE: Constants.NAME + ".showOutline",
    SHOW_LOG: Constants.NAME + ".showLogPane",
    SORT_CHILDREN: Constants.NAME + ".sortChildrenSelection", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
    SORT_SIBLING: Constants.NAME + ".sortSiblingsSelection",
    SORT_SIBLING_FO: Constants.NAME + ".sortSiblingsSelectionFromOutline",
    CONTRACT_ALL: Constants.NAME + ".contractAll", // From command Palette
    CONTRACT_ALL_FO: Constants.NAME + ".contractAllFromOutline", // from button, return focus on OUTLINE
    // * Commands from tree panel buttons or context: focus on OUTLINE
    MARK: Constants.NAME + ".mark",
    UNMARK: Constants.NAME + ".unmark",
    COPY: Constants.NAME + ".copyNode",
    CUT: Constants.NAME + ".cutNode",
    PASTE: Constants.NAME + ".pasteNode",
    PASTE_CLONE: Constants.NAME + ".pasteNodeAsClone",
    DELETE: Constants.NAME + ".delete",
    HEADLINE: Constants.NAME + ".editHeadline",
    MOVE_DOWN: Constants.NAME + ".moveOutlineDown",
    MOVE_LEFT: Constants.NAME + ".moveOutlineLeft",
    MOVE_RIGHT: Constants.NAME + ".moveOutlineRight",
    MOVE_UP: Constants.NAME + ".moveOutlineUp",
    INSERT: Constants.NAME + ".insertNode",
    CLONE: Constants.NAME + ".cloneNode",
    PROMOTE: Constants.NAME + ".promote",
    DEMOTE: Constants.NAME + ".demote",
    REFRESH_FROM_DISK: Constants.NAME + ".refreshFromDisk",
    // * Commands from keyboard, while focus on BODY (command-palette returns to BODY for now)
    MARK_SELECTION: Constants.NAME + ".markSelection",
    UNMARK_SELECTION: Constants.NAME + ".unmarkSelection",
    COPY_SELECTION: Constants.NAME + ".copyNodeSelection", // Nothing to refresh/focus so no "FO" version
    CUT_SELECTION: Constants.NAME + ".cutNodeSelection",
    PASTE_SELECTION: Constants.NAME + ".pasteNodeAtSelection",
    PASTE_CLONE_SELECTION: Constants.NAME + ".pasteNodeAsCloneAtSelection",
    DELETE_SELECTION: Constants.NAME + ".deleteSelection",
    HEADLINE_SELECTION: Constants.NAME + ".editSelectedHeadline",
    MOVE_DOWN_SELECTION: Constants.NAME + ".moveOutlineDownSelection",
    MOVE_LEFT_SELECTION: Constants.NAME + ".moveOutlineLeftSelection",
    MOVE_RIGHT_SELECTION: Constants.NAME + ".moveOutlineRightSelection",
    MOVE_UP_SELECTION: Constants.NAME + ".moveOutlineUpSelection",
    INSERT_SELECTION: Constants.NAME + ".insertNodeSelection", // Can be interrupted
    INSERT_SELECTION_INTERRUPT: Constants.NAME + ".insertNodeSelectionInterrupt", // Interrupted version
    CLONE_SELECTION: Constants.NAME + ".cloneNodeSelection",
    PROMOTE_SELECTION: Constants.NAME + ".promoteSelection",
    DEMOTE_SELECTION: Constants.NAME + ".demoteSelection",
    REFRESH_FROM_DISK_SELECTION: Constants.NAME + ".refreshFromDiskSelection",
    // * Commands from keyboard, while focus on OUTLINE
    MARK_SELECTION_FO: Constants.NAME + ".markSelectionFromOutline",
    UNMARK_SELECTION_FO: Constants.NAME + ".unmarkSelectionFromOutline",
    // COPY_SELECTION Nothing to refresh/focus for "copy a node" so no "FO" version
    CUT_SELECTION_FO: Constants.NAME + ".cutNodeSelectionFromOutline",
    PASTE_SELECTION_FO: Constants.NAME + ".pasteNodeAtSelectionFromOutline",
    PASTE_CLONE_SELECTION_FO: Constants.NAME + ".pasteNodeAsCloneAtSelectionFromOutline",
    DELETE_SELECTION_FO: Constants.NAME + ".deleteSelectionFromOutline",
    HEADLINE_SELECTION_FO: Constants.NAME + ".editSelectedHeadlineFromOutline",
    MOVE_DOWN_SELECTION_FO: Constants.NAME + ".moveOutlineDownSelectionFromOutline",
    MOVE_LEFT_SELECTION_FO: Constants.NAME + ".moveOutlineLeftSelectionFromOutline",
    MOVE_RIGHT_SELECTION_FO: Constants.NAME + ".moveOutlineRightSelectionFromOutline",
    MOVE_UP_SELECTION_FO: Constants.NAME + ".moveOutlineUpSelectionFromOutline",
    INSERT_SELECTION_FO: Constants.NAME + ".insertNodeSelectionFromOutline",
    CLONE_SELECTION_FO: Constants.NAME + ".cloneNodeSelectionFromOutline",
    PROMOTE_SELECTION_FO: Constants.NAME + ".promoteSelectionFromOutline",
    DEMOTE_SELECTION_FO: Constants.NAME + ".demoteSelectionFromOutline",
    REFRESH_FROM_DISK_SELECTION_FO: Constants.NAME + ".refreshFromDiskSelectionFromOutline",
    HOIST: Constants.NAME + ".hoistNode",
    HOIST_SELECTION: Constants.NAME + ".hoistSelection",
    HOIST_SELECTION_FO: Constants.NAME + ".hoistSelectionFromOutline",
    DEHOIST: Constants.NAME + ".deHoist",
    DEHOIST_FO: Constants.NAME + ".deHoistFromOutline",
    EXTRACT: Constants.NAME + ".extract",
    EXTRACT_NAMES: Constants.NAME + ".extractNames",
    COPY_MARKED: Constants.NAME + ".copyMarked",
    DIFF_MARKED_NODES: Constants.NAME + ".diffMarkedNodes",
    MARK_CHANGED_ITEMS: Constants.NAME + ".markChangedItems",
    MARK_SUBHEADS: Constants.NAME + ".markSubheads",
    UNMARK_ALL: Constants.NAME + ".unmarkAll",
    CLONE_MARKED_NODES: Constants.NAME + ".cloneMarkedNodes",
    DELETE_MARKED_NODES: Constants.NAME + ".deleteMarkedNodes",
    MOVE_MARKED_NODES: Constants.NAME + ".moveMarkedNodes",
    // * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - not implemented yet #24
    CLONE_FIND_ALL: Constants.NAME + ".cloneFindAll",
    CLONE_FIND_ALL_FLATTENED: Constants.NAME + ".cloneFindAllFlattened",
    CLONE_FIND_MARKED: Constants.NAME + ".cloneFindMarked",
    CLONE_FIND_FLATTENED_MARKED: Constants.NAME + ".cloneFindFlattenedMarked",
};

</t>
<t tx="felix.20200718020912.2">/**
 * * Text and numeric constants used throughout leoInteg
 */
export class Constants {

    @others
}
</t>
<t tx="felix.20200718020912.3">public static PUBLISHER: string = "boltex";
public static NAME: string = "leointeg";
public static CONFIG_NAME: string = "leoIntegration";
public static CONFIG_WORKBENCH_ENABLED_PREVIEW: string = "workbench.editor.enablePreview";
public static CONFIG_REFRESH_MATCH: string = "OnNodes"; // substring to distinguish 'on-hover' icon commands

public static TREEVIEW_ID: string = Constants.CONFIG_NAME;
public static TREEVIEW_EXPLORER_ID: string = Constants.CONFIG_NAME + "Explorer";

public static DOCUMENTS_ID: string = "leoDocuments";
public static DOCUMENTS_EXPLORER_ID: string = "leoDocumentsExplorer";

public static BUTTONS_ID: string = "leoButtons";
public static BUTTONS_EXPLORER_ID: string = "leoButtonsExplorer";

public static VERSION_STATE_KEY: string = "leoIntegVersion";

public static FILE_EXTENSION: string = "leo";
public static URI_LEO_SCHEME: string = "leo";
public static URI_FILE_SCHEME: string = "file";
public static URI_SCHEME_HEADER: string = "leo:/";
public static FILE_OPEN_FILTER_MESSAGE: string = "Leo Files";
public static UNTITLED_FILE_NAME: string = "untitled";
public static RECENT_FILES_KEY: string = "leoRecentFiles";
public static LAST_FILES_KEY: string = "leoLastFiles";

public static DEFAULT_PYTHON: string = "python3.7";
public static WIN32_PYTHON: string = "py";
public static SERVER_PATH: string = "/leobridgeserver.py";
public static SERVER_STARTED_TOKEN: string = "LeoBridge started";
public static TCPIP_DEFAULT_PROTOCOL: string = "ws://";

public static ERROR_PACKAGE_ID: number = 0;
public static STARTING_PACKAGE_ID: number = 1;
public static STATUSBAR_DEBOUNCE_DELAY: number = 60;
public static DOCUMENTS_DEBOUNCE_DELAY: number = 80;
public static STATES_DEBOUNCE_DELAY: number = 100;

</t>
<t tx="felix.20200718020912.5">/**
 * * Strings used in the workbench interface panels (not for messages or dialogs)
 */
public static GUI = {
    ICON_LIGHT_DOCUMENT: "resources/light/document.svg",
    ICON_DARK_DOCUMENT: "resources/dark/document.svg",
    ICON_LIGHT_DOCUMENT_DIRTY: "resources/light/document-dirty.svg",
    ICON_DARK_DOCUMENT_DIRTY: "resources/dark/document-dirty.svg",
    ICON_LIGHT_BUTTON: "resources/light/button.svg",
    ICON_DARK_BUTTON: "resources/dark/button.svg",
    ICON_LIGHT_BUTTON_ADD: "resources/light/button-add.svg",
    ICON_DARK_BUTTON_ADD: "resources/dark/button-add.svg",
    ICON_LIGHT_PATH: "resources/light/box",
    ICON_DARK_PATH: "resources/dark/box",
    ICON_FILE_EXT: ".svg",
    STATUSBAR_INDICATOR: "$(keyboard) ",
    QUICK_OPEN_LEO_COMMANDS: "&gt;leo: ",
    EXPLORER_TREEVIEW_PREFIX: "LEO ",
    TREEVIEW_TITLE: "OUTLINE",
    TREEVIEW_TITLE_NOT_CONNECTED: "NOT CONNECTED",
    TREEVIEW_TITLE_CONNECTED: "CONNECTED",
    TREEVIEW_TITLE_INTEGRATION: "INTEGRATION",
    BODY_TITLE: "LEO BODY",
    LOG_PANE_TITLE: "Leo Log Window",
    TERMINAL_PANE_TITLE: "LeoBridge Server",
    THEME_STATUSBAR: "statusBar.foreground"
};

</t>
<t tx="felix.20200718020912.6">/**
 * * Basic user messages strings for messages and dialogs
 */
public static USER_MESSAGES = {
    SCRIPT_BUTTON: "Creates a button from selected node's script",
    SCRIPT_BUTTON_TOOLTIP:
        "The 'Script Button' button creates a new button.\n" +
        "Its name will be the headline of the presently selected node\n" +
        "Hitting this newly created button executes the button's script.\n" +
        "\n" +
        "For example, to run a script on any part of an outline:\n" +
        "\n" +
        "1.  Select the node containing a script. (Ex.: \"g.es(p.h)\")\n" +
        "2.  Press 'Script Button'. This will create a new button.\n" +
        "3.  Select a node on which you want to run the script.\n" +
        "4.  Press the *new* button.",
    SAVE_CHANGES: "Save changes to",
    BEFORE_CLOSING: "before closing?",
    CANCEL: "Cancel",
    OPEN_WITH_LEOINTEG: "Open this Leo file with LeoInteg?",
    OPEN_RECENT_FILE: "Open Recent Leo File",
    RIGHT_CLICK_TO_OPEN: "Right-click Leo files to open with LeoInteg",
    FILE_ALREADY_OPENED: "Leo file already opened",
    CHOOSE_OPENED_FILE: "Select an opened Leo File",
    FILE_NOT_OPENED: "No files opened.",
    STATUSBAR_TOOLTIP_ON: "Leo Key Bindings are in effect", // TODO : Add description of what happens if clicked
    STATUSBAR_TOOLTIP_OFF: "Leo Key Bindings off", // TODO : Add description of what happens if clicked
    PROMPT_EDIT_HEADLINE: "Edit Headline",
    PROMPT_INSERT_NODE: "Insert Node",
    DEFAULT_HEADLINE: "New Headline",
    START_SERVER_ERROR: "Error - Cannot start server: ",
    CONNECT_FAILED: "Leo Bridge Connection Failed",
    CONNECT_ERROR: "Leo Bridge Connection Error: Incorrect id",
    CONNECTED: "Connected",
    ALREADY_CONNECTED: "Already connected",
    DISCONNECTED: "Disconnected",
    CLOSE_ERROR: "Cannot close: No files opened.",
    YES: "Yes",
    NO: "No",
    YES_ALL: "Yes to all",
    NO_ALL: "No to all",
    MINIBUFFER_PROMPT: "Minibuffer Full Command",
    CHANGES_DETECTED: "Changes to external files were detected.",
    REFRESHED: " Nodes refreshed.", // with voluntary leading space
    IGNORED: " They were ignored.", // with voluntary leading space
    TOO_FAST: "leoInteg is busy! " // with voluntary trailing space
};

</t>
<t tx="felix.20200718020912.7">/**
 * * Choices offered when about to lose current changes to a Leo Document
 */
public static ASK_SAVE_CHANGES_BUTTONS: vscode.MessageItem[] = [
    {
        title: Constants.USER_MESSAGES.YES,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.NO,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.CANCEL,
        isCloseAffordance: true
    }
];

</t>
<t tx="felix.20200718020912.8">/**
 * * String for JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public static CONFIG_NAMES = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "checkForChangeExternalFiles",
    DEFAULT_RELOAD_IGNORE: "defaultReloadIgnore",
    LEO_TREE_BROWSE: "leoTreeBrowse",
    TREE_KEEP_FOCUS: "treeKeepFocus",
    TREE_KEEP_FOCUS_WHEN_ASIDE: "treeKeepFocusWhenAside",
    STATUSBAR_STRING: "statusBarString",
    STATUSBAR_COLOR: "statusBarColor",
    TREE_IN_EXPLORER: "treeInExplorer",
    SHOW_OPEN_ASIDE: "showOpenAside",
    SHOW_EDIT: "showEditOnNodes",
    SHOW_ARROWS: "showArrowsOnNodes",
    SHOW_ADD: "showAddOnNodes",
    SHOW_MARK: "showMarkOnNodes",
    SHOW_CLONE: "showCloneOnNodes",
    SHOW_COPY: "showCopyOnNodes",
    INVERT_NODES: "invertNodeContrast",
    LEO_PYTHON_COMMAND: "leoPythonCommand",
    AUTO_START_SERVER: "startServerAutomatically",
    AUTO_CONNECT: "connectToServerAutomatically",
    IP_ADDRESS: "connectionAddress",
    IP_PORT: "connectionPort",
};

</t>
<t tx="felix.20200718020912.9">/**
 * * Used in 'when' clauses, set with vscode.commands.executeCommand("setContext",...)
 */
public static CONTEXT_FLAGS = {
    // Main flags for connection and opened file
    BRIDGE_READY: "leoBridgeReady", // Connected to leoBridge
    TREE_OPENED: "leoTreeOpened", // At least one Leo file opened
    TREE_TITLED: "leoTreeTitled", // Tree is a Leo file and not a new untitled document
    SERVER_STARTED: "leoServerStarted", // Auto-start or manually started
    // 'states' flags for currently opened tree view
    LEO_CHANGED: "leoChanged",
    LEO_CAN_UNDO: "leoCanUndo",
    LEO_CAN_REDO: "leoCanRedo",
    LEO_CAN_DEMOTE: "leoCanDemote",
    LEO_CAN_PROMOTE: "leoCanPromote",
    LEO_CAN_DEHOIST: "leoCanDehoist",
    // 'states' flags about current selection, for visibility and commands availability
    SELECTED_MARKED: "leoMarked", // no need for unmarked here, use !leoMarked
    SELECTED_CLONE: "leoCloned",
    SELECTED_DIRTY: "leoDirty",
    SELECTED_EMPTY: "leoEmpty",
    SELECTED_CHILD: "leoChild", // Has children
    SELECTED_ATFILE: "LeoAtFile", // Can be refreshed
    SELECTED_ROOT: "leoRoot", // ! Not given by Leo: Computed by leoInteg/vscode instead
    // Statusbar Flag 'keybindings in effect'
    LEO_SELECTED: "leoObjectSelected", // keybindings "On": Outline or body has focus
    // Context Flags for 'when' clauses, used concatenated, for each outline node
    NODE_MARKED: "leoNodeMarked",  // Selected node is marked
    NODE_UNMARKED: "leoNodeUnmarked", // Selected node is unmarked (Needed for regexp)
    NODE_ATFILE: "leoNodeAtFile", // Selected node is an @file or @clean, etc...
    NODE_CLONED: "leoNodeCloned",
    NODE_ROOT: "leoNodeRoot",
    NODE_NOT_ROOT: "leoNodeNotRoot",
    // Flags for Leo documents tree view icons and hover node command buttons
    DOCUMENT_SELECTED_TITLED: "leoDocumentSelectedTitled",
    DOCUMENT_TITLED: "leoDocumentTitled",
    DOCUMENT_SELECTED_UNTITLED: "leoDocumentSelectedUntitled",
    DOCUMENT_UNTITLED: "leoDocumentUntitled",
    // Flags that match specific LeoInteg config settings
    LEO_TREE_BROWSE: Constants.CONFIG_NAMES.LEO_TREE_BROWSE, // Force ar'jan's suggestion of Leo's tree behavior override
    TREE_IN_EXPLORER: Constants.CONFIG_NAMES.TREE_IN_EXPLORER, // Leo outline also in the explorer view
    SHOW_OPEN_ASIDE: Constants.CONFIG_NAMES.SHOW_OPEN_ASIDE,   // Show 'open aside' in context menu
    SHOW_EDIT: Constants.CONFIG_NAMES.SHOW_EDIT,              // Hover Icons on outline nodes
    SHOW_ARROWS: Constants.CONFIG_NAMES.SHOW_ARROWS,           // Hover Icons on outline nodes
    SHOW_ADD: Constants.CONFIG_NAMES.SHOW_ADD,                 // Hover Icons on outline nodes
    SHOW_MARK: Constants.CONFIG_NAMES.SHOW_MARK,               // Hover Icons on outline nodes
    SHOW_CLONE: Constants.CONFIG_NAMES.SHOW_CLONE,             // Hover Icons on outline nodes
    SHOW_COPY: Constants.CONFIG_NAMES.SHOW_COPY,               // Hover Icons on outline nodes
    AUTO_START_SERVER: Constants.CONFIG_NAMES.AUTO_START_SERVER,   // Used at startup
    AUTO_CONNECT: Constants.CONFIG_NAMES.AUTO_CONNECT              // Used at startup
};

</t>
<t tx="felix.20200718024635.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { UserCommand, LeoBridgePackage, ReqRefresh } from "./types";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718024635.2">/**
 * * Front-facing, user command stack of actions
 * This implements a user-facing command stack, (push on top, remove bottom)
 * Commands can also be added while this stack has started resolving.
 * This 'stack' concept is similar to the 'LeoBridge' class used for interacting with Leo.
 */
export class CommandStack {

    private _stack: UserCommand[] = []; // Actual commands array
    private _busy: boolean = false; // Flag stating commands started resolving

    // Refresh type, for use after the last command has done resolving (From highest so far)
    private _finalRefreshType: ReqRefresh = {}; // new empty ReqRefresh

    // Flag used to set focus on outline instead of body when done resolving (From last pushed)
    private _finalFromOutline: boolean = false;

    // Received selection from the last command that finished as JSON string representation
    // It will be re-sent as 'target node' instead of lastSelectedNode if present
    private _selectedNode: string = ""; // Empty string is used as 'falsy'

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20200718024635.3">/**
 * * Returns the command stack size
 * @returns number of actions on the command stack
 */
public size(): number {
    return this._stack.length;
}

</t>
<t tx="felix.20200718024635.4">/**
 * * Signal to the command stack that a new selected node was received.
 * Command stack needs to know when to clear its own '_receivedSelection'
 */
public newSelection(): void {
    if (!this._busy) {
        this._selectedNode = "";
    }
}

</t>
<t tx="felix.20200718024635.5">/**
 * * Adds on top and try to execute the bottom command if not already running
 * Targeted command (targeting a specific node) can only be added on an empty stack
 * @param p_command Object that has the action, targeted node (if any), refresh type and 'fromOutline' flag
 * @returns true if added, false if it could not (due to front end stack 'rules')
 */
public add(p_command: UserCommand): Promise&lt;LeoBridgePackage&gt; | undefined {
    if (p_command.node &amp;&amp; this.size()) {
        return undefined; // Can only add a command which targets a node if the stack is empty
    } else {
        const q_promise = new Promise&lt;LeoBridgePackage&gt;((p_resolve, p_reject) =&gt; {
            p_command.resolveFn = p_resolve;
            p_command.rejectFn = p_reject;
        });
        this._stack.push(p_command);
        this._finalFromOutline = p_command.fromOutline; // Set final "focus-placement"
        this._tryStart();
        return q_promise;
    }
}

</t>
<t tx="felix.20200718024635.6">/**
 * * Try to launch commands that were added on the stack, if any.
 */
private _tryStart(): void {
    if (this.size() &amp;&amp; !this._busy) {
        // Ok to start, so set the busy flag and start from the bottom
        this._busy = true; // Cleared when the last command has returned (and the stack is empty)
        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}

</t>
<t tx="felix.20200718024635.7">/**
 * * Run the command at index 0: The bottom of the stack.
 */
private _runStackCommand(): Promise&lt;LeoBridgePackage&gt; {
    // Reference from bottom of stack, but don't remove it yet!
    const w_command: UserCommand = this._stack[0];

    let w_nodeJson: string = ""; // ap json used in building w_jsonParam
    let w_jsonParam: string = ""; // Finished parameter that is sent

    // First command uses given node or last selected node.
    // Other subsequent commands on stack will use _receivedSelection regardless.
    // (Commands such as 'collapse all' just ignore node parameter)
    if (w_command.node) {
        // Was node specific, so starting a new stack of commands
        w_nodeJson = w_command.node.apJson;
    } else {
        // Use received "selected node" unless first use, then use last selected node
        if (this._selectedNode) {
            w_nodeJson = this._selectedNode;
        } else {
            w_nodeJson = this._leoIntegration.lastSelectedNode!.apJson;
        }
        if (!w_nodeJson) {
            console.log('ERROR NO ARCHIVED POSITION JSON');
        }
    }
    w_jsonParam = utils.buildNodeAndTextJson(w_nodeJson, w_command); // 'Insert Named Node' or 'Edit Headline'

    // Setup _finalRefreshType, if command requires higher than the one setup so far
    Object.assign(this._finalRefreshType, w_command.refreshType); // add all properties (expecting only 'true' properties)

    // Submit this action to Leo and return a promise of its packaged answer
    return this._leoIntegration.sendAction(w_command.action, w_jsonParam)
        .then((p_package) =&gt; {
            if (w_command.resolveFn) {
                w_command.resolveFn(p_package);
            }
            return p_package;
        },
            (p_reason) =&gt; {
                if (w_command.rejectFn) {
                    w_command.rejectFn(p_reason);
                }
                return p_reason;
            }
        );
}

</t>
<t tx="felix.20200718024635.8">/**
 * * Handle the result from the command that has finished: either launch the next one, or refresh accordingly.
 * @param p_package is the json return 'package' that was just received back from Leo
 */
private _resolveResult(p_package: LeoBridgePackage): void {
    this._stack.shift(); // Finally remove resolved command from stack bottom

    this._selectedNode = JSON.stringify(p_package.node);

    if (!this.size()) {
        // If last is done then do refresh outline and focus on outline, or body, as required
        this._busy = false;
        if (Object.keys(this._finalRefreshType).length) {
            // At least some type of refresh
            this._leoIntegration.launchRefresh(this._finalRefreshType, this._finalFromOutline, p_package.node);
        }
        // Reset refresh type and focus flag nonetheless
        this._finalRefreshType = {};
        this._finalFromOutline = false;
    } else {
        // Size &gt; 0, so call _runStackCommand again, keep _busy set to true
        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}

</t>
<t tx="felix.20200718030926.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { ConfigMembers, ConfigSetting } from "./types";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718030926.2">/**
 * * Configuration Settings Service
 */
export class Config implements ConfigMembers {

    // Config settings used in leobridgeserver.py, on Leo's side
    public checkForChangeExternalFiles: string = Constants.CONFIG_DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES;
    public defaultReloadIgnore: string = Constants.CONFIG_DEFAULTS.DEFAULT_RELOAD_IGNORE;
    // Config settings used in leoInteg/vscode's side
    public leoTreeBrowse: boolean = Constants.CONFIG_DEFAULTS.LEO_TREE_BROWSE;
    public treeKeepFocus: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS;
    public treeKeepFocusWhenAside: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE;
    public statusBarString: string = Constants.CONFIG_DEFAULTS.STATUSBAR_STRING;
    public statusBarColor: string = Constants.CONFIG_DEFAULTS.STATUSBAR_COLOR;
    public treeInExplorer: boolean = Constants.CONFIG_DEFAULTS.TREE_IN_EXPLORER;
    public showOpenAside: boolean = Constants.CONFIG_DEFAULTS.SHOW_OPEN_ASIDE;
    public showEditOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_EDIT;
    public showArrowsOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_ARROWS;
    public showAddOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_ADD;
    public showMarkOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_MARK;
    public showCloneOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_CLONE;
    public showCopyOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_COPY;
    public invertNodeContrast: boolean = Constants.CONFIG_DEFAULTS.INVERT_NODES;
    public leoPythonCommand: string = Constants.CONFIG_DEFAULTS.LEO_PYTHON_COMMAND;
    public startServerAutomatically: boolean = Constants.CONFIG_DEFAULTS.AUTO_START_SERVER;
    public connectToServerAutomatically: boolean = Constants.CONFIG_DEFAULTS.AUTO_CONNECT;
    public connectionAddress: string = Constants.CONFIG_DEFAULTS.IP_ADDRESS;
    public connectionPort: number = Constants.CONFIG_DEFAULTS.IP_PORT;

    private _isBusySettingConfig: boolean = false;
    private _needsTreeRefresh: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20200718030926.3">/**
 * * Get actual 'live' Leointeg configuration
 * @returns An object with config settings members such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public getConfig(): ConfigMembers {
    return {
        checkForChangeExternalFiles: this.checkForChangeExternalFiles,  // Used in leoBridge script
        defaultReloadIgnore: this.defaultReloadIgnore,  // Used in leoBridge script
        leoTreeBrowse: this.leoTreeBrowse,
        treeKeepFocus: this.treeKeepFocus,
        treeKeepFocusWhenAside: this.treeKeepFocusWhenAside,
        statusBarString: this.statusBarString,
        statusBarColor: this.statusBarColor,
        treeInExplorer: this.treeInExplorer,
        showOpenAside: this.showOpenAside,
        showEditOnNodes: this.showEditOnNodes,
        showArrowsOnNodes: this.showArrowsOnNodes,
        showAddOnNodes: this.showAddOnNodes,
        showMarkOnNodes: this.showMarkOnNodes,
        showCloneOnNodes: this.showCloneOnNodes,
        showCopyOnNodes: this.showCopyOnNodes,
        invertNodeContrast: this.invertNodeContrast,
        leoPythonCommand: this.leoPythonCommand,
        startServerAutomatically: this.startServerAutomatically,
        connectToServerAutomatically: this.connectToServerAutomatically,
        connectionAddress: this.connectionAddress,
        connectionPort: this.connectionPort,
    };
}

</t>
<t tx="felix.20200718030926.4">/**
 * * Apply changes to the expansion config settings and save them in ser settings.
 * @param p_changes is an array of codes and values to be changed
 * @returns a promise that resolves upon completion
 */
public setLeoIntegSettings(p_changes: ConfigSetting[]): Promise&lt;void&gt; {
    this._isBusySettingConfig = true;
    const w_promises: Thenable&lt;void&gt;[] = [];
    const w_vscodeConfig = vscode.workspace.getConfiguration(Constants.CONFIG_NAME);
    p_changes.forEach(i_change =&gt; {
        if (i_change &amp;&amp; i_change.code.includes(Constants.CONFIG_REFRESH_MATCH)) {
            // Check if tree refresh is required for hover-icons to be displayed or hidden accordingly
            this._needsTreeRefresh = true;
        }
        if (w_vscodeConfig.inspect(i_change.code)!.defaultValue === i_change.value) {
            // Set as undefined - same as default
            w_promises.push(w_vscodeConfig.update(i_change.code, undefined, true));
        } else {
            // Set as value which is not default
            w_promises.push(w_vscodeConfig.update(i_change.code, i_change.value, true));
        }
    });
    return Promise.all(w_promises).then(() =&gt; {
        if (this._needsTreeRefresh) {
            this._needsTreeRefresh = false;
            setTimeout(() =&gt; {
                this._leoIntegration.configTreeRefresh();
            }, 200);
        }
        this._isBusySettingConfig = false;
        this.buildFromSavedSettings();
        return Promise.resolve();
    });
}

</t>
<t tx="felix.20200718030926.5">/**
 * * Build config from settings from vscode's saved config settings
 */
public buildFromSavedSettings(): void {
    // Shorthand pointers for readability
    const GET = vscode.workspace.getConfiguration;
    const NAME = Constants.CONFIG_NAME;
    const NAMES = Constants.CONFIG_NAMES;
    const DEFAULTS = Constants.CONFIG_DEFAULTS;
    const FLAGS = Constants.CONTEXT_FLAGS;

    if (this._isBusySettingConfig) {
        // * Currently setting config, wait until its done all, and this will be called automatically
        return;
    } else {
        this.checkForChangeExternalFiles = GET(NAME).get(NAMES.CHECK_FOR_CHANGE_EXTERNAL_FILES, DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES);
        this.defaultReloadIgnore = GET(NAME).get(NAMES.DEFAULT_RELOAD_IGNORE, DEFAULTS.DEFAULT_RELOAD_IGNORE);
        this.leoTreeBrowse = GET(NAME).get(NAMES.LEO_TREE_BROWSE, DEFAULTS.LEO_TREE_BROWSE);
        this.treeKeepFocus = GET(NAME).get(NAMES.TREE_KEEP_FOCUS, DEFAULTS.TREE_KEEP_FOCUS);
        this.treeKeepFocusWhenAside = GET(NAME).get(NAMES.TREE_KEEP_FOCUS_WHEN_ASIDE, DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE);
        this.statusBarString = GET(NAME).get(NAMES.STATUSBAR_STRING, DEFAULTS.STATUSBAR_STRING);
        if (this.statusBarString.length &gt; 8) {
            this.statusBarString = DEFAULTS.STATUSBAR_STRING;
        }
        this.statusBarColor = GET(NAME).get(NAMES.STATUSBAR_COLOR, DEFAULTS.STATUSBAR_COLOR);
        if (!utils.isHexColor(this.statusBarColor)) {
            this.statusBarColor = DEFAULTS.STATUSBAR_COLOR;
        }
        this.treeInExplorer = GET(NAME).get(NAMES.TREE_IN_EXPLORER, DEFAULTS.TREE_IN_EXPLORER);
        this.showOpenAside = GET(NAME).get(NAMES.SHOW_OPEN_ASIDE, DEFAULTS.SHOW_OPEN_ASIDE);
        this.showEditOnNodes = GET(NAME).get(NAMES.SHOW_EDIT, DEFAULTS.SHOW_EDIT);
        this.showArrowsOnNodes = GET(NAME).get(NAMES.SHOW_ARROWS, DEFAULTS.SHOW_ARROWS);
        this.showAddOnNodes = GET(NAME).get(NAMES.SHOW_ADD, DEFAULTS.SHOW_ADD);
        this.showMarkOnNodes = GET(NAME).get(NAMES.SHOW_MARK, DEFAULTS.SHOW_MARK);
        this.showCloneOnNodes = GET(NAME).get(NAMES.SHOW_CLONE, DEFAULTS.SHOW_CLONE);
        this.showCopyOnNodes = GET(NAME).get(NAMES.SHOW_COPY, DEFAULTS.SHOW_COPY);
        this.invertNodeContrast = GET(NAME).get(NAMES.INVERT_NODES, DEFAULTS.INVERT_NODES);
        this.leoPythonCommand = GET(NAME).get(NAMES.LEO_PYTHON_COMMAND, DEFAULTS.LEO_PYTHON_COMMAND);
        this.startServerAutomatically = GET(NAME).get(NAMES.AUTO_START_SERVER, DEFAULTS.AUTO_START_SERVER);
        this.connectToServerAutomatically = GET(NAME).get(NAMES.AUTO_CONNECT, DEFAULTS.AUTO_CONNECT);
        this.connectionAddress = GET(NAME).get(NAMES.IP_ADDRESS, DEFAULTS.IP_ADDRESS);
        this.connectionPort = GET(NAME).get(NAMES.IP_PORT, DEFAULTS.IP_PORT);

        // * Set context for tree items visibility that are based on config options
        if (this._leoIntegration.leoStates.leoBridgeReady) {
            this._leoIntegration.sendConfigToServer(this.getConfig());
        }
        utils.setContext(FLAGS.LEO_TREE_BROWSE, this.leoTreeBrowse);
        utils.setContext(FLAGS.TREE_IN_EXPLORER, this.treeInExplorer);
        utils.setContext(FLAGS.SHOW_OPEN_ASIDE, this.showOpenAside);
        utils.setContext(FLAGS.SHOW_EDIT, this.showEditOnNodes);
        utils.setContext(FLAGS.SHOW_ARROWS, this.showArrowsOnNodes);
        utils.setContext(FLAGS.SHOW_ADD, this.showAddOnNodes);
        utils.setContext(FLAGS.SHOW_MARK, this.showMarkOnNodes);
        utils.setContext(FLAGS.SHOW_CLONE, this.showCloneOnNodes);
        utils.setContext(FLAGS.SHOW_COPY, this.showCopyOnNodes);
        utils.setContext(FLAGS.AUTO_START_SERVER, this.startServerAutomatically); // server started
        utils.setContext(FLAGS.AUTO_CONNECT, this.connectToServerAutomatically); // server started
    }
}

</t>
<t tx="felix.20200718031424.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { ReqRefresh } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { LeoSettingsWebview } from "./webviews/leoSettingsWebview";
import { LeoButtonNode } from "./leoButtonNode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718031424.2">/**
 * * Called by vscode when extension is activated
 * It creates the leoIntegration instance
 * Will also open the 'welcome/Settings' webview instance if a new version is opened
 */
export function activate(p_context: vscode.ExtensionContext) {

    // * Reset Extension context flags (used in 'when' clauses in package.json)
    utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, false); // Connected to a leobridge server?
    utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, false); // Having a Leo file opened on that server?

    const w_leoIntegExtension = vscode.extensions.getExtension(Constants.PUBLISHER + '.' + Constants.NAME)!;
    const w_leoIntegVersion = w_leoIntegExtension.packageJSON.version;
    const w_leo: LeoIntegration = new LeoIntegration(p_context);
    const w_leoSettingsWebview: LeoSettingsWebview = new LeoSettingsWebview(p_context, w_leo);
    const w_previousVersion = p_context.globalState.get&lt;string&gt;(Constants.VERSION_STATE_KEY);
    const w_start = process.hrtime(); // For calculating total startup time duration

    // Shortcut pointers for readability
    const U = undefined;
    const BRIDGE = Constants.LEOBRIDGE;
    const CMD = Constants.COMMANDS;
    const NO_REFRESH: ReqRefresh = {};
    const REFRESH_NODE_BODY: ReqRefresh = {
        node: true, // Reveal the returned 'selected position' without changes to the tree
        body: true, // Goto/select another node needs the body pane refreshed
        states: true
    };
    const REFRESH_TREE: ReqRefresh = {
        tree: true,
        states: true
    };
    const REFRESH_TREE_BODY: ReqRefresh = {
        tree: true,
        body: true,
        states: true
    };
    const showInfo = vscode.window.showInformationMessage;

    const w_commands: [string, (...args: any[]) =&gt; any][] = [

        // ! REMOVE TESTS ENTRIES FROM PACKAGE.JSON FOR MASTER BRANCH RELEASES !
        ["leointeg.test", () =&gt; w_leo.test()], // Test function useful when debugging
        ["leointeg.testFromOutline", () =&gt; w_leo.test(true)], // Test function useful when debugging.

        &lt;&lt; Define entries for all commands &gt;&gt;
    ];

    w_commands.map(function (p_command) {
        p_context.subscriptions.push(vscode.commands.registerCommand(...p_command));
    });

    showWelcomeIfNewer(w_leoIntegVersion, w_previousVersion).then(() =&gt; {
        // Start server and/or connect to it, as per user settings
        w_leo.startNetworkServices();
        // Save version # for next startup comparison
        p_context.globalState.update(Constants.VERSION_STATE_KEY, w_leoIntegVersion);
        console.log('leoInteg startup launched in ', utils.getDurationMs(w_start), 'ms');
    });
}

</t>
<t tx="felix.20200718031424.24">/**
 * * Called when extension is deactivated
 */
export function deactivate() {
    console.log('deactivate called for extension "leointeg"');
}

</t>
<t tx="felix.20200718031424.25">/**
 * * Show welcome screen if needed, based on last version executed
 * @param p_version Current version, as a string, from packageJSON.version
 * @param p_previousVersion Previous version, as a string, from context.globalState.get service
 * @returns A promise that triggers when command to show the welcome screen is finished, or immediately if not needed
 */
async function showWelcomeIfNewer(p_version: string, p_previousVersion: string | undefined): Promise&lt;unknown&gt; {
    let w_showWelcomeScreen: boolean = false;
    if (p_previousVersion === undefined) {
        console.log('leoInteg first-time install');
        w_showWelcomeScreen = true;
    } else {
        if (p_previousVersion !== p_version) {
            console.log(`leoInteg upgraded from v${p_previousVersion} to v${p_version}`);
        }
        const [w_major, w_minor] = p_version.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        const [w_prevMajor, w_prevMinor] = p_previousVersion.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        if (
            (w_major === w_prevMajor &amp;&amp; w_minor === w_prevMinor) ||
            // Don't notify on downgrades
            (w_major &lt; w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &lt; w_prevMinor))
        ) {
            w_showWelcomeScreen = false;
        } else if (w_major !== w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &gt; w_prevMinor)) {
            // Will show on major or minor upgrade (Formatted as 'Major.Minor.Revision' eg. 1.2.3)
            w_showWelcomeScreen = true;
        }
    }
    if (w_showWelcomeScreen) {
        return vscode.commands.executeCommand(Constants.COMMANDS.SHOW_WELCOME);
    } else {
        return Promise.resolve();
    }
}
</t>
<t tx="felix.20200718035737.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import {
    AskMessageItem,
    runAskYesNoDialogParameters,
    runWarnMessageDialogParameters,
    runInfoMessageDialogParameters,
    showSaveAsDialogParameters
} from "./types";
import { LeoIntegration } from "./leoIntegration";

@others
</t>
<t tx="felix.20200718040540.1">import * as vscode from "vscode";
import * as utils from "./utils";
import * as path from 'path';
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { BodyTimeInfo } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718040540.10">public stat(p_uri: vscode.Uri): vscode.FileStat | Thenable&lt;vscode.FileStat&gt; {
    // TODO : Fix/Check extraneous stat(...) call(s)

    if (this._leoIntegration.leoStates.fileOpenedReady) {
        const w_gnx = utils.leoUriToStr(p_uri);
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            // console.log('called stat on root');
            return { type: vscode.FileType.Directory, ctime: 0, mtime: 0, size: 0 };

        } else if (w_gnx === this._lastGnx &amp;&amp; this._openedBodiesGnx.includes(this._lastGnx)) {

            // If same as last checked, sending back time at absolute past
            // ? VERIFY this._selectedBody.mtime we get file changed on disk error??
            // console.log('VERIFY this._selectedBody.mtime we get file changed on disk error :', p_uri);
            return {
                type: vscode.FileType.File,
                ctime: this._openedBodiesInfo[this._lastGnx].ctime,
                mtime: this._openedBodiesInfo[this._lastGnx].mtime,
                size: this._lastBodyLength
            };

        } else if (this._openedBodiesGnx.includes(w_gnx)) {

            return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BODY_LENGTH, '"' + w_gnx + '"')
                .then((p_result) =&gt; {
                    return Promise.resolve(
                        {
                            type: vscode.FileType.File,
                            ctime: this._openedBodiesInfo[w_gnx].ctime,
                            mtime: this._openedBodiesInfo[w_gnx].mtime,
                            size: p_result.bodyLength ? p_result.bodyLength : 0
                        }
                    );
                });
        }
    }
    throw vscode.FileSystemError.FileNotFound();
}

</t>
<t tx="felix.20200718040540.11">public readFile(p_uri: vscode.Uri): Thenable&lt;Uint8Array&gt; {
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            throw vscode.FileSystemError.FileIsADirectory();
        } else {
            const w_gnx = utils.leoUriToStr(p_uri);
            // if (!this._possibleGnxList.includes(w_gnx)) {
            if (!this._openedBodiesGnx.includes(w_gnx)) {
                console.error("readFile: ERROR File not in _openedBodiesGnx! readFile missing refreshes?");
                throw vscode.FileSystemError.FileNotFound();
            } else {
                return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BODY, '"' + w_gnx + '"')
                    .then((p_result) =&gt; {
                        if (p_result.bodyData) {
                            this._lastGnx = w_gnx;
                            this._lastBodyData = p_result.bodyData;
                            const w_buffer: Uint8Array = Buffer.from(p_result.bodyData);
                            this._lastBodyLength = w_buffer.byteLength;
                            return Promise.resolve(w_buffer);
                        } else if (p_result.bodyData === "") {
                            this._lastGnx = w_gnx;
                            this._lastBodyLength = 0;
                            this._lastBodyData = "";
                            return Promise.resolve(Buffer.from(""));
                        } else {
                            if (this._lastGnx === w_gnx) {
                                // was last gnx of closed file about to be switched to new document selected
                                console.log('Passed in not found: ' + w_gnx);

                                return Promise.resolve(Buffer.from(this._lastBodyData));
                            }
                            console.error("ERROR =&gt; readFile of unknown GNX"); // is possibleGnxList updated correctly?
                            return Promise.resolve(Buffer.from(""));
                            //  throw vscode.FileSystemError.FileNotFound();
                        }
                    });
            }
        }
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20200718040540.12">public readDirectory(p_uri: vscode.Uri): Thenable&lt;[string, vscode.FileType][]&gt; {
    console.warn('Called readDirectory with ', p_uri.fsPath); // should not happen
    if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
        const w_directory: [string, vscode.FileType][] = [];
        w_directory.push([this._selectedBody, vscode.FileType.File]);
        return Promise.resolve(w_directory);
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20200718040540.13">public createDirectory(p_uri: vscode.Uri): void {
    console.warn('Called createDirectory with ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20200718040540.14">public writeFile(p_uri: vscode.Uri, p_content: Uint8Array, p_options: { create: boolean, overwrite: boolean }): void {
    // console.log('trigger called in writeFile');

    this._leoIntegration.triggerBodySave(true); // Might have been a vscode 'save' via the menu
    const w_gnx = utils.leoUriToStr(p_uri);

    if (!this._openedBodiesGnx.includes(w_gnx)) {
        console.error("ASKED TO REFRESH NOT EVEN IN SELECTED BODY: ", w_gnx);
        this._openedBodiesGnx.push(w_gnx);
    }
    const w_now = new Date().getTime();
    this._openedBodiesInfo[w_gnx] = {
        ctime: w_now,
        mtime: w_now
    };

    this._fireSoon({ type: vscode.FileChangeType.Changed, uri: p_uri });
}

</t>
<t tx="felix.20200718040540.15">public rename(p_oldUri: vscode.Uri, p_newUri: vscode.Uri, p_options: { overwrite: boolean }): void {
    console.warn('Called rename on ', p_oldUri.fsPath, p_newUri.fsPath); // should not happen
    this._fireSoon(
        { type: vscode.FileChangeType.Deleted, uri: p_oldUri },
        { type: vscode.FileChangeType.Created, uri: p_newUri }
    );
}

</t>
<t tx="felix.20200718040540.16">public delete(p_uri: vscode.Uri): void {
    // console.log("delete", p_uri.fsPath);
    const w_gnx = utils.leoUriToStr(p_uri);
    if (this._openedBodiesGnx.includes(w_gnx)) {
        this._openedBodiesGnx.splice(this._openedBodiesGnx.indexOf(w_gnx), 1);
        delete this._openedBodiesInfo[w_gnx];
    }

    // dirname is just a slash "/"
    let w_dirname = p_uri.with({ path: path.posix.dirname(p_uri.path) });

    this._fireSoon(
        { type: vscode.FileChangeType.Changed, uri: w_dirname },
        { uri: p_uri, type: vscode.FileChangeType.Deleted }
    );
}

</t>
<t tx="felix.20200718040540.17">public copy(p_uri: vscode.Uri): void {
    console.warn('Called copy on ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20200718040540.18">private _fireSoon(...p_events: vscode.FileChangeEvent[]): void {
    this._bufferedEvents.push(...p_events);
    if (this._fireSoonHandle) {
        clearTimeout(this._fireSoonHandle);
    }
    this._fireSoonHandle = setTimeout(() =&gt; {
        this._onDidChangeFileEmitter.fire(this._bufferedEvents);
        this._bufferedEvents.length = 0; // clearing events array
    }, 5);
}

</t>
<t tx="felix.20200718040540.2">/**
 * * Body panes implementation as a file system using "leo" as a scheme identifier
 * TODO : Replace save/rename procedure to overcome API change for undos.
 * Saving and renaming prevents flickering and prevents undos to 'traverse through' different gnx
 */
export class LeoBodyProvider implements vscode.FileSystemProvider {

    // * Simple structure to keep mtime of selected and renamed body virtual files
    private _selectedBody: string = "";

    // * Last file read data with the readFile method
    private _lastGnx: string = ""; // gnx of last file read
    private _lastBodyData: string = ""; // body content of last file read
    private _lastBodyLength: number = 0; // length of last file read

    // * List of currently opened body panes gnx (from 'watch' &amp; 'dispose' methods)
    private _watchedBodiesGnx: string[] = [];

    // * List of gnx that should be available (from more.selectNode and fs.delete)
    private _openedBodiesGnx: string[] = [];
    private _openedBodiesInfo: { [key: string]: BodyTimeInfo } = {};

    // * List of all possible vNodes gnx in the currently opened leo file (since last refresh/tree operation)
    private _possibleGnxList: string[] = []; // Maybe deprecated

    // * An event to signal that a resource has been changed
    // * It should fire for resources that are being [watched](#FileSystemProvider.watch) by clients of this provider
    private _onDidChangeFileEmitter = new vscode.EventEmitter&lt;vscode.FileChangeEvent[]&gt;();
    readonly onDidChangeFile: vscode.Event&lt;vscode.FileChangeEvent[]&gt; = this._onDidChangeFileEmitter.event;
    private _bufferedEvents: vscode.FileChangeEvent[] = [];
    private _fireSoonHandle?: NodeJS.Timer;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718040540.3">/**
 * * Sets selected node body's modified time for this gnx virtual file
 * @param p_uri URI of file for which to set made-up modified time
 */
public setBodyTime(p_uri: vscode.Uri): void {

    const w_gnx = utils.leoUriToStr(p_uri);

    // console.log('Selected', w_gnx, ' total:', this._openedBodiesGnx.length);

    if (!this._openedBodiesGnx.includes(w_gnx)) {
        this._openedBodiesGnx.push(w_gnx);
    }
    const w_now = new Date().getTime();
    this._openedBodiesInfo[w_gnx] = {
        ctime: w_now,
        mtime: w_now
    };
}

</t>
<t tx="felix.20200718040540.5">/**
 * * Refresh the body pane for a particular gnx by telling vscode that the file from the Leo file provider has changed
 * @param p_gnx Gnx of body associated with this virtual file, mostly Leo's selected node
 */
public fireRefreshFile(p_gnx: string): void {
    this._selectedBody = p_gnx;
    if (!this._openedBodiesGnx.includes(p_gnx)) {
        console.error("ASKED TO REFRESH NOT EVEN IN SELECTED BODY: ", p_gnx);
        this._openedBodiesGnx.push(p_gnx);
    }
    const w_now = new Date().getTime();
    this._openedBodiesInfo[p_gnx] = {
        ctime: w_now,
        mtime: w_now
    };
    this._onDidChangeFileEmitter.fire([{
        type: vscode.FileChangeType.Changed,
        uri: utils.strToLeoUri(p_gnx)
    } as vscode.FileChangeEvent]);
}

</t>
<t tx="felix.20200718040540.6">/**
 * Maybe deprecated
 * * Refreshes the '_possibleGnxList' list of all unique gnx from Leo
 * @returns a promise that resolves to the fresh gnx string array
 */
public refreshPossibleGnxList(): Thenable&lt;string[]&gt; {
    // * Get updated list of possible gnx
    return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_ALL_GNX).then((p_result) =&gt; {
        if (p_result.allGnx) {
            this._possibleGnxList = p_result.allGnx;
        } else {
            this._possibleGnxList = [];
        }
        return Promise.resolve(this._possibleGnxList);
    });
}

</t>
<t tx="felix.20200718040540.8">public watch(p_resource: vscode.Uri): vscode.Disposable {
    const w_gnx = utils.leoUriToStr(p_resource);

    if (!this._watchedBodiesGnx.includes(w_gnx)) {
        // console.log('MORE fs watch put in _openedBodiesGnx:', p_resource.fsPath);
        this._watchedBodiesGnx.push(w_gnx); // add gnx
    } else {
        // console.warn('MORE fs watch: already in _openedBodiesGnx:', p_resource.fsPath);

    }
    return new vscode.Disposable(() =&gt; {
        const w_position = this._watchedBodiesGnx.indexOf(w_gnx); // find and remove it
        if (w_position &gt; -1) {
            // console.log('MORE fs removed from _openedBodiesGnx: ', w_gnx);
            this._watchedBodiesGnx.splice(w_position, 1);
        }
    });
}

</t>
<t tx="felix.20200718153505.1">import * as vscode from "vscode";
import * as WebSocket from 'ws';
import { Constants } from "./constants";
import { LeoBridgePackage, LeoAction } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoAsync } from "./leoAsync";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718153505.11">/**
 * * Process data that came from the Leo process
 * @param p_data given JSON data
 */
private _processAnswer(p_data: string): void {
    const w_parsedData = this._tryParseJSON(p_data);
    if (w_parsedData &amp;&amp; w_parsedData.id) {
        this._resolveBridgeReady(w_parsedData);
        this._callAction();
    } else if (w_parsedData &amp;&amp; w_parsedData.async) {
        // * Check for async messages such as log pane entries or other
        this._asyncAction(w_parsedData);
    } else {
        // unprocessed/unknown python output
        console.error("[leoBridge] Unprocessed or unknown JSON received: ", p_data);
    }
}

</t>
<t tx="felix.20200718153505.12">/**
 * * Spawn a websocket
 * @returns A promise for a LeoBridgePackage object containing only an 'id' member of 1 that will resolve when the 'leoBridge' is established
 */
public initLeoProcess(): Promise&lt;LeoBridgePackage&gt; {
    this._websocket = new WebSocket(Constants.TCPIP_DEFAULT_PROTOCOL +
        this._leoIntegration.config.connectionAddress +
        ":" + this._leoIntegration.config.connectionPort);
    // * Capture the python process output
    this._websocket.onmessage = (p_event) =&gt; {
        if (p_event.data) {
            this._processAnswer(p_event.data.toString());
        }
    };
    this._websocket.onerror = (p_event: WebSocket.ErrorEvent) =&gt; {
        console.error(`Websocket error: ${p_event.message}`);
    };
    this._websocket.onclose = (p_event: WebSocket.CloseEvent) =&gt; {
        // * Disconnected from server
        console.log(`Websocket closed, code: ${p_event.code}`);
        this._rejectAction(`Websocket closed, code: ${p_event.code}`);
        // TODO : Implement a better connection error handling
        if (this._leoIntegration.leoStates.leoBridgeReady) {
            this._leoIntegration.cancelConnect(`Websocket closed, code: ${p_event.code}`);
        }
    };
    // * Start first with 'preventCall' set to true: no need to call anything for the first 'ready'
    this._readyPromise = this.action("", "", { id: Constants.STARTING_PACKAGE_ID }, true);
    return this._readyPromise; // This promise will resolve when the started python process starts
}

</t>
<t tx="felix.20200718153505.13">/**
 * * Send into the python process input
 * @param p_data JSON Message string to be sent to leobridgeserver.py
 */
private _send(p_data: string): any {
    if (this._readyPromise) {
        this._readyPromise.then(() =&gt; { // using '.then' that was surely resolved already: to be buffered in case process isn't ready.
            if (this._websocket &amp;&amp; this._websocket.OPEN) {
                this._websocket.send(p_data); // p_message should be json
            }
        });
    }
}

</t>
<t tx="felix.20200718153505.2">/**
 * * Handles communication with the leobridgeserver.py python script via websockets
 * This implements a bridge-facing action stack, (push on top, remove bottom)
 * 'actions' get sent to Leo, and resolve a promise with the result when the answer comes back.
 * This 'stack' concept is similar to the 'CommandStack' class used for vscode's user interactions.
 */
export class LeoBridge {

    private _callStack: LeoAction[] = [];
    private _actionBusy: boolean = false; // Action was started from the bottom, but has yet to resolve

    private _leoBridgeSerialId: number = 0; // TODO : Error checking (should be Constants.STARTING_PACKAGE_ID or 0 or 2...?)
    private _readyPromise: Promise&lt;LeoBridgePackage&gt; | undefined;

    private _websocket: WebSocket | null = null;
    private _leoAsync: LeoAsync;

    // TODO : #10 @boltex See if this can help with anaconda/miniconda issues
    // private _hasbin = require('hasbin');

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._leoAsync = new LeoAsync(_context, _leoIntegration);
    }

    @others
}
</t>
<t tx="felix.20200718153505.3">/**
 * * Places an action on top of a stack, to be resolved from the bottom
 * @param p_action Command string to be performed by Leo via leobridgeserver.py
 * @param p_jsonParam Optional JSON parameter for the specified action
 * @param p_deferredPayload Used to build this._readyPromise that resolves itself at startup
 * @param p_preventCall Flag for special action used to build this._readyPromise that resolves itself at startup
 * @returns a Promise that will contain the JSON package answered back by leobridgeserver.py
 */
public action(p_action: string, p_jsonParam = "null", p_deferredPayload?: LeoBridgePackage, p_preventCall?: boolean): Promise&lt;LeoBridgePackage&gt; {
    return new Promise((p_resolve, p_reject) =&gt; {
        const w_action: LeoAction = {
            parameter: this._buildActionParameter(p_action, p_jsonParam),
            deferredPayload: p_deferredPayload ? p_deferredPayload : undefined,
            resolveFn: p_resolve,
            rejectFn: p_reject
        };

        this._callStack.push(w_action);
        if (!p_preventCall) {
            this._callAction();
        }
    });
}

</t>
<t tx="felix.20200718153505.4">/**
 * * Actions invoked by Leo that can be called asynchronously at any time
 * @param w_parsedData that contains an 'async' string member,
 * that was parsed from a _websocket.onmessage package
 */
private _asyncAction(w_parsedData: any): void {
    if (w_parsedData &amp;&amp; w_parsedData.async &amp;&amp; (typeof w_parsedData.async === "string")) {
        switch (w_parsedData.async) {
            case Constants.ASYNC_ACTIONS.ASYNC_LOG: {
                this._leoAsync.log(w_parsedData.log);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_ASK: {
                this._leoAsync.showAskModalDialog(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_WARN: {
                this._leoAsync.showWarnModalMessage(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_INFO: {
                this._leoAsync.showChangesDetectedInfoMessage(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_INTERVAL: {
                console.log("interval ", w_parsedData); // 'ping' interval for debugging
                break;
            }
            default: {
                console.error("[leoIntegration] Unknown async action ", w_parsedData);
                break;
            }
        }
    } else {
        console.error("[leoIntegration] Unknown async command from leoBridge");
    }
}

</t>
<t tx="felix.20200718153505.5">/**
 * * Build JSON string for action parameter to the leoBridge
 * @param p_action Action string to be invoked as command by Leo in the leobridgeserver.py script
 * @param p_jsonParam Optional JSON string to be added as a 'param' to the action sent to Leo
 */
private _buildActionParameter(p_action: string, p_jsonParam?: string): string {
    return "{\"id\":" + (++this._leoBridgeSerialId) + // no quotes, serial id is a number, pre incremented
        ", \"action\": \"" + p_action +  // action is string so surround with quotes
        "\", \"param\":" + p_jsonParam +  // param is already json, no need for added quotes
        "}";
}

</t>
<t tx="felix.20200718153505.6">/**
 * * Resolves promises with the answers from an action that was finished
 * @param p_object Parsed data that was given as the answer by the Leo command that finished
 */
private _resolveBridgeReady(p_object: string) {
    let w_bottomAction = this._callStack.shift();
    if (w_bottomAction) {
        if (w_bottomAction.deferredPayload) {
            // Used when the action already has a return value ready but is also waiting for python's side
            w_bottomAction.resolveFn(w_bottomAction.deferredPayload); // given back 'as is'
        } else {
            w_bottomAction.resolveFn(p_object);
        }
        this._actionBusy = false;
    } else {
        console.error("[leoBridge] Error stack empty");
    }
}

</t>
<t tx="felix.20200718153505.7">/**
 * * Rejects an action from the bottom of the stack
 * @param p_reason Given rejection 'reason'
 */
private _rejectAction(p_reason: string): void {
    const w_bottomAction = this._callStack.shift();
    if (w_bottomAction) {
        w_bottomAction.rejectFn(p_reason);
    }
}

</t>
<t tx="felix.20200718153505.8">/**
 * * Sends an action from the bottom of the stack
 */
private _callAction(): void {
    if (this._callStack.length &amp;&amp; !this._actionBusy) {
        this._actionBusy = true; // launch / resolve bottom one
        const w_action = this._callStack[0];
        this._send(w_action.parameter + "\n");
    }
}

</t>
<t tx="felix.20200718153505.9">/**
 * * JSON.parse encased in a Try/Catch block
 * @param p_jsonStr The JSON string to be parsed
 * @returns The resulting object or 'false' if unsuccessful
 */
private _tryParseJSON(p_jsonStr: string): boolean | any {
    try {
        var w_object = JSON.parse(p_jsonStr);
        // JSON.parse(null) returns null, and typeof null === "object", null is falsy, so this suffices:
        if (w_object &amp;&amp; typeof w_object === "object") {
            return w_object;
        }
    }
    catch (e) {
        console.error('[leoBridge] JSON was invalid: ' + p_jsonStr);
    }
    return false;
}

</t>
<t tx="felix.20200718155251.1">/**
 * * Busy state of the leoBridge's command stack
 */
public isBusy(): boolean {
    return this._actionBusy || !!this._callStack.length;
}

</t>
<t tx="felix.20200718162303.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoButton, Icon } from "./types";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718162303.2">/**
 * * Leo @buttons tree view node item implementation, for usage in a TreeDataProvider.
 */
export class LeoButtonNode extends vscode.TreeItem {

    // Context string that is checked in package.json with 'when' clauses
    public contextValue: string;

    // is the special 'add' button used to create button from a given node's script
    private _isAdd: boolean;

    constructor(
        public button: LeoButton,
        private _leoIntegration: LeoIntegration
    ) {
        super(button.name);
        // Setup this instance (just differentiate 'script-button' for now)
        this.command = {
            command: Constants.COMMANDS.CLICK_BUTTON,
            title: '',
            arguments: [this]
        };
        this._isAdd = (this.button.index.startsWith(Constants.BUTTON_STRINGS.NULL_WIDGET) &amp;&amp;
            this.button.name === Constants.BUTTON_STRINGS.SCRIPT_BUTTON);
        this.contextValue = this._isAdd ? Constants.BUTTON_STRINGS.ADD_BUTTON : Constants.BUTTON_STRINGS.NORMAL_BUTTON;
    }

    @others
}
</t>
<t tx="felix.20200718162435.1">// @ts-ignore
public get iconPath(): Icon {
    return this._leoIntegration.buttonIcons[this._isAdd ? 1 : 0];
}

</t>
<t tx="felix.20200718162442.1">// @ts-ignore
public get id(): string {
    // Add prefix and suffix salt to index to prevent accidental duplicates
    return "p" + this.button.index + "s" + this.button.name;
}

</t>
<t tx="felix.20200718162452.1">// @ts-ignore
public get tooltip(): string {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON_TOOLTIP;
    } else {
        return this.button.name;
    }
}

</t>
<t tx="felix.20200718162459.1">// @ts-ignore
public get description(): string | boolean {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20200718164130.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoButtonNode } from "./leoButtonNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoButton } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718164130.2">/**
 * * '@buttons' shown as a list with this TreeDataProvider implementation
 */
export class LeoButtonsProvider implements vscode.TreeDataProvider&lt;LeoButtonNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoButtonNode | undefined&gt; = new vscode.EventEmitter&lt;LeoButtonNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoButtonNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718164130.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718164130.4">public getTreeItem(element: LeoButtonNode): Thenable&lt;LeoButtonNode&gt; | LeoButtonNode {
    return element;
}

</t>
<t tx="felix.20200718164130.5">public getChildren(element?: LeoButtonNode): Thenable&lt;LeoButtonNode[]&gt; {

    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

        // call action to get get list, and convert to LeoButtonNode(s) array
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BUTTONS).then(p_package =&gt; {
            if (p_package &amp;&amp; p_package) {
                const w_list: LeoButtonNode[] = [];
                const w_buttons: LeoButton[] = p_package.buttons!;
                if (w_buttons &amp;&amp; w_buttons.length) {
                    w_buttons.forEach((i_button: LeoButton) =&gt; {
                        w_list.push(new LeoButtonNode(i_button, this._leoIntegration));
                    });
                }
                return Promise.resolve(w_list);
            } else {
                return Promise.resolve([]);
            }
        });
    } else {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
}

</t>
<t tx="felix.20200718164130.6">public getParent(element: LeoButtonNode): ProviderResult&lt;LeoButtonNode&gt; | null {
    // Buttons are just a list, as such, entries are always child of root so return null
    return null;
}

</t>
<t tx="felix.20200718164509.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoDocument, Icon } from "./types";
import * as utils from "./utils";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718164509.2">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoDocumentNode extends vscode.TreeItem {

    // Context string is checked in package.json with 'when' clauses
    public contextValue: string;

    constructor(
        public documentEntry: LeoDocument,
        private _leoIntegration: LeoIntegration
    ) {
        super(documentEntry.name);
        // Setup this instance
        const w_isNamed: boolean = !!this.documentEntry.name;
        this.label = w_isNamed ? utils.getFileFromPath(this.documentEntry.name) : Constants.UNTITLED_FILE_NAME;
        this.tooltip = w_isNamed ? this.documentEntry.name : Constants.UNTITLED_FILE_NAME;
        this.command = {
            command: Constants.COMMANDS.SET_OPENED_FILE,
            title: '',
            arguments: [this.documentEntry.index]
        };
        // If this was created as a selected node, make sure it's selected as we may have opened/closed document
        if (this.documentEntry.selected) {
            this._leoIntegration.setDocumentSelection(this);
            this.contextValue = w_isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_UNTITLED;
        } else {
            this.contextValue = w_isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_UNTITLED;
        }
    }

    @others
}
</t>
<t tx="felix.20200718164635.1">// @ts-ignore
public get iconPath(): Icon {
    return this._leoIntegration.documentIcons[this.documentEntry.changed ? 1 : 0];
}

</t>
<t tx="felix.20200718164638.1">// @ts-ignore
public get id(): string {
    // Add prefix and suffix salt to numeric index to prevent accidental duplicates
    return "p" + this.documentEntry.index + "s" + this.documentEntry.name;
}

</t>
<t tx="felix.20200718165108.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoDocumentNode } from "./leoDocumentNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoDocument } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718165108.2">/**
 * * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
export class LeoDocumentsProvider implements vscode.TreeDataProvider&lt;LeoDocumentNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoDocumentNode | undefined&gt; = new vscode.EventEmitter&lt;LeoDocumentNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoDocumentNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718165108.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718165108.4">public getTreeItem(element: LeoDocumentNode): Thenable&lt;LeoDocumentNode&gt; | LeoDocumentNode {
    return element;
}

</t>
<t tx="felix.20200718165108.5">public getChildren(element?: LeoDocumentNode): Thenable&lt;LeoDocumentNode[]&gt; {

    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

        // call action to get get list, and convert to LeoDocumentNode(s) array
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_OPENED_FILES).then(p_package =&gt; {
            if (p_package &amp;&amp; p_package) {
                const w_list: LeoDocumentNode[] = [];
                const w_files: LeoDocument[] = p_package.openedFiles!.files;

                let w_index: number = 0;

                if (w_files &amp;&amp; w_files.length) {
                    w_files.forEach((i_file: LeoDocument) =&gt; {
                        w_list.push(new LeoDocumentNode(i_file, this._leoIntegration));
                        w_index++;
                    });
                }

                return Promise.resolve(w_list);
            } else {
                return Promise.resolve([]);
            }
        });
    } else {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
}

</t>
<t tx="felix.20200718165108.6">public getParent(element: LeoDocumentNode): ProviderResult&lt;LeoDocumentNode&gt; | null {
    // Leo documents are just a list, as such, entries are always child of root, so return null
    return null;
}

</t>
<t tx="felix.20200718165721.1"></t>
<t tx="felix.20200718170429.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import * as path from "path"; // TODO : Use this to have reliable support for window-vs-linux file-paths

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718170429.2">/**
 * * Handles opening of file browser when choosing which Leo file to open
 */
export class LeoFilesBrowser {

    private _fileBrowserActive: boolean = false;

    constructor(private _context: vscode.ExtensionContext) { }

    @others
}
</t>
<t tx="felix.20200718170429.3">/**
 * * Finds a folder to propose when opening the browse-for-leo-file chooser
 * @returns An Uri for path to a folder for initial opening
 */
private _getBestOpenFolderUri(): vscode.Uri {
    let w_openedFileEnvUri: vscode.Uri | boolean = false;
    let w_activeUri: vscode.Uri | undefined = undefined;

    if (vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders[0]) {
        w_activeUri = vscode.workspace.workspaceFolders[0].uri;
    }

    if (w_activeUri) {
        const w_defaultFolder = vscode.workspace.getWorkspaceFolder(w_activeUri);
        if (w_defaultFolder) {
            w_openedFileEnvUri = w_defaultFolder.uri; // Set as current opened document-path's folder
        }
    }
    if (!w_openedFileEnvUri) {
        w_openedFileEnvUri = vscode.Uri.file("~"); // TODO : set as home folder properly, this doesn't work
        // ! EXAMPLE WITH os : const homedir = require('os').homedir();
    }
    return w_openedFileEnvUri;
}

</t>
<t tx="felix.20200718170429.4">/**
 * * Open a file browser and let the user choose a Leo file or cancel the operation
 * @param p_saveAsFlag Optional flag that will ask for a 'save' path+filename
 * @returns A promise resolving to a chosen path string, or rejected with an empty string if cancelled
 */
public getLeoFileUrl(p_saveAsFlag?: boolean): Promise&lt;string&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve("");
    }
    this._fileBrowserActive = true;
    return new Promise((p_resolve, p_reject) =&gt; {
        const w_filters: { [name: string]: string[] } = {};
        w_filters[Constants.FILE_OPEN_FILTER_MESSAGE] = [Constants.FILE_EXTENSION];

        if (p_saveAsFlag) {
            // Choose file
            vscode.window.showSaveDialog({
                saveLabel: "Save Leo File",
                defaultUri: this._getBestOpenFolderUri(),
                filters: { 'Leo File': ['leo'] }
            })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // single string
                        p_resolve(p_chosenLeoFile.fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                    } else {
                        p_resolve(""); // not rejection - resolve empty string
                    }
                });
        } else {
            vscode.window
                .showOpenDialog({
                    canSelectMany: false,
                    defaultUri: this._getBestOpenFolderUri(),
                    filters: w_filters
                })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // array instead of single string
                        p_resolve(p_chosenLeoFile[0].fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                    } else {
                        p_resolve("");
                    }
                });
        }
    });
}

</t>
<t tx="felix.20200718170712.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { ArchivedPosition, Icon } from "./types"; // ArchivedPosition included to help debug

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718170712.2">/**
 * * Implementation of tree nodes for usage in a TreeDataProvider
 */
export class LeoNode extends vscode.TreeItem {

    public contextValue: string; // * Context string is checked in package.json with 'when' clauses

    public isRoot: boolean = false; // * for hoist/dehoist context flags purposes

    constructor(
        public label: string, // Node headline
        public gnx: string,
        public collapsibleState: vscode.TreeItemCollapsibleState, // Computed in receiver/creator
        public apJson: string, // Key for leo/python side of things
        public childIndex: number, // For debugging purposes
        public cloned: boolean,
        public dirty: boolean,
        public marked: boolean,
        public atFile: boolean,
        public hasBody: boolean,
        public u: any,
        private _leoIntegration: LeoIntegration,
        private _id: string
    ) {
        super(label, collapsibleState);
        this.contextValue = this._getNodeContextValue();
        this.command = {
            command: Constants.COMMANDS.SELECT_NODE,
            title: '',
            arguments: [this]
        };
    }

    // * TO HELP DEBUG
    // get description(): string {
    //     // * some smaller grayed-out text accompanying the main label
    //     const w_ap: ArchivedPosition = JSON.parse(this.apJson);
    //     return "child:" + w_ap.childIndex + " lvl:" + w_ap.level + " gnx:" + w_ap.gnx;
    // }

    // get description(): string {
    //     // * some smaller grayed-out text accompanying the main label
    //     return "id:" + this.id;
    // }

    @others
}
</t>
<t tx="felix.20200718170712.3">/**
 * * Sets this node properties (dirty, marked, etc.) by copying from a given node.
 * * This is needed by the outline provider when refreshing a single node.
 * @param p_node Node to copy properties from.
 * @returns Node itself with the new properties applied
 */
public copyProperties(p_node: LeoNode): LeoNode {
    this.label = p_node.label;
    this.gnx = p_node.gnx;
    this.collapsibleState = p_node.collapsibleState;
    this.apJson = p_node.apJson;
    this.childIndex = p_node.childIndex;
    this.cloned = p_node.cloned;
    this.dirty = p_node.dirty;
    this.marked = p_node.marked;
    this.atFile = p_node.atFile;
    this.hasBody = p_node.hasBody;
    this.isRoot = p_node.isRoot;
    this.contextValue = this._getNodeContextValue();
    return this;
}

</t>
<t tx="felix.20200718170712.4">/**
 * * Set this node as the root for hoist/dehoist context flags purposes
 */
public setRoot(): void {
    this.isRoot = true;
    this._leoIntegration.leoStates.leoRoot = true; // Set this special global 'selected node' flag
    this.contextValue = this._getNodeContextValue();
}

</t>
<t tx="felix.20200718170712.5">private _getNodeContextValue(): string {
    // Start it with 'leoNodeMarked' or 'leoNodeUnmarked'
    let w_contextValue = Constants.CONTEXT_FLAGS.NODE_UNMARKED;
    if (this.marked) {
        w_contextValue = Constants.CONTEXT_FLAGS.NODE_MARKED;
    }
    // then append 'leoNodeAtFile' to existing if needed
    if (this.atFile) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ATFILE;
    }
    // then append 'leoNodeCloned' to existing if needed
    if (this.cloned) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_CLONED;
    }
    // and finally, check for 'root' too
    if (this.isRoot) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ROOT;
    } else {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_NOT_ROOT;
    }
    return w_contextValue;
}

</t>
<t tx="felix.20200718171837.1">// @ts-ignore
public get description(): string {
    // * some smaller grayed-out text accompanying the main label
    if (this.u) {
        return "\u{1F4CE} (" + Object.keys(this.u).length + ")";
    } else {
        // return "id:" + this.id; // ! debug test
        // return "gnx:" + this.gnx; // ! debug test
        return ""; // Falsy will not be shown
    }
}

</t>
<t tx="felix.20200718171849.1">// @ts-ignore
public get tooltip(): string {
    if (this.u) {
        //  "\ntotal keys is :" + Object.keys(this.u).length
        return this.label + "\n" +
            JSON.stringify(this.u, undefined, 2);
    } else {
        return this.label; // * Whole headline as tooltip
    }
}

</t>
<t tx="felix.20200718171854.1">// Optional id for the tree item that has to be unique across tree.
// The id is used to preserve the selection and expansion state of the tree item.
// If not provided, an id is generated using the tree item's label.
// Note that when labels change, ids will change and that selection and expansion state cannot be kept stable anymore.
// @ts-ignore
public get id(): string { return this._id; }

</t>
<t tx="felix.20200718171904.1">// @ts-ignore
public get iconPath(): Icon {
    // From Leo's leoNodes.py computeIcon function
    // 1=has Body, 2=marked, 4=cloned, 8=dirty
    let w_dirty: boolean = this._leoIntegration.config.invertNodeContrast ? !this.dirty : this.dirty;
    let w_icon: number =
        (+w_dirty &lt;&lt; 3) |
        (+this.cloned &lt;&lt; 2) |
        (+this.marked &lt;&lt; 1) |
        +this.hasBody;
    return this._leoIntegration.nodeIcons[w_icon];
}

</t>
<t tx="felix.20200718180428.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoBridgePackage } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718180428.2">/**
 * * Leo outline implemented as a tree view with this TreeDataProvider
 */
export class LeoOutlineProvider implements vscode.TreeDataProvider&lt;LeoNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoNode | undefined&gt; = this._onDidChangeTreeData.event;

    // used in leoOutline.ts to check if getTreeItem(element: LeoNode) should fetch from Leo, or return as-is
    private _refreshSingleNodeFlag: boolean = false;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718180428.3">/**
 * * Refresh a single node
 * @param p_node The outline's node itself as a LeoNode instance
 */
public refreshTreeNode(p_node: LeoNode): void {
    // Do a real node refresh, not just giving back the same element: see getTreeItem(element) below
    this._refreshSingleNodeFlag = true;
    this._onDidChangeTreeData.fire(p_node);
}

</t>
<t tx="felix.20200718180428.4">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    // TODO : have this return a promise that resolves when the selected node is encountered by ap_to_p
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718180428.5">public getTreeItem(element: LeoNode): Thenable&lt;LeoNode&gt; | LeoNode {
    if (this._refreshSingleNodeFlag) {
        this._refreshSingleNodeFlag = false;
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_PNODE, element.apJson)
            .then((p_package: LeoBridgePackage) =&gt; {
                const w_node = this._leoIntegration.apToLeoNode(p_package.node!, true, element);
                return element.copyProperties(w_node);
            });
    } else {
        return element;
    }
}

</t>
<t tx="felix.20200718180428.6">public getChildren(element?: LeoNode): Thenable&lt;LeoNode[]&gt; {
    if (!this._leoIntegration.leoStates.fileOpenedReady) {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
    if (element) {
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_CHILDREN, element.apJson)
            .then((p_package: LeoBridgePackage) =&gt; {
                return this._leoIntegration.arrayToLeoNodesArray(p_package.nodes!);
            });
    } else {
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_CHILDREN, "null")
            .then((p_package: LeoBridgePackage) =&gt; {
                const w_nodes = this._leoIntegration.arrayToLeoNodesArray(p_package.nodes!);
                if (w_nodes &amp;&amp; w_nodes.length === 1) {
                    w_nodes[0].setRoot();
                }
                return w_nodes;
            });
    }
}

</t>
<t tx="felix.20200718180428.7">public getParent(element: LeoNode): ProviderResult&lt;LeoNode&gt; | null {
    // * This method should be implemented in order to access reveal API.
    // ! But it should NOT have to be called if only trying to 'select' already revealed nodes
    // ! Called when revealing single nodes

    // ! Might be called if nodes are revealed while in vscode's refresh process
    // ! Parent asked for this way will go up till root and effectively refresh whole tree.
    // console.log('ERROR! GET PARENT CALLED! on: ', element.label);

    if (this._leoIntegration.leoStates.fileOpenedReady) {
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_PARENT, element ? element.apJson : "null")
            .then((p_package: LeoBridgePackage) =&gt; {
                if (p_package.node === null) {
                    return null;
                } else {
                    return this._leoIntegration.apToLeoNode(p_package.node!);
                }
            });
    } else {
        return null; // Default gives no parent
    }
}

</t>
<t tx="felix.20200718185403.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718185403.2">/**
 * * Statusbar indicator controller service
 */
export class LeoStatusBar {

    private _leoStatusBarItem: vscode.StatusBarItem;
    private _statusbarNormalColor = new vscode.ThemeColor(Constants.GUI.THEME_STATUSBAR);  // "statusBar.foreground"
    private _updateStatusBarTimeout: NodeJS.Timeout | undefined;
    private _string: string = ""; // Use this string with indicator, using this will replace the default from config

    // * Represents having focus on a leo tree, body or document panel to enable leo keybindings
    private _statusBarFlag: boolean = false;
    set statusBarFlag(p_value: boolean) {
        this._statusBarFlag = p_value;
    }
    get statusBarFlag(): boolean {
        return this._statusBarFlag;
    }

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._leoStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
        this._leoStatusBarItem.color = this._leoIntegration.config.statusBarColor;

        // this._leoStatusBarItem.command = Constants.COMMANDS.SWITCH_FILE;
        this._leoStatusBarItem.command = "leointeg.test"; // just call test function for now to help debugging
        this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR + this._leoIntegration.config.statusBarString;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;
        _context.subscriptions.push(this._leoStatusBarItem);
        this._leoStatusBarItem.hide();
    }

    @others
}
</t>
<t tx="felix.20200718185403.3">/**
 * * Makes the statusbar indicator visible
 */
public show(): void {
    this._leoStatusBarItem.show();
}

</t>
<t tx="felix.20200718185403.4">/**
 * * Hides the statusbar indicator
 */
public hide(): void {
    this._leoStatusBarItem.hide();
}

</t>
<t tx="felix.20200718185403.5">/**
 * * Sets string to replace default from config &amp; refresh it
 */
public setString(p_string: string): void {
    this._string = p_string;
    this._updateLeoObjectIndicator();
}

</t>
<t tx="felix.20200718185403.6">/**
 * * Updates the status bar visual indicator visual indicator with optional debouncing delay
 * @param p_state True/False flag for On or Off status
 * @param p_debounceDelay Optional, in milliseconds
 */
public update(p_state: boolean, p_debounceDelay?: number, p_forced?: boolean): void {
    if (p_forced || (p_state !== this.statusBarFlag)) {
        this.statusBarFlag = p_state;
        if (p_debounceDelay) {
            this._updateLeoObjectIndicatorDebounced(p_debounceDelay);
        } else {
            this._updateLeoObjectIndicator();
        }
    }
}

</t>
<t tx="felix.20200718185403.7">/**
 * * Updates the status bar visual indicator flag in a debounced manner
 * @param p_delay number of milliseconds
 */
private _updateLeoObjectIndicatorDebounced(p_delay: number): void {
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }
    this._updateStatusBarTimeout = setTimeout(() =&gt; {
        this._updateLeoObjectIndicator();
    }, p_delay);
}

</t>
<t tx="felix.20200718185403.8">/**
 * * Updates the status bar visual indicator flag directly
 */
private _updateLeoObjectIndicator(): void {
    // Can be called directly, so clear timer if any
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }

    utils.setContext(Constants.CONTEXT_FLAGS.LEO_SELECTED, !!this.statusBarFlag);

    this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR +
        (this._string ? this._string : this._leoIntegration.config.statusBarString) + " " +
        (this._leoIntegration.leoStates.leoOpenedFileName ? utils.getFileFromPath(this._leoIntegration.leoStates.leoOpenedFileName) : Constants.UNTITLED_FILE_NAME);

    // Also check in constructor for statusBar properties (the createStatusBarItem call itself)
    if (this.statusBarFlag &amp;&amp; this._leoIntegration.leoStates.fileOpenedReady) {
        this._leoStatusBarItem.color = "#" + this._leoIntegration.config.statusBarColor;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;
    } else {
        this._leoStatusBarItem.color = this._statusbarNormalColor;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_OFF;
    }
}

</t>
<t tx="felix.20200718191946.1">import * as os from 'os';
import * as child from 'child_process';
import * as path from "path"; // TODO : Use this to have reliable support for window-vs-linux file-paths
import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from './leoIntegration';

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718191946.2">/**
 * * Leo bridge server service
 * Provides simple automatic leo bridge server startup functionality
 */
export class ServerService {
    // TODO : See #10 @boltex Problem starting the leo-bridge server automatically with anaconda/miniconda on windows
    // See https://github.com/yhirose/vscode-filtertext/blob/master/src/extension.ts#L196

    private _platform: string;
    private _isWin32: boolean;

    /**
     * * Leo Bridge Server Process
     */
    private _serverProcess: child.ChildProcess | undefined;

    private _resolvePromise: ((value?: unknown) =&gt; void) | undefined;
    private _rejectPromise: ((reason?: any) =&gt; void) | undefined;

    private _isStarted: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._platform = os.platform();
        this._isWin32 = this._platform === "win32";
    }

    @others
}
</t>
<t tx="felix.20200718191946.4">/**
 * * Get command from settings or best command for the current OS
 * @param p_leoPythonCommand String command to start python on this computer
 * @returns A promise that resolves when the server is started, or that is rejected in case of problem while starting
 */
public startServer(p_leoPythonCommand: string): Promise&lt;any&gt; {
    let w_pythonPath = "";
    this._leoIntegration.showTerminalPane();
    const w_serverScriptPath = this._context.extensionPath + Constants.SERVER_PATH;
    if (p_leoPythonCommand &amp;&amp; p_leoPythonCommand.length) {
        // Start by running command (see executeCommand for multiple useful snippets)
        w_pythonPath = p_leoPythonCommand; // Set path
        this._leoIntegration.addTerminalPaneEntry('Starting server with command: ' + p_leoPythonCommand);
    } else {
        w_pythonPath = Constants.DEFAULT_PYTHON;
        if (this._isWin32) {
            w_pythonPath = Constants.WIN32_PYTHON;
        }
        this._leoIntegration.addTerminalPaneEntry('Starting server with command : ' +
            w_pythonPath + ((this._isWin32 &amp;&amp; w_pythonPath === "py") ? " -3 " : "") +
            " " + w_serverScriptPath);
    }

    const w_serverStartPromise = new Promise((p_resolve, p_reject) =&gt; {
        // * Spawn a python child process for a leoBridge server
        this._resolvePromise = p_resolve;
        this._rejectPromise = p_reject;
    });

    let w_args: string[] = []; //  "\"" + w_serverScriptPath + "\"" // For on windows ??

    if (this._isWin32 &amp;&amp; w_pythonPath === "py") {
        w_args.push("-3");
    }
    w_args.push(w_serverScriptPath);
    this._serverProcess = child.spawn(w_pythonPath, w_args);

    if (this._serverProcess &amp;&amp; this._serverProcess.stdout) {
        // * Capture the python process output
        this._serverProcess.stdout.on("data", (p_data: string) =&gt; {
            this._gotTerminalData(p_data);
        });
    } else {
        console.error("No stdout");
    }
    if (this._serverProcess &amp;&amp; this._serverProcess.stderr) {
        // * Capture other python process outputs
        this._serverProcess.stderr.on("data", (p_data: string) =&gt; {
            console.log(`stderr: ${p_data}`);
            this._isStarted = false;
            utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);
            this._serverProcess = undefined;
            if (this._rejectPromise) {
                this._rejectPromise(`stderr: ${p_data}`);
            }
        });
    } else {
        console.error("No stderr");
    }
    if (this._serverProcess) {
        this._serverProcess!.on("close", (p_code: any) =&gt; {
            console.log(`leoBridge exited with code ${p_code}`);
            this._isStarted = false;
            utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);
            this._serverProcess = undefined;
            if (this._rejectPromise) {
                this._rejectPromise(`leoBridge exited with code ${p_code}`);
            }
        });
    }

    return w_serverStartPromise;
}

</t>
<t tx="felix.20200718192351.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { LeoPackageStates } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718192411.1">/**
 * * Global states service
 * Holds state flags used to restrict command availability and icon visibility
 * Changes UI by changing vscode's context variables
 */
export class LeoStates {

    @others
}
</t>
<t tx="felix.20200718192411.2">public setSelectedNodeFlags(p_node: LeoNode): void {
    this.leoRoot = false; // * RESET the root flag : It is set by vscode instead right after getting list of children for root of outline
    this.leoMarked = p_node.marked;
    this.leoCloned = p_node.cloned;
    this.leoDirty = p_node.dirty;
    this.leoEmpty = !p_node.hasBody;
    this.leoChild = !(p_node.collapsibleState === vscode.TreeItemCollapsibleState.None);
    this.leoAtFile = p_node.atFile;
}

</t>
<t tx="felix.20200718192411.3">public setLeoStateFlags(p_states: LeoPackageStates): void {
    this.leoChanged = p_states.changed;
    this.leoCanUndo = p_states.canUndo;
    this.leoCanRedo = p_states.canRedo;
    this.leoCanDemote = p_states.canDemote;
    this.leoCanPromote = p_states.canPromote;
    this.leoCanDehoist = p_states.canDehoist;
}
</t>
<t tx="felix.20200718193219.1">// * Connected to a Leo bridge server
private _leoBridgeReady: boolean = false;
get leoBridgeReady(): boolean {
    return this._leoBridgeReady;
}
set leoBridgeReady(p_value: boolean) {
    this._leoBridgeReady = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, p_value);
}

</t>
<t tx="felix.20200718193222.1">// * A Leo file is opened
private _fileOpenedReady: boolean = false; // Sets context flag along with treeview title
get fileOpenedReady(): boolean {
    return this._fileOpenedReady;
}
set fileOpenedReady(p_value: boolean) {
    this._fileOpenedReady = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, p_value);
    this._leoIntegration.setTreeViewTitle(
        p_value ? Constants.GUI.TREEVIEW_TITLE : Constants.GUI.TREEVIEW_TITLE_INTEGRATION
    );
}

</t>
<t tx="felix.20200718193226.1">// * Currently opened Leo file path and name, empty string if new unsaved file.
private _leoOpenedFileName: string = "";
get leoOpenedFileName(): string {
    return this._leoOpenedFileName;
}
set leoOpenedFileName(p_name: string) {
    if (p_name &amp;&amp; p_name.length) {
        this._leoOpenedFileName = p_name;
        utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, true);
    } else {
        this._leoOpenedFileName = "";
        utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, false);
    }
}

</t>
<t tx="felix.20200718193230.1">// * 'states' flags for currently opened tree view
private _leoChanged: boolean = false;
get leoChanged(): boolean {
    return this._leoChanged;
}
set leoChanged(p_value: boolean) {
    if (this._leoChanged !== p_value) {
        // Refresh Documents Panel
        this._leoIntegration.refreshDocumentsPane();
    }
    this._leoChanged = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CHANGED, p_value);
}

</t>
<t tx="felix.20200718193233.1">private _leoCanUndo: boolean = false;
get leoCanUndo(): boolean {
    return this._leoCanUndo;
}
set leoCanUndo(p_value: boolean) {
    this._leoCanUndo = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_UNDO, p_value);
}

</t>
<t tx="felix.20200718193235.1">private _leoCanRedo: boolean = false;
get leoCanRedo(): boolean {
    return this._leoCanRedo;
}
set leoCanRedo(p_value: boolean) {
    this._leoCanRedo = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_REDO, p_value);
}

</t>
<t tx="felix.20200718193238.1">private _leoCanDemote: boolean = false;
get leoCanDemote(): boolean {
    return this._leoCanDemote;
}
set leoCanDemote(p_value: boolean) {
    this._leoCanDemote = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEMOTE, p_value);
}

</t>
<t tx="felix.20200718193241.1">private _leoCanPromote: boolean = false;
get leoCanPromote(): boolean {
    return this._leoCanPromote;
}
set leoCanPromote(p_value: boolean) {
    this._leoCanPromote = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_PROMOTE, p_value);
}

</t>
<t tx="felix.20200718193244.1">private _leoCanDehoist: boolean = false;
get leoCanDehoist(): boolean {
    return this._leoCanDehoist;
}
set leoCanDehoist(p_value: boolean) {
    this._leoCanDehoist = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEHOIST, p_value);
}

</t>
<t tx="felix.20200718193338.1">// * 'states' flags about current selection, for visibility and commands availability
private _leoMarked: boolean = false;
get leoMarked(): boolean {
    return this._leoMarked;
}
set leoMarked(p_value: boolean) {
    this._leoMarked = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_value);
}

</t>
<t tx="felix.20200718193341.1">private _leoCloned: boolean = false;
get leoCloned(): boolean {
    return this._leoCloned;
}
set leoCloned(p_value: boolean) {
    this._leoCloned = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CLONE, p_value);
}

</t>
<t tx="felix.20200718193343.1">private _leoDirty: boolean = false;
get leoDirty(): boolean {
    return this._leoDirty;
}
set leoDirty(p_value: boolean) {
    this._leoDirty = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_DIRTY, p_value);
}

</t>
<t tx="felix.20200718193348.1">private _leoEmpty: boolean = false;
get leoEmpty(): boolean {
    return this._leoEmpty;
}
set leoEmpty(p_value: boolean) {
    this._leoEmpty = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_EMPTY, p_value);
}

</t>
<t tx="felix.20200718193350.1">private _leoChild: boolean = false;
get leoChild(): boolean {
    return this._leoChild;
}
set leoChild(p_value: boolean) {
    this._leoChild = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CHILD, p_value);
}

</t>
<t tx="felix.20200718193353.1">private _leoAtFile: boolean = false;
get leoAtFile(): boolean {
    return this._leoAtFile;
}
set leoAtFile(p_value: boolean) {
    this._leoAtFile = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_ATFILE, p_value);
}

</t>
<t tx="felix.20200718193403.1">// * Special is-root 'state' flag about current selection, for visibility and commands availability
private _leoRoot: boolean = false;
get leoRoot(): boolean {
    return this._leoRoot;
}
set leoRoot(p_value: boolean) {
    this._leoRoot = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_ROOT, p_value);
}

</t>
<t tx="felix.20200718193500.1">constructor(
    private _context: vscode.ExtensionContext,
    private _leoIntegration: LeoIntegration
) { }

</t>
<t tx="felix.20200718193719.1"></t>
<t tx="felix.20200718193731.1"></t>
<t tx="felix.20200718194857.1">import * as vscode from "vscode";
import { LeoNode } from "./leoNode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718194857.10">/**
 * * Main interface for JSON sent from Leo back to leoInteg
 */
export interface LeoBridgePackage {
    id: number; // TODO : Could be used for error checking
    // * Each of those top level member is an answer from a "Constants.LEOBRIDGE" command
    allGnx?: string[];
    bodyLength?: number;
    bodyData?: string;
    bodyStates?: {
        language: string;
        selection: BodySelectionInfo;
    }
    node?: ArchivedPosition;
    nodes?: ArchivedPosition[];
    states?: LeoPackageStates;
    closed?: {
        total: number;
        filename?: string;
        node?: ArchivedPosition;
    },
    opened?: LeoBridgePackageOpenedInfo,
    setOpened?: LeoBridgePackageOpenedInfo,
    openedFiles?: {
        index: number;
        files: LeoDocument[];
    }
    buttons?: LeoButton[];
    commands?: MinibufferCommand[];
}

</t>
<t tx="felix.20200718194857.11">/**
 * * Leo document structure used in the 'Opened Leo Documents' tree view provider sent back by the server
 */
export interface LeoDocument {
    name: string;
    index: number;
    changed: boolean;
    selected: boolean;
}

</t>
<t tx="felix.20200718194857.12">/**
 * * Leo '@button' structure used in the '@buttons' tree view provider sent back by the server
 */
export interface LeoButton {
    name: string;
    index: string; // STRING KEY
}

</t>
<t tx="felix.20200718194857.13">/**
 * * Icon path names used in leoNodes for rendering in treeview
 */
export interface Icon {
    light: string;
    dark: string;
}

</t>
<t tx="felix.20200718194857.14">/**
 * * LeoBody virtual file time information object
 */
export interface BodyTimeInfo {
    ctime: number;
    mtime: number;
}

</t>
<t tx="felix.20200718194857.15">/**
 * * Parameter structure used in the 'runSaveFileDialog' equivalent when asking user input
 */
export interface showSaveAsDialogParameters {
    // See TODO in leoAsync.ts
    "initialFile": string;
    "title": string;
    "message": string;
    "filetypes": string[];
    "defaultExtension": string;
}

</t>
<t tx="felix.20200718194857.16">/**
 * * Parameter structure used in the 'runAskYesNoDialog' equivalent when asking user input
 */
export interface runAskYesNoDialogParameters {
    "ask": string;
    "message": string;
    "yes_all": boolean;
    "no_all": boolean;
}

</t>
<t tx="felix.20200718194857.17">/**
 * * Parameter structure used in the 'runAskOkDialog' equivalent when showing a warning
 */
export interface runWarnMessageDialogParameters {
    "warn": string;
    "message": string;
}

</t>
<t tx="felix.20200718194857.18">/**
 * * Parameter structure for non-blocking info message about detected file changes
 */
export interface runInfoMessageDialogParameters {
    "message": string;
}

</t>
<t tx="felix.20200718194857.19">/**
 * * Used in showAskModalDialog to get answer from user interaction
 */
export interface AskMessageItem extends vscode.MessageItem {
    value: string;
}

</t>
<t tx="felix.20200718194857.2">/**
 * * Types of the various JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
export interface ConfigMembers {
    checkForChangeExternalFiles: string;
    defaultReloadIgnore: string;
    leoTreeBrowse: boolean;
    treeKeepFocus: boolean;
    treeKeepFocusWhenAside: boolean;
    statusBarString: string;
    statusBarColor: string;
    treeInExplorer: boolean;
    showOpenAside: boolean;
    showEditOnNodes: boolean;
    showArrowsOnNodes: boolean;
    showAddOnNodes: boolean;
    showMarkOnNodes: boolean;
    showCloneOnNodes: boolean;
    showCopyOnNodes: boolean;
    invertNodeContrast: boolean;
    leoPythonCommand: string;
    startServerAutomatically: boolean;
    connectToServerAutomatically: boolean;
    connectionAddress: string;
    connectionPort: number;
}

</t>
<t tx="felix.20200718194857.20">/**
 * * Used in switch Leo document to get answer from user interaction
 */
export interface ChooseDocumentItem extends vscode.QuickPickItem {
    value: number;
}

</t>
<t tx="felix.20200718194857.3">/**
 * * When refreshing the outline and getting to Leo's selected node
 */
export const enum RevealType {
    NoReveal = 0, // In apToLeoNode conversion, If if the global revealType is "NoReveal" and its the selected node, re-use the old id
    Reveal,
    RevealSelect,
    RevealSelectFocus
}

</t>
<t tx="felix.20200718194857.4">/**
 * * Required Refresh Dictionary of "elements to refresh" flags
 */
export interface ReqRefresh {
    node?: boolean; // Reveal received selected node (Navigation only, no tree change)
    tree?: boolean; // Tree needs refresh
    body?: boolean; // Body needs refresh
    states?: boolean; // States needs refresh (changed, canUndo, canRedo, canDemote, canPromote, canDehoist)
    buttons?: boolean; // Buttons needs refresh
    documents?: boolean; // Documents needs refresh
}

</t>
<t tx="felix.20200718194857.5">/**
 * * Stackable front end commands
 */
export interface UserCommand {
    action: string; // String from Constants.LEOBRIDGE, which are commands for leobridgeserver
    node?: LeoNode | undefined;  // We can START a stack with a targeted command
    text?: string | undefined; // If a string is required, for headline, etc.
    refreshType: ReqRefresh; // Minimal refresh level required by this command
    fromOutline: boolean; // Focus back on outline instead of body
    keepSelection?: boolean; // Should bring back selection on node prior to command
    resolveFn?: (result: any) =&gt; void; // call that with an answer from python's (or other) side
    rejectFn?: (reason: any) =&gt; void; // call if problem is encountered
}

</t>
<t tx="felix.20200718194857.6">
/**
 * * Stackable leoBridge actions to be performed by Leo
 */
export interface LeoAction {
    parameter: string; // to pass along with action to python's side
    deferredPayload?: any | undefined; // Used when the action already has a return value ready but is also waiting for python's side
    resolveFn: (result: any) =&gt; void; // call that with an answer from python's (or other) side
    rejectFn: (reason: any) =&gt; void; // call if problem is encountered
}

</t>
<t tx="felix.20200718194857.7">/**
 * * Simple 'string log entry' package format
 */
export interface LeoLogEntry {
    log: string;
}

</t>
<t tx="felix.20200718194857.8">/**
 * * ArchivedPosition format package from Leo's leoflexx.py
 */
export interface ArchivedPosition {
    hasBody: boolean;       // bool(p.b),
    hasChildren: boolean;   // p.hasChildren()
    childIndex: number;     // p._childIndex
    cloned: boolean;        // p.isCloned()
    dirty: boolean;         // p.isDirty()
    expanded: boolean;      // p.isExpanded()
    gnx: string;            // p.v.gnx
    level: number;          // p.level()
    headline: string;       // p.h
    marked: boolean;        // p.isMarked()
    atFile: boolean         // p.isAnyAtFileNode():
    selected: boolean;      // p == commander.p
    u?: any;               // User Attributes
    stack: {
        gnx: string;        // stack_v.gnx
        childIndex: number; // stack_childIndex
        headline: string;   // stack_v.h
    }[];                    // for (stack_v, stack_childIndex) in p.stack]
}

</t>
<t tx="felix.20200718195558.1">import * as vscode from "vscode";
import * as murmur from "murmurhash-js";
import { Constants } from "./constants";
import { Icon, UserCommand, ArchivedPosition } from "./types";
import { LeoNode } from "./leoNode";

// String and other types/structures helper functions, along with common vscode API calls

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718195558.10">/**
 * * Builds a 'Leo Scheme' vscode.Uri from a gnx (or strings like 'LEO BODY' or empty strings to decorate breadcrumbs)
 * with a scheme header like "leo:/" or 'more:/' 
 * @param p_str leo node gnx strings are used to build Uri
 * @returns A vscode 'Uri' object
 */
export function strToLeoUri(p_str: string): vscode.Uri {
    return vscode.Uri.parse(Constants.URI_SCHEME_HEADER + p_str);
}

</t>
<t tx="felix.20200718195558.11">/**
 * * Gets the gnx, (or another string like 'LEO BODY' or other), from a vscode.Uri object
 * @param p_uri Source uri to extract from
 * @returns The string source that was used to build this Uri
 */
export function leoUriToStr(p_uri: vscode.Uri): string {
    // TODO : Use length of a constant or something other than 'fsPath'
    // For now, just remove the '/' (or backslash on Windows) before the path string
    return p_uri.fsPath.substr(1);
}

</t>
<t tx="felix.20200718195558.12">/**
 * * Sets a vscode context variable with 'vscode.commands.executeCommand' &amp; 'setContext'
 * @param p_key Key string name such as constants 'bridgeReady' or 'treeOpened', etc.
 * @param p_value Value to be assigned to the p_key 'key'
 * @returns A Thenable that is returned by the executeCommand call
 */
export function setContext(p_key: string, p_value: any): Thenable&lt;unknown&gt; {
    return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.SET_CONTEXT, p_key, p_value);
}

</t>
<t tx="felix.20200718195558.2">/**
 * * Build a string for representing a number that's 2 digits wide, padding with a zero if needed
 * @param p_number Between 0 and 99
 * @returns a 2 digit wide string representation of the number, left padded with zeros as needed.
 */
export function padNumber2(p_number: number): string {
    return ("0" + p_number).slice(-2);
}

</t>
<t tx="felix.20200718195558.3">/**
 * * Build all possible strings for node icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array of the 16 vscode node icons used in this vscode expansion
 */
export function buildNodeIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return Array(16).fill("").map((p_val, p_index) =&gt; {
        return {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT)
        };
    });
}

</t>
<t tx="felix.20200718195558.4">/**
 * * Build all possible strings for documents icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildDocumentIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_DOCUMENT),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_DOCUMENT)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_DOCUMENT_DIRTY),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_DOCUMENT_DIRTY)
        }
    ];
}

</t>
<t tx="felix.20200718195558.6">/**
 * * Builds and returns a JSON string with 'node' and 'text' members
 * @param p_nodeJson Targeted tree node in the proper JSON format
 * @param p_text Desired text sent along with node in the parameters of the action to be 'called'
 * @returns JSON string suitable for being a parameter of a leoBridge action
 */
export function buildNodeAndTextJson(p_nodeJson: string, p_command: UserCommand): string {
    let w_json = "{\"node\":" + p_nodeJson; // already json
    if (p_command.text) {
        w_json += ", \"text\": " + JSON.stringify(p_command.text);
    }
    if (p_command.keepSelection) {
        w_json += ", \"keep\": true";
    }
    // TODO : Generalize this function to send any other members of p_command / other members
    w_json += "}";
    return w_json;
}

</t>
<t tx="felix.20200718195558.7">/**
 * * Extracts the file name from a full path, such as "foo.bar" from "/abc/def/foo.bar"
 * @param p_path Full path such as "/var/drop/foo/boo/moo.js" or "C:\Documents and Settings\img\recycled log.jpg"
 * @returns file name string such as "moo.js" or "recycled log.jpg""
 */
export function getFileFromPath(p_path: string): string {
    return p_path.replace(/^.*[\\\/]/, '');
}

</t>
<t tx="felix.20200718195558.8">/**
 * * Checks if a node would become dirty if it were to now have body content at all
 * @param p_node LeoNode from vscode's outline
 * @param p_newHasBody Flag to signify presence of body content, to be compared with its current state
 * @returns True if it would change the icon with actual body content, false otherwise
 */
export function isIconChangedByEdit(p_node: LeoNode, p_newHasBody: boolean): boolean {
    if (!p_node.dirty || (p_node.hasBody === !p_newHasBody)) {
        return true;
    }
    return false;
}

</t>
<t tx="felix.20200718195558.9">/**
 * * Checks if a string is formatted as a valid rrggbb color code.
 * @param p_hexString hexadecimal 6 digits string, without leading '0x'
 * @returns True if the string is a valid representation of an hexadecimal 6 digit number
 */
export function isHexColor(p_hexString: string): boolean {
    return typeof p_hexString === 'string'
        &amp;&amp; p_hexString.length === 6
        &amp;&amp; !isNaN(Number('0x' + p_hexString));
}

</t>
<t tx="felix.20200718220811.1"></t>
<t tx="felix.20200718220818.1">@language md
@tabwidth -4
# ![LeoEditor](resources/leoapp.png) Leo Editor Integration with Visual Studio Code

## Literate Programming with _Directed Acyclic Graphs_ ([dag](https://en.wikipedia.org/wiki/Directed_acyclic_graph))

### Break your code down into sections structured as an outline, to derive or parse back your files

&gt; Leo is a fundamentally different way of using and organizing data, programs and scripts.\
&gt; [View Preview Video](https://www.youtube.com/watch?v=SYwlfdEukD4) 🎥

See Leo, the Literate Editor with Outline, at [leoeditor.com](https://leoeditor.com/)
or on [github](https://github.com/leo-editor/leo-editor), and vscode at [code.visualstudio.com](https://code.visualstudio.com/).

![Screenshot](resources/animated-screenshot.gif)

@others

---

**🦁 Enjoy!**
</t>
<t tx="felix.20200718220833.1">@language md
@tabwidth -4
# Change Log

## 0.1.13

-   Added support for precise focus placement, focus switch between tree/body.
-   Made the extension more aware of the current selection state, to have strictly relevant buttons visible shown only.
-   Made the 'edit headline' hover icon removable, in order to enable 'Tab' keybinding to go from tree to body directly.
-   Added commands and keybindings for 'goto' operations 'hoist/dehoist' [#25](https://github.com/boltex/leointeg/issues/25) and other commands. [#30](https://github.com/boltex/leointeg/issues/30)
-   Added support for Leo-Style outline navigation. [#43](https://github.com/boltex/leointeg/issues/43) Has to be enabled with an option in the config settings: "Use Leo Tree Browsing" which makes the arrow keys, pgUp/pgDn, home/end move the selection instead of a cursor when focus is on Leo's outline.
-   Implemented @buttons in it's own panel, visible where the already existing 'outline' and 'opened leo documents' panels reside.
-   Added (basic) unknown attributes support as hover tooltip and small description on node headlines.
-   Added a 'leoBridge Server Terminal Panel' to gather output of the leoBridge stdOut pipe. It's displayed among the 'output panels', along with the standard 'leo log window', when the server is started by leoInteg. (either with the auto-start config setting, or by calling the 'start server' command via buttons or the command-palette.)
-   Syntax coloring and Snippets are now enabled for those languages : C, C++, CSS, HTML, Java, Javascript, json, Markdown, PHP, Python, Rust and Typescript. They are taken from the default extension for that language, or if non-existent, from the most popular extension for that language
-   Recent files are now remembered and restored upon re-opening vscode.
-   Leo files can be opened from the explorer pane directly.
-   Added 'minibuffer' feature with the usual alt-x command from Leo.
-   Added cursor position, selected range and scrolling position to be captured and restored when navigating the outline. [#39](https://github.com/boltex/leointeg/issues/39) This allows for commands that use the currently selected text, [#61](https://github.com/boltex/leointeg/issues/61) such as run script and extract/extract name, etc.

@others
</t>
<t tx="felix.20200718220833.2">@language md
@tabwidth -4
# How to install and run the development version

Thanks for trying out the development version of LeoInteg! :sunglasses: Contributions and pull requests are more than welcome!

@others
</t>
<t tx="felix.20200718221645.1">## Requirements

-   Having [Leo's path made available in the \$PYTHONPATH environment variable](https://docs.python.org/2/using/windows.html#excursus-setting-environment-variables)\
    ([More info](https://docs.python.org/2/using/cmdline.html#environment-variables))
-   Having the Websocket Python Library installed.
    _Install with :_ `pip install websockets`\
    (See [websockets.readthedocs.io/en/stable/intro.html](https://websockets.readthedocs.io/en/stable/intro.html))

</t>
<t tx="felix.20200718222026.1">## Development Version Installation

[Video tutorial of installation and startup](https://www.youtube.com/watch?v=rutt11xL54I):

[![Installation and startup video](https://img.youtube.com/vi/rutt11xL54I/0.jpg)](https://www.youtube.com/watch?v=rutt11xL54I)

In addition to the above requirements, **use Leo's 'devel' branch** (This is temporary until Leo's next release), make sure you have Node.js and Git installed, then clone the sources and run `npm install` in a terminal to install the remaining development dependencies.

![run extension](resources/run-extension.png)

You can then run the **Run Extension** target, as shown above, in the **Debug View**.

&gt; See [CONTRIBUTING.md](CONTRIBUTING.md) for complete details on how to install and run this extension.

</t>
<t tx="felix.20200718222035.1">## Features

-   UI controls such as a **Leo Outline** in the explorer view, or as a standalone sidebar, **body panes**, **opened documents selector** along with **Log Window** and **Terminal** [output channels](https://code.visualstudio.com/api/extension-capabilities/common-capabilities#output-channel).
-   Keybindings that match those of Leo, including arrow keys behavior for outline keyboard navigation. (Can be turned off with the **'Leo Tree Browsing'** option setting)
-   A **welcome screen** that also gives access to this extension's **settings**.
-   **Derived files change detection**. See [External Files](#derive-external-files) below for more details
-   **'@button' panel** for [creating your own commands with @buttons](https://leoeditor.com/tutorial-tips.html#use-button-nodes)
-   Access **Leo commands** with context menus, outline-node hover icons, keyboard shortcuts, or the command palette:
    -   Open body panes to the side
    -   Outline edition commands
    -   Clipboard operations
    -   Undo/Redo commands

![Menu](resources/context-hover-menus.png)

</t>
<t tx="felix.20200718222043.1">## Keybindings

### Outline Commands

|                            |     |            |                  |
| :------------------------- | :-- | :--------- | :--------------- |
| `Ctrl + I`                 |     |            | Insert Node      |
| `Ctrl + H`                 |     |            | Edit Headline    |
| `Ctrl + Shift + C`         |     |            | Copy Node        |
| `Ctrl + Shift + X`         |     |            | Cut Node         |
| `Ctrl + Shift + V`         |     |            | Paste Node       |
| `Ctrl + Shift + Backspace` |     |            | Delete Node      |
| `Ctrl + Backquote`         |     |            | Clone Node       |
| `Ctrl + {`                 | and | `Ctrl + }` | Promote / Demote |

### Moving Outline Nodes

|            |     |                         |                    |
| :--------- | :-- | :---------------------- | :----------------- |
| `Ctrl + U` | or  | `Shift [+ Alt] + Up`    | Move Outline Up    |
| `Ctrl + D` | or  | `Shift [+ Alt] + Down`  | Move Outline Down  |
| `Ctrl + L` | or  | `Shift [+ Alt] + Left`  | Move Outline Left  |
| `Ctrl + R` | or  | `Shift [+ Alt] + Right` | Move Outline Right |

_Move Outline commands need the 'Alt' key modifier only when focus is on body pane._

### Common Operations

|                    |     |           |                     |
| :----------------- | :-- | :-------- | :------------------ |
| `Alt + -`          |     |           | Contract All        |
| `Ctrl + M`         |     |           | Mark / Unmark       |
| `Ctrl + B`         |     |           | Execute Script      |
| `Ctrl + T`         |     |           | Toggle Outline/Body |
| `Tab`              | or  | `Alt + D` | Focus on Body       |
| `Alt + T`          |     |           | Focus on Outline    |
| `Ctrl + Shift + D` |     |           | Extract             |
| `Ctrl + Shift + N` |     |           | Extract Names       |
| `Alt + A`          |     |           | Sort Siblings       |

### Tree Navigation

|                    |     |                 |                          |
| :----------------- | :-- | :-------------- | :----------------------- |
| `Alt + Home`       | or  | `Home` \*       | Go To First Visible Node |
| `Alt + End`        |     |                 | Go To Last Sibling       |
|                    |     | `End` \*        | Go To Last Visible Node  |
| `Alt + N`          |     |                 | Go To Next Clone         |
| `Alt + Arrow Keys` | or  | `Arrow Keys` \* | Browse Tree              |
| `Ctrl + T`         |     |                 | Switch Tree/Body Focus   |
| `Tab`              |     |                 | Focus from Tree to Body  |

\* _With the **'Leo Tree Browsing'** setting enabled by default, all arrows and numeric keypad keys change the outline's selection directly_

#

</t>
<t tx="felix.20200718222048.1">## Derive External Files

Use the **Save Leo File** command to derive external files.

Leo will detect derived file changes and will ask to either **refresh from disk** or **ignore the changes**.

![derive files](resources/derived-file.gif)

</t>
<t tx="felix.20200718222053.1">## Automate Synchronization

The **change detection** process can be automated to always refresh, or ignore file changes: A **notification** will inform you of the action taken instead.

![auto sync](resources/auto-sync.gif)

</t>
<t tx="felix.20200718222058.1">## Status Bar Indicator

A customizable keyboard status bar indicator is shown when this extension is activated.
It will turn orange (or your choice of text and color), when leo's **keyboard shortcuts** are active.
This occurs when an outline node or a body pane has focus:

![Statusbar](resources/statusbar-keyboard.gif)

</t>
<t tx="felix.20200718222102.1">## Extension Settings

### Open the command palette `CTRL+SHIFT+P` and start typing `leo settings` to access LeoInteg's welcome/settings screen

&gt; _(Changes are auto-saved to the user's profile after 0.5 seconds)_

-   Control the visibility of the outline pane in the explorer view.
-   Decide how and when to refresh and synchronize content when derived (external) file are modified.
-   Show additional icons on outline nodes (Move, delete, mark, copy, paste...)
-   Choose to either focus on the body pane, or keep focus in the outline when a node is selected.
-   Hide or show the "Open on the side" command in the context menu to open a node beside the active editor
-   Set preferences for setting the address and port, and for automatically starting, and/or connecting, to a Leo Bridge server.

![Settings](resources/welcome-settings.gif)

</t>
<t tx="felix.20200718222108.1">## Issues

Main issues are listed below. See the repository's [Issues Page](https://github.com/boltex/leointeg/issues) to submit issues.

### Linux Keybindings

If you're experiencing trouble with the keyboard shortcuts for
the 'Clone Node' or the 'Promote' and 'Demote' commands,
use **"keyboard.dispatch": "keyCode"** in your settings and restart vscode.
See [Troubleshoot Linux Keybindings](https://github.com/microsoft/vscode/wiki/Keybinding-Issues#troubleshoot-linux-keybindings)
for more information.

### Move Outline Keyboard Commands

For some users, the **`Alt+[Arrow Keys]`**, **`Ctrl+D`** and **`Ctrl+T`** keybinding are already assigned.
To help with this conflict, tree-browsing, outline-move keyboard commands, and switch focus command will only trigger
with the additional condition of having no text selection in the editor.
So select at least one character to use the previously assigned original keyboard commands while focus is in the body pane.

&gt; This extension is still in development, so please refer to its [issue tracker](https://github.com/boltex/leointeg/issues) to learn more about its intended features, or to contribute with additional information if you encounter other issues yourself.

</t>
<t tx="felix.20200718222113.1">## How It Works

Integration is done by starting a python server script and connecting to it via a [websocket](https://websockets.readthedocs.io/en/stable/intro.html) to exchange JSON data. That script leverages [leoBridge](https://leoeditor.com/leoBridge.html) and re-uses code from the leoflexx.py plugin.

The outline pane is made by implementing a [TreeDataProvider for vscode's TreeView API](https://code.visualstudio.com/api/extension-guides/tree-view#tree-view-api-basics), while the body panes _virtual documents_ are made by [implementing a filesystem provider](https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api) and using the node's gnx as identifiers.

#

</t>
<t tx="felix.20200718222118.1">## Acknowledgments

### _Thanks to_

-   [Edward K. Ream](https://github.com/edreamleo) creator of the [Leo Editor](https://leoeditor.com/)
-   [Eric Amodio](https://github.com/eamodio) for the [welcome screen templates](https://github.com/eamodio/vscode-gitlens/tree/master/src/webviews)
-   [Vitalije](https://github.com/vitalije) for his contributions and support
-   [Arjan](https://github.com/ar-jan) for his suggestions and ideas
</t>
<t tx="felix.20200718222417.1">## 0.1.12

-   Added support for multiple opened files along with the 'new', 'Close', 'Save-As' commands.
-   Improved the icons and commands, which are visible, or invisible depending on context.
-   Added 'tree view' listing the opened Leo documents which is available in the Leo view, and the explorer view.
-   Added basic leonine syntax coloring. (No specific \@languages yet)
-   Added selection support to the 'Execute-Script' command.

</t>
<t tx="felix.20200718222419.1">## 0.1.11

-   Fixed undo operation for the _insert_ and _rename_ commands (Some other commands may still need fixes to their 'undo' support)
-   Fixed crashing when editing body pane under Leo 6.2.

</t>
<t tx="felix.20200718222422.1">## 0.1.10

-   Added more [welcome content](https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content) in outlines panes that have not yet opened a tree for starting a server, connecting to it, and added content to help with automation settings.
-   Changed the starting default configuration setting for starting and connecting to the leoBridge server script to false.
-   Made starting and connecting to the leoBridge server script easier to access in the interface, and in the welcome/settings webview.
-   Added new CONTRIBUTING.md markdown file for running the development version of the leoInteg extension.
-   Closes [#44](https://github.com/boltex/leointeg/issues/44)

</t>
<t tx="felix.20200718222425.1">## 0.1.9

-   Added new compilation configuration (server, extension, or both) to help debugging.
-   Support async output from leoBridge, for log pane and other events.
-   External file change detection with modal dialogs matching Leo's gui dialogs.
-   Added config options to bypass derived files change detection dialogs with defaults, allowing automatic synchronization of derived files in both directions.
-   Added support for redo, refresh from disk and many any other core Leo commands and operations.
-   Added support for rapid outline edition command entry, including 'insert node' command **`Ctrl+I`** and for replacing focus on relevant elements to mimic actual Leo interface workflow.
-   Added [welcome content](https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content) in outlines panes that have not yet opened a tree to help with connecting and opening
-   Replaced body-editor content transfer logic and removed the related option in the expansion's settings. The body is sent to Leo when appropriate without need of a timed delay.
-   _REMOVED FEATURE_ Rolled back 'multi-body' feature for simultaneous body panes from different gnx. Body panes from the same gnx are still available.

</t>
<t tx="felix.20200718222427.1">## 0.1.8

-   Extension now built with webpack. [As recommended by vsCode's extension guidelines](https://code.visualstudio.com/api/working-with-extensions/bundling-extension#using-webpack)
-   Added a 'Welcome Screen' webview (also compiled by webpack from html, scss and ts files) to show a greeting with basic info, and provide an easy way to change the configuration settings.
-   Added commands accessible via either tree menu, context menu, and 'standard' Leo keyboard shortcuts:
    -   Insert, delete
    -   Cut/Copy/Paste/Clone/Paste as clone
    -   Move, promote, demote node operations
    -   Mark, unmark, sort children, sort siblings and undo

</t>
<t tx="felix.20200718222429.1">## 0.1.7

-   Changed main mode of communication from stdin/out to tcp/ip websockets.
-   Made a standalone 'Leo Server' python script.

</t>
<t tx="felix.20200718222433.1">## 0.1.6

-   Major 'Browsing' update before adding outline editing and file saving &amp; derivation (Thanks for testing!)
-   Refactored and simplified communication between vscode and leoBridge.
-   Stabilized browsing with multiple simultaneous body panes.
-   Added Leo Outline into explorer view.
-   Supports new command to open a node on the side from the context menu.
-   Multiple configuration options: Open Settings with CTRL+',' type 'leo', or look for 'leo integration' in extensions.

_Note: Headline and body edition does not affect the Leo file yet._

</t>
<t tx="felix.20200718222435.1">## 0.1.5

-   Stabilized tree browsing, along with headline and body editing.

</t>
<t tx="felix.20200718222437.1">## 0.1.4

-   Major Refactor to streamline codebase; Eliminated code duplication.
-   Complete rewrite after going trying out most of what is possible with both vscode and leo APIs.
-   New body pane system that prevents corrupting undos across different positions: It uses the node's actual gnx instead of a generic "body" string as a file path for the custom filesystem.

</t>
<t tx="felix.20200718222439.1">## 0.1.3

-   This version creates a body panel via a custom filesystem: 'leo'. It only has a file, "leo:/body", the body of the currently selected node.

_Note: This editable body panel does not affect Leo file yet._

</t>
<t tx="felix.20200718222440.1">## 0.1.2

-   Prototype Goal Achieved!
-   Browsing Now shows body text too, just like browsing in Leo without editing body nor headlines. (read only for now)

</t>
<t tx="felix.20200718222442.1">## 0.1.1

-   Leo File Opening.
-   Basic outline browsing, along with the recognizable node icons.

</t>
<t tx="felix.20200718222445.1">## 0.0.1

-   Initial basic skeleton of this extension. Press F5 to view icon and test the startup of the extension!
-   Implemented [leoBridge](https://leoeditor.com/leoBridge.html) interaction.

![LeoEditor](resources/leoapp96px.png)
</t>
<t tx="felix.20200718222731.1">## Introduction

[Video tutorial of installation and startup](https://www.youtube.com/watch?v=rutt11xL54I):

[![Installation and startup video](https://img.youtube.com/vi/rutt11xL54I/0.jpg)](https://www.youtube.com/watch?v=rutt11xL54I)

If you're new to vscode and want to try out Leo with this vscode extension, you might want to look at this [Getting Started](https://code.visualstudio.com/docs#vscode-in-action) page to get an overview of vscode.

Furthermore, if you've never ran a vscode extension in an **Extension Development Host**, here is a [short overview about running and modifying a simple extension](https://code.visualstudio.com/api/get-started/your-first-extension).

If you're having problems with the procedures below, try [running this sample extension](https://github.com/Microsoft/vscode-extension-samples/tree/master/helloworld-sample#running-the-sample) first to catch underlying problems or missing dependencies.

</t>
<t tx="felix.20200718222739.1">## Development requirements

- **use Leo's 'devel' branch** (This is temporary until Leo's next release)

- Make sure you have [Node.js](https://nodejs.org/en/download/) and [Git](https://git-scm.com/downloads) installed.

- Check your node.js version by typing `node -v` in a terminal. [The latest lts version is 12.18.0](https://nodejs.org/en/download/).

- Also check your vscode version by opening the 'about' dialog from the help menu. You should at least match or exceed the version below.

On Windows:

![about](resources/vscode-about-win.png)

On Linux:

![about](resources/vscode-about.png)

</t>
<t tx="felix.20200718222741.1">## Getting the source and its development dependencies

- Clone the repository using the command line by typing : `git clone https://github.com/boltex/leointeg.git`

![clone](resources/git-clone.png)

- Although you could 'cd' into the leoInteg folder and run some commands from the same terminal, let's instead use the terminal from within vscode. So open the leoInteg folder with vscode instead, either with the context menu as shown below, or by choosing "Open Folder..." from within vscode:

![open with vscode](resources/open-with-vscode.png)

- With vscode now opened with the **leoInteg folder as its workspace**, use the `ctrl+shift+p` keyboard shortcut to open command palette and toggle the terminal. (You can find any command through the command palette)

![open terminal](resources/open-terminal.png)

- Install the development dependencies by entering the `npm install` command in the terminal. **(Important if you also just _pulled_ updated sources)**

- When the command has finished running, you should see logged results in the terminal and also that a new **node_modules** folder was created.

![dependencies](resources/node-modules.png)

- You're now ready to **compile and run** the development version of the leoInteg extension.

</t>
<t tx="felix.20200718222745.1">## Choosing a debug profile

- Bring up the **Run view**, by selecting the Run icon in the **Activity Bar**. _(Screenshot below)_

- When simply running the extension, choose the **Run Extension** profile.

![profile](resources/debug-profile.png)

&gt; (**Optional**) To contribute code to the python server script, or run it through the vscode debugger, you may need to install the [python development extension](https://marketplace.visualstudio.com/items?itemName=ms-python.python).

- For simply running and using leoInteg, just start the extension and the server as shown below.

</t>
<t tx="felix.20200718222748.1">## Starting the extension

- Use the **Start Debugging** command (or press **F5**) to start another vscode window with the expansion _installed and running_ within it.

![extension started](resources/leointeg-started.png)

- If any problems occurred during the extension compilation it will be logged in the vscode instance that started the debug process in its **task-webpack** terminal panel. Otherwise if its running, the extension itself will be logging any messages in the **debug-console** panel. (See animation below)

![extension logs](resources/debug-anim.gif)

</t>
<t tx="felix.20200718222754.1">## The python server script

- This extension needs the **`leobridgeserver.py`** script to be running. That is where the two extra extension requirements come into play:
  - Having [Leo's path made available in the \$PYTHONPATH environment variable](https://docs.python.org/2/using/windows.html#excursus-setting-environment-variables) ([More info](https://docs.python.org/2/using/cmdline.html#environment-variables))
  - Having the [Websocket Python Library installed](https://websockets.readthedocs.io/en/stable/intro.html)

### 3 ways to start the server script

1. You can have LeoInteg try to start a server script instance itself via the **Start Leo Bridge Server** command or button. It will use the 'py' command on Windows and 'python3' command on other OSes by default. _You can automate this process via leoInteg's configuration settings._
2. You can have vscode's **Debug View** start it as a debug session starts by choosing a debug profile that includes the server script. It's then possible to step in, inspect and debug the python server script. _The [python development extension](https://marketplace.visualstudio.com/items?itemName=ms-python.python) may be required._
3. You can also start it yourself manually, by running the leobridgeserver.py script from a command prompt.

### Using Anaconda or other custom python installations

- LeoInteg provides configuration options to specify how to launch python interpreter but this may not be enough to get it to start on your system, see [#10](https://github.com/boltex/leointeg/issues/10) and other issues relating to configurations in _sitecustomize.py_ file as noted in [Leo's google group forum](https://groups.google.com/d/msg/leo-editor/FAP8lVnWLyQ/lWHWEYH9AgAJ).

- If Leointeg or vscode cannot start running the server script on you system or OS, a **workaround** is to start the server script beforehand manually with whichever python interpreter you have installed.

![launch server](resources/manual-server-start.png)

- It will terminate automatically when a user disconnect.

**Note**: If force-closing the server from the integrated vscode terminal, use the 'Kill terminal' button instead of the 'X' that just hides the panel.

![kill terminal](resources/kill-terminal.png)

</t>
<t tx="felix.20200718222757.1">## Issues

More information can be found on the repository's [Issues Page](https://github.com/boltex/leointeg/issues), where details and troubleshooting can be addressed more directly.
</t>
<t tx="felix.20200719025231.1">import * as vscode from "vscode";
import { debounce } from "debounce";
import * as utils from "./utils";
import { Constants } from "./constants";
import {
    LeoBridgePackage,
    RevealType,
    ArchivedPosition,
    Icon,
    ConfigMembers,
    ReqRefresh,
    ChooseDocumentItem,
    LeoDocument,
    LeoBridgePackageOpenedInfo,
    MinibufferCommand,
    UserCommand,
    ShowBodyParam,
    BodySelectionInfo,
    BodyPosition
} from "./types";
import { Config } from "./config";
import { LeoFilesBrowser } from "./leoFileBrowser";
import { LeoNode } from "./leoNode";
import { LeoOutlineProvider } from "./leoOutline";
import { LeoBodyProvider } from "./leoBody";
import { LeoBridge } from "./leoBridge";
import { ServerService } from "./serverManager";
import { LeoStatusBar } from "./leoStatusBar";
import { CommandStack } from "./commandStack";
import { LeoDocumentsProvider } from "./leoDocuments";
import { LeoDocumentNode } from "./leoDocumentNode";
import { LeoStates } from "./leoStates";
import { LeoButtonsProvider } from "./leoButtons";
import { LeoButtonNode } from "./leoButtonNode";

@others
@language typescript
@tabwidth -4
</t>
<t tx="felix.20200719025231.10"></t>
<t tx="felix.20200719025231.11">/**
 * * Open Leo files found in "context.globalState.leoFiles"
 * @returns promise that resolves with editor of last opened from the list, or rejects if empty
 */
private _openLastFiles(): Promise&lt;vscode.TextEditor&gt; {
    // Loop through context.globalState.&lt;something&gt; and check if they exist: open them
    const w_lastFiles: string[] = this._context.globalState.get(Constants.LAST_FILES_KEY) || [];
    if (w_lastFiles.length) {
        return this.sendAction(Constants.LEOBRIDGE.OPEN_FILES, JSON.stringify({ "files": w_lastFiles }))
            .then((p_openFileResult: LeoBridgePackage) =&gt; {
                this.leoStates.leoBridgeReady = true;
                return this._setupOpenedLeoDocument(p_openFileResult.opened!);
            }, p_errorOpen =&gt; {
                this.leoStates.leoBridgeReady = true;
                console.log('in .then not opened or already opened');
                return Promise.reject(p_errorOpen);
            });
    } else {
        return Promise.reject("Recent files list is empty");
    }
}

</t>
<t tx="felix.20200719025231.12">/**
 * * Adds to the context.globalState.&lt;xxx&gt;files if not already in there (no duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when all global storage modifications are done
 */
private _addRecentAndLastFile(p_file: string): Promise&lt;void&gt; {
    if (!p_file.length) {
        return Promise.reject();
    }
    return Promise.all([
        utils.addFileToGlobal(this._context, p_file, Constants.RECENT_FILES_KEY),
        utils.addFileToGlobal(this._context, p_file, Constants.LAST_FILES_KEY)
    ]).then(() =&gt; {
        return Promise.resolve();
    });
}

</t>
<t tx="felix.20200719025231.13">/**
 * * Removes from context.globalState.leoRecentFiles if found (should not have duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when the global storage modification is done
 */
private _removeRecentFile(p_file: string): Thenable&lt;void&gt; {
    return utils.removeFileFromGlobal(this._context, p_file, Constants.RECENT_FILES_KEY);
}

</t>
<t tx="felix.20200719025231.14">/**
 * * Removes from context.globalState.leoLastFiles if found (should not have duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when the global storage modification is done
 */
private _removeLastFile(p_file: string): Thenable&lt;void&gt; {
    return utils.removeFileFromGlobal(this._context, p_file, Constants.LAST_FILES_KEY);
}

</t>
<t tx="felix.20200719025231.15">/**
 * * Shows the recent Leo files list, choosing one will open it
 * @returns A promise that resolves when the a file is finally opened, rejected otherwise
 */
public showRecentLeoFiles(): Thenable&lt;vscode.TextEditor | undefined&gt; {
    const w_recentFiles: string[] = this._context.globalState.get(Constants.RECENT_FILES_KEY) || [];
    let q_chooseFile: Thenable&lt;string | undefined&gt;;
    if (w_recentFiles.length) {
        q_chooseFile = vscode.window.showQuickPick(
            w_recentFiles,
            { placeHolder: Constants.USER_MESSAGES.OPEN_RECENT_FILE }
        );
    } else {
        // No file to list
        return Promise.resolve(undefined);
    }
    return q_chooseFile.then((p_result) =&gt; {
        if (p_result) {
            return this.openLeoFile(vscode.Uri.file(p_result));
        } else {
            // Canceled
            return Promise.resolve(undefined);
        }
    });
}

</t>
<t tx="felix.20200719025231.19">/**
 * * 'getStates' action for use in debounced method call
 */
private _triggerGetStates(): void {
    if (this._refreshType.documents) {
        this._refreshType.documents = false;
        this.refreshDocumentsPane();
    }
    if (this._refreshType.buttons) {
        this._refreshType.buttons = false;
        this._leoButtonsProvider.refreshTreeRoot();
    }
    if (this._refreshType.states) {
        this._refreshType.states = false;
        this.sendAction(Constants.LEOBRIDGE.GET_STATES)
            .then((p_package: LeoBridgePackage) =&gt; {

                //                            **********************************
                //                             TODO : Check if still same GNX !
                //                            **********************************

                if (p_package.states) {
                    this.leoStates.setLeoStateFlags(p_package.states);
                }
            });
    }

}

</t>
<t tx="felix.20200719025231.2">/**
 * * Orchestrates Leo integration into vscode
 */
export class LeoIntegration {

    // * Status Flags
    private _leoIsConnecting: boolean = false; // Used in connect method, to prevent other attempts while trying
    private _leoBridgeReadyPromise: Promise&lt;LeoBridgePackage&gt; | undefined; // Is set when leoBridge has a leo controller ready
    private _currentOutlineTitle: string = Constants.GUI.TREEVIEW_TITLE_INTEGRATION; // Might need to be re-set when switching visibility
    private _hasShownContextOpenMessage: boolean = false; // Used to show this information only once

    // * State flags
    public leoStates: LeoStates;

    // * Frontend command stack
    private _commandStack: CommandStack;

    // * Configuration Settings Service
    public config: Config; // Public configuration service singleton, used in leoSettingsWebview, leoBridge, and leoNode for inverted contrast

    // * Icon Paths
    public nodeIcons: Icon[] = []; // Singleton static array of all icon paths used in leoNodes for rendering in treeview
    public documentIcons: Icon[] = [];
    public buttonIcons: Icon[] = [];

    // * File Browser
    private _leoFilesBrowser: LeoFilesBrowser; // Browsing dialog service singleton used in the openLeoFile and save-as methods

    // * LeoBridge
    private _leoBridge: LeoBridge; // Singleton service to access leobridgeserver

    // * Outline Pane
    private _leoTreeProvider: LeoOutlineProvider; // TreeDataProvider single instance
    private _leoTreeView: vscode.TreeView&lt;LeoNode&gt;; // Outline tree view added to the Tree View Container with an Activity Bar icon
    private _leoTreeExView: vscode.TreeView&lt;LeoNode&gt;; // Outline tree view added to the Explorer Sidebar
    private _lastTreeView: vscode.TreeView&lt;LeoNode&gt;; // Last visible treeview
    private _treeId: number = 0; // Starting salt for tree node murmurhash generated Ids

    private _lastSelectedNode: LeoNode | undefined; // Last selected node we got a hold of; leoTreeView.selection maybe newer and unprocessed
    get lastSelectedNode(): LeoNode | undefined {
        return this._lastSelectedNode;
    }
    set lastSelectedNode(p_leoNode: LeoNode | undefined) { // Needs undefined type because it cannot be set in the constructor
        this._lastSelectedNode = p_leoNode;
        if (p_leoNode) {
            utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_leoNode.marked); // Global context to 'flag' the selected node's marked state
        }
    }

    // * Outline Pane redraw/refresh flags. Also set when calling refreshTreeRoot
    // If there's no reveal and its the selected node, the old id will be re-used for the node. (see _id property in LeoNode)
    private _revealType: RevealType = RevealType.NoReveal; // to be read/cleared in arrayToLeoNodesArray, to check if any should self-select
    private _preventShowBody = false; // Used when refreshing treeview from config: It requires not to open the body pane when refreshing.

    // * Documents Pane
    private _leoDocumentsProvider: LeoDocumentsProvider;
    private _leoDocuments: vscode.TreeView&lt;LeoDocumentNode&gt;;
    private _leoDocumentsExplorer: vscode.TreeView&lt;LeoDocumentNode&gt;;
    private _currentDocumentChanged: boolean = false; // if clean and an edit is done: refresh opened documents view

    // * Commands stack finishing resolving "refresh flags", for type of refresh after finishing stack
    private _refreshType: ReqRefresh = {}; // Flags for commands to require parts of UI to refresh
    private _fromOutline: boolean = false; // Last command issued had focus on outline, as opposed to the body
    private _focusInterrupt: boolean = false; // Flag for preventing setting focus when interrupting (canceling) an 'insert node' text input dialog with another one

    // * Body Pane
    private _bodyFileSystemStarted: boolean = false;
    private _bodyEnablePreview: boolean = true;
    private _leoFileSystem: LeoBodyProvider; // as per https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api
    private _bodyTextDocument: vscode.TextDocument | undefined; // Set when selected in tree by user, or opening a Leo file in showBody. and by _locateOpenedBody.
    private _bodyMainSelectionColumn: vscode.ViewColumn | undefined; // Column of last body 'textEditor' found, set to 1

    private _bodyPreviewMode: boolean = true;

    private _showBodyStarted: boolean = false; // Flag for when _applySelectionToBody 'show body' cycle is busy
    private _showBodyParams: ShowBodyParam | undefined; // _applySelectionToBody parameters, may be overwritten at each call if not finished

    // * Selection
    private _selectionDirty: boolean = false; // Flag set when cursor selection is changed
    private _selectionGnx: string = ""; // Packaged into 'BodySelectionInfo' structures, sent to Leo
    private _selection: vscode.Selection | undefined; // also packaged into 'BodySelectionInfo'
    private _scrollDirty: boolean = false; // Flag set when cursor selection is changed
    private _scrollGnx: string = "";
    private _scroll: vscode.Range | undefined;

    private _bodyUri: vscode.Uri = utils.strToLeoUri("");
    get bodyUri(): vscode.Uri {
        return this._bodyUri;
    }
    set bodyUri(p_uri: vscode.Uri) {
        this._leoFileSystem.setBodyTime(p_uri);
        this._bodyUri = p_uri;
    }

    // * '@button' pane
    private _leoButtonsProvider: LeoButtonsProvider;
    private _leoButtons: vscode.TreeView&lt;LeoButtonNode&gt;;
    private _leoButtonsExplorer: vscode.TreeView&lt;LeoButtonNode&gt;;

    // * Log and terminal Panes
    private _leoLogPane: vscode.OutputChannel = vscode.window.createOutputChannel(Constants.GUI.LOG_PANE_TITLE);
    private _leoTerminalPane: vscode.OutputChannel | undefined;

    // * Status Bar
    private _leoStatusBar: LeoStatusBar;

    // * Edit/Insert Headline Input Box options instance, setup so clicking outside cancels the headline change
    private _headlineInputOptions: vscode.InputBoxOptions = { ignoreFocusOut: false, value: "", valueSelection: undefined, prompt: "" };

    // * Automatic leobridgeserver startup management service
    private _serverService: ServerService;

    // * Timing
    private _needLastSelectedRefresh = false;
    private _bodyLastChangedDocument: vscode.TextDocument | undefined; // Only set in _onDocumentChanged

    // * Debounced method used to get states for UI display flags (commands such as undo, redo, save, ...)
    public getStates: (() =&gt; void) &amp; {
        clear(): void;
    } &amp; {
        flush(): void;
    };

    // * Debounced method used to get opened Leo Files for the documents pane
    public refreshDocumentsPane: (() =&gt; void) &amp; {
        clear(): void;
    } &amp; {
        flush(): void;
    };

    @others
}
</t>
<t tx="felix.20200719025231.20">/**
 * * Returns the 'busy' state flag of the command stack, and leoBridge stack, while showing a message if it is.
 * Needed by special unstackable commands such as new, open,...
 * @param p_all Flag to also return true if either front command stack or bridge stack is busy
 * @returns true if command stack is busy, also returns true if p_all flag is set and bridge is busy
 */
private _isBusy(p_all?: boolean): boolean {
    if (this._commandStack.size() || (p_all &amp;&amp; this._leoBridge.isBusy())) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.TOO_FAST);
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20200719025231.21">/**
 * * Returns true if the current opened Leo document's filename has some content. (not a new unnamed file)
 */
private _isCurrentFileNamed(): boolean {
    return !!this.leoStates.leoOpenedFileName.length; // checks if it's an empty string
}

</t>
<t tx="felix.20200719025231.22">/**
 * * Setup leoInteg's UI for having no opened Leo documents
 */
private _setupNoOpenedLeoDocument(): void {
    this.leoStates.fileOpenedReady = false;
    this._bodyTextDocument = undefined;
    this.lastSelectedNode = undefined;
    this._refreshOutline(false, RevealType.NoReveal);
    this.refreshDocumentsPane();
    this._leoButtonsProvider.refreshTreeRoot();
    this.closeBody();
}

</t>
<t tx="felix.20200719025231.23">/**
 * * A Leo file was opened: setup leoInteg's UI accordingly.
 * @param p_openFileResult Returned info about currently opened and editing document
 * @return a promise that resolves to an opened body pane text editor
 */
private _setupOpenedLeoDocument(p_openFileResult: LeoBridgePackageOpenedInfo): Promise&lt;vscode.TextEditor&gt; {
    const w_selectedLeoNode = this.apToLeoNode(p_openFileResult.node, false); // Just to get gnx for the body's fist appearance
    this.leoStates.leoOpenedFileName = p_openFileResult.filename;

    // * If not unnamed file add to recent list &amp; last opened list
    this._addRecentAndLastFile(p_openFileResult.filename);

    // * Could be already opened, so perform 'rename hack' as if another node was selected
    if (this._bodyTextDocument &amp;&amp; this.bodyUri) {
        // TODO : BUG WHEN SWITCHING LEO DOCUMENT : NEED CROSSOVER LOGIC!
        this._switchBody(w_selectedLeoNode.gnx, false, true);
    } else {
        this.bodyUri = utils.strToLeoUri(w_selectedLeoNode.gnx);
    }

    // * Start body pane system
    if (!this._bodyFileSystemStarted) {
        this._context.subscriptions.push(
            vscode.workspace.registerFileSystemProvider(Constants.URI_LEO_SCHEME, this._leoFileSystem, { isCaseSensitive: true })
        );
        this._bodyFileSystemStarted = true;
    }
    // * Startup flag
    this.leoStates.fileOpenedReady = true;
    // * Maybe first valid redraw of tree along with the selected node and its body
    this._refreshOutline(true, RevealType.RevealSelectFocus); // p_revealSelection flag set
    // * Maybe first StatusBar appearance
    this._leoStatusBar.update(true, 0, true);
    this._leoStatusBar.show(); // Just selected a node
    // * Show leo log pane
    this.showLogPane();
    // * Send config to python's side (for settings such as defaultReloadIgnore and checkForChangeExternalFiles)
    this.sendConfigToServer(this.config.getConfig());
    // * Refresh Opened tree views
    this.refreshDocumentsPane();
    this._leoButtonsProvider.refreshTreeRoot();
    // * Maybe first Body appearance
    return this.showBody(false);
}

</t>
<t tx="felix.20200719025231.24">/**
 * * Handles the change of vscode config: a onDidChangeConfiguration event triggered
 * @param p_event The configuration-change event passed by vscode
 */
private _onChangeConfiguration(p_event: vscode.ConfigurationChangeEvent): void {
    if (p_event.affectsConfiguration(Constants.CONFIG_NAME)) {
        this.config.buildFromSavedSettings();
    }
    // also check if workbench.editor.enablePreview
    this._bodyEnablePreview = !!vscode.workspace.getConfiguration('workbench.editor').get("enablePreview");
}

</t>
<t tx="felix.20200719025231.25">/**
 * * Handles the node expanding and collapsing interactions by the user in the treeview
 * @param p_event The event passed by vscode
 * @param p_expand True if it was an expand, false if it was a collapse event
 * @param p_treeView Pointer to the treeview itself, either the standalone treeview or the one under the explorer
 */
private _onChangeCollapsedState(p_event: vscode.TreeViewExpansionEvent&lt;LeoNode&gt;, p_expand: boolean, p_treeView: vscode.TreeView&lt;LeoNode&gt;): void {
    // * Expanding or collapsing via the treeview interface selects the node to mimic Leo
    this.triggerBodySave(true);
    if (p_treeView.selection[0] &amp;&amp; p_treeView.selection[0] === p_event.element) {
        // * This happens if the tree selection is the same as the expanded/collapsed node: Just have Leo do the same
        // Pass
    } else {
        // * This part only happens if the user clicked on the arrow without trying to select the node
        this._revealTreeViewNode(p_event.element, { select: true, focus: false }); // No force focus : it breaks collapse/expand when direct parent
        this.selectTreeNode(p_event.element, true);  // not waiting for a .then(...) so not to add any lag
    }
    this.sendAction(p_expand ? Constants.LEOBRIDGE.EXPAND_NODE : Constants.LEOBRIDGE.COLLAPSE_NODE, p_event.element.apJson)
        .then(() =&gt; {
            if (this.config.leoTreeBrowse) {
                this._refreshOutline(true, RevealType.RevealSelect);
            }
        });
}

</t>
<t tx="felix.20200719025231.26">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flag to signify that the treeview who triggered this event is the one in the explorer view
 */
private _onTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_event.visible) {
        this._lastTreeView = p_explorerView ? this._leoTreeExView : this._leoTreeView;
        this.setTreeViewTitle();
        this._needLastSelectedRefresh = true; // Its a new node in a new tree so refresh lastSelectedNode too
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="felix.20200719025231.27">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onDocTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_explorerView) { } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this.refreshDocumentsPane();
    }
}

</t>
<t tx="felix.20200719025231.29">/**
 * * Handles detection of the active editor having changed from one to another, or closed
 * TODO : Make sure the selection in tree if highlighted when a body pane is selected
 * @param p_editor The editor itself that is now active
 * @param p_internalCall Flag used to signify the it was called voluntarily by leoInteg itself
 */
private _onActiveEditorChanged(p_editor: vscode.TextEditor | undefined, p_internalCall?: boolean): void {
    if (p_editor &amp;&amp; p_editor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        if (this.bodyUri.fsPath !== p_editor.document.uri.fsPath) {
            this._hideDeleteBody(p_editor);
        }
        this._checkPreviewMode(p_editor);
    }
    if (!p_internalCall) {
        this.triggerBodySave(true); // Save in case edits were pending
    }
    // * Status flag check
    if (!p_editor &amp;&amp; this._leoStatusBar.statusBarFlag) {
        return;
    }
    // * Status flag check
    if (vscode.window.activeTextEditor) {
        this._leoStatusBar.update(vscode.window.activeTextEditor.document.uri.scheme === Constants.URI_LEO_SCHEME);
    }
}

</t>
<t tx="felix.20200719025231.3">constructor(private _context: vscode.ExtensionContext) {
    // * Setup States
    this.leoStates = new LeoStates(_context, this);

    // * Get configuration settings
    this.config = new Config(_context, this);

    // * also check workbench.editor.enablePreview
    this.config.buildFromSavedSettings();
    this._bodyEnablePreview = !!vscode.workspace.getConfiguration('workbench.editor').get("enablePreview");

    // * Build Icon filename paths
    this.nodeIcons = utils.buildNodeIconPaths(_context);
    this.documentIcons = utils.buildDocumentIconPaths(_context);
    this.buttonIcons = utils.buildButtonsIconPaths(_context);

    // * Create file browser instance
    this._leoFilesBrowser = new LeoFilesBrowser(_context);

    // * Setup leoBridge
    this._leoBridge = new LeoBridge(_context, this);

    // * Setup frontend command stack
    this._commandStack = new CommandStack(_context, this);

    // * Create a single data provider for both outline trees, Leo view and Explorer view
    this._leoTreeProvider = new LeoOutlineProvider(this);

    // * Create Leo stand-alone view and Explorer view outline panes
    // Uses 'select node' command, so 'onDidChangeSelection' is not used
    this._leoTreeView = vscode.window.createTreeView(Constants.TREEVIEW_ID, { showCollapseAll: false, treeDataProvider: this._leoTreeProvider });
    this._leoTreeView.onDidExpandElement((p_event =&gt; this._onChangeCollapsedState(p_event, true, this._leoTreeView)));
    this._leoTreeView.onDidCollapseElement((p_event =&gt; this._onChangeCollapsedState(p_event, false, this._leoTreeView)));
    this._leoTreeView.onDidChangeVisibility((p_event =&gt; this._onTreeViewVisibilityChanged(p_event, false))); // * Trigger 'show tree in Leo's view'
    this._leoTreeExView = vscode.window.createTreeView(Constants.TREEVIEW_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoTreeProvider });
    this._leoTreeExView.onDidExpandElement((p_event =&gt; this._onChangeCollapsedState(p_event, true, this._leoTreeExView)));
    this._leoTreeExView.onDidCollapseElement((p_event =&gt; this._onChangeCollapsedState(p_event, false, this._leoTreeExView)));
    this._leoTreeExView.onDidChangeVisibility((p_event =&gt; this._onTreeViewVisibilityChanged(p_event, true))); // * Trigger 'show tree in explorer view'
    this._lastTreeView = this.config.treeInExplorer ? this._leoTreeExView : this._leoTreeView;

    // * Create Leo Opened Documents Treeview Providers and tree views
    this._leoDocumentsProvider = new LeoDocumentsProvider(this);
    this._leoDocuments = vscode.window.createTreeView(Constants.DOCUMENTS_ID, { showCollapseAll: false, treeDataProvider: this._leoDocumentsProvider });
    this._leoDocuments.onDidChangeVisibility((p_event =&gt; this._onDocTreeViewVisibilityChanged(p_event, false)));
    this._leoDocumentsExplorer = vscode.window.createTreeView(Constants.DOCUMENTS_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoDocumentsProvider });
    this._leoDocumentsExplorer.onDidChangeVisibility((p_event =&gt; this._onDocTreeViewVisibilityChanged(p_event, true)));

    // * Create '@buttons' Treeview Providers and tree views
    this._leoButtonsProvider = new LeoButtonsProvider(this);
    this._leoButtons = vscode.window.createTreeView(Constants.BUTTONS_ID, { showCollapseAll: false, treeDataProvider: this._leoButtonsProvider });
    this._leoButtons.onDidChangeVisibility((p_event =&gt; this._onButtonsTreeViewVisibilityChanged(p_event, false)));
    this._leoButtonsExplorer = vscode.window.createTreeView(Constants.BUTTONS_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoButtonsProvider });
    this._leoButtonsExplorer.onDidChangeVisibility((p_event =&gt; this._onButtonsTreeViewVisibilityChanged(p_event, true)));

    // * Create Body Pane
    this._leoFileSystem = new LeoBodyProvider(this);
    this._bodyMainSelectionColumn = 1;

    // * Create Status bar Entry
    this._leoStatusBar = new LeoStatusBar(_context, this);

    // * Automatic server start service
    this._serverService = new ServerService(_context, this);

    // * React to change in active panel/text editor (window.activeTextEditor) - also fires when the active editor becomes undefined
    vscode.window.onDidChangeActiveTextEditor(p_editor =&gt; this._onActiveEditorChanged(p_editor));

    // * React to change in selection, cursor position and scroll position
    vscode.window.onDidChangeTextEditorSelection(p_event =&gt; this._onChangeEditorSelection(p_event));
    vscode.window.onDidChangeTextEditorVisibleRanges((p_event =&gt; this._onChangeEditorScroll(p_event)));

    // * Triggers when a different text editor/vscode window changed focus or visibility, or dragged
    // This is also what triggers after drag and drop, see '_onChangeEditorViewColumn'
    vscode.window.onDidChangeTextEditorViewColumn((p_columnChangeEvent) =&gt; this._changedTextEditorViewColumn(p_columnChangeEvent)); // Also triggers after drag and drop
    vscode.window.onDidChangeVisibleTextEditors((p_editors) =&gt; this._changedVisibleTextEditors(p_editors)); // Window.visibleTextEditors changed
    vscode.window.onDidChangeWindowState((p_windowState) =&gt; this._changedWindowState(p_windowState)); // Focus state of the current window changes

    // * React when typing and changing body pane
    vscode.workspace.onDidChangeTextDocument(p_textDocumentChange =&gt; this._onDocumentChanged(p_textDocumentChange));

    // * React to configuration settings events
    vscode.workspace.onDidChangeConfiguration(p_configChange =&gt; this._onChangeConfiguration(p_configChange));

    // * React to opening of any file in vscode
    vscode.workspace.onDidOpenTextDocument(p_document =&gt; this._onDidOpenTextDocument(p_document));

    // * Debounced refresh flags and UI parts, other than the tree and body, when operation(s) are done executing
    this.getStates = debounce(this._triggerGetStates, Constants.STATES_DEBOUNCE_DELAY);
    this.refreshDocumentsPane = debounce(this._refreshDocumentsPane, Constants.DOCUMENTS_DEBOUNCE_DELAY);
}

</t>
<t tx="felix.20200719025231.31">/**
 * * Handle typing that was detected in a document
 * @param p_textDocumentChange Text changed event passed by vscode
 */
private _onDocumentChanged(p_textDocumentChange: vscode.TextDocumentChangeEvent): void {
    // ".length" check necessary, see https://github.com/microsoft/vscode/issues/50344
    if (this.lastSelectedNode &amp;&amp; p_textDocumentChange.contentChanges.length &amp;&amp; (p_textDocumentChange.document.uri.scheme === Constants.URI_LEO_SCHEME)) {

        // * There was an actual change on a Leo Body by the user
        this._bodyLastChangedDocument = p_textDocumentChange.document;
        this._bodyPreviewMode = false;
        this._fromOutline = false; // Focus is on body pane

        // * If icon should change then do it now (if there's no document edit pending)
        if (!this._currentDocumentChanged || utils.leoUriToStr(p_textDocumentChange.document.uri) === this.lastSelectedNode.gnx) {
            const w_hasBody = !!(p_textDocumentChange.document.getText().length);
            if (utils.isIconChangedByEdit(this.lastSelectedNode, w_hasBody)) {
                this._bodySaveDocument(p_textDocumentChange.document)
                    .then(() =&gt; {
                        if (this.lastSelectedNode) {
                            this.lastSelectedNode.dirty = true;
                            this.lastSelectedNode.hasBody = w_hasBody;
                            // NOT incrementing this.treeID to keep ids intact
                        }
                        // NoReveal since we're keeping the same id.
                        this._refreshOutline(false, RevealType.NoReveal);
                    });
            }
        }
    }
}

</t>
<t tx="felix.20200719025231.32">/**
 * * Save body to Leo if its dirty. That is, only if a change has been made to the body 'document' so far
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the possible saving process is finished
 */
public triggerBodySave(p_forcedVsCodeSave?: boolean): Promise&lt;boolean&gt; {
    // * Save body to Leo if a change has been made to the body 'document' so far
    if (this._bodyLastChangedDocument &amp;&amp; this._bodyLastChangedDocument.isDirty) {
        const w_document = this._bodyLastChangedDocument; // backup for bodySaveDocument before reset
        this._bodyLastChangedDocument = undefined; // reset to make falsy
        return this._bodySaveDocument(w_document, p_forcedVsCodeSave);
    } else {
        this._bodyLastChangedDocument = undefined;
        return this._bodySaveSelection();
    }
}

</t>
<t tx="felix.20200719025231.33">/**
 * * Sets new body text on leo's side, and may optionally save vsCode's body editor (which will trim spaces)
 * @param p_document Vscode's text document which content will be used to be the new node's body text in Leo
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the complete saving process is finished
 */
private _bodySaveDocument(p_document: vscode.TextDocument, p_forcedVsCodeSave?: boolean): Promise&lt;boolean&gt; {
    if (p_document) {
        // * Fetch gnx and document's body text first, to be reused more than once in this method
        const w_param = {
            gnx: utils.leoUriToStr(p_document.uri),
            body: p_document.getText()
        };
        this.sendAction(Constants.LEOBRIDGE.SET_BODY, JSON.stringify(w_param)); // Don't wait for promise
        // This bodySaveSelection is placed on the stack right after saving body, returns promise either way
        return this._bodySaveSelection()
            .then(() =&gt; {
                this._refreshType.states = true;
                this.getStates();
                if (p_forcedVsCodeSave) {
                    return p_document.save(); // ! USED INTENTIONALLY: This trims trailing spaces
                }
                return Promise.resolve(p_document.isDirty);
            });
    } else {
        return Promise.resolve(false);
    }
}

</t>
<t tx="felix.20200719025231.34">/**
 * * Places selection on the required node with a 'timeout'. Used after refreshing the opened Leo documents view.
 * @param p_documentNode Document node instance in the Leo document view to be the 'selected' one.
 */
public setDocumentSelection(p_documentNode: LeoDocumentNode): void {
    this._currentDocumentChanged = p_documentNode.documentEntry.changed;
    this.leoStates.leoOpenedFileName = p_documentNode.documentEntry.name;
    @others
    setTimeout(() =&gt; {
        if (!this._leoDocuments.visible &amp;&amp; !this._leoDocumentsExplorer.visible) {
            return;
        }
        let w_trigger = false;
        let w_docView: vscode.TreeView&lt;LeoDocumentNode&gt;;
        if (this._leoDocuments.visible) {
            w_docView = this._leoDocuments;
        } else {
            w_docView = this._leoDocumentsExplorer;
        }
        if (w_docView.selection.length &amp;&amp; w_docView.selection[0] === p_documentNode) {
            // console.log('already selected!');
        } else {
            w_trigger = true;
        }
        if (w_trigger) {
            w_docView.reveal(p_documentNode, { select: true, focus: false });
        }
    });
}

</t>
<t tx="felix.20200719025231.35">/**
 * * Show the outline, with Leo's selected node also selected, and optionally focussed
 * @param p_focusOutline Flag for focus to be placed in outline
 */
public showOutline(p_focusOutline?: boolean): void {
    if (this.lastSelectedNode) {
        this._lastTreeView.reveal(this.lastSelectedNode, {
            select: true,
            focus: p_focusOutline
        });
    }
}

</t>
<t tx="felix.20200719025231.38">/**
 * * Converts an archived position object to a LeoNode instance
 * @param p_ap The archived position to convert
 * @param p_revealSelected Flag that will trigger the node to reveal, select, and focus if its selected node in Leo
 * @param p_specificNode Other specific LeoNode to be used to override when revealing the the selected node is encountered
 */
public apToLeoNode(p_ap: ArchivedPosition, p_revealSelected?: boolean, p_specificNode?: LeoNode): LeoNode {
    let w_collapse: vscode.TreeItemCollapsibleState = vscode.TreeItemCollapsibleState.None;
    if (p_ap.hasChildren) {
        w_collapse = p_ap.expanded ? vscode.TreeItemCollapsibleState.Expanded : vscode.TreeItemCollapsibleState.Collapsed;
    }
    // * Unknown attributes are one-way read-only data, don't carry this in for string key for leo/python side of things
    let w_u = false;
    if (p_ap.u) {
        w_u = p_ap.u;
        delete p_ap.u;
    }
    const w_leoNode = new LeoNode(
        p_ap.headline,          // label-headline
        p_ap.gnx,               // gnx
        w_collapse,             // collapsibleState
        JSON.stringify(p_ap),   // string key for leo/python side of things
        p_ap.childIndex,        // childIndex
        !!p_ap.cloned,          // cloned
        !!p_ap.dirty,           // dirty
        !!p_ap.marked,          // marked
        !!p_ap.atFile,          // atFile
        !!p_ap.hasBody,         // hasBody
        w_u,                    // unknownAttributes
        this,                   // _leoIntegration pointer
        utils.hashNode(p_ap, this._treeId.toString(36))
    );
    if (p_revealSelected &amp;&amp; this._revealType &amp;&amp; p_ap.selected) {
        this._apToLeoNodeConvertReveal(p_specificNode ? p_specificNode : w_leoNode);
    }
    return w_leoNode;
}

</t>
<t tx="felix.20200719025231.39">/**
 * * Reveals the node that was detected as being the selected one while converting from archived positions
 * Also select it, or focus on it too depending on global this._revealType variable
 * @param p_leoNode The node that was detected as the selected node in Leo
 */
private _apToLeoNodeConvertReveal(p_leoNode: LeoNode): void {
    this.leoStates.setSelectedNodeFlags(p_leoNode);
    // First setup flags for selecting and focusing based on the current reveal type needed
    const w_selectFlag = this._revealType &gt;= RevealType.RevealSelect; // at least RevealSelect
    let w_focusFlag = this._revealType &gt;= RevealType.RevealSelectFocus;  // at least RevealSelectFocus
    // Flags are setup so now reveal, select and / or focus as needed
    this._revealType = RevealType.NoReveal; // ok reset
    // If first time, or when treeview switched, lastSelectedNode will be undefined
    if (!this.lastSelectedNode || this._needLastSelectedRefresh) {
        this._needLastSelectedRefresh = false;
        this.lastSelectedNode = p_leoNode; // special case only: lastSelectedNode should be set in selectTreeNode
    }
    setTimeout(() =&gt; {
        // TODO : MAKE SURE TIMEOUT IS REALLY REQUIRED
        this._revealTreeViewNode(p_leoNode, { select: w_selectFlag, focus: w_focusFlag })
            .then(() =&gt; {
                // console.log('did this ask for parent?', p_leoNode.id, p_leoNode.label); // ! debug
                if (w_selectFlag) {
                    this._gotSelection(p_leoNode);
                }
            });
    });
}

</t>
<t tx="felix.20200719025231.4"></t>
<t tx="felix.20200719025231.40">/**
 * * Converts an array of 'ap' to an array of leoNodes.  This is used in 'getChildren' of leoOutline.ts
 * @param p_array Array of archived positions to be converted to leoNodes for the vscode treeview
 */
public arrayToLeoNodesArray(p_array: ArchivedPosition[]): LeoNode[] {
    const w_leoNodesArray: LeoNode[] = [];
    for (let w_apData of p_array) {
        const w_leoNode = this.apToLeoNode(w_apData, true);
        w_leoNodesArray.push(w_leoNode);
    }
    return w_leoNodesArray;
}

</t>
<t tx="felix.20200719025231.47">/**
 * * Close body pane document and change the bodyUri
 * This blocks 'undos' from crossing over
 * @param p_newGnx New gnx body id to switch to
 */
private _switchBody(p_newGnx: string, p_aside: boolean, p_preserveFocus?: boolean): Thenable&lt;vscode.TextEditor&gt; {

    const w_oldUri: vscode.Uri = this.bodyUri;

    // ? Set timestamps ?
    // this._leoFileSystem.setRenameTime(p_newGnx);

    if (this._bodyPreviewMode &amp;&amp; this._bodyEnablePreview) {
        // just show in same column and delete after
        this.bodyUri = utils.strToLeoUri(p_newGnx);
        const q_showBody = this.showBody(p_aside, p_preserveFocus);
        vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_oldUri.path);
        return q_showBody;
    } else {
        // Gotta delete to close all and re-open, so:
        // Promise to Delete first, synchronously (as thenable),
        // tagged along with automatically removeFromRecentlyOpened in parallel
        const w_edit = new vscode.WorkspaceEdit();
        w_edit.deleteFile(w_oldUri, { ignoreIfNotExists: true });
        return vscode.workspace.applyEdit(w_edit)
            .then(() =&gt; {
                // Set new uri and remove from 'Recently opened'
                this._bodyPreviewMode = true;
                this.bodyUri = utils.strToLeoUri(p_newGnx);
                // async, so don't wait for this to finish
                if (w_oldUri.fsPath !== this.bodyUri.fsPath) {
                    vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_oldUri.path);
                }
                return this.showBody(p_aside, p_preserveFocus);
            });
    }
}

</t>
<t tx="felix.20200719025231.48">/**
 * * Sets globals if the current body is found opened in an editor panel for a particular gnx
 * @param p_gnx gnx to match
 */
private _locateOpenedBody(p_gnx: string): boolean {
    let w_found = false;
    // * Only gets to visible editors, not every tab per editor
    vscode.window.visibleTextEditors.forEach(p_textEditor =&gt; {
        if (utils.leoUriToStr(p_textEditor.document.uri) === p_gnx) {
            w_found = true;
            this._bodyTextDocument = p_textEditor.document;
            this._bodyMainSelectionColumn = p_textEditor.viewColumn;
        }
    });
    return w_found;
}

</t>
<t tx="felix.20200719025231.49">/**
 * * Closes any body pane opened in this vscode window instance
 */
public closeBody(): void {
    // TODO : CLEAR UNDO HISTORY AND FILE HISTORY for this.bodyUri !
    if (this.bodyUri) {
        vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', this.bodyUri.path);
    }
    vscode.window.visibleTextEditors.forEach(p_textEditor =&gt; {
        if (p_textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
            vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', p_textEditor.document.uri.path);
            if (p_textEditor.hide) {
                p_textEditor.hide();
            }
        }
    });
}

</t>
<t tx="felix.20200719025231.5">/**
 * * Core of the integration of Leo into vscode: Sends an action to leobridgeserver.py, to run in Leo.
 * @param p_action is the action string constant, from Constants.LEOBRIDGE
 * @param p_jsonParam (optional) JSON string to be given to the python script action call
 * @param p_deferredPayload (optional) a pre-made package that will be given back as the response, instead of package coming back from python
 * @param p_preventCall (optional) Flag for special case, only used at startup
 * @returns a Promise that will contain the JSON package answered back by leobridgeserver.py
 */
public sendAction(p_action: string, p_jsonParam = "null", p_deferredPayload?: LeoBridgePackage, p_preventCall?: boolean): Promise&lt;LeoBridgePackage&gt; {
    return this._leoBridge.action(p_action, p_jsonParam, p_deferredPayload, p_preventCall);
}

</t>
<t tx="felix.20200719025231.50">/**
 * * Opens an an editor for the currently selected node: "this.bodyUri". If already opened, this just 'reveals' it
 * @param p_aside Flag for opening the editor beside any currently opened and focused editor
 * @param p_preserveFocus flag that when true will stop the editor from taking focus once opened
 */
public showBody(p_aside: boolean, p_preserveFocus?: boolean): Promise&lt;vscode.TextEditor&gt; {

    // First setup timeout asking for gnx file refresh in case we were resolving a refresh of type 'RefreshTreeAndBody'
    if (this._refreshType.body) {
        this._refreshType.body = false;
        // TODO : CHECK IF TIMEOUT NECESSARY!
        setTimeout(() =&gt; {
            this._leoFileSystem.fireRefreshFile(utils.leoUriToStr(this.bodyUri));
        }, 0);
    }

    if (this._preventShowBody) {
        this._preventShowBody = false;
        return Promise.resolve(vscode.window.activeTextEditor!);
    }

    return Promise.resolve(vscode.workspace.openTextDocument(this.bodyUri)).then(p_document =&gt; {

        this._bodyTextDocument = p_document;

        // * Set document language along with the proper cursor position, selection range and scrolling position
        this._setLanguageAndSelection(this._bodyTextDocument);

        // Find body pane's position if already opened
        vscode.window.visibleTextEditors.forEach(p_textEditor =&gt; {
            if (p_textEditor.document.uri.fsPath === p_document.uri.fsPath) {
                this._bodyMainSelectionColumn = p_textEditor.viewColumn;
                this._bodyTextDocument = p_textEditor.document;
            }
        });
        // Setup options for the preview state of the opened editor, and to choose which column it should appear
        const w_showOptions: vscode.TextDocumentShowOptions = p_aside ?
            {
                viewColumn: vscode.ViewColumn.Beside,
                preserveFocus: p_preserveFocus, // an optional flag that when true will stop the editor from taking focus
                preview: true // should text document be in preview only? set false for fully opened
                // selection is instead set when the GET_BODY_STATES above resolves
            } : {
                viewColumn: this._bodyMainSelectionColumn ? this._bodyMainSelectionColumn : 1, // view column in which the editor should be shown
                preserveFocus: p_preserveFocus, // an optional flag that when true will stop the editor from taking focus
                preview: true // should text document be in preview only? set false for fully opened
                // selection is instead set when the GET_BODY_STATES above resolves
            };

        // NOTE: textEditor.show() is deprecated — Use window.showTextDocument instead.
        return vscode.window.showTextDocument(this._bodyTextDocument, w_showOptions).then(w_bodyEditor =&gt; {
            // TODO : #38 if position is in an derived file node show relative position
            // w_bodyEditor.options.lineNumbers = OFFSET;
            return Promise.resolve(w_bodyEditor);
        });
    });
}

</t>
<t tx="felix.20200719025231.51"></t>
<t tx="felix.20200719025231.52">/**
 * * Select a tree node. Either called from user interaction, or used internally (p_internalCall flag)
 * @param p_node Node that was just selected
 * @param p_internalCall Flag used to indicate the selection is forced, and NOT originating from user interaction
 * @param p_aside Flag to force opening the body "Aside", i.e. when the selection was made from choosing "Open Aside"
 * @returns a promise with the package gotten back from Leo when asked to select the tree node
 */
public selectTreeNode(p_node: LeoNode, p_internalCall?: boolean, p_aside?: boolean): Promise&lt;LeoBridgePackage | vscode.TextEditor&gt; {

    this.triggerBodySave(true);

    // * check if used via context menu's "open-aside" on an unselected node: check if p_node is currently selected, if not select it
    if (p_aside &amp;&amp; p_node !== this.lastSelectedNode) {
        this._revealTreeViewNode(p_node, { select: true, focus: false }); // no need to set focus: tree selection is set to right-click position
    }

    this.leoStates.setSelectedNodeFlags(p_node);
    this._leoStatusBar.update(true); // Just selected a node directly, or via expand/collapse
    const w_showBodyKeepFocus = p_aside ? this.config.treeKeepFocusWhenAside : this.config.treeKeepFocus;

    // * Check if having already this exact node position selected : Just show the body and exit
    // (other tree nodes with same gnx may have different syntax language coloring because of parents lineage)
    if (p_node === this.lastSelectedNode) {
        this._locateOpenedBody(p_node.gnx); // LOCATE NEW GNX
        return this.showBody(!!p_aside, w_showBodyKeepFocus); // Voluntary exit
    }

    // * Set selected node in Leo via leoBridge
    const q_setSelectedNode = this.sendAction(Constants.LEOBRIDGE.SET_SELECTED_NODE, p_node.apJson)
        .then((p_setSelectedResult) =&gt; {
            if (!p_internalCall) {
                this._refreshType.states = true;
                this.getStates();
            }
            return p_setSelectedResult;
        });

    // * Apply the node to the body text without waiting for the selection promise to resolve
    this._tryApplyNodeToBody(p_node, !!p_aside, w_showBodyKeepFocus, true);
    return q_setSelectedNode;
}

</t>
<t tx="felix.20200719025231.54">/**
 * * Changes the marked state of a specified, or currently selected node
 * @param p_isMark Set 'True' to mark, otherwise unmarks the node
 * @param p_node Specifies which node use, or leave undefined to mark or unmark the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 */
public changeMark(p_isMark: boolean, p_node?: LeoNode, p_fromOutline?: boolean): Promise&lt;LeoBridgePackage&gt; {
    // No need to wait for body-save trigger for marking/un-marking a node
    const q_commandResult = this.nodeCommand({
        action: p_isMark ? Constants.LEOBRIDGE.MARK_PNODE : Constants.LEOBRIDGE.UNMARK_PNODE,
        node: p_node,
        refreshType: { tree: true },
        fromOutline: !!p_fromOutline
    });
    if (q_commandResult) {
        if (!p_node || p_node === this.lastSelectedNode) {
            utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_isMark);
        }
        return q_commandResult;
    } else {
        return Promise.reject("Change mark on node not added on command stack");
    }
}

</t>
<t tx="felix.20200719025231.55">/**
 * * Asks for a new headline label, and replaces the current label with this new one one the specified, or currently selected node
 * @param p_node Specifies which node to rename, or leave undefined to rename the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 */
public editHeadline(p_node?: LeoNode, p_fromOutline?: boolean): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(false, true)
        .then(() =&gt; {
            if (!p_node &amp;&amp; this.lastSelectedNode) {
                p_node = this.lastSelectedNode; // Gets last selected node if called via keyboard shortcut or command palette (not set in command stack class)
            }
            if (p_node) {
                this._headlineInputOptions.prompt = Constants.USER_MESSAGES.PROMPT_EDIT_HEADLINE;
                this._headlineInputOptions.value = p_node.label; // preset input pop up
                return vscode.window.showInputBox(this._headlineInputOptions);
            } else {
                return Promise.reject("No node selected");
            }
        })
        .then(p_newHeadline =&gt; {
            if (p_newHeadline) {
                p_node!.label = p_newHeadline; // ! When labels change, ids will change and its selection and expansion states cannot be kept stable anymore.
                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.SET_HEADLINE,
                    node: p_node,
                    refreshType: { tree: true, states: true },
                    fromOutline: !!p_fromOutline,
                    text: p_newHeadline
                });
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject("Edit Headline not added on command stack");
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20200719025231.56">/**
 * * Asks for a headline label to be entered and creates (inserts) a new node under the current, or specified, node
 * @param p_node specified under which node to insert, or leave undefined to use whichever is currently selected
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_interrupt Signifies the insert action is actually interrupting itself (e.g. rapid CTRL+I actions by the user)
 */
public insertNode(p_node?: LeoNode, p_fromOutline?: boolean, p_interrupt?: boolean): Promise&lt;LeoBridgePackage&gt; {
    let w_fromOutline: boolean = !!p_fromOutline; // Use w_fromOutline for where we intend to leave focus when done with the insert
    if (p_interrupt) {
        this._focusInterrupt = true;
        w_fromOutline = this._fromOutline; // Going to use last state
    }
    // if no node parameter, the front command stack CAN be busy, but if a node is passed, stack must be free
    if (!p_node || !this._isBusy()) {
        this.triggerBodySave(true); // Don't wait for saving to resolve because we're waiting for user input anyways
        this._headlineInputOptions.prompt = Constants.USER_MESSAGES.PROMPT_INSERT_NODE;
        this._headlineInputOptions.value = Constants.USER_MESSAGES.DEFAULT_HEADLINE;
        return new Promise&lt;LeoBridgePackage&gt;((p_resolve, p_reject) =&gt; {
            vscode.window.showInputBox(this._headlineInputOptions)
                .then(p_newHeadline =&gt; {
                    const w_action = p_newHeadline ? Constants.LEOBRIDGE.INSERT_NAMED_PNODE : Constants.LEOBRIDGE.INSERT_PNODE;
                    const q_commandResult = this.nodeCommand({
                        action: w_action,
                        node: p_node,
                        refreshType: { tree: true, states: true },
                        fromOutline: w_fromOutline,
                        text: p_newHeadline
                    });
                    if (q_commandResult) {
                        q_commandResult.then(p_package =&gt; p_resolve(p_package));
                    } else {
                        p_reject(w_action + " not added on command stack");
                    }
                });
        });
    } else {
        return Promise.reject("Insert node not added on command stack");
    }
}

</t>
<t tx="felix.20200719025231.57"></t>
<t tx="felix.20200719025231.58">/**
 * * Asks for file name and path, then saves the Leo file
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 */
public saveAsLeoFile(p_fromOutline?: boolean): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
                return this._leoFilesBrowser.getLeoFileUrl(true);
            } else {
                // 'when-conditions' should prevent this
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            }
        })
        .then((p_chosenLeoFile) =&gt; {
            if (p_chosenLeoFile.trim()) {
                const w_hasDot = p_chosenLeoFile.indexOf('.') !== -1;
                if (!w_hasDot || (p_chosenLeoFile.split('.').pop() !== Constants.FILE_EXTENSION &amp;&amp; w_hasDot)) {
                    if (!p_chosenLeoFile.endsWith(".")) {
                        p_chosenLeoFile += "."; // Add dot if needed
                    }
                    p_chosenLeoFile += Constants.FILE_EXTENSION; // Add extension
                }
                if (this.leoStates.leoOpenedFileName) {
                    this._removeLastFile(this.leoStates.leoOpenedFileName);
                    this._removeRecentFile(this.leoStates.leoOpenedFileName);
                }
                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.SAVE_FILE,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    fromOutline: !!p_fromOutline,
                    text: p_chosenLeoFile
                });
                this.leoStates.leoOpenedFileName = p_chosenLeoFile.trim();
                this._leoStatusBar.update(true, 0, true);
                this._addRecentAndLastFile(p_chosenLeoFile.trim());
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject("Save file not added on command stack");
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20200719025231.59">/**
 * * Invokes the self.commander.save() Leo command
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns Promise that resolves when the save command is placed on the front-end command stack
 */
public saveLeoFile(p_fromOutline?: boolean): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (this.leoStates.fileOpenedReady) {
                if (this.lastSelectedNode &amp;&amp; this._isCurrentFileNamed()) {
                    const q_commandResult = this.nodeCommand({
                        action: Constants.LEOBRIDGE.SAVE_FILE,
                        node: undefined,
                        refreshType: { tree: true, states: true, documents: true },
                        fromOutline: !!p_fromOutline,
                        text: ""
                    });
                    return q_commandResult ? q_commandResult : Promise.reject("Save file not added on command stack");
                } else {
                    return this.saveAsLeoFile(p_fromOutline); // Override this command call if file is unnamed!
                }
            } else {
                // 'when-conditions' should prevent this
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            }
        });
}


</t>
<t tx="felix.20200719025231.6">/**
 * * leoInteg starting entry point
 * Starts a leoBridge server, and/or establish a connection to a server, based on config settings.
 */
public startNetworkServices(): void {
    // * Check settings and start a server accordingly
    if (this.config.startServerAutomatically) {
        this.startServer();
    } else {
        // * (via settings) Connect to Leo Bridge server automatically without starting one first
        if (this.config.connectToServerAutomatically) {
            this.connect();
        }
    }
}

</t>
<t tx="felix.20200719025231.60">/**
 * * Show switch document 'QuickPick' dialog and switch file if selection is made, or just return if no files are opened.
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly selected document
 */
public switchLeoFile(): Promise&lt;vscode.TextEditor | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.GET_OPENED_FILES);
        })
        .then((p_package) =&gt; {
            const w_entries: ChooseDocumentItem[] = []; // Entries to offer as choices.
            const w_files: LeoDocument[] = p_package.openedFiles!.files;
            const w_selectedIndex: number = p_package.openedFiles!.index;
            let w_index: number = 0;
            let w_currentlySelected = "";  // ? not used elsewhere ?
            if (w_files &amp;&amp; w_files.length) {
                w_files.forEach(function (p_filePath: LeoDocument) {
                    if (w_index === w_selectedIndex) {
                        w_currentlySelected = p_filePath.name; // ? not used elsewhere ?
                    }
                    w_entries.push({
                        label: w_index.toString(),
                        description: p_filePath.name ? p_filePath.name : Constants.UNTITLED_FILE_NAME,
                        value: w_index,
                        alwaysShow: true
                    });
                    w_index++;
                });
                const w_pickOptions: vscode.QuickPickOptions = {
                    matchOnDescription: true,
                    placeHolder: Constants.USER_MESSAGES.CHOOSE_OPENED_FILE
                };
                return vscode.window.showQuickPick(w_entries, w_pickOptions);
            } else {
                // "No opened documents"
                return Promise.resolve(undefined);
            }
        })
        .then((p_chosenDocument) =&gt; {
            if (p_chosenDocument) {
                return Promise.resolve(this.selectOpenedLeoDocument(p_chosenDocument.value));
            } else {
                // Canceled
                return Promise.resolve(undefined);

            }
        });
}

</t>
<t tx="felix.20200719025231.61">/**
 * * Switches Leo document directly by index number. Used by document treeview and switchLeoFile command.
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly opened document
 */
public selectOpenedLeoDocument(p_index: number): Promise&lt;vscode.TextEditor&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.SET_OPENED_FILE, JSON.stringify({ "index": p_index }));
        })
        .then((p_openFileResult: LeoBridgePackage) =&gt; {
            // Like we just opened or made a new file
            if (p_openFileResult.setOpened) {
                return this._setupOpenedLeoDocument(p_openFileResult.setOpened);
            } else {
                console.log('Select Opened Leo File Error');
                return Promise.reject('Select Opened Leo File Error');
            }
        });
}

</t>
<t tx="felix.20200719025231.64">/**
 * * Close an opened Leo file
 * @returns the launchRefresh promise started after it's done closing the Leo document
 */
public closeLeoFile(): Promise&lt;boolean&gt; {
    let w_removeLastFileName: string = "";
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (!this.leoStates.fileOpenedReady) {
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLOSE_ERROR);
                return Promise.reject(Constants.USER_MESSAGES.CLOSE_ERROR);
            }
            w_removeLastFileName = this.leoStates.leoOpenedFileName;
            return this.sendAction(Constants.LEOBRIDGE.CLOSE_FILE, JSON.stringify({ forced: false }));
        })
        .then((p_tryCloseResult =&gt; {
            if (p_tryCloseResult.closed) {
                this._removeLastFile(w_removeLastFileName);
                if (p_tryCloseResult.closed.total === 0) {
                    this._setupNoOpenedLeoDocument();
                } else {
                    this.launchRefresh({ tree: true, body: true, documents: true, buttons: true, states: true }, false);
                }
                return Promise.resolve(true);
            } else if (p_tryCloseResult.closed === false) {
                // Explicitly false and not just undefined : FILE IS DIRTY
                const q_askSaveChangesInfoMessage: Thenable&lt;vscode.MessageItem | undefined&gt; = vscode.window.showInformationMessage(
                    Constants.USER_MESSAGES.SAVE_CHANGES + ' ' +
                    this.leoStates.leoOpenedFileName + ' ' +
                    Constants.USER_MESSAGES.BEFORE_CLOSING,
                    { modal: true },
                    ...Constants.ASK_SAVE_CHANGES_BUTTONS
                );
                return Promise.resolve(q_askSaveChangesInfoMessage)
                    .then((p_askSaveResult: vscode.MessageItem | undefined) =&gt; {
                        if (p_askSaveResult) {
                            if (p_askSaveResult.title === Constants.USER_MESSAGES.YES) {
                                // save and then force-close
                                let w_savePromise: Promise&lt;LeoBridgePackage | undefined&gt;;
                                if (this._isCurrentFileNamed()) {
                                    w_savePromise = this.sendAction(Constants.LEOBRIDGE.SAVE_FILE, JSON.stringify({ text: "" }));
                                } else {
                                    w_savePromise = this._leoFilesBrowser.getLeoFileUrl(true).then((p_chosenLeoFile) =&gt; {
                                        if (p_chosenLeoFile.trim()) {
                                            return this.sendAction(Constants.LEOBRIDGE.SAVE_FILE, JSON.stringify({ text: p_chosenLeoFile.trim() }));
                                        } else {
                                            // Canceled
                                            return Promise.resolve(undefined);
                                        }
                                    });
                                }
                                return w_savePromise
                                    .then((p_packageAfterSave) =&gt; {
                                        return this.sendAction(Constants.LEOBRIDGE.CLOSE_FILE, JSON.stringify({ forced: true }));
                                    }, () =&gt; {
                                        return Promise.reject("Save failed");
                                    });
                            } else if (p_askSaveResult.title === Constants.USER_MESSAGES.NO) {
                                // Don't want to save so just force-close directly
                                return this.sendAction(Constants.LEOBRIDGE.CLOSE_FILE, JSON.stringify({ forced: true }));
                            } else {
                                // Canceled
                                return Promise.resolve(undefined);
                            }
                        } else {
                            // Canceled
                            return Promise.resolve(undefined);
                        }
                    })
                    .then((p_closeResult: LeoBridgePackage | undefined) =&gt; {
                        if (p_closeResult) {
                            // * back from CLOSE_FILE action, the last that can be performed (after saving if dirty or not)
                            this._removeLastFile(w_removeLastFileName);
                            if (p_closeResult &amp;&amp; p_closeResult.closed &amp;&amp; p_closeResult.closed.total === 0) {
                                this._setupNoOpenedLeoDocument();
                            } else {
                                this.launchRefresh({ tree: true, body: true, documents: true, buttons: true, states: true }, false);
                            }
                            return Promise.resolve(true);
                        }
                        // Canceled
                        return Promise.resolve(false);
                    });
            }
            // else 'close' is undefined
            return Promise.reject("Close command failed");
        }));
}

</t>
<t tx="felix.20200719025231.65">/**
 * * Creates a new untitled Leo document
 * * If not shown already, it also shows the outline, body and log panes along with leaving focus in the outline
 * @returns A promise that resolves with a textEditor of the new file
 */
public newLeoFile(): Promise&lt;vscode.TextEditor&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.OPEN_FILE, '""');
        })
        .then((p_openFileResult: LeoBridgePackage) =&gt; {
            if (p_openFileResult.opened) {
                return this._setupOpenedLeoDocument(p_openFileResult.opened);
            } else {
                return Promise.reject('New Leo File Error');
            }
        });
}

</t>
<t tx="felix.20200719025231.66">/**
 * * Shows an 'Open Leo File' dialog window and opens the chosen file
 * * If not shown already, it also shows the outline, body and log panes along with leaving focus in the outline
 * @returns A promise that resolves with a textEditor of the chosen file
 */
public openLeoFile(p_leoFileUri?: vscode.Uri): Promise&lt;vscode.TextEditor | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            let q_openedFile: Promise&lt;LeoBridgePackage | undefined&gt;; // Promise for opening a file
            if (p_leoFileUri &amp;&amp; p_leoFileUri.fsPath.trim()) {
                const w_fixedFilePath: string = p_leoFileUri.fsPath.replace(/\\/g, "/");
                q_openedFile = this.sendAction(Constants.LEOBRIDGE.OPEN_FILE, '"' + w_fixedFilePath + '"');
            } else {
                q_openedFile = this._leoFilesBrowser.getLeoFileUrl()
                    .then(p_chosenLeoFile =&gt; {
                        if (p_chosenLeoFile.trim()) {
                            return this.sendAction(Constants.LEOBRIDGE.OPEN_FILE, '"' + p_chosenLeoFile + '"');
                        } else {
                            return Promise.resolve(undefined);
                        }
                    }, p_errorGetFile =&gt; {
                        return Promise.reject(p_errorGetFile);
                    });
            }
            return q_openedFile;
        })
        .then((p_openFileResult: LeoBridgePackage | undefined) =&gt; {
            if (p_openFileResult) {
                return this._setupOpenedLeoDocument(p_openFileResult.opened!);
            } else {
                return Promise.resolve(undefined);
            }
        }, p_errorOpen =&gt; {
            console.log('in .then not opened or already opened'); // TODO : IS REJECTION BEHAVIOR NECESSARY HERE TOO?
            return Promise.reject(p_errorOpen);
        });
}

</t>
<t tx="felix.20200719025231.69">/**
 * * StatusBar click handler
 * @returns Thenable from the statusBar click customizable behavior
 */
public statusBarOnClick(): Thenable&lt;unknown&gt; {
    // TODO : Set definitive (customizable?) behavior (For now, offer to switch documents, or show leoInteg's commands)
    if (this.leoStates.fileOpenedReady) {
        return this.switchLeoFile();
    } else {
        return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.QUICK_OPEN, Constants.GUI.QUICK_OPEN_LEO_COMMANDS);
    }
}

</t>
<t tx="felix.20200719025231.7">/**
 * * Starts an instance of a leoBridge server, and may connect to it afterwards, based on configuration flags.
 */
public startServer(): void {
    if (!this._leoTerminalPane) {
        this._leoTerminalPane = vscode.window.createOutputChannel(Constants.GUI.TERMINAL_PANE_TITLE);
    }
    this._serverService.startServer(this.config.leoPythonCommand)
        .then((p_message) =&gt; {
            utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, true); // server started
            if (this.config.connectToServerAutomatically) {
                this.connect();
            }
        }, (p_reason) =&gt; {
            vscode.window.showErrorMessage(Constants.USER_MESSAGES.START_SERVER_ERROR + p_reason);
        });
}

</t>
<t tx="felix.20200719025231.70">/**
 * * Test/Dummy command
 * @param p_fromOutline Flags if the call came with focus on the outline
 * @returns Thenable from the tested functionality
 */
public test(p_fromOutline?: boolean): Thenable&lt;unknown&gt; {
    // return this.statusBarOnClick();
    console.log('initial test call');


    vscode.commands.executeCommand(Constants.COMMANDS.MARK_SELECTION)
        .then((p_result) =&gt; {
            console.log(
                'BACK FROM EXEC COMMAND ' +
                Constants.COMMANDS.MARK_SELECTION +
                ', p_result: ',
                JSON.stringify(p_result)
            );

        });


    return this.sendAction(Constants.LEOBRIDGE.TEST, JSON.stringify({ "testParam": "Some String" }))
        .then((p_result: LeoBridgePackage) =&gt; {
            // this.launchRefresh({ buttons: true }, false);
            return vscode.window.showInformationMessage(
                ' back from test, called from ' +
                (p_fromOutline ? "outline" : "body") +
                ', with result: ' +
                JSON.stringify(p_result)
            );
        });
}

</t>
<t tx="felix.20200719025231.8">/**
 * * Initiate a connection to the leoBridge server, then show view title, log pane, and set 'bridge ready' flags.
 */
public connect(): void {
    if (this.leoStates.leoBridgeReady || this._leoIsConnecting) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.ALREADY_CONNECTED);
        return;
    }
    this._leoIsConnecting = true;
    this._leoBridgeReadyPromise = this._leoBridge.initLeoProcess();
    this._leoBridgeReadyPromise.then(
        (p_package) =&gt; {
            this._leoIsConnecting = false;
            if (p_package.id !== 1) {
                this.cancelConnect(Constants.USER_MESSAGES.CONNECT_ERROR);
            } else {
                const w_lastFiles: string[] = this._context.globalState.get(Constants.LAST_FILES_KEY) || [];
                if (w_lastFiles.length) {
                    // This context flag will trigger 'Connecting...' placeholder
                    utils.setContext(Constants.CONTEXT_FLAGS.AUTO_CONNECT, true);
                    setTimeout(() =&gt; {
                        this._openLastFiles(); // Try to open last opened files, if any
                    }, 0);

                } else {
                    this.leoStates.leoBridgeReady = true;
                }

                this.showLogPane();
                if (!this.config.connectToServerAutomatically) {
                    vscode.window.showInformationMessage(Constants.USER_MESSAGES.CONNECTED);
                }
            }

            // TODO : Finish Closing and possibly SAME FOR OPENING AND CONNECTING
            // TODO : #14 @boltex COULD BE SOME FILES ALREADY OPENED OR NONE!

        },
        (p_reason) =&gt; {
            this._leoIsConnecting = false;
            this.cancelConnect(Constants.USER_MESSAGES.CONNECT_FAILED + p_reason);
        });
}

</t>
<t tx="felix.20200719025231.9">/**
 * * Cancels websocket connection and reverts context flags. Called from leoBridge.ts when its websocket reports disconnection.
 * @param p_message
 */
public cancelConnect(p_message?: string): void {
    // 'disconnect error' versus 'failed to connect'
    if (this.leoStates.leoBridgeReady) {
        vscode.window.showErrorMessage(p_message ? p_message : Constants.USER_MESSAGES.DISCONNECTED);
    } else {
        vscode.window.showInformationMessage(p_message ? p_message : Constants.USER_MESSAGES.DISCONNECTED);
    }
    this.leoStates.fileOpenedReady = false;
    this.leoStates.leoBridgeReady = false;
    this._leoBridgeReadyPromise = undefined;
    this._leoStatusBar.update(false);
    this._refreshOutline(false, RevealType.NoReveal);
}

</t>
<t tx="felix.20200719030811.1"></t>
<t tx="felix.20200719030842.1"></t>
<t tx="felix.20200719030902.1"></t>
<t tx="felix.20200719030909.1"></t>
<t tx="felix.20200719031115.1"></t>
<t tx="felix.20200719031346.1">/**
 * * Send user's configuration through leoBridge to the server script
 * @param p_config A config object containing all the configuration settings
 * @returns promise that will resolves with the package from "applyConfig" call in Leo bridge server
 */
public sendConfigToServer(p_config: ConfigMembers): Promise&lt;LeoBridgePackage&gt; {
    if (this.leoStates.leoBridgeReady) {
        return this.sendAction(Constants.LEOBRIDGE.APPLY_CONFIG, JSON.stringify(p_config));
    } else {
        return Promise.reject("Leo Bridge Not Ready");
    }
}

</t>
<t tx="felix.20200719031802.1"></t>
<t tx="felix.20200719033306.1"></t>
<t tx="felix.20200719033511.1"></t>
<t tx="felix.20200924205439.1">def _get_commander_method(self, p_command):
    """ Return the given method (p_command) in the Commands class or subcommanders."""
    # self.g.trace(p_command)
    #
    # First, try the commands class.
    w_func = getattr(self.commander, p_command, None)
    if w_func:
        return w_func
    #
    # Search all subcommanders for the method.
    table = (  # This table comes from c.initObjectIvars.
        'abbrevCommands',
        'bufferCommands',
        'chapterCommands',
        'controlCommands',
        'convertCommands',
        'debugCommands',
        'editCommands',
        'editFileCommands',
        'evalController',
        'gotoCommands',
        'helpCommands',
        'keyHandler',
        'keyHandlerCommands',
        'killBufferCommands',
        'leoCommands',
        'leoTestManager',
        'macroCommands',
        'miniBufferWidget',
        'printingController',
        'queryReplaceCommands',
        'rectangleCommands',
        'searchCommands',
        'spellCommands',
        'vimCommands',  # Not likely to be useful.
    )
    for ivar in table:
        subcommander = getattr(self.commander, ivar, None)
        if subcommander:
            w_func = getattr(subcommander, p_command, None)
            if w_func:
                ### self.g.trace(f"Found c.{ivar}.{p_command}")
                return w_func
        # else:
            # self.g.trace(f"Not Found: c.{ivar}") # Should never happen.
    return None

</t>
<t tx="felix.20200924205503.1">def leoCommand(self, p_command, p_package):
    '''
    Generic call to a method in Leo's Commands class or any subcommander class.

    The p_ap position node is to be selected before having the command run,
    while the p_keepSelection parameter specifies wether the original position
    should be re-selected afterward.
    The whole of those operations is to be undoable as one undo step.

    p_command: a method name (a string).
    p_ap: an archived position.
    p_keepSelection: preserve the current selection, if possible.
    '''
    w_keepSelection = False  # Set default, optional component of package
    if "keep" in p_package:
        w_keepSelection = p_package["keep"]
    #     print("have keep! " + str(w_keepSelection), flush=True)
    # else:
    #     print("NO keep!", flush=True)

    w_ap = p_package["node"]  # At least node parameter is present
    if not w_ap:
        return self._outputError(f"Error in {p_command}: no param node")
    w_p = self._ap_to_p(w_ap)
    if not w_p:
        return self._outputError(f"Error in {p_command}: no w_p node found")
    w_func = self._get_commander_method(p_command)
    if not w_func:
        return self._outputError(f"Error in {p_command}: no method found")

    if w_p == self.commander.p:
        w_func(event=None)
    else:
        oldPosition = self.commander.p
        self.commander.selectPosition(w_p)
        w_func(event=None)
        if w_keepSelection and self.commander.positionExists(oldPosition):
            self.commander.selectPosition(oldPosition)
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924205915.1">def openFiles(self, p_package):
    """
    Opens an array of leo files
    Returns an object that contains the last 'opened' member.
    """
    w_files = []
    if "files" in p_package:
        w_files = p_package["files"]

    for i_file in w_files:
        w_found = False
        # If not empty string (asking for New file) then check if already opened
        if i_file:
            for w_commander in self.g.app.commanders():
                if w_commander.fileName() == i_file:
                    w_found = True
                    self.commander = w_commander

        if not w_found:
            if os.path.isfile(i_file):
                self.commander = self.bridge.openLeoFile(
                    i_file)  # create self.commander
        if self.commander:
            self.commander.closed = False
            self.commander.frame.body.wrapper = IntegTextWrapper(
                self.commander, "integBody", self.g)
            self.commander.selectPosition(self.commander.p)

    # Done with the last one, it's now the selected commander. Check again just in case.
    if self.commander:
        self._create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self._p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage("opened", w_result)
    else:
        return self._outputError('Error in openFiles')

</t>
<t tx="felix.20200924210020.1">def getButtons(self, p_package):
    '''Gets the currently opened file's @buttons list'''
    w_buttons = []
    if self.commander and self.commander.theScriptingController and self.commander.theScriptingController.buttonsDict:
        w_dict = self.commander.theScriptingController.buttonsDict
        for w_key in w_dict:
            w_entry = {"name": w_dict[w_key], "index": str(w_key)}
            w_buttons.append(w_entry)
    return self.sendLeoBridgePackage("buttons", w_buttons)

</t>
<t tx="felix.20200924210024.1">def removeButton(self, p_package):
    '''Removes an entry from the buttonsDict by index string'''
    w_index = p_package['index']
    w_dict = self.commander.theScriptingController.buttonsDict
    w_key = None
    for i_key in w_dict:
        if(str(i_key) == w_index):
            w_key = i_key
    if w_key:
        del(w_dict[w_key])  # delete object member
    # return selected node when done
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924210029.1">def clickButton(self, p_package):
    '''Handles buttons clicked in client from the '@button' panel'''
    w_index = p_package['index']
    w_dict = self.commander.theScriptingController.buttonsDict
    w_button = None
    for i_key in w_dict:
        if(str(i_key) == w_index):
            w_button = i_key
    if w_button:
        w_button.command()  # run clicked button command
    # return selected node when done
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924210036.1">def getCommands(self, p_package):
    """Return a list of all Leo commands that make sense in leoInteg."""
    c = self.commander
    d = c.commandsDict  # keys are command names, values are functions.
    bad_names = self._bad_commands()  # #92.
    good_names = self._good_commands()
    duplicates = set(bad_names).intersection(set(good_names))
    if duplicates:
        print('duplicate command names...', flush=True)
        for z in sorted(duplicates):
            print(z)
    result = []
    for command_name in sorted(d):
        func = d.get(command_name)
        if not func:
            print('no func:', command_name, flush=True)
            continue
        if command_name in bad_names:  # #92.
            continue
        # Prefer func.__func_name__ to func.__name__: Leo's decorators change func.__name__!
        func_name = getattr(func, '__func_name__', func.__name__)
        if not func_name:
            print('no name', command_name, flush=True)
            continue
        doc = func.__doc__ or ''
        result.append({
            "label": command_name,
            "func":  func_name,
            "detail": doc,
        })
        # This shows up in the bridge log.
        # print(f"__doc__: {len(doc):4} {command_name:40} {func_name} ", flush=True)
        # print(f"{func_name} ", flush=True)

    return self.sendLeoBridgePackage("commands", result)

</t>
<t tx="felix.20200924210058.1">def _bad_commands(self):
    """Return the list of Leo's command names that leoInteg should ignore."""
    c = self.commander
    bad = []
    d = c.commandsDict  # keys are command names, values are functions.
    #
    # First, remove @button, @command and vim commands.
    for command_name in sorted(d):
        if command_name.startswith((':', '@')):
            # print('ignore', command_name)
            bad.append(command_name)
    # Second, remove other commands.
    # This is a hand-curated list.
    bad_list = [

        # Abbreviations...
        'abbrev-kill-all',
        'abbrev-list',
        'dabbrev-completion',
        'dabbrev-expands',

        # Autocompletion...
        'auto-complete',
        'auto-complete-force',
        'disable-autocompleter',
        'disable-calltips',
        'enable-autocompleter',
        'enable-calltips',

        # Debugger...
        'debug',
        'db-again',
        'db-b',
        'db-c',
        'db-h',
        'db-input',
        'db-l',
        'db-n',
        'db-q',
        'db-r',
        'db-s',
        'db-status',
        'db-w',

        # File operations...
        'directory-make',
        'directory-remove',
        'file-delete',
        'file-diff-files',
        'file-insert',
        'file-new',
        'file-open-by-name',

        # All others...
        'shell-command',
        'shell-command-on-region',
        'cheat-sheet',
        'dehoist',  # Duplicates of de-hoist.
        'find-clone-all',
        'find-clone-all-flattened',
        'find-clone-tag',
        'find-all',
        'find-all-unique-regex',
        'find-character',
        'find-character-extend-selection',
        'find-next',
        'find-prev',
        'find-word',
        'find-word-in-line',

        'global-search',

        'isearch-backward',
        'isearch-backward-regexp',
        'isearch-forward',
        'isearch-forward-regexp',
        'isearch-with-present-options',

        'replace',
        'replace-all',
        'replace-current-character',
        'replace-then-find',

        're-search-backward',
        're-search-forward',

        'search-backward',
        'search-forward',
        'search-return-to-origin',

        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
        'set-replace-string',
        'set-search-string',

        'show-find-options',

        'start-search',

        'toggle-find-collapses-nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',

        'word-search-backward',
        'word-search-forward',

        # Buttons...
        'delete-script-button-button',

        # Clicks...
        'click-click-box',
        'click-icon-box',
        'ctrl-click-at-cursor',
        'ctrl-click-icon',
        'double-click-icon-box',
        'right-click-icon',

        # Editors...
        'add-editor', 'editor-add',
        'delete-editor', 'editor-delete',
        'detach-editor-toggle',
        'detach-editor-toggle-max',

        # Focus...
        'cycle-editor-focus', 'editor-cycle-focus',
        'focus-to-body',
        'focus-to-find',
        'focus-to-log',
        'focus-to-minibuffer',
        'focus-to-nav',
        'focus-to-spell-tab',
        'focus-to-tree',

        'tab-cycle-next',
        'tab-cycle-previous',
        'tab-detach',

        # Headlines..
        'abort-edit-headline',
        'edit-headline',
        'end-edit-headline',

        # Layout and panes...
        'adoc',
        'adoc-with-preview',

        'contract-body-pane',
        'contract-log-pane',
        'contract-outline-pane',

        'edit-pane-csv',
        'edit-pane-test-open',
        'equal-sized-panes',
        'expand-log-pane',
        'expand-body-pane',
        'expand-outline-pane',

        'free-layout-context-menu',
        'free-layout-load',
        'free-layout-restore',
        'free-layout-zoom',

        'zoom-in',
        'zoom-out'

        # Log
        'clear-log',

        # Menus...
        'activate-cmds-menu',
        'activate-edit-menu',
        'activate-file-menu',
        'activate-help-menu',
        'activate-outline-menu',
        'activate-plugins-menu',
        'activate-window-menu',
        'context-menu-open',
        'menu-shortcut',

        # Modes...
        'clear-extend-mode',

        # Outline...
        'contract-or-go-left',
        'contract-node',
        'contract-parent',

        # Scrolling...
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-outline-down-line',
        'scroll-outline-down-page',
        'scroll-outline-left',
        'scroll-outline-right',
        'scroll-outline-up-line',
        'scroll-outline-up-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',

        # Windows...
        'about-leo',

        'cascade-windows',
        'close-others',
        'close-window',

        'iconify-frame',

        'find-tab-hide',
        'find-tab-open',

        'hide-body-dock',
        'hide-body-pane',
        'hide-invisibles',
        'hide-log-pane',
        'hide-outline-dock',
        'hide-outline-pane',
        'hide-tabs-dock',

        'minimize-all',

        'resize-to-screen',

        'show-body-dock',
        'show-hide-body-dock',
        'show-hide-outline-dock',
        'show-hide-render-dock',
        'show-hide-tabs-dock',
        'show-tabs-dock',
        'clean-diff',
        'cm-external-editor',

        'delete-@button-parse-json-button',
        'delete-trace-statements',

        'disable-idle-time-events',
        'do-nothing',

        'enable-idle-time-events',
        'enter-quick-command-mode',
        'exit-named-mode',

        'F6-open-console',

        'flush-lines',
        'full-command',

        'get-child-headlines',

        'history',

        'insert-file-name',

        'justify-toggle-auto',

        'keep-lines',
        'keyboard-quit',

        'line-number',
        'line-numbering-toggle',
        'line-to-headline',

        'marked-list',

        'mode-help',

        'open-python-window',

        'open-with-idle',
        'open-with-open-office',
        'open-with-scite',
        'open-with-word',

        'recolor',
        'redraw',

        'repeat-complex-command',

        'session-clear',
        'session-create',
        'session-refresh',
        'session-restore',
        'session-snapshot-load',
        'session-snapshot-save',

        'set-colors',
        'set-command-state',
        'set-comment-column',
        'set-extend-mode',
        'set-fill-column',
        'set-fill-prefix',
        'set-font',
        'set-insert-state',
        'set-overwrite-state',
        'set-silent-mode',

        'show-buttons',
        'show-calltips',
        'show-calltips-force',
        'show-color-names',
        'show-color-wheel',
        'show-commands',
        'show-file-line',

        'show-focus',
        'show-fonts',

        'show-invisibles',
        'show-next-tip',
        'show-node-uas',
        'show-outline-dock',
        'show-plugin-handlers',
        'show-plugins-info',
        'show-settings',
        'show-settings-outline',
        'show-spell-info',
        'show-stats',

        'style-set-selected',

        'suspend',

        'toggle-abbrev-mode',
        'toggle-active-pane',
        'toggle-angle-brackets',
        'toggle-at-auto-at-edit',
        'toggle-autocompleter',
        'toggle-calltips',
        'toggle-case-region',
        'toggle-extend-mode',
        'toggle-idle-time-events',
        'toggle-input-state',
        'toggle-invisibles',
        'toggle-line-numbering-root',
        'toggle-sparse-move',
        'toggle-split-direction',

        'what-line',
        'eval',
        'eval-block',
        'eval-last',
        'eval-last-pretty',
        'eval-replace',

        'find-quick',
        'find-quick-changed',
        'find-quick-selected',
        'find-quick-test-failures',
        'find-quick-timeline',

        'goto-next-history-node',
        'goto-prev-history-node',

        'preview',
        'preview-body',
        'preview-expanded-body',
        'preview-expanded-html',
        'preview-html',
        'preview-marked-bodies',
        'preview-marked-html',
        'preview-marked-nodes',
        'preview-node',
        'preview-tree-bodies',
        'preview-tree-html',
        'preview-tree-nodes',

        'spell-add',
        'spell-as-you-type-next',
        'spell-as-you-type-toggle',
        'spell-as-you-type-undo',
        'spell-as-you-type-wrap',
        'spell-change',
        'spell-change-then-find',
        'spell-find',
        'spell-ignore',
        'spell-tab-hide',
        'spell-tab-open',

        'tag-children',

        'todo-children-todo',
        'todo-dec-pri',
        'todo-find-todo',
        'todo-fix-datetime',
        'todo-inc-pri',

        'vr',
        'vr-contract',
        'vr-expand',
        'vr-hide',
        'vr-lock',
        'vr-pause-play-movie',
        'vr-show',
        'vr-toggle',
        'vr-unlock',
        'vr-update',
        'vr-zoom',

        'vs-create-tree',
        'vs-dump',
        'vs-reset',
        'vs-update',
        # vs code's text editing commands should cover all of these...
        'add-comments',
        'add-space-to-lines',
        'add-tab-to-lines',
        'align-eq-signs',

        'back-char',
        'back-char-extend-selection',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'back-to-home',
        'back-to-home-extend-selection',
        'back-to-indentation',
        'back-word',
        'back-word-extend-selection',
        'back-word-smart',
        'back-word-smart-extend-selection',
        'backward-delete-char',
        'backward-delete-word',
        'backward-delete-word-smart',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'backward-kill-paragraph',
        'backward-kill-sentence',
        'backward-kill-word',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',

        'capitalize-word',
        'center-line',
        'center-region',
        'clean-all-blank-lines',
        'clean-all-lines',
        'clean-body',
        'clean-lines',
        'clear-kill-ring',
        'clear-selected-text',
        'convert-blanks',
        'convert-tabs',
        'copy-text',
        'cut-text',

        'delete-char',
        'delete-comments',
        'delete-indentation',
        'delete-spaces',
        'delete-word',
        'delete-word-smart',
        'downcase-region',
        'downcase-word',

        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'end-of-line',
        'end-of-line-extend-selection',

        'exchange-point-mark',

        'extend-to-line',
        'extend-to-paragraph',
        'extend-to-sentence',
        'extend-to-word',

        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',

        'finish-of-line',
        'finish-of-line-extend-selection',

        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'forward-word-smart',
        'forward-word-smart-extend-selection',

        'go-anywhere',
        'go-back',
        'go-forward',
        'goto-char',

        'indent-region',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',

        'insert-hard-tab',
        'insert-newline',
        'insert-parentheses',
        'insert-soft-tab',

        'kill-line',
        'kill-paragraph',
        'kill-pylint',
        'kill-region',
        'kill-region-save',
        'kill-sentence',
        'kill-to-end-of-line',
        'kill-word',
        'kill-ws',

        'match-brackets',

        'move-lines-down',
        'move-lines-up',
        'move-past-close',
        'move-past-close-extend-selection',

        'newline-and-indent',
        'next-line',
        'next-line-extend-selection',
        'next-or-end-of-line',
        'next-or-end-of-line-extend-selection',

        'previous-line',
        'previous-line-extend-selection',
        'previous-or-beginning-of-line',
        'previous-or-beginning-of-line-extend-selection',

        'rectangle-clear',
        'rectangle-close',
        'rectangle-delete',
        'rectangle-kill',
        'rectangle-open',
        'rectangle-string',
        'rectangle-yank',

        'remove-blank-lines',
        'remove-newlines',
        'remove-space-from-lines',
        'remove-tab-from-lines',

        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',

        'paste-text',
        'pop-cursor',
        'push-cursor',

        'select-all',
        'select-next-trace-statement',
        'select-to-matching-bracket',

        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',

        'split-defs',
        'split-line',

        'start-of-line',
        'start-of-line-extend-selection',

        'tabify',
        'transpose-chars',
        'transpose-lines',
        'transpose-words',

        'unformat-paragraph',
        'unindent-region',

        'untabify',

        'upcase-region',
        'upcase-word',
        'update-ref-file',

        'yank',
        'yank-pop',

        'zap-to-character',

    ]
    bad.extend(bad_list)
    result = list(sorted(bad))
    return result

</t>
<t tx="felix.20200924210112.1">def _good_commands(self):
    """Defined commands that definitely should be included in leoInteg."""
    good_list = [

        'contract-all',
        'contract-all-other-nodes',
        'clone-node',
        'copy-node',
        'copy-marked-nodes',
        'cut-node',

        'de-hoist',
        'delete-marked-nodes',
        'delete-node',
        'demangle-recent-files',
        'demote',

        'expand-and-go-right',
        'expand-next-level',
        'expand-node',
        'expand-or-go-right',
        'expand-prev-level',
        'expand-to-level-1',
        'expand-to-level-2',
        'expand-to-level-3',
        'expand-to-level-4',
        'expand-to-level-5',
        'expand-to-level-6',
        'expand-to-level-7',
        'expand-to-level-8',
        'expand-to-level-9',
        'expand-all',
        'expand-all-subheads',
        'expand-ancestors-only',

        'find-next-clone',

        'goto-first-node',
        'goto-first-sibling',
        'goto-first-visible-node',
        'goto-last-node',
        'goto-last-sibling',
        'goto-last-visible-node',
        'goto-next-changed',
        'goto-next-clone',
        'goto-next-marked',
        'goto-next-node',
        'goto-next-sibling',
        'goto-next-visible',
        'goto-parent',
        'goto-prev-marked',
        'goto-prev-node',
        'goto-prev-sibling',
        'goto-prev-visible',

        'hoist',

        'insert-node',
        'insert-node-before',
        'insert-as-first-child',
        'insert-as-last-child',
        'insert-child',

        'mark',
        'mark-changed-items',
        'mark-first-parents',
        'mark-subheads',

        'move-marked-nodes',
        'move-outline-down',
        'move-outline-left',
        'move-outline-right',
        'move-outline-up',

        'paste-node',
        'paste-retaining-clones',
        'promote',
        'promote-bodies',
        'promote-headlines',

        'sort-children',
        'sort-siblings',

        'tangle',
        'tangle-all',
        'tangle-marked',

        'unmark-all',
        'unmark-first-parents',
        'clean-main-spell-dict',
        'clean-persistence',
        'clean-recent-files',
        'clean-spellpyx',
        'clean-user-spell-dict',

        'clear-all-caches',
        'clear-all-hoists',
        'clear-all-uas',
        'clear-cache',
        'clear-node-uas',
        'clear-recent-files',

        'delete-first-icon',
        'delete-last-icon',
        'delete-node-icons',

        'dump-caches',
        'dump-clone-parents',
        'dump-expanded',
        'dump-node',
        'dump-outline',

        'insert-icon',

        'set-ua',

        'show-all-uas',
        'show-bindings',
        'show-clone-ancestors',
        'show-clone-parents',
        # Export files...
        'export-headlines',
        'export-jupyter-notebook',
        'outline-to-cweb',
        'outline-to-noweb',
        'remove-sentinels',
        'typescript-to-py',

        # Import files...
        'import-MORE-files',
        'import-file',
        'import-free-mind-files',
        'import-jupyter-notebook',
        'import-legacy-external-files',
        'import-mind-jet-files',
        'import-tabbed-files',
        'import-todo-text-files',
        'import-zim-folder',

        # Open specific files...
        # 'ekr-projects',
        'leo-cheat-sheet',  # These duplicates are useful.
        'leo-dist-leo',
        'leo-docs-leo',
        'leo-plugins-leo',
        'leo-py-leo',
        'leo-quickstart-leo',
        'leo-scripts-leo',
        'leo-settings',
        'leo-unittest-leo',
        'my-leo-settings',
        # 'scripts',
        'settings',

        'open-cheat-sheet-leo',
        'open-desktop-integration-leo',
        'open-leo-dist-leo',
        'open-leo-docs-leo',
        'open-leo-plugins-leo',
        'open-leo-py-leo',
        'open-leo-settings',
        'open-leo-settings-leo',
        'open-local-settings',
        'open-my-leo-settings',
        'open-my-leo-settings-leo',
        'open-quickstart-leo',
        'open-scripts-leo',
        'open-unittest-leo',

        # Open other places...
        'open-offline-tutorial',
        'open-online-home',
        'open-online-toc',
        'open-online-tutorials',
        'open-online-videos',
        'open-recent-file',
        'open-theme-file',
        'open-url',
        'open-url-under-cursor',
        'open-users-guide',

        # Read outlines...
        'read-at-auto-nodes',
        'read-at-file-nodes',
        'read-at-shadow-nodes',
        'read-file-into-node',
        'read-outline-only',
        'read-ref-file',

        # Save Files.
        'file-save',
        'file-save-as',
        'file-save-as-unzipped',
        'file-save-by-name',
        'file-save-to',
        'save',  # Some may not be needed.
        'save-all',
        'save-as',
        'save-file',
        'save-file-as',
        'save-file-as-unzipped',
        'save-file-as-zipped',
        'save-file-by-name',
        'save-file-to',
        'save-to',

        # Write parts of outlines...
        'write-at-auto-nodes',
        'write-at-file-nodes',
        'write-at-shadow-nodes',
        'write-dirty-at-auto-nodes',
        'write-dirty-at-file-nodes',
        'write-dirty-at-shadow-nodes',
        'write-edited-recent-files',
        'write-file-from-node',
        'write-missing-at-file-nodes',
        'write-outline-only',

        'clone-find-all',
        'clone-find-all-flattened',
        'clone-find-all-flattened-marked',
        'clone-find-all-marked',
        'clone-find-parents',
        'clone-find-tag',
        'clone-marked-nodes',
        'clone-node-to-last-node',
        'clone-to-at-spot',

        'edit-setting',
        'edit-shortcut',

        'execute-pytest',
        'execute-script',
        'extract',
        'extract-names',

        'goto-any-clone',
        'goto-global-line',
        'goto-line',
        'git-diff', 'gd',

        'log-kill-listener', 'kill-log-listener',
        'log-listen', 'listen-to-log',

        'make-stub-files',

        'pdb',

        'redo',
        'rst3',
        'run-all-unit-tests-externally',
        'run-all-unit-tests-locally',
        'run-marked-unit-tests-externally',
        'run-marked-unit-tests-locally',
        'run-selected-unit-tests-externally',
        'run-selected-unit-tests-locally',
        'run-tests',

        'undo',

        'xdb',
        # Beautify, blacken, fstringify...
        'beautify-files',
        'beautify-files-diff',
        'blacken-files',
        'blacken-files-diff',
        'diff-and-open-leo-files',
        'diff-beautify-files',
        'diff-fstringify-files',
        'diff-leo-files',
        'diff-marked-nodes',
        'fstringify-files',
        'fstringify-files-diff',
        'fstringify-files-silent',
        'pretty-print-c',
        'silent-fstringify-files',

        # All other commands...
        'at-file-to-at-auto',

        'beautify-c',

        'cls',
        'c-to-python',
        'c-to-python-clean-docs',
        'check-derived-file',
        'check-outline',
        'code-to-rst',
        'compare-two-leo-files',
        'convert-all-blanks',
        'convert-all-tabs',
        'count-children',
        'count-pages',
        'count-region',

        'desktop-integration-leo',

        'edit-recent-files',
        'exit-leo',

        'file-compare-two-leo-files',
        'find-def',
        'find-long-lines',
        'find-missing-docstrings',
        'flake8',
        'flatten-outline',
        'flatten-outline-to-node',
        'flatten-script',

        'gc-collect-garbage',
        'gc-dump-all-objects',
        'gc-dump-new-objects',
        'gc-dump-objects-verbose',
        'gc-show-summary',

        'help',  # To do.
        'help-for-abbreviations',
        'help-for-autocompletion',
        'help-for-bindings',
        'help-for-command',
        'help-for-creating-external-files',
        'help-for-debugging-commands',
        'help-for-drag-and-drop',
        'help-for-dynamic-abbreviations',
        'help-for-find-commands',
        'help-for-keystroke',
        'help-for-minibuffer',
        'help-for-python',
        'help-for-regular-expressions',
        'help-for-scripting',
        'help-for-settings',

        'insert-body-time',  # ?
        'insert-headline-time',
        'insert-jupyter-toc',
        'insert-markdown-toc',

        'find-var',

        'join-leo-irc',
        'join-node-above',
        'join-node-below',
        'join-selection-to-node-below',

        'move-lines-to-next-node',

        'new',

        'open-outline',

        'parse-body',
        'parse-json',
        'pandoc',
        'pandoc-with-preview',
        'paste-as-template',

        'print-body',
        'print-cmd-docstrings',
        'print-expanded-body',
        'print-expanded-html',
        'print-html',
        'print-marked-bodies',
        'print-marked-html',
        'print-marked-nodes',
        'print-node',
        'print-sep',
        'print-tree-bodies',
        'print-tree-html',
        'print-tree-nodes',
        'print-window-state',

        'pyflakes',
        'pylint',
        'pylint-kill',
        'python-to-coffeescript',

        'quit-leo',

        'reformat-body',
        'reformat-paragraph',
        'refresh-from-disk',
        'reload-all-settings',
        'reload-settings',
        'reload-style-sheets',
        'revert',

        'save-buffers-kill-leo',
        'screen-capture-5sec',
        'screen-capture-now',
        'script-button',  # ?
        'set-reference-file',
        'show-style-sheet',
        'sort-recent-files',
        'sphinx',
        'sphinx-with-preview',
        'style-reload',  # ?

        'untangle',
        'untangle-all',
        'untangle-marked',

        'view-lossage',  # ?

        'weave',

        # Dubious commands (to do)...
        'act-on-node',

        'cfa',  # Do we need abbreviations?
        'cfam',
        'cff',
        'cffm',
        'cft',

        'buffer-append-to',
        'buffer-copy',
        'buffer-insert',
        'buffer-kill',
        'buffer-prepend-to',
        'buffer-switch-to',
        'buffers-list',
        'buffers-list-alphabetically',

        'chapter-back',
        'chapter-next',
        'chapter-select',
        'chapter-select-main',
        'create-def-list',  # ?
    ]
    return good_list

</t>
<t tx="felix.20200924210952.1">def _getDocstringForCommand(self, command_name):
    """get docstring for the given command."""
    func = self._get_commander_method(command_name)
    docstring = func.__doc__ if func else ''
    return docstring

</t>
<t tx="felix.20200924211032.1">def setActionId(self, p_id):
    self.currentActionId = p_id

</t>
<t tx="felix.20200924211034.1">async def asyncOutput(self, p_json):
    '''Output json string to the websocket'''
    if self.webSocket:
        await self.webSocket.send(p_json)
    else:
        print("websocket not ready yet", flush=True)

</t>
<t tx="felix.20200924211037.1">def sendLeoBridgePackage(self, p_key=False, p_any=None):
    w_package = {"id": self.currentActionId}
    if p_key:
        w_package[p_key] = p_any  # add [key]?:any
    return(json.dumps(w_package, separators=(',', ':')))  # send as json
    # await self.webSocket.send(json.dumps(w_package, separators=(',', ':')))  # send as json

</t>
<t tx="felix.20200924211041.1">def _outputError(self, p_message="Unknown Error"):
    # Output to this server's running console
    print("ERROR: " + p_message, flush=True)
    w_package = {"id": self.currentActionId}
    w_package["error"] = p_message
    return p_message

</t>
<t tx="felix.20200924211048.1">def _outputBodyData(self, p_bodyText=""):
    return self.sendLeoBridgePackage("bodyData", p_bodyText)

</t>
<t tx="felix.20200924211051.1">def _outputPNode(self, p_node=False):
    if p_node:
        # Single node, singular
        return self.sendLeoBridgePackage("node", self._p_to_ap(p_node))
    else:
        return self.sendLeoBridgePackage("node", None)

</t>
<t tx="felix.20200924211054.1">def _outputPNodes(self, p_pList):
    w_apList = []
    for p in p_pList:
        w_apList.append(self._p_to_ap(p))
    # Multiple nodes, plural
    return self.sendLeoBridgePackage("nodes", w_apList)

</t>
<t tx="felix.20200924211057.1">def markPNode(self, p_package):
    '''Mark a node, don't select it'''
    w_ap = p_package["node"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            w_p.setMarked()
            # return selected node when done (not w_p)
            return self._outputPNode(self.commander.p)
        else:
            return self._outputError("Error in markPNode no w_p node found")
    else:
        return self._outputError("Error in markPNode no param node")

</t>
<t tx="felix.20200924211100.1">def unmarkPNode(self, p_package):
    '''Unmark a node, don't select it'''
    w_ap = p_package["node"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            w_p.clearMarked()
            # return selected node when done (not w_p)
            return self._outputPNode(self.commander.p)
        else:
            return self._outputError("Error in unmarkPNode no w_p node found")
    else:
        return self._outputError("Error in unmarkPNode no param node")

</t>
<t tx="felix.20200924211104.1">def clonePNode(self, p_package):
    '''Clone a node, return it, if it was also the current selection, otherwise try not to select it'''
    w_ap = p_package["node"]
    if not w_ap:
        return self._outputError("Error in clonePNode function, no param p_ap")
    w_p = self._ap_to_p(w_ap)
    if not w_p:
        # default empty
        return self._outputError("Error in clonePNode function, no w_p node found")
    if w_p == self.commander.p:
        self.commander.clone()
    else:
        oldPosition = self.commander.p
        self.commander.selectPosition(w_p)
        self.commander.clone()
        if self.commander.positionExists(oldPosition):
            self.commander.selectPosition(oldPosition)
    # return selected node either ways
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924211121.1">def cutPNode(self, p_package):
    '''Cut a node, don't select it. Try to keep selection, then return the selected node that remains'''
    w_ap = p_package["node"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            if w_p == self.commander.p:
                self.commander.cutOutline()  # already on this node, so cut it
            else:
                oldPosition = self.commander.p  # not same node, save position to possibly return to
                self.commander.selectPosition(w_p)
                self.commander.cutOutline()
                if self.commander.positionExists(oldPosition):
                    # select if old position still valid
                    self.commander.selectPosition(oldPosition)
                else:
                    oldPosition._childIndex = oldPosition._childIndex-1
                    # Try again with childIndex decremented
                    if self.commander.positionExists(oldPosition):
                        # additional try with lowered childIndex
                        self.commander.selectPosition(oldPosition)
            # in both cases, return selected node
            return self._outputPNode(self.commander.p)
        else:
            # default empty
            return self._outputError("Error in cutPNode no w_p node found")
    else:
        return self._outputError("Error in cutPNode no param node")

</t>
<t tx="felix.20200924211125.1">def deletePNode(self, p_package):
    '''Delete a node, don't select it. Try to keep selection, then return the selected node that remains'''
    w_ap = p_package["node"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            if w_p == self.commander.p:
                self.commander.deleteOutline()  # already on this node, so delete it
            else:
                oldPosition = self.commander.p  # not same node, save position to possibly return to
                self.commander.selectPosition(w_p)
                self.commander.deleteOutline()
                if self.commander.positionExists(oldPosition):
                    # select if old position still valid
                    self.commander.selectPosition(oldPosition)
                else:
                    oldPosition._childIndex = oldPosition._childIndex-1
                    # Try again with childIndex decremented
                    if self.commander.positionExists(oldPosition):
                        # additional try with lowered childIndex
                        self.commander.selectPosition(oldPosition)
            # in both cases, return selected node
            return self._outputPNode(self.commander.p)
        else:
            # default empty
            return self._outputError("Error in deletePNode no w_p node found")
    else:
        return self._outputError("Error in deletePNode no param node")

</t>
<t tx="felix.20200924211127.1">def insertPNode(self, p_package):
    '''Insert a node at given node, then select it once created, and finally return it'''
    w_ap = p_package["node"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            w_bunch = self.commander.undoer.beforeInsertNode(w_p)
            w_newNode = w_p.insertAfter()
            w_newNode.setDirty()
            self.commander.undoer.afterInsertNode(
                w_newNode, 'Insert Node', w_bunch)
            self.commander.selectPosition(w_newNode)
            # in both cases, return selected node
            return self._outputPNode(self.commander.p)
        else:
            # default empty
            return self._outputError("Error in insertPNode no w_p node found")
    else:
        return self._outputError("Error in insertPNode no param node")

</t>
<t tx="felix.20200924211132.1">def insertNamedPNode(self, p_package):
    '''Insert a node at given node, set its headline, select it and finally return it'''
    w_newHeadline = p_package['text']
    w_ap = p_package['node']
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            w_u = self.commander.undoer.beforeInsertNode(w_p)
            w_newNode = w_p.insertAfter()
            # set this node's new headline
            w_newNode.h = w_newHeadline
            w_newNode.setDirty()
            self.commander.undoer.afterInsertNode(
                w_newNode, 'Insert Node', w_u)
            self.commander.selectPosition(w_newNode)
            # in any case, return selected node
            return self._outputPNode(self.commander.p)
        else:
            # default empty
            return self._outputError("Error in insertNamedPNode no w_p node found")
    else:
        return self._outputError("Error in insertNamedPNode no param node")

</t>
<t tx="felix.20200924211135.1">def undo(self, p_paramUnused):
    '''Undo last un-doable operation'''
    if self.commander.undoer.canUndo():
        self.commander.undoer.undo()
    # return selected node when done
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924211138.1">def redo(self, p_paramUnused):
    '''Undo last un-doable operation'''
    if self.commander.undoer.canRedo():
        self.commander.undoer.redo()
    # return selected node when done
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924223845.1"></t>
<t tx="felix.20200924223910.1"></t>
<t tx="felix.20200924223945.1"></t>
<t tx="felix.20200924224017.1"></t>
<t tx="felix.20200924224100.1"></t>
<t tx="felix.20200927213534.1">def _getScript(self, c, p,
               useSelectedText=True,
               forcePythonSentinels=True,
               useSentinels=True,
               ):
    """
    Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if
    p is not the current node or if there is no text selection.
    """
    w = c.frame.body.wrapper
    if not p:
        p = c.p
    try:
        if w and p == c.p and useSelectedText and w.hasSelection():
            s = w.getSelectedText()
        else:
            s = p.b
        # Remove extra leading whitespace so the user may execute indented code.
        s = self.g.removeExtraLws(s, c.tab_width)
        s = self.g.extractExecutableString(c, p, s)
        script = self.g.composeScript(c, p, s,
                                      forcePythonSentinels=forcePythonSentinels,
                                      useSentinels=useSentinels)
    except Exception:
        self.g.es_print("unexpected exception in g.getScript")
        self.g.es_exception()
        script = ''
    return script

</t>
<t tx="felix.20200927224639.1">def _outputSelectionData(self, p_bodySelection):
    return self.sendLeoBridgePackage("bodySelection", p_bodySelection)

</t>
<t tx="felix.20200928004727.1">/**
 * * Handles detection of the active editor's selection change or cursor position
 * @param p_event a change event containing the active editor's selection, if any.
 */
private _onChangeEditorSelection(p_event: vscode.TextEditorSelectionChangeEvent): void {
    if ((p_event.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME)) {
        if (p_event.selections.length) {
            this._selectionDirty = true;
            this._selection = p_event.selections[0];
            this._selectionGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20200928133238.1">/**
 * * Saves the cursor position along with the text selection range and scroll position
 * @returns Promise that resolves when the "setSelection" action returns from Leo's side
 */
private _bodySaveSelection(): Promise&lt;boolean&gt; {
    if (this._selectionDirty &amp;&amp; this._selection) {
        // Prepare scroll data separately
        let w_scroll: { start: BodyPosition; end: BodyPosition; };
        if (this._selectionGnx === this._scrollGnx &amp;&amp; this._scrollDirty) {
            w_scroll = {
                start: {
                    line: this._scroll?.start.line || 0,
                    col: this._scroll?.start.character || 0
                },
                end: {
                    line: this._scroll?.end.line || 0,
                    col: this._scroll?.end.character || 0
                }
            };
        } else {
            w_scroll = {
                start: {
                    line: 0, col: 0
                },
                end: {
                    line: 0, col: 0
                }
            };
        }
        // Send whole
        const w_param: BodySelectionInfo = {
            gnx: this._selectionGnx,
            scroll: w_scroll,
            active: {
                line: this._selection.active.line || 0,
                col: this._selection.active.character || 0
            },
            start: {
                line: this._selection.start.line || 0,
                col: this._selection.start.character || 0
            },
            end: {
                line: this._selection.end.line || 0,
                col: this._selection.end.character || 0
            }

        };
        this._scrollDirty = false;
        this._selectionDirty = false; // don't wait for return of this call
        return this.sendAction(Constants.LEOBRIDGE.SET_SELECTION, JSON.stringify(w_param)).then(p_result =&gt; {
            return Promise.resolve(true);
        });
    } else {
        return Promise.resolve(true);
    }
}

</t>
<t tx="felix.20200928174406.1">class IntegTextWrapper:
    """
    A class that represents text as a Python string.
    Modified from Leo's StringTextWrapper class source
    """

    @others

</t>
<t tx="felix.20200928174406.10">def getAllText(self):
    """IntegTextWrapper getAllText"""
    s = self.s
    # print("WRAPPER getAllText  " + s)
    return self.g.checkUnicode(s)

</t>
<t tx="felix.20200928174406.11">def getInsertPoint(self):
    """IntegTextWrapper getInsertPoint"""
    i = self.ins
    if i is None:
        if self.virtualInsertPoint is None:
            i = 0
        else:
            i = self.virtualInsertPoint
    self.virtualInsertPoint = i
    return i

</t>
<t tx="felix.20200928174406.12">def getSelectedText(self):
    """IntegTextWrapper getSelectedText"""
    i, j = self.sel
    s = self.s[i:j]
    # print("WRAPPER getSelectedText with self.s[i:j]: " + s)
    return self.g.checkUnicode(s)

</t>
<t tx="felix.20200928174406.13">def getSelectionRange(self, sort=True):
    """Return the selected range of the widget."""
    sel = self.sel
    if len(sel) == 2 and sel[0] &gt;= 0 and sel[1] &gt;= 0:
        i, j = sel
        if sort and i &gt; j:
            sel = j, i  # Bug fix: 10/5/07
        return sel
    i = self.ins
    return i, i

</t>
<t tx="felix.20200928174406.14">def hasSelection(self):
    """IntegTextWrapper hasSelection"""
    i, j = self.getSelectionRange()
    return i != j

</t>
<t tx="felix.20200928174406.15">def insert(self, i, s):
    """IntegTextWrapper insert"""
    i = self.toPythonIndex(i)
    s1 = s
    self.s = self.s[:i] + s1 + self.s[i:]
    i += len(s1)
    self.ins = i
    self.sel = i, i

</t>
<t tx="felix.20200928174406.16">def selectAllText(self, insert=None):
    """IntegTextWrapper selectAllText"""
    self.setSelectionRange(0, 'end', insert=insert)

</t>
<t tx="felix.20200928174406.17">def setAllText(self, s):
    """IntegTextWrapper setAllText"""
    # print("WRAPPER setAllText: " + s)
    self.s = s
    i = len(self.s)
    self.ins = i
    self.sel = i, i

</t>
<t tx="felix.20200928174406.18">def setInsertPoint(self, pos, s=None):
    """IntegTextWrapper setInsertPoint"""
    self.virtualInsertPoint = i = self.toPythonIndex(pos)
    self.ins = i
    self.sel = i, i

</t>
<t tx="felix.20200928174406.19">def setSelectionRange(self, i, j, insert=None):
    """IntegTextWrapper setSelectionRange"""
    i, j = self.toPythonIndex(i), self.toPythonIndex(j)
    self.sel = i, j
    self.ins = j if insert is None else self.toPythonIndex(insert)

</t>
<t tx="felix.20200928174406.2">def __init__(self, c, name, g):
    """Ctor for the IntegTextWrapper class."""
    self.c = c
    self.name = name
    self.g = g  # Should g be totally global across all leoIntegration classes?
    self.ins = 0
    self.sel = 0, 0
    self.s = ''
    self.yScroll = 0
    self.supportsHighLevelInterface = True
    self.widget = None  # This ivar must exist, and be None.

def __repr__(self):
    return f"&lt;IntegTextWrapper: {id(self)} {self.name}&gt;"

def getName(self):
    """IntegTextWrapper."""
    return self.name  # Essential.

</t>
<t tx="felix.20200928174406.20">def toPythonIndex(self, index):
    """IntegTextWrapper toPythonIndex"""
    return self.g.toPythonIndex(self.s, index)

</t>
<t tx="felix.20200928174406.21">def toPythonIndexRowCol(self, index):
    """IntegTextWrapper toPythonIndexRowCol"""
    s = self.getAllText()
    i = self.toPythonIndex(index)
    row, col = self.g.convertPythonIndexToRowCol(s, i)
    return i, row, col

</t>
<t tx="felix.20200928174406.3">def clipboard_clear(self):
    self.g.app.gui.replaceClipboardWith('')

def clipboard_append(self, s):
    s1 = self.g.app.gui.getTextFromClipboard()
    self.g.app.gui.replaceClipboardWith(s1 + s)

</t>
<t tx="felix.20200928174406.4">def flashCharacter(self, i, bg='white', fg='red',
                   flashes=3, delay=75): pass

def see(self, i): pass

def seeInsertPoint(self): pass

def setFocus(self): pass

def setStyleClass(self, name): pass

def tag_configure(self, colorName, **keys): pass

</t>
<t tx="felix.20200928174406.5"></t>
<t tx="felix.20200928174406.6">def appendText(self, s):
    """IntegTextWrapper appendText"""
    self.s = self.s + self.g.toUnicode(s)
    # defensive
    self.ins = len(self.s)
    self.sel = self.ins, self.ins

</t>
<t tx="felix.20200928174406.7">def delete(self, i, j=None):
    """IntegTextWrapper delete"""
    i = self.toPythonIndex(i)
    if j is None:
        j = i + 1
    j = self.toPythonIndex(j)
    # This allows subclasses to use this base class method.
    if i &gt; j:
        i, j = j, i
    s = self.getAllText()
    self.setAllText(s[:i] + s[j:])
    # Bug fix: 2011/11/13: Significant in external tests.
    self.setSelectionRange(i, i, insert=i)

</t>
<t tx="felix.20200928174406.8">def deleteTextSelection(self):
    """IntegTextWrapper."""
    i, j = self.getSelectionRange()
    self.delete(i, j)

</t>
<t tx="felix.20200928174406.9">def get(self, i, j=None):
    """IntegTextWrapper get"""
    i = self.toPythonIndex(i)
    if j is None:
        j = i + 1
    j = self.toPythonIndex(j)
    s = self.s[i:j]
    # print("WRAPPER GET with self.s[i:j]: " + s)
    return self.g.toUnicode(s)

</t>
<t tx="felix.20200929215102.2">def getStates(self, p_package):
    """
    Gets the currently opened file's general states for UI enabled/disabled states
    such as undo available, file changed/unchanged
    """
    w_states = {}
    if self.commander:
        try:
            # 'dirty/changed' member
            w_states["changed"] = self.commander.changed
            w_states["canUndo"] = self.commander.canUndo()
            w_states["canRedo"] = self.commander.canRedo()
            w_states["canDemote"] = self.commander.canDemote()
            w_states["canPromote"] = self.commander.canPromote()
            w_states["canDehoist"] = self.commander.canDehoist()

        except Exception as e:
            self.g.trace('Error while getting states')
            print("Error while getting states", flush=True)
            print(str(e), flush=True)
    else:
        w_states["changed"] = False
        w_states["canUndo"] = False
        w_states["canRedo"] = False
        w_states["canDemote"] = False
        w_states["canPromote"] = False
        w_states["canDehoist"] = False

    return self.sendLeoBridgePackage("states", w_states)

</t>
<t tx="felix.20200929215102.3">def pageUp(self, p_unused):
    """Selects a node a couple of steps up in the tree to simulate page up"""
    self.commander.selectVisBack()
    self.commander.selectVisBack()
    self.commander.selectVisBack()
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200929215102.4">def pageDown(self, p_unused):
    """Selects a node a couple of steps down in the tree to simulate page down"""
    self.commander.selectVisNext()
    self.commander.selectVisNext()
    self.commander.selectVisNext()
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200929215102.5">def getBodyStates(self, p_ap):
    """
    Finds the language in effect at top of body for position p,
    return type is lowercase 'language' non-empty string.
    Also returns the saved cursor position from last time node was accessed.
    """
    if not p_ap:
        return self._outputError("Error in getLanguage, no param p_ap")

    w_p = self._ap_to_p(p_ap)
    if not w_p:
        print(
            "in GBS -&gt; P NOT FOUND gnx:" + p_ap['gnx'] + " using self.commander.p gnx: " + self.commander.p.v.gnx)
        w_p = self.commander.p

    w_wrapper = self.commander.frame.body.wrapper

    defaultPosition = {"line": 0, "col": 0}
    states = {
        'language': 'plain',
        # See BodySelectionInfo interface in types.d.ts
        'selection': {
            "gnx": w_p.v.gnx,
            "scroll": {
                "start": defaultPosition,
                "end": defaultPosition
            },
            "active": defaultPosition,
            "start": defaultPosition,
            "end": defaultPosition
        }
    }

    if w_p:
        c, g = self.commander, self.g
        aList = g.get_directives_dict_list(w_p)
        d = g.scanAtCommentAndAtLanguageDirectives(aList)

        language = (
            d and d.get('language') or
            g.getLanguageFromAncestorAtFileNode(w_p) or
            c.config.getString('target-language') or
            'plain'
        )

        w_scroll = w_p.v.scrollBarSpot
        w_active = w_p.v.insertSpot
        w_start = w_p.v.selectionStart
        w_end = w_p.v.selectionStart + w_p.v.selectionLength

        # get selection from wrapper instead if its the selected node
        if self.commander.p.v.gnx == w_p.v.gnx:
            # print("in GBS -&gt; SAME AS self.commander.p SO USING FROM WRAPPER")
            w_active = w_wrapper.getInsertPoint()
            w_start, w_end = w_wrapper.getSelectionRange(True)
            w_scroll = w_wrapper.getYScrollPosition()

        # TODO : This conversion for scroll position may be unneeded (consider as lines only)
        # w_scrollI, w_scrollRow, w_scrollCol = c.frame.body.wrapper.toPythonIndexRowCol(w_Scroll)
        # compute line and column for the insertion point, and the start &amp; end of selection
        w_activeI, w_activeRow, w_activeCol = c.frame.body.wrapper.toPythonIndexRowCol(
            w_active)
        w_startI, w_startRow, w_startCol = c.frame.body.wrapper.toPythonIndexRowCol(
            w_start)
        w_endI, w_endRow, w_endCol = c.frame.body.wrapper.toPythonIndexRowCol(
            w_end)

        states = {
            'language': language.lower(),
            'selection': {
                "gnx": w_p.v.gnx,
                "scroll": w_scroll,  # w_scroll was kept as-is
                "active": {"line": w_activeRow, "col": w_activeCol},
                "start": {"line": w_startRow, "col": w_startCol},
                "end": {"line": w_endRow, "col": w_endCol}
            }
        }
    return self.sendLeoBridgePackage("bodyStates", states)

</t>
<t tx="felix.20200929230231.1">def setSelection(self, p_package):
    '''
    Set cursor position and scroll position along with selection start and end.
    (For the currently selected node's body, if gnx matches only)
    Save those values on the commander's body "wrapper"
    See BodySelectionInfo interface in types.d.ts
    '''
    w_same = False  # Flag for actually setting values in the wrapper, if same gnx.
    w_wrapper = self.commander.frame.body.wrapper
    w_gnx = p_package['gnx']
    w_body = ""
    w_v = None
    if self.commander.p.v.gnx == w_gnx:
        # print('Set Selection! OK SAME GNX: ' + self.commander.p.v.gnx)
        w_same = True
        w_v = self.commander.p.v
    else:
        # ? When navigating rapidly - Check if this is a bug - how to improve
        # print('Set Selection! NOT SAME GNX: selected:' +
        #       self.commander.p.v.gnx + ', package:' + w_gnx)
        w_v = self.commander.fileCommands.gnxDict.get(w_gnx)

    if not w_v:
        print('ERROR : Set Selection! NOT SAME Leo Document')
        # ! FAILED (but return as normal)
        return self._outputPNode(self.commander.p)

    w_body = w_v.b
    f_convert = self.g.convertRowColToPythonIndex
    w_active = p_package['active']
    w_start = p_package['start']
    w_end = p_package['end']

    # no convertion necessary, its given back later
    w_scroll = p_package['scroll']
    w_insert = f_convert(
        w_body, w_active['line'], w_active['col'])
    w_startSel = f_convert(
        w_body, w_start['line'], w_start['col'])
    w_endSel = f_convert(
        w_body, w_end['line'], w_end['col'])

    # print("setSelection (same as selected): " + str(w_same) + " w_insert " + str(w_insert) +
    #       " w_startSel " + str(w_startSel) + " w_endSel " + str(w_endSel))

    if w_same:
        w_wrapper.setSelectionRange(w_startSel, w_endSel, w_insert)
        w_wrapper.setYScrollPosition(w_scroll)
    else:
        pass

    # Set for v node no matter what
    w_v.scrollBarSpot = w_scroll
    w_v.insertSpot = w_insert
    w_v.selectionStart = w_startSel
    w_v.selectionLength = (
        w_endSel - w_startSel) if w_endSel &gt; w_startSel else 0

    # When switching nodes, Leo's core saves the insert point, selection,
    # and vertical scroll position in the old (unselected) vnode. From v.init:

    # self.insertSpot = None
    #     # Location of previous insert point.
    # self.scrollBarSpot = None
    #     # Previous value of scrollbar position.
    # self.selectionLength = 0
    #     # The length of the selected body text.
    # self.selectionStart = 0
    #         # The start of the selected body text.

    # output selected node as 'ok'
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20201006195046.1">/**
 * * LeoBody cursor active position and text selection state, along with gnx
 */
export interface BodySelectionInfo {
    gnx: string;
    // scroll is stored as-is as the 'scrollBarSpot' in Leo
    scroll: {
        start: BodyPosition;
        end: BodyPosition;
    }
    active: BodyPosition;
    start: BodyPosition;
    end: BodyPosition;
}

</t>
<t tx="felix.20201014020145.1">/**
 * * Handles detection of the active editor's scroll position changes
 * @param p_event a change event containing the active editor's visible range, if any.
 */
private _onChangeEditorScroll(p_event: vscode.TextEditorVisibleRangesChangeEvent): void {
    if ((p_event.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME)) {
        if (p_event.visibleRanges.length) {
            this._scrollDirty = true;
            this._scroll = p_event.visibleRanges[0];
            this._scrollGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20201017224340.1">/**
 * * Structure for configuration settings changes used along with welcome/settings webview.
 */
export interface ConfigSetting {
    code: string;
    value: any;
}

</t>
<t tx="felix.20201018163510.1">/**
 * * Returns the milliseconds between a given starting process.hrtime tuple and the current call to process.hrtime
 * @param p_start starting process.hrtime to subtract from current immediate time
 * @returns number of milliseconds passed since the given start hrtime
 */
export function getDurationMs(p_start: [number, number]): number {
    const [w_secs, w_nanosecs] = process.hrtime(p_start);
    return w_secs * 1000 + Math.floor(w_nanosecs / 1000000);
}

</t>
<t tx="felix.20201025144113.1">def test(self, p_package):
    '''Utility test function for debugging'''
    print("Called test")
    return self.sendLeoBridgePackage('testReturnedKey', 'testReturnedValue')
    # return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20201028223434.1">def setXScrollPosition(self, i):
    pass
    # X axis ignored

</t>
<t tx="felix.20201028223533.1">def getXScrollPosition(self):
    return 0
    # X axis ignored

</t>
<t tx="felix.20201102223046.1">def setYScrollPosition(self, i):
    self.yScroll = i
    # print("wrapper set y scroll" + str(self.yScroll))

</t>
<t tx="felix.20201102223052.1">def getYScrollPosition(self):
    # print("wrapper get y scroll" + str(self.yScroll))
    return self.yScroll

</t>
<t tx="felix.20201103000337.1">/**
 * * Table for converting Leo languages names for the currently opened body pane
 * Used in showBody method of leoIntegration.ts
 */
public static LANGUAGE_CODES: { [key: string]: string | undefined } = {
    cplusplus: 'cpp',
    md: 'markdown'
};

</t>
<t tx="felix.20201105010253.1">{
  "command": "leointeg.extract",
  "key": "ctrl+shift+d",
  "mac": "cmd+shift+d",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.extract",
  "key": "ctrl+shift+d",
  "mac": "cmd+shift+d",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.extractNames",
  "key": "ctrl+shift+n",
  "mac": "cmd++shift+n",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.extractNames",
  "key": "ctrl+shift+n",
  "mac": "cmd+shift+n",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="felix.20201105010614.1">{
  "command": "leointeg.extract",
  "category": "Leo",
  "title": "Extract"
},
{
  "command": "leointeg.extractNames",
  "category": "Leo",
  "title": "Extract Names"
},
</t>
<t tx="felix.20201106200100.1">/**
 * * Performs the actual addition into globalState context
 * @param p_context Needed to get to vscode global storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the global storage modification is done
 */
export function addFileToGlobal(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Just push that string into the context.globalState.&lt;something&gt; array
    const w_contextEntry: string[] = p_context.globalState.get(p_key) || [];
    if (w_contextEntry) {
        if (!w_contextEntry.includes(p_file)) {
            w_contextEntry.push(p_file);
            if (w_contextEntry.length &gt; 10) {
                w_contextEntry.shift();
            }
        }
        return p_context.globalState.update(p_key, w_contextEntry); // Added file
    } else {
        // First so create key entry with an array of single file
        return p_context.globalState.update(p_key, [p_file]);
    }
}

</t>
<t tx="felix.20201106200109.1">/**
 * * Removes file entry from globalState context
 * @param p_context Needed to get to vscode global storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the global storage modification is done
  */
export function removeFileFromGlobal(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Check if exist in context.globalState.&lt;something&gt; and remove if found
    const w_files: string[] = p_context.globalState.get(p_key) || [];
    if (w_files &amp;&amp; w_files.includes(p_file)) {
        w_files.splice(w_files.indexOf(p_file), 1); // Splice and update
        return p_context.globalState.update(p_key, w_files);
    }
    return Promise.resolve(); // not even in list so just resolve
}

</t>
<t tx="felix.20201107224112.1">/**
 * * Promise that triggers body save (rejects if busy), and resolves when done
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the possible saving process is finished
 */
private _isBusyTriggerSave(p_all: boolean, p_forcedVsCodeSave?: boolean): Promise&lt;boolean&gt; {
    if (this._isBusy(p_all)) {
        return Promise.reject("Command stack busy"); // Warn user to wait for end of busy state
    }
    return this.triggerBodySave(p_forcedVsCodeSave);
}

</t>
<t tx="felix.20201114185218.1">/**
 * * Sets the outline pane top bar string message or refreshes with existing title if no title passed
 * @param p_title new string to replace the current title
 */
public setTreeViewTitle(p_title?: string): void {
    if (p_title) {
        this._currentOutlineTitle = p_title;
    }
    // * Set/Change outline pane title e.g. "INTEGRATION", "OUTLINE"
    if (this._leoTreeView) {
        this._leoTreeView.title = this._currentOutlineTitle;
    }
    if (this._leoTreeExView) {
        this._leoTreeExView.title = Constants.GUI.EXPLORER_TREEVIEW_PREFIX + this._currentOutlineTitle;
    }
}

</t>
<t tx="felix.20201114185813.1">/**
 * * Opens quickPick minibuffer pallette to choose from all commands in this file's commander
 * @returns Promise that resolves when the chosen command is placed on the front-end command stack
 */
public minibuffer(): Thenable&lt;LeoBridgePackage | undefined&gt; {
    // Wait for _isBusyTriggerSave resolve because the full body save may change available commands
    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {
            const q_commandList: Thenable&lt;MinibufferCommand[]&gt; = this.sendAction(Constants.LEOBRIDGE.GET_COMMANDS, JSON.stringify({ "text": "" }))
                .then((p_result: LeoBridgePackage) =&gt; {
                    if (p_result.commands &amp;&amp; p_result.commands.length) {
                        return p_result.commands;
                    } else {
                        return [];
                    }
                });
            const w_options: vscode.QuickPickOptions = {
                placeHolder: Constants.USER_MESSAGES.MINIBUFFER_PROMPT,
                matchOnDetail: true
            };
            return vscode.window.showQuickPick(q_commandList, w_options);
        })
        .then((p_picked) =&gt; {
            if (p_picked &amp;&amp; p_picked.func) {
                const w_commandResult = this.nodeCommand({
                    action: p_picked.func,
                    node: undefined,
                    refreshType: { tree: true, body: true, documents: true, buttons: true, states: true },
                    fromOutline: false // true // TODO : Differentiate from outline?
                });
                return w_commandResult ? w_commandResult : Promise.reject("Command not added");
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20201119002510.1">/**
 * * Body position
 * Used in BodySelectionInfo interface
 */
export interface BodyPosition {
    line: number;
    col: number;
}

</t>
<t tx="felix.20201126235315.1">/**
 * * Strings used in 'at-button' panel display in LeoButtonNode
 */
public static BUTTON_STRINGS = {
    NULL_WIDGET: "nullButtonWidget",
    SCRIPT_BUTTON: "script-button",
    ADD_BUTTON: "leoButtonAdd",
    NORMAL_BUTTON: "leoButtonNode"
};

</t>
<t tx="felix.20201129184357.1">def printAction(p_param):
    # print action if not getChild or getChildren
    w_action = p_param["action"]
    if w_action in commonActions:
        pass
    else:
        print(f"*ACTION* {w_action}, id {p_param['id']}", flush=True)


</t>
<t tx="felix.20201208235246.1">/**
 * * Command strings to be used with vscode.commands.executeCommand
 * See https://code.visualstudio.com/api/extension-guides/command#programmatically-executing-a-command
 */
public static VSCODE_COMMANDS = {
    SET_CONTEXT: "setContext",
    CLOSE_ACTIVE_EDITOR: "workbench.action.closeActiveEditor",
    QUICK_OPEN: "workbench.action.quickOpen"
};

</t>
<t tx="felix.20201215210439.1">"view/title": [
  {
    "command": "leointeg.openLeoFile",
    "when": "view =~ /leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "view =~ /leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.showSettingsPage",
    "when": "view =~ /leoIntegration/ &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.connectToServer",
    "when": "view =~ /leoIntegration/ &amp;&amp; !leoBridgeReady &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.openLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoTreeTitled &amp;&amp; leoChanged",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.undoFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanUndo",
    "group": "navigation@3"
  },
  {
    "command": "leointeg.redoFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanRedo",
    "group": "navigation@4"
  },
  {
    "command": "leointeg.deHoistFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanDehoist",
    "group": "navigation@5"
  },
  {
    "command": "leointeg.contractAllFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened",
    "group": "navigation@6"
  }
],
</t>
<t tx="felix.20201215210510.1">"view/item/context": [
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "viewItem =~ /leoDocumentSelectedTitled/ &amp;&amp; leoChanged",
    "group": "inline@1"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "viewItem =~ /leoDocumentSelectedUntitled/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.closeLeoFile",
    "when": "viewItem =~ /leoDocumentSelected/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.editHeadline",
    "when": "showEditOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.insertNode",
    "when": "showAddOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.moveOutlineDown",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineLeft",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineRight",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineUp",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.copyNode",
    "when": "showCopyOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "showCloneOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.mark",
    "when": "showMarkOnNodes &amp;&amp; viewItem =~ /leoNodeUnmarked/",
    "group": "inline@5"
  },
  {
    "command": "leointeg.unmark",
    "when": "showMarkOnNodes &amp;&amp; viewItem =~ /leoNodeMarked/",
    "group": "inline@5"
  },
  {
    "command": "leointeg.openAside",
    "when": "showOpenAside &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext1@1"
  },
  {
    "command": "leointeg.hoistNode",
    "when": "viewItem =~ /leoNodeNotRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.deHoist",
    "when": "leoCanDehoist &amp;&amp; viewItem =~ /leoNodeRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.refreshFromDisk",
    "when": "viewItem =~ /leoNodeAtFile/",
    "group": "leoNodeContext1@3"
  },
  {
    "command": "leointeg.mark",
    "when": "viewItem =~ /leoNodeUnmarked/",
    "group": "leoNodeContext2@1"
  },
  {
    "command": "leointeg.unmark",
    "when": "viewItem =~ /leoNodeMarked/",
    "group": "leoNodeContext2@2"
  },
  {
    "command": "leointeg.copyNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@3"
  },
  {
    "command": "leointeg.cutNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@4"
  },
  {
    "command": "leointeg.pasteNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@5"
  },
  {
    "command": "leointeg.pasteNodeAsClone",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@6"
  },
  {
    "command": "leointeg.delete",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@7"
  },
  {
    "command": "leointeg.insertNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext3@1"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext3@2"
  },
  {
    "command": "leointeg.gotoNextClone",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNodeCloned/",
    "group": "leoNodeContext3@3"
  },
  {
    "command": "leointeg.removeButton",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoButtonNode/",
    "group": "leoButtonContext1@1"
  }
]</t>
<t tx="felix.20210418013332.1">private _hideDeleteBody(p_textEditor: vscode.TextEditor): void {
    console.log('DELETE EXTRANEOUS:', p_textEditor.document.uri.fsPath);
    const w_edit = new vscode.WorkspaceEdit();
    w_edit.deleteFile(p_textEditor.document.uri, { ignoreIfNotExists: true });
    if (p_textEditor.hide) {
        p_textEditor.hide();
    }
    vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', p_textEditor.document.uri.path);
}

</t>
<t tx="felix.20210418014039.1">/**
 * * Moved a document to another column
 */
public _changedTextEditorViewColumn(p_columnChangeEvent: vscode.TextEditorViewColumnChangeEvent): void {
    if (p_columnChangeEvent &amp;&amp; p_columnChangeEvent.textEditor.document.uri.scheme === 'more') {
        console.log('changedTextEditorViewColumn: gnx', p_columnChangeEvent.textEditor.document.uri.fsPath);
        this._checkPreviewMode(p_columnChangeEvent.textEditor);
    }
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20210418014040.1">/**
 * * Tabbed on another editor
 */
public _changedVisibleTextEditors(p_editors: vscode.TextEditor[]): void {
    if (p_editors &amp;&amp; p_editors.length) {
        p_editors.forEach(p_textEditor =&gt; {
            if (p_textEditor &amp;&amp; p_textEditor.document.uri.scheme === 'more') {
                console.log('changedVisibleTextEditors: gnx', p_textEditor.document.uri.fsPath);
                if (this.bodyUri.fsPath !== p_textEditor.document.uri.fsPath) {
                    this._hideDeleteBody(p_textEditor);
                }
                this._checkPreviewMode(p_textEditor);
            }
        });
    }
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20210418014040.2">/**
 * * Whole window has been minimized/restored
 */
public _changedWindowState(p_windowState: vscode.WindowState): void {
    // no other action
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20210418220343.1">private _checkPreviewMode(p_editor: vscode.TextEditor): void {
    // if selected gnx but in another column
    if (
        p_editor.document.uri.fsPath === this.bodyUri.fsPath &amp;&amp;
        p_editor.viewColumn !== this._bodyMainSelectionColumn
    ) {
        this._bodyPreviewMode = false;
        this._bodyMainSelectionColumn = p_editor.viewColumn;
    }
}

</t>
<t tx="felix.20210418230204.1">private _findUriColumn(p_uri: vscode.Uri): vscode.ViewColumn | undefined {
    let w_column: vscode.ViewColumn | undefined;
    vscode.window.visibleTextEditors.forEach(p_textEditor =&gt; {
        if (p_textEditor.document.uri.fsPath === p_uri.fsPath) {
            w_column = p_textEditor.viewColumn;
        }
    });
    return w_column;
}

</t>
<t tx="felix.20210418230204.2">private findGnxColumn(p_gnx: string): vscode.ViewColumn | undefined {
    let w_column: vscode.ViewColumn | undefined;
    vscode.window.visibleTextEditors.forEach(p_textEditor =&gt; {
        if (p_textEditor.document.uri.fsPath.substr(1) === p_gnx) {
            w_column = p_textEditor.viewColumn;
        }
    });
    return w_column;
}

</t>
<t tx="felix.20210420004713.1">/**
 * Fetch language, cursor position and text selection for the current selected tree node,
 * then apply it to the text document given as parameter when the fetch resolves,
 * but only if it's still the same gnx/node as the currently selected node.
 * @param p_document text document opened for which the language and cursor has to be set
 */
private _setLanguageAndSelection(p_document: vscode.TextDocument): void {
    if (this.lastSelectedNode) {
        // this.lastSelectedNode MAY NOT BE VALID
        this.sendAction(Constants.LEOBRIDGE.GET_BODY_STATES, this.lastSelectedNode.apJson)
            .then((p_result: LeoBridgePackage) =&gt; {

                const w_bodyStates = p_result.bodyStates!; // This answer has bodyStates member
                let w_language: string = w_bodyStates.language;
                const w_leoBodySel: BodySelectionInfo = w_bodyStates.selection;

                if (w_leoBodySel.gnx !== this.lastSelectedNode!.gnx) {
                    console.error(
                        'GOT STATES FOR DIFFERENT GNX: ' + w_leoBodySel.gnx +
                        ", last sel node is now: " + this.lastSelectedNode!.gnx
                    );
                }

                const w_scroll = w_leoBodySel.scroll;

                let w_scrollRange: vscode.Range | undefined;
                if (w_scroll &amp;&amp; w_scroll.start &amp;&amp; w_scroll.end &amp;&amp;
                    (w_scroll.start.line ||
                        w_scroll.start.col ||
                        w_scroll.end.line ||
                        w_scroll.end.col)
                ) {
                    w_scrollRange = new vscode.Range(
                        w_scroll.start.line,
                        w_scroll.start.col,
                        w_scroll.end.line,
                        w_scroll.end.col,
                    );
                } else {
                    // w_scrollRange = new vscode.Range(0, 0, 0, 0); // try with p_textEditor.document.lineAt(0).range;
                }

                // Cursor position and selection range
                const w_activeRow: number = w_leoBodySel.active.line;
                const w_activeCol: number = w_leoBodySel.active.col;
                let w_anchorLine: number = w_leoBodySel.start.line;
                let w_anchorCharacter: number = w_leoBodySel.start.col;

                if (w_activeRow === w_anchorLine &amp;&amp;
                    w_activeCol === w_anchorCharacter) {
                    // Active insertion same as start selection, so use the other ones
                    w_anchorLine = w_leoBodySel.end.line;
                    w_anchorCharacter = w_leoBodySel.end.col;
                }

                const w_selection = new vscode.Selection(
                    w_anchorLine,
                    w_anchorCharacter,
                    w_activeRow,
                    w_activeCol
                );

                const w_documentGnx = utils.leoUriToStr(p_document.uri);

                // if any editors now have gnx match of the selections that was just fetched
                vscode.window.visibleTextEditors.forEach(p_textEditor =&gt; {
                    if (p_textEditor.document.uri.fsPath === p_document.uri.fsPath &amp;&amp;
                        w_documentGnx === w_leoBodySel.gnx
                    ) {
                        p_textEditor.selection = w_selection; // set cursor insertion point &amp; selection range
                        if (!w_scrollRange) {
                            w_scrollRange = p_textEditor.document.lineAt(0).range;
                        }
                        p_textEditor.revealRange(w_scrollRange); // set
                    }
                });

                // Replace language string if in 'exceptions' array
                w_language = "leobody." + (Constants.LANGUAGE_CODES[w_language] || w_language);

                // Apply language if the selected node is still the same after all those events
                if (
                    !p_document.isClosed &amp;&amp; this.lastSelectedNode &amp;&amp;
                    w_documentGnx === this.lastSelectedNode.gnx
                ) {
                    vscode.languages.setTextDocumentLanguage(p_document, w_language);
                }
            });
    }
}

</t>
<t tx="felix.20210420215230.1">/**
 * Show file browser to find leoserver.py. Save it's path in the config or cancel.
 */
public chooseLeoServerPath(): void {
    vscode.window.showOpenDialog(
        {
            title: "Locate Leo Server Script",
            canSelectMany: false,
            openLabel: "Choose",
            filters: { 'script': ['py'] }
        }
    )
        .then(p_chosenFile =&gt; {
            console.log(p_chosenFile);

        });
}

</t>
</tnodes>
</leo_file>
