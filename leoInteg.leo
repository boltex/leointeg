<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="felix.20200718220811.1"><vh>Documentation</vh>
<v t="felix.20200718220818.1"><vh>@clean README.md</vh>
<v t="felix.20200718221645.1"><vh>Requirements</vh></v>
<v t="felix.20200718222035.1"><vh>Features</vh></v>
<v t="felix.20231001151916.1"><vh>Leo Commands</vh></v>
<v t="felix.20200718222043.1"><vh>Keybindings</vh></v>
<v t="felix.20200718222048.1"><vh>Derive External Files</vh></v>
<v t="felix.20200718222053.1"><vh>Automate Synchronization</vh></v>
<v t="felix.20200718222102.1"><vh>Extension Settings</vh></v>
<v t="felix.20210829192609.1"><vh>Server Settings</vh></v>
<v t="felix.20230304202815.1"><vh>Navigating a Leo Document</vh></v>
<v t="felix.20230304182815.1"><vh>Undo Panel</vh></v>
<v t="felix.20200718222108.1"><vh>Issues</vh></v>
<v t="felix.20200718222113.1"><vh>How it works</vh></v>
<v t="felix.20200718222118.1"><vh>Acknowledgments</vh></v>
</v>
<v t="felix.20200718220833.1"><vh>@clean CHANGELOG.md</vh>
<v t="felix.20240330232425.1"><vh>1.0.21</vh></v>
<v t="felix.20240122213243.1"><vh>1.0.20</vh></v>
<v t="felix.20231216214036.1"><vh>1.0.19</vh></v>
<v t="felix.20231210150154.1"><vh>1.0.18</vh></v>
<v t="felix.20231130225803.1"><vh>1.0.17</vh></v>
<v t="felix.20231009003516.1"><vh>1.0.16</vh></v>
<v t="felix.20230821005233.1"><vh>1.0.15</vh></v>
<v t="fil.20230405000235.1"><vh>1.0.14</vh></v>
<v t="felix.20230310210120.1"><vh>1.0.13</vh></v>
<v t="felix.20221208001059.1"><vh>1.0.12</vh></v>
<v t="felix.20221212232224.1"><vh>1.0.11</vh></v>
<v t="felix.20221009171323.1"><vh>1.0.10</vh></v>
<v t="felix.20221002170017.1"><vh>1.0.9</vh></v>
<v t="felix.20220702153409.1"><vh>1.0.8</vh></v>
<v t="felix.20220321001559.1"><vh>1.0.7</vh></v>
<v t="felix.20220216005511.1"><vh>1.0.6</vh></v>
<v t="felix.20211210001626.1"><vh>1.0.5</vh></v>
<v t="felix.20211018004333.1"><vh>1.0.4</vh></v>
<v t="felix.20211007215423.1"><vh>1.0.3</vh></v>
<v t="felix.20210928231455.1"><vh>1.0.2</vh></v>
<v t="felix.20210919194446.1"><vh>1.0.1</vh></v>
<v t="felix.20210923233342.1"><vh>1.0.0</vh></v>
<v t="felix.20210919194259.1"><vh>0.1.20</vh></v>
<v t="felix.20210901215735.1"><vh>0.1.19</vh></v>
<v t="felix.20210916004954.1"><vh>0.1.18</vh></v>
<v t="felix.20210816230003.1"><vh>0.1.17</vh></v>
<v t="felix.20210725153617.1"><vh>0.1.16</vh></v>
<v t="felix.20210718163005.1"><vh>0.1.15</vh></v>
<v t="felix.20210612000127.1"><vh>0.1.14</vh></v>
<v t="felix.20210509210502.1"><vh>0.1.13</vh></v>
<v t="felix.20200718222417.1"><vh>0.1.12</vh></v>
<v t="felix.20200718222419.1"><vh>0.1.11</vh></v>
<v t="felix.20200718222422.1"><vh>0.1.10</vh></v>
<v t="felix.20200718222425.1"><vh>0.1.9</vh></v>
<v t="felix.20200718222427.1"><vh>0.1.8</vh></v>
<v t="felix.20200718222429.1"><vh>0.1.7</vh></v>
<v t="felix.20200718222433.1"><vh>0.1.6</vh></v>
<v t="felix.20200718222435.1"><vh>0.1.5</vh></v>
<v t="felix.20200718222437.1"><vh>0.1.4</vh></v>
<v t="felix.20200718222439.1"><vh>0.1.3</vh></v>
<v t="felix.20200718222440.1"><vh>0.1.2</vh></v>
<v t="felix.20200718222442.1"><vh>0.1.1</vh></v>
<v t="felix.20200718222445.1"><vh>0.0.1</vh></v>
</v>
<v t="felix.20200718220833.2"><vh>@clean CONTRIBUTING.md</vh>
<v t="felix.20200718222731.1"><vh>Introduction</vh></v>
<v t="felix.20200718222739.1"><vh>Development requirements</vh></v>
<v t="felix.20200718222741.1"><vh>Getting the source</vh></v>
<v t="felix.20200718222745.1"><vh>Choosing a debug profile</vh></v>
<v t="felix.20200718222748.1"><vh>Starting the extension</vh></v>
<v t="felix.20200718222754.1"><vh>The python server script</vh></v>
<v t="felix.20200718222757.1"><vh>Issues</vh></v>
</v>
<v t="felix.20230304215145.1"><vh>@clean BACKERS.md</vh></v>
</v>
<v t="ekr.20200722190517.1"><vh>Files: Other</vh>
<v t="ekr.20200815123601.1"><vh>@clean package.json</vh>
<v t="ekr.20200815123601.2"><vh>configuration</vh>
<v t="ekr.20200815123601.3"><vh>External Files Change Detection</vh></v>
<v t="ekr.20200815123601.4"><vh>Interface Behavior</vh></v>
<v t="ekr.20200815123601.5"><vh>Statusbar Indicator</vh></v>
<v t="ekr.20200815123601.6"><vh>Interface Appearance</vh></v>
<v t="ekr.20200815123601.7"><vh>Leo Bridge Options</vh></v>
</v>
<v t="ekr.20200815123601.8"><vh>viewsContainers</vh></v>
<v t="ekr.20200815123601.9"><vh>views</vh></v>
<v t="ekr.20200815123601.10"><vh>languages</vh></v>
<v t="ekr.20200815123601.11"><vh>grammars</vh></v>
<v t="ekr.20200815123601.12"><vh>snippets</vh></v>
<v t="ekr.20200815123601.28"><vh>viewsWelcome</vh>
<v t="ekr.20200815123601.29"><vh>Leo Integration</vh>
<v t="ekr.20200815123601.30"><vh>Not Ready: [start], [connect] and settings</vh></v>
<v t="felix.20230226173728.1"><vh>Not Ready: Starting Server...</vh></v>
<v t="ekr.20200815123601.31"><vh>Not Ready : [connect] and settings</vh></v>
<v t="ekr.20200815123601.33"><vh>Not Ready: Connecting...</vh></v>
<v t="ekr.20200815123601.34"><vh>Ready: [open], [new] and settings</vh></v>
</v>
<v t="ekr.20200815123601.35"><vh>Leo Documents</vh>
<v t="ekr.20200815123601.36"><vh>Not Ready</vh></v>
<v t="ekr.20200815123601.37"><vh>Ready: Empty</vh></v>
</v>
<v t="ekr.20200815123601.38"><vh>leoButtons</vh>
<v t="ekr.20200815123601.39"><vh>Not Ready</vh></v>
<v t="ekr.20200815123601.40"><vh>Ready: No Opened Files</vh></v>
<v t="ekr.20200815123601.41"><vh>Ready: No Buttons</vh></v>
</v>
<v t="felix.20210522233604.1"><vh>leoFind</vh>
<v t="felix.20210522233744.1"><vh>Not Ready</vh></v>
</v>
<v t="felix.20220706220024.1"><vh>leoUndos</vh>
<v t="felix.20220706220120.1"><vh>Not Ready</vh></v>
<v t="felix.20220706220128.1"><vh>Ready: No Undos</vh></v>
</v>
</v>
<v t="felix.20240430200658.1"><vh>icons</vh></v>
<v t="ekr.20200815123601.13"><vh>commands</vh>
<v t="ekr.20200815123601.15"><vh>Show Webviews</vh></v>
<v t="ekr.20200815123601.16"><vh>Server</vh></v>
<v t="ekr.20200815123601.17"><vh>Scripting &amp; @buttons</vh></v>
<v t="ekr.20200815123601.18"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.19"><vh>Leo File Documents</vh></v>
<v t="felix.20220808231327.1"><vh>Import Export Files</vh></v>
<v t="ekr.20200815123601.20"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.21"><vh>Node Editing</vh></v>
<v t="felix.20201105010614.1"><vh>Text Editing</vh></v>
<v t="ekr.20200815123601.22"><vh>Move Nodes</vh></v>
<v t="ekr.20200815123601.23"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.24"><vh>Goto Nodes</vh></v>
<v t="ekr.20200815123601.25"><vh>Hoist/Dehoist</vh></v>
<v t="ekr.20200815123601.26"><vh>Undo/Redo</vh></v>
<v t="felix.20210517001143.1"><vh>Search</vh></v>
<v t="felix.20220307235733.1"><vh>Nav</vh></v>
<v t="felix.20210517001459.1"><vh>Mark Nodes</vh></v>
</v>
<v t="ekr.20200815123601.42"><vh>menus</vh>
<v t="ekr.20200815123601.43"><vh>commandPalette</vh>
<v t="ekr.20200815123601.58"><vh>Scripting &amp; @buttons</vh></v>
<v t="ekr.20200815123601.60"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.61"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.62"><vh>Node Editing</vh></v>
<v t="ekr.20200815123601.63"><vh>Move Nodes</vh></v>
<v t="ekr.20200815123601.64"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.65"><vh>Goto Nodes</vh></v>
<v t="ekr.20200815123601.66"><vh>Hoist/Dehoist</vh></v>
<v t="ekr.20200815123601.67"><vh>Undo/Redo</vh></v>
<v t="felix.20210530161800.1"><vh>Search</vh></v>
</v>
<v t="ekr.20200815123601.68"><vh>explorer/context</vh></v>
<v t="felix.20210610022645.1"><vh>editor/title</vh></v>
<v t="felix.20210713005825.1"><vh>editor/context</vh></v>
<v t="felix.20201215210439.1"><vh>view/title</vh></v>
<v t="felix.20201215210510.1"><vh>view/item/context</vh></v>
<v t="felix.20210821212114.1"><vh>extension/context</vh></v>
</v>
<v t="ekr.20200815123601.76"><vh>keybindings</vh>
<v t="ekr.20200815123601.77"><vh>Scripting</vh></v>
<v t="ekr.20200815123601.78"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.79"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.80"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.81"><vh>Node Editing</vh></v>
<v t="felix.20201105010253.1"><vh>Text Editing</vh></v>
<v t="ekr.20200815123601.82"><vh>Move Nodes</vh>
<v t="ekr.20200815123601.83"><vh>Move Down</vh></v>
<v t="ekr.20200815123601.84"><vh>Move left</vh></v>
<v t="ekr.20200815123601.85"><vh>Move right</vh></v>
<v t="ekr.20200815123601.86"><vh>Move Up</vh></v>
</v>
<v t="ekr.20200815123601.87"><vh>Outline Editing</vh></v>
<v t="felix.20211114150842.1"><vh>Undo/Redo</vh></v>
<v t="felix.20210517004335.1"><vh>Search</vh></v>
<v t="ekr.20200815123601.88"><vh>Goto Nodes</vh></v>
<v t="felix.20210812004050.1"><vh>VSCode Commands</vh></v>
</v>
<v t="ekr.20200815123601.89"><vh>resourceLabelFormatters</vh></v>
</v>
<v t="ekr.20200722130456.1"><vh>@edit .gitignore</vh></v>
<v t="felix.20220707233628.1"><vh>@edit .vscodeignore</vh></v>
</v>
<v t="felix.20200718165721.1"><vh>Files: Typescript</vh>
<v t="felix.20200718024635.1"><vh>@clean src/commandStack.ts</vh>
<v t="felix.20200718024635.2"><vh>class CommandStack</vh>
<v t="felix.20200718024635.3"><vh>size</vh></v>
<v t="felix.20200718024635.4"><vh>newSelection</vh></v>
<v t="felix.20200718024635.5"><vh>add</vh></v>
<v t="felix.20200718024635.6"><vh>_tryStart</vh></v>
<v t="felix.20200718024635.7"><vh>_runStackCommand</vh></v>
<v t="felix.20200718024635.8"><vh>_resolveResult</vh></v>
</v>
</v>
<v t="felix.20200718030926.1"><vh>@clean src/config.ts</vh>
<v t="felix.20200718030926.2"><vh>class Config</vh>
<v t="felix.20200718030926.3"><vh>getConfig</vh></v>
<v t="felix.20200718030926.4"><vh>setLeoIntegSettings</vh></v>
<v t="felix.20210818223534.1"><vh>setEnablePreview</vh></v>
<v t="felix.20210821203119.1"><vh>clearCloseEmptyGroups</vh></v>
<v t="felix.20240121200443.1"><vh>setBodyWrap</vh></v>
<v t="felix.20240221215337.1"><vh>removeOldBodyWrap</vh></v>
<v t="felix.20210818225820.1"><vh>checkEnablePreview</vh></v>
<v t="felix.20210821202347.1"><vh>checkCloseEmptyGroups</vh></v>
<v t="felix.20240121200637.1"><vh>checkBodyWrap</vh></v>
<v t="felix.20200718030926.5"><vh>buildFromSavedSettings</vh></v>
</v>
</v>
<v t="felix.20200718020912.1"><vh>@clean src/constants.ts</vh>
<v t="felix.20200718020912.2"><vh>class Constants</vh>
<v t="felix.20200718020912.3"><vh>general constants</vh></v>
<v t="felix.20240121194014.1"><vh>supported languages</vh></v>
<v t="felix.20221127172926.1"><vh>server minimal version</vh></v>
<v t="felix.20210530233134.1"><vh>find panel ids</vh></v>
<v t="felix.20200718020912.5"><vh>workbench interface panels</vh></v>
<v t="felix.20200718020912.6"><vh>user messages</vh></v>
<v t="felix.20210602213308.1"><vh>import file types</vh></v>
<v t="felix.20200718020912.7"><vh>ask/save buttons</vh></v>
<v t="felix.20201126235315.1"><vh>at-buttons strings</vh></v>
<v t="felix.20200718020912.8"><vh>configuration keys</vh></v>
<v t="ekr.20200815084016.1"><vh>config defaults</vh></v>
<v t="felix.20231007200850.1"><vh>history quickItem</vh></v>
<v t="felix.20200718020912.9"><vh>context flags</vh></v>
<v t="felix.20201208235246.1"><vh>vscode commands</vh></v>
<v t="felix.20200718020912.10"><vh>async actions</vh></v>
<v t="felix.20200718020912.11"><vh>async info messages codes</vh></v>
<v t="felix.20200718020912.12"><vh>async ask return codes</vh></v>
<v t="felix.20201103000337.1"><vh>body language code strings</vh></v>
<v t="felix.20200718020912.13"><vh>leoBridge action strings</vh></v>
<v t="felix.20200718020912.15"><vh>commands strings</vh></v>
<v t="felix.20220321211021.1"><vh>additional minibuffer commands</vh></v>
<v t="felix.20220709005340.1"><vh>unsupported minibuffer commands</vh></v>
<v t="felix.20210602151654.1"><vh>minibuffer overridden commands</vh></v>
</v>
</v>
<v t="felix.20200718031424.1"><vh>@clean src/extension.ts</vh>
<v t="felix.20200718031424.2"><vh>activate</vh>
<v t="ekr.20200815113156.1"><vh>&lt;&lt; Define entries for all commands &gt;&gt;</vh></v>
</v>
<v t="felix.20200718031424.24"><vh>deactivate</vh></v>
<v t="felix.20200718031424.25"><vh>showWelcomeIfNewer</vh></v>
</v>
<v t="felix.20200718035737.1"><vh>@clean src/leoAsync.ts</vh>
<v t="ekr.20200815083608.1"><vh>class LeoAsync</vh>
<v t="ekr.20200815083608.2"><vh>log</vh></v>
<v t="felix.20210804175113.1"><vh>refresh</vh></v>
<v t="ekr.20200815083608.3"><vh>showSaveAsDialog</vh></v>
<v t="ekr.20200815083609.1"><vh>showAskModalDialog</vh></v>
<v t="ekr.20200815083609.2"><vh>showWarnModalMessage</vh></v>
<v t="ekr.20200815083609.3"><vh>showChangesDetectedInfoMessage</vh></v>
<v t="ekr.20200815084550.1"><vh>&lt;&lt; TODO &gt;&gt;</vh></v>
</v>
</v>
<v t="felix.20200718040540.1"><vh>@clean src/leoBody.ts</vh>
<v t="felix.20200718040540.2"><vh>class LeoBodyProvider</vh>
<v t="felix.20230130154800.1"><vh>setNewBodyUriTime</vh></v>
<v t="felix.20230130154806.1"><vh>_setOpenedBodyTime</vh></v>
<v t="felix.20240501232955.1"><vh>cleanupBodies</vh></v>
<v t="felix.20200718040540.5"><vh>fireRefreshFile</vh></v>
<v t="felix.20200718040540.8"><vh>watch</vh></v>
<v t="felix.20200718040540.10"><vh>stat</vh></v>
<v t="felix.20200718040540.11"><vh>readFile</vh></v>
<v t="felix.20200718040540.12"><vh>readDirectory</vh></v>
<v t="felix.20200718040540.13"><vh>createDirectory</vh></v>
<v t="felix.20200718040540.14"><vh>writeFile</vh></v>
<v t="felix.20200718040540.15"><vh>rename</vh></v>
<v t="felix.20200718040540.16"><vh>delete</vh></v>
<v t="felix.20200718040540.17"><vh>copy</vh></v>
<v t="felix.20200718040540.18"><vh>_fireSoon</vh></v>
</v>
</v>
<v t="felix.20240502002356.1"><vh>@clean src/leoBodyDetached.ts</vh>
<v t="felix.20240502002356.2"><vh>class LeoBodyDetachedProvider</vh>
<v t="felix.20240502002356.3"><vh>setNewBodyUriTime</vh></v>
<v t="felix.20240502002356.4"><vh>_setOpenedBodyTime</vh></v>
<v t="felix.20240502002356.5"><vh>cleanupDetachedBodies</vh></v>
<v t="felix.20240502002356.6"><vh>fireRefreshFile</vh></v>
<v t="felix.20240502002356.7"><vh>watch</vh></v>
<v t="felix.20240502002356.8"><vh>stat</vh></v>
<v t="felix.20240502002356.9"><vh>readFile</vh></v>
<v t="felix.20240502002356.10"><vh>readDirectory</vh></v>
<v t="felix.20240502002356.11"><vh>createDirectory</vh></v>
<v t="felix.20240502002356.12"><vh>writeFile</vh></v>
<v t="felix.20240502002356.13"><vh>rename</vh></v>
<v t="felix.20240502002356.14"><vh>delete</vh></v>
<v t="felix.20240502002356.15"><vh>copy</vh></v>
<v t="felix.20240502002356.16"><vh>_fireSoon</vh></v>
</v>
</v>
<v t="felix.20200718153505.1"><vh>@clean src/leoBridge.ts</vh>
<v t="felix.20200718153505.2"><vh>class LeoBridge</vh>
<v t="felix.20200718153505.3"><vh>action</vh></v>
<v t="felix.20200718155251.1"><vh>isBusy</vh></v>
<v t="felix.20200718153505.4"><vh>_asyncAction</vh></v>
<v t="felix.20200718153505.6"><vh>_resolveBridgeReady</vh></v>
<v t="felix.20200718153505.7"><vh>_rejectAction</vh></v>
<v t="felix.20200718153505.8"><vh>_callAction</vh></v>
<v t="felix.20200718153505.9"><vh>_tryParseJSON</vh></v>
<v t="felix.20200718153505.11"><vh>_processAnswer</vh></v>
<v t="felix.20200718153505.12"><vh>initLeoProcess</vh></v>
<v t="felix.20210802163703.1"><vh>closeLeoProcess</vh></v>
<v t="felix.20200718153505.13"><vh>_send</vh></v>
</v>
</v>
<v t="felix.20220307233825.1"><vh>@clean src/leoGoto.ts</vh>
<v t="felix.20220903004804.1"><vh>class LeoGotoProvider</vh></v>
<v t="felix.20220903004914.1"><vh>class LeoGotoNode</vh></v>
</v>
<v t="felix.20200718164130.1"><vh>@clean src/leoButtons.ts</vh>
<v t="felix.20200718164130.2"><vh>class LeoButtonsProvider</vh>
<v t="felix.20200718164130.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718164130.4"><vh>getTreeItem</vh></v>
<v t="felix.20200718164130.5"><vh>getChildren</vh></v>
<v t="felix.20200718164130.6"><vh>getParent</vh></v>
</v>
<v t="felix.20200718162303.2"><vh>class LeoButtonNode</vh>
<v t="felix.20200718162435.1"><vh>iconPath</vh></v>
<v t="felix.20200718162442.1"><vh>id</vh></v>
<v t="felix.20200718162452.1"><vh>tooltip</vh></v>
<v t="felix.20200718162459.1"><vh>description</vh></v>
</v>
</v>
<v t="felix.20200718165108.1"><vh>@clean src/leoDocuments.ts</vh>
<v t="felix.20200718165108.2"><vh>class LeoDocumentsProvider</vh>
<v t="felix.20200718165108.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718165108.4"><vh>getTreeItem</vh></v>
<v t="felix.20200718165108.5"><vh>getChildren</vh></v>
<v t="felix.20200718165108.6"><vh>getParent</vh></v>
</v>
<v t="felix.20200718164509.2"><vh>class LeoDocumentNode</vh>
<v t="felix.20200718164635.1"><vh>iconPath</vh></v>
<v t="felix.20200718164638.1"><vh>id</vh></v>
</v>
</v>
<v t="felix.20200718170429.1"><vh>@clean src/leoFileBrowser.ts</vh>
<v t="felix.20200718170429.2"><vh>class LeoFilesBrowser</vh>
<v t="felix.20200718170429.3"><vh>_getBestOpenFolderUri</vh></v>
<v t="felix.20210602160216.1"><vh>getImportFileUrls</vh></v>
<v t="felix.20200718170429.4"><vh>getLeoFileUrl</vh></v>
<v t="felix.20210915234252.1"><vh>getLeoJsFileUrl</vh></v>
<v t="felix.20220810231122.1"><vh>getExportFileUrl</vh></v>
</v>
</v>
<v t="felix.20200719025231.1"><vh>@clean src/leoIntegration.ts</vh>
<v t="felix.20200719025231.2"><vh>class LeoIntegration</vh>
<v t="felix.20200719025231.3"><vh>Constructor</vh></v>
<v t="felix.20200719025231.4"><vh>Server</vh>
<v t="felix.20200719025231.5"><vh>sendAction</vh></v>
<v t="felix.20200719025231.6"><vh>startNetworkServices</vh></v>
<v t="felix.20231102230431.1"><vh>findInstallPath</vh></v>
<v t="felix.20200719025231.7"><vh>startServer</vh></v>
<v t="felix.20210717204048.1"><vh>killServer</vh></v>
<v t="felix.20210802162424.1"><vh>stopConnection</vh></v>
<v t="felix.20200719025231.8"><vh>connect</vh></v>
<v t="felix.20200719025231.9"><vh>cancelConnect</vh></v>
<v t="felix.20220327211552.1"><vh>setLeoID</vh></v>
<v t="felix.20220705220032.1"><vh>checkVersion</vh></v>
<v t="felix.20210613210351.1"><vh>chooseLeoFolder</vh></v>
<v t="felix.20200719031346.1"><vh>sendConfigToServer</vh></v>
<v t="felix.20240107202609.1"><vh>handleUnl</vh></v>
</v>
<v t="felix.20200719025231.10"><vh>Recently Opened Files</vh>
<v t="felix.20200719025231.11"><vh>_openLastFiles</vh></v>
<v t="felix.20230227002122.1"><vh>_finishOpenLastFiles</vh></v>
<v t="felix.20200719025231.12"><vh>_addRecentAndLastFile</vh></v>
<v t="felix.20200719025231.13"><vh>_removeRecentFile</vh></v>
<v t="felix.20200719025231.14"><vh>_removeLastFile</vh></v>
<v t="felix.20200719025231.15"><vh>showRecentLeoFiles</vh></v>
</v>
<v t="ekr.20200815085229.1"><vh>Log pane</vh>
<v t="ekr.20200815085316.4"><vh>showLogPane</vh></v>
<v t="ekr.20200815085316.5"><vh>hideLogPane</vh></v>
<v t="ekr.20200815085316.6"><vh>addLogPaneEntry</vh></v>
</v>
<v t="felix.20200719031802.1"><vh>Document States</vh>
<v t="felix.20200719025231.19"><vh>_triggerGetStates</vh></v>
<v t="felix.20240214000508.1"><vh>_getUNL</vh></v>
<v t="felix.20200719025231.20"><vh>_isBusy</vh></v>
<v t="felix.20201107224112.1"><vh>_isBusyTriggerSave</vh></v>
<v t="felix.20200719025231.21"><vh>_isCurrentFileNamed</vh></v>
<v t="felix.20200719025231.22"><vh>_setupNoOpenedLeoDocument</vh></v>
<v t="felix.20200719025231.23"><vh>_setupOpenedLeoDocument</vh></v>
</v>
<v t="felix.20200719030811.1"><vh>UI Change Events</vh>
<v t="felix.20200719025231.24"><vh>_onChangeConfiguration</vh></v>
<v t="ekr.20200815085628.1"><vh>_onDidOpenTextDocument</vh></v>
<v t="felix.20200719025231.25"><vh>_onChangeCollapsedState</vh></v>
<v t="felix.20200719025231.26"><vh>_onTreeViewVisibilityChanged</vh></v>
<v t="felix.20200719025231.27"><vh>_onDocTreeViewVisibilityChanged</vh></v>
<v t="ekr.20200815085705.1"><vh>_onButtonsTreeViewVisibilityChanged</vh></v>
<v t="felix.20220310224330.1"><vh>_onGotoTreeViewVisibilityChanged</vh></v>
<v t="felix.20220706000811.1"><vh>_onUndosTreeViewVisibilityChanged</vh></v>
<v t="felix.20220826004334.1"><vh>_onFindViewVisibilityChanged</vh></v>
<v t="felix.20240502230536.1"><vh>_onTabGroupsChanged</vh></v>
<v t="felix.20240502230541.1"><vh>_onTabsChanged</vh></v>
<v t="felix.20200719025231.29"><vh>_onActiveEditorChanged</vh></v>
<v t="felix.20210418014039.1"><vh>_changedTextEditorViewColumn</vh></v>
<v t="felix.20210418014040.1"><vh>_changedVisibleTextEditors</vh></v>
<v t="felix.20210418014040.2"><vh>_changedWindowState</vh></v>
<v t="felix.20200928004727.1"><vh>_onChangeEditorSelection</vh></v>
<v t="felix.20201014020145.1"><vh>_onChangeEditorScroll</vh></v>
<v t="felix.20200719025231.31"><vh>_onDocumentChanged</vh></v>
<v t="felix.20221031200229.1"><vh>_refreshDesc</vh></v>
<v t="felix.20220806151117.1"><vh>setFindPanel</vh></v>
</v>
<v t="felix.20200719030842.1"><vh>Body Editing</vh>
<v t="felix.20200719025231.32"><vh>triggerBodySave</vh></v>
<v t="felix.20200928133238.1"><vh>_bodySaveSelection</vh></v>
<v t="felix.20200719025231.33"><vh>_bodySaveDocument</vh></v>
<v t="felix.20210806175431.1"><vh>_bodySaveDeactivate</vh></v>
</v>
<v t="felix.20200719030902.1"><vh>Refresh UI</vh>
<v t="felix.20201114185218.1"><vh>setTreeViewTitle</vh></v>
<v t="felix.20200719025231.35"><vh>showOutline</vh></v>
<v t="ekr.20200815085806.1"><vh>configTreeRefresh</vh></v>
<v t="felix.20220724224959.1"><vh>setupRefresh</vh></v>
<v t="ekr.20200815085830.3"><vh>_launchRefresh</vh></v>
<v t="felix.20220804203041.1"><vh>fullRefresh</vh></v>
<v t="felix.20240502230658.1"><vh>_refreshDetachedBodies</vh></v>
<v t="felix.20220824014747.1"><vh>isTsStillValid</vh></v>
<v t="felix.20220804203829.1"><vh>isGnxStillValid</vh></v>
<v t="felix.20220805212936.1"><vh>isGnxReselected</vh></v>
<v t="ekr.20200815085830.1"><vh>_refreshOutline</vh></v>
<v t="ekr.20200815085830.2"><vh>_revealNode</vh></v>
<v t="felix.20220721225622.1"><vh>gotSelectedNode</vh></v>
<v t="felix.20220726144945.1"><vh>_refreshDocumentsPane</vh></v>
<v t="felix.20220726145121.1"><vh>_refreshButtonsPane</vh></v>
<v t="felix.20220726145220.1"><vh>_refreshGotoPane</vh></v>
<v t="felix.20220726145019.1"><vh>_refreshUndoPane</vh></v>
</v>
<v t="felix.20200719031115.1"><vh>Body Pane Management</vh>
<v t="ekr.20200815090152.1"><vh>_tryApplyNodeToBody</vh></v>
<v t="felix.20200719025231.47"><vh>_switchBody</vh></v>
<v t="felix.20200719025231.48"><vh>_locateOpenedBody</vh></v>
<v t="felix.20220905181421.1"><vh>_isBodyVisible</vh></v>
<v t="felix.20220907223335.1"><vh>_isBodyPreview</vh></v>
<v t="felix.20240502230809.1"><vh>_checkClosedTabs</vh></v>
<v t="felix.20220905194121.1"><vh>isOutlineVisible</vh></v>
<v t="felix.20240523231957.1"><vh>_hideBodiesUnknownToFileSys</vh></v>
<v t="felix.20210418013332.1"><vh>_hideDeleteBody</vh></v>
<v t="felix.20210418220343.1"><vh>_checkPreviewMode</vh></v>
<v t="felix.20200719025231.49"><vh>closeBody</vh></v>
<v t="felix.20210718155134.1"><vh>cleanupBody</vh></v>
<v t="felix.20200719025231.50"><vh>showBody</vh></v>
<v t="felix.20240505142143.1"><vh>_getBodyLanguage</vh></v>
<v t="felix.20220215235325.1"><vh>_setBodyLanguage</vh></v>
<v t="felix.20211111214657.1"><vh>refreshBodyStates</vh></v>
<v t="felix.20211111233213.1"><vh>debouncedRefreshBodyStates</vh></v>
<v t="felix.20240502230852.1"><vh>_refreshCommanderDetachedLanguage</vh></v>
</v>
<v t="felix.20200719025231.51"><vh>Commands</vh>
<v t="felix.20201114185813.1"><vh>minibuffer</vh></v>
<v t="felix.20220824144905.1"><vh>_showMinibufferHistory</vh></v>
<v t="felix.20220825004838.1"><vh>_doMinibufferCommand</vh></v>
<v t="felix.20231101204323.1"><vh>_showHeadlineInputBox</vh></v>
<v t="felix.20220806151009.1"><vh>prevNextNode</vh></v>
<v t="felix.20200719025231.52"><vh>selectTreeNode</vh></v>
<v t="felix.20240502214807.1"><vh>openAside</vh></v>
<v t="ekr.20200815090400.1"><vh>nodeCommand</vh></v>
<v t="felix.20200719025231.54"><vh>changeMark</vh></v>
<v t="felix.20200719025231.55"><vh>editHeadline</vh></v>
<v t="felix.20200719025231.56"><vh>insertNode</vh></v>
<v t="felix.20220222012540.1"><vh>copyNode</vh></v>
<v t="felix.20220815210705.1"><vh>copyNodeAsJson</vh></v>
<v t="felix.20220815210715.1"><vh>copyGnx</vh></v>
<v t="felix.20220222012528.1"><vh>cutNode</vh></v>
<v t="felix.20220222012552.1"><vh>pasteNode</vh></v>
<v t="felix.20220222012602.1"><vh>pasteAsCloneNode</vh></v>
<v t="felix.20220815221536.1"><vh>pasteAsTemplate</vh></v>
<v t="felix.20220714224733.1"><vh>setUa</vh></v>
</v>
<v t="felix.20220222014050.1"><vh>Clipboard</vh>
<v t="felix.20220222014050.2"><vh>replaceClipboardWith</vh></v>
<v t="felix.20220222014050.3"><vh>asyncGetTextFromClipboard</vh></v>
<v t="felix.20220222014050.4"><vh>getTextFromClipboard</vh></v>
<v t="felix.20240223230449.1"><vh>unlToClipboard</vh></v>
</v>
<v t="felix.20220308213523.1"><vh>Nav</vh>
<v t="felix.20221202003550.1"><vh>gotoAnywhere</vh></v>
<v t="felix.20220714002222.1"><vh>chapterSelect</vh></v>
<v t="felix.20220308213538.1"><vh>findQuick</vh></v>
<v t="felix.20220308213547.1"><vh>findQuickSelected</vh></v>
<v t="felix.20220308213552.1"><vh>findQuickTimeline</vh></v>
<v t="felix.20220308213557.1"><vh>findQuickChanged</vh></v>
<v t="felix.20220308213600.1"><vh>findQuickHistory</vh></v>
<v t="felix.20220308213605.1"><vh>findQuick_marked</vh></v>
<v t="felix.20220308213619.1"><vh>showGotoPane</vh></v>
<v t="felix.20220309215616.1"><vh>gotoNavEntry</vh></v>
<v t="felix.20220903192048.1"><vh>navigateNavEntry</vh></v>
</v>
<v t="felix.20210530225640.1"><vh>Search</vh>
<v t="felix.20220305225942.1"><vh>navEnter</vh></v>
<v t="felix.20220305231404.1"><vh>navTextChange</vh></v>
<v t="felix.20220925181748.1"><vh>navTextClear</vh></v>
<v t="felix.20210516233931.1"><vh>startSearch</vh></v>
<v t="felix.20220825224916.1"><vh>checkForceFindFocus</vh></v>
<v t="felix.20210613205741.1"><vh>_inputFindPattern</vh></v>
<v t="felix.20210516234059.1"><vh>find</vh></v>
<v t="felix.20210713000442.1"><vh>findSymbol</vh></v>
<v t="felix.20210530223726.1"><vh>replace &amp; replaceThenFind</vh></v>
<v t="felix.20230204150552.1"><vh>interactiveSearch</vh></v>
<v t="felix.20210530230354.1"><vh>findAll &amp; replaceAll</vh></v>
<v t="felix.20210530230400.1"><vh>cloneFind</vh></v>
<v t="felix.20210530225306.1"><vh>setSearchOption</vh></v>
<v t="felix.20210525232728.1"><vh>loadSearchSettings</vh></v>
<v t="felix.20210524215215.1"><vh>saveSearchSettings</vh></v>
<v t="felix.20210601164915.1"><vh>gotoGlobalLine</vh></v>
<v t="felix.20210620220655.1"><vh>tagChildren</vh></v>
<v t="felix.20220313211902.1"><vh>tag_node</vh></v>
<v t="felix.20220313211907.1"><vh>remove_tag</vh></v>
<v t="felix.20220313221212.1"><vh>remove_tags</vh></v>
<v t="felix.20210620220702.1"><vh>cloneFindTag</vh></v>
</v>
<v t="felix.20200719025231.57"><vh>Leo Documents</vh>
<v t="felix.20220724215921.1"><vh>setDocumentSelection</vh></v>
<v t="felix.20230815233005.1"><vh>tabCycle</vh></v>
<v t="felix.20200719025231.58"><vh>saveAsLeoFile</vh></v>
<v t="felix.20210915233602.1"><vh>saveAsLeoJsFile</vh></v>
<v t="felix.20200719025231.59"><vh>saveLeoFile</vh></v>
<v t="felix.20200719025231.60"><vh>switchLeoFile</vh></v>
<v t="felix.20200719025231.61"><vh>selectOpenedLeoDocument</vh></v>
<v t="fil.20210609233100.1"><vh>clearRecentLeoFiles</vh></v>
<v t="felix.20230811224332.1"><vh>revertToSaved</vh></v>
<v t="felix.20200719025231.64"><vh>closeLeoFile</vh></v>
<v t="felix.20200719025231.65"><vh>newLeoFile</vh></v>
<v t="felix.20200719025231.66"><vh>openLeoFile</vh></v>
</v>
<v t="felix.20220808233838.1"><vh>Export/Import Commands</vh>
<v t="felix.20210602155312.1"><vh>importFile</vh></v>
<v t="felix.20220808233838.2"><vh>exportHeadlines</vh></v>
<v t="felix.20220808233838.4"><vh>flattenOutline</vh></v>
<v t="felix.20220808233838.5"><vh>outlineToCweb</vh></v>
<v t="felix.20220808233838.6"><vh>outlineToNoweb</vh></v>
<v t="felix.20220808233838.7"><vh>removeSentinels</vh></v>
<v t="felix.20220808233838.8"><vh>weave</vh></v>
<v t="felix.20220808233838.9"><vh>writeFileFromNode</vh></v>
<v t="felix.20220809232939.1"><vh>readFileIntoNode</vh></v>
</v>
<v t="felix.20200719033306.1"><vh>AtButtons</vh>
<v t="ekr.20200815090517.1"><vh>clickAtButton</vh></v>
<v t="felix.20220221003719.1"><vh>_handleRClicks</vh></v>
<v t="felix.20211017002435.1"><vh>gotoScript</vh></v>
<v t="ekr.20200815090517.2"><vh>removeAtButton</vh></v>
</v>
<v t="felix.20220706223903.1"><vh>Undos</vh>
<v t="felix.20220706233403.1"><vh>revertToUndo</vh></v>
<v t="felix.20220706223907.1"><vh>_setUndoSelection</vh></v>
</v>
<v t="felix.20200719033511.1"><vh>Status Bar</vh>
<v t="felix.20200719025231.69"><vh>statusBarOnClick</vh></v>
</v>
</v>
</v>
<v t="felix.20220721204822.1"><vh>@clean src/leoApOutline.ts</vh>
<v t="felix.20220721204822.2"><vh>class LeoApOutlineProvider</vh>
<v t="felix.20220721204822.3"><vh>constructor</vh></v>
<v t="felix.20220924172739.1"><vh>setInvertFlag</vh></v>
<v t="felix.20220721204822.4"><vh>refreshTreeRoot</vh></v>
<v t="felix.20220721204822.5"><vh>buildId</vh></v>
<v t="felix.20220721204822.6"><vh>incTreeId</vh></v>
<v t="felix.20220721204822.7"><vh>getTreeItem</vh></v>
<v t="felix.20220721204822.8"><vh>getChildren</vh></v>
<v t="felix.20220721204822.9"><vh>getParent</vh></v>
<v t="felix.20220721204822.10"><vh>resolveTreeItem</vh></v>
</v>
<v t="felix.20220721204822.11"><vh>class LeoApNode</vh></v>
</v>
<v t="felix.20200718192351.1"><vh>@clean src/leoStates.ts</vh>
<v t="felix.20200718192411.1"><vh>class LeoStates</vh>
<v t="felix.20200718193719.1"><vh>General State Flags</vh>
<v t="felix.20200718193219.1"><vh>leoBridgeReady</vh></v>
<v t="felix.20220327193813.1"><vh>leoIDMissing</vh></v>
<v t="felix.20200718193222.1"><vh>fileOpenedReady</vh></v>
<v t="felix.20200718193226.1"><vh>leoOpenedFileName</vh></v>
<v t="felix.20200718193230.1"><vh>leoChanged</vh></v>
<v t="felix.20200718193233.1"><vh>leoCanUndo</vh></v>
<v t="felix.20200718193235.1"><vh>leoCanRedo</vh></v>
<v t="felix.20220704004247.1"><vh>leoCanGoBack</vh></v>
<v t="felix.20220704004253.1"><vh>leoCanGoNext</vh></v>
<v t="felix.20200718193238.1"><vh>leoCanDemote</vh></v>
<v t="felix.20200718193241.1"><vh>leoCanPromote</vh></v>
<v t="felix.20220704004530.1"><vh>leoCanHoist</vh></v>
<v t="felix.20200718193244.1"><vh>leoCanDehoist</vh></v>
<v t="felix.20220716153757.1"><vh>inChapter</vh></v>
<v t="felix.20220716153803.1"><vh>topHoistChapter</vh></v>
<v t="felix.20231101200432.1"><vh>leoEditHeadline</vh></v>
</v>
<v t="felix.20200718193731.1"><vh>Selected Node Flags</vh>
<v t="felix.20200718193338.1"><vh>leoMarked</vh></v>
<v t="felix.20200718193341.1"><vh>leoCloned</vh></v>
<v t="felix.20200718193343.1"><vh>leoDirty</vh></v>
<v t="felix.20200718193348.1"><vh>leoEmpty</vh></v>
<v t="felix.20200718193350.1"><vh>leoChild</vh></v>
<v t="felix.20200718193353.1"><vh>leoAtFile</vh></v>
</v>
<v t="felix.20200718193500.1"><vh>constructor</vh></v>
<v t="felix.20200718192411.2"><vh>selectedNodeFlags</vh></v>
<v t="felix.20200718192411.3"><vh>leoStateFlags</vh></v>
</v>
</v>
<v t="felix.20200718185403.1"><vh>@clean src/leoStatusBar.ts</vh>
<v t="felix.20200718185403.2"><vh>class LeoStatusBar</vh>
<v t="felix.20200718185403.3"><vh>show</vh></v>
<v t="felix.20200718185403.4"><vh>hide</vh></v>
<v t="felix.20200718185403.6"><vh>setString</vh></v>
<v t="felix.20200718185403.7"><vh>_updateLeoObjectIndicatorDebounced</vh></v>
<v t="felix.20200718185403.8"><vh>_updateLeoObjectIndicator</vh></v>
</v>
</v>
<v t="felix.20220705000805.1"><vh>@clean src/leoUndos.ts</vh>
<v t="felix.20220705001810.1"><vh>class LeoUndoProvider</vh></v>
<v t="felix.20220705001820.1"><vh>class LeoUndoNode</vh></v>
</v>
<v t="felix.20200718191946.1"><vh>@clean src/serverManager.ts</vh>
<v t="felix.20200718191946.2"><vh>class ServerService</vh>
<v t="felix.20200718191946.4"><vh>startServer</vh></v>
<v t="felix.20210717192921.1"><vh>killServer</vh></v>
<v t="ekr.20200815091220.1"><vh>_gotTerminalData</vh></v>
</v>
</v>
<v t="felix.20240107210250.1"><vh>@clean src/unlProvider.ts</vh></v>
<v t="felix.20200718194857.1"><vh>@clean src/types.d.ts</vh>
<v t="felix.20210727225050.1"><vh>IVsCodeApi</vh></v>
<v t="felix.20200718194857.2"><vh>ConfigMembers</vh></v>
<v t="felix.20201017224340.1"><vh>ConfigSetting</vh></v>
<v t="felix.20231102005402.1"><vh>Version</vh></v>
<v t="felix.20220901003642.1"><vh>Focus</vh></v>
<v t="felix.20200718194857.3"><vh>RevealType</vh></v>
<v t="felix.20200718194857.4"><vh>ReqRefresh</vh></v>
<v t="felix.20200718194857.5"><vh>UserCommand</vh></v>
<v t="felix.20200718194857.6"><vh>LeoAction</vh></v>
<v t="felix.20200718194857.7"><vh>LeoLogEntry</vh></v>
<v t="felix.20200718194857.8"><vh>ArchivedPosition</vh></v>
<v t="ekr.20200815091408.1"><vh>LeoPackageStates</vh></v>
<v t="felix.20200718194857.10"><vh>LeoBridgePackage</vh></v>
<v t="felix.20200718194857.11"><vh>LeoDocument</vh></v>
<v t="felix.20200718194857.12"><vh>LeoButton</vh></v>
<v t="felix.20220319202027.1"><vh>TGotoTypes</vh></v>
<v t="felix.20220308203528.1"><vh>LeoGoto</vh></v>
<v t="felix.20220903201408.1"><vh>LeoGotoNavKey</vh></v>
<v t="felix.20210522152922.1"><vh>LeoSearchScope</vh></v>
<v t="felix.20210522152739.1"><vh>LeoSearchSettings</vh></v>
<v t="felix.20210523162125.1"><vh>LeoGuiFindTabManagerSettings</vh></v>
<v t="felix.20200718194857.13"><vh>Icon</vh></v>
<v t="felix.20200718194857.14"><vh>BodyTimeInfo</vh></v>
<v t="felix.20201119002510.1"><vh>BodyPosition</vh></v>
<v t="felix.20201006195046.1"><vh>BodySelectionInfo</vh></v>
<v t="felix.20200718194857.15"><vh>showSaveAsDialogParameters</vh></v>
<v t="felix.20200718194857.16"><vh>runAskYesNoDialogParameters</vh></v>
<v t="felix.20200718194857.17"><vh>runWarnMessageDialogParameters</vh></v>
<v t="felix.20200718194857.18"><vh>runInfoMessageDialogParameters</vh></v>
<v t="felix.20200718194857.19"><vh>AskMessageItem</vh></v>
<v t="felix.20221204000406.1"><vh>ChoosePositionItem</vh></v>
<v t="felix.20200718194857.20"><vh>ChooseDocumentItem</vh></v>
<v t="felix.20220220191549.1"><vh>ChooseRClickItem</vh></v>
<v t="felix.20220221001803.1"><vh>RClick</vh></v>
<v t="felix.20240223230656.1"><vh>UnlType</vh></v>
</v>
<v t="felix.20200718195558.1"><vh>@clean src/utils.ts</vh>
<v t="felix.20210706233101.1"><vh>uniqueId</vh></v>
<v t="felix.20210706233106.1"><vh>getUniqueId</vh></v>
<v t="felix.20240502215719.1"><vh>closeLeoTextEditors</vh></v>
<v t="felix.20231102005126.1"><vh>compareVersions</vh></v>
<v t="felix.20200718195558.2"><vh>padNumber2</vh></v>
<v t="felix.20220327223745.1"><vh>cleanLeoID</vh></v>
<v t="felix.20201106200100.1"><vh>addFileToGlobal</vh></v>
<v t="felix.20201106200109.1"><vh>removeFileFromGlobal</vh></v>
<v t="felix.20221030151905.1"><vh>setGlobalLastEditedFile</vh></v>
<v t="felix.20221030152024.1"><vh>getGlobalLastEditedFile</vh></v>
<v t="felix.20220730152836.1"><vh>buildApId</vh></v>
<v t="felix.20200718195558.3"><vh>buildNodeIconPaths</vh></v>
<v t="felix.20221027232254.1"><vh>buildUndoIconPaths</vh></v>
<v t="felix.20200718195558.4"><vh>buildDocumentIconPaths</vh></v>
<v t="ekr.20200815091945.1"><vh>buildButtonsIconPaths</vh></v>
<v t="felix.20220320172705.1"><vh>buildGotoIconPaths</vh></v>
<v t="felix.20220904222510.1"><vh>buildNodeCommand</vh></v>
<v t="felix.20210614235023.1"><vh>chooseLeoFolderDialog</vh></v>
<v t="felix.20201018163510.1"><vh>getDurationMilliseconds</vh></v>
<v t="felix.20200718195558.7"><vh>getFileFromPath</vh></v>
<v t="felix.20230808224051.1"><vh>getOnce</vh></v>
<v t="felix.20220826200039.1"><vh>isApEqual</vh></v>
<v t="felix.20200718195558.8"><vh>isIconChangedByEdit</vh></v>
<v t="felix.20200718195558.9"><vh>isHexColor</vh></v>
<v t="felix.20220327230102.1"><vh>isAlphaNum</vh></v>
<v t="felix.20231130222754.1"><vh>fixSlashesDriveLetter</vh></v>
<v t="felix.20200718195558.10"><vh>strToLeoUri</vh></v>
<v t="felix.20240502210859.1"><vh>strToLeoDetachedUri</vh></v>
<v t="felix.20200718195558.11"><vh>leoUriToStr</vh></v>
<v t="felix.20200718195558.12"><vh>setContext</vh></v>
<v t="felix.20210612214028.1"><vh>findNextAvailablePort</vh></v>
<v t="felix.20210820231649.1"><vh>findSingleAvailablePort</vh></v>
</v>
<v t="felix.20210522001751.1"><vh>@clean src/leoFindPanelWebview.ts</vh>
<v t="felix.20210522001814.1"><vh>class LeoFindPanelProvider</vh>
<v t="fil.20210603195851.1"><vh>resolveWebviewView</vh></v>
<v t="fil.20210603195902.1"><vh>_getHtmlForWebview</vh></v>
</v>
</v>
<v t="fil.20210603195218.1"><vh>@clean src/leoSettingsWebview.ts</vh>
<v t="fil.20210603195319.1"><vh>class LeoSettingsWebview</vh>
<v t="fil.20210603195319.2"><vh>changedConfiguration</vh></v>
<v t="fil.20210603195319.3"><vh>openWebview</vh></v>
<v t="fil.20210603195319.4"><vh>_getBaseHtml</vh></v>
</v>
</v>
</v>
<v t="fil.20210603223013.1"><vh>Files: Find Panel Webview</vh>
<v t="fil.20210603223013.2"><vh>@clean find-panel/style.css</vh></v>
<v t="fil.20210603223013.4"><vh>@clean find-panel/main.js</vh>
<v t="felix.20220301224252.1"><vh>main function</vh></v>
</v>
</v>
<v t="fil.20210603223933.1"><vh>Files: Settings Panel Webview</vh>
<v t="fil.20210603223933.9"><vh>@clean settings-panel/index.html</vh></v>
<v t="fil.20210603223933.165"><vh>@clean settings-panel/main.js</vh></v>
<v t="fil.20210603223956.2"><vh>@clean settings-panel/style.css</vh></v>
</v>
<v t="ekr.20200808100339.1"><vh>----- TS Classes</vh>
<v t="felix.20200718024635.2"></v>
<v t="felix.20200718030926.2"></v>
<v t="felix.20200718020912.2"></v>
<v t="felix.20220721204822.2"></v>
<v t="felix.20220721204822.11"></v>
<v t="ekr.20200815083608.1"></v>
<v t="felix.20200718040540.2"></v>
<v t="felix.20240502002356.2"></v>
<v t="felix.20200718153505.2"></v>
<v t="felix.20200718162303.2"></v>
<v t="felix.20200718164130.2"></v>
<v t="felix.20220903004914.1"></v>
<v t="felix.20220903004804.1"></v>
<v t="felix.20200718164509.2"></v>
<v t="felix.20200718165108.2"></v>
<v t="felix.20220705001820.1"></v>
<v t="felix.20220705001810.1"></v>
<v t="felix.20200718170429.2"></v>
<v t="felix.20210522001814.1"></v>
<v t="felix.20200719025231.2"></v>
<v t="fil.20210603195319.1"></v>
<v t="felix.20200718192411.1"></v>
<v t="felix.20200718185403.2"></v>
<v t="felix.20200718191946.2"></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20200722190517.1"></t>
<t tx="ekr.20200808100339.1">@language typescript
</t>
<t tx="ekr.20200815083608.1">/**
 * * Handles the functions called by Leo through leoBridge such as adding a log pane entry, runAskYesNoDialog for file changes, etc.
 * * Some config settings affect this behavior, such as defaultReloadIgnore and checkForChangeExternalFiles
 */
export class LeoAsync {

    private _askResult: string = "";

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others

}

&lt;&lt; TODO &gt;&gt;

@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200815083608.2">/**
 * * Adds message string to leoInteg's log pane, used when leoBridge gets an async 'log' command
 */
public log(p_message: string, p_color?: string): void {
    if (p_color &amp;&amp; p_color === Constants.LOG_ALERT_COLOR) {
        // Red Detected: Force showing the log pane for 'errors' in the log pane.
        this._leoIntegration.showLogPane();
    }
    this._leoIntegration.addLogPaneEntry(p_message);
}

</t>
<t tx="ekr.20200815083608.3">/**
 * * Equivalent to runSaveFileDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * @param p_saveAsArg
 */
public showSaveAsDialog(p_saveAsArg: showSaveAsDialogParameters): void {
    console.log('TODO: SHOW SAVE AS DIALOG!');
}

</t>
<t tx="ekr.20200815083609.1">/**
 * * Equivalent to runAskYesNoDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * * Opens a modal dialog to return one of 'yes', 'yes-all', 'no' or 'no-all' to be sent back with the leoBridge 'ASK_RESULT' action
 * @param p_askArg an async package object {"ask": title, "message": message, "yes_all": yes_all, "no_all": no_all}
 */
public showAskModalDialog(p_askArg: runAskYesNoDialogParameters): void {
    this._askResult = "no"; // defaults to not doing anything, matches isCloseAffordance just to be safe
    // Note: "last line" could be eventually used in the message
    // const w_lastLine = p_askArg.message.substr(p_askArg.message.lastIndexOf("\n") + 1);
    const w_items: AskMessageItem[] = [
        {
            title: Constants.USER_MESSAGES.YES,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES,
            isCloseAffordance: false
        },
        {
            title: Constants.USER_MESSAGES.NO,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO,
            isCloseAffordance: true
        }
    ];
    if (p_askArg.yes_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.YES_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES_ALL,
            isCloseAffordance: false
        });
    }
    if (p_askArg.no_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.NO_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO_ALL,
            isCloseAffordance: false
        });
    }
    const w_askRefreshInfoMessage: Thenable&lt;AskMessageItem | undefined&gt; = vscode.window.showInformationMessage(
        p_askArg.message,
        { modal: true },
        ...w_items
    );
    w_askRefreshInfoMessage.then((p_result: AskMessageItem | undefined) =&gt; {
        if (p_result) {
            this._askResult = p_result.value;
        }
        const w_sendResultPromise = this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.ASK_RESULT,
            { "result": this._askResult }
        );
        if (this._askResult.includes(Constants.ASYNC_ASK_RETURN_CODES.YES)) {
            w_sendResultPromise.then(() =&gt; {
                return this._leoIntegration.sendAction(Constants.LEOBRIDGE.DO_NOTHING);
            }).then((p_package) =&gt; {
                if (p_package.commander) {
                    p_package.filename = p_package.commander.fileName;
                    this._leoIntegration.serverOpenedFileName = p_package.filename;
                    this._leoIntegration.serverOpenedNode = p_package.node!;
                }

                // refresh and reveal selection
                this._leoIntegration.setupRefresh(
                    Focus.NoChange,
                    {
                        tree: true,
                        body: true,
                        states: true,
                        buttons: true,
                        documents: true,
                        goto: true
                    },
                    p_package.node
                );
                this._leoIntegration.launchRefresh();
            });
        }
    });
}

</t>
<t tx="ekr.20200815083609.2">/**
 * * Equivalent to runAskOkDialog from Leo's qt_gui.py, used when leoBridge gets an async 'warn' command
 * @param p_waitArg an async package object {"warn": "", "message": ""}
 */
public showWarnModalMessage(p_waitArg: runWarnMessageDialogParameters): void {
    vscode.window.showInformationMessage(
        p_waitArg.message,
        { modal: true }
    ).then(() =&gt; {
        this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.ASK_RESULT,
            { "result": Constants.ASYNC_ASK_RETURN_CODES.OK }
        );
    });
}

</t>
<t tx="ekr.20200815083609.3">/**
 * * Show non-blocking info message about detected file changes, used when leoBridge gets an async 'info' command
 * @param p_infoArg an async package object { "message": string; }
 */
public showChangesDetectedInfoMessage(p_infoArg: runInfoMessageDialogParameters): void {
    let w_message = "";
    switch (p_infoArg.message) {
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_REFRESHED:
            w_message = Constants.USER_MESSAGES.CHANGES_DETECTED + Constants.USER_MESSAGES.REFRESHED;

            this._leoIntegration.sendAction(Constants.LEOBRIDGE.DO_NOTHING)
                .then((p_package) =&gt; {
                    if (p_package.commander) {
                        p_package.filename = p_package.commander.fileName;
                        this._leoIntegration.serverOpenedFileName = p_package.filename;
                        this._leoIntegration.serverOpenedNode = p_package.node!;
                    }
                    this._leoIntegration.setupRefresh(
                        Focus.NoChange,
                        {
                            tree: true,
                            body: true,
                            states: true,
                            buttons: true,
                            documents: true
                        },
                        p_package.node
                    );
                    this._leoIntegration.launchRefresh();
                });

            break;
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_IGNORED:
            w_message = Constants.USER_MESSAGES.CHANGES_DETECTED + Constants.USER_MESSAGES.IGNORED;
            break;
        default:
            w_message = p_infoArg.message;
            break;
    }
    vscode.window.showInformationMessage(w_message);
}

</t>
<t tx="ekr.20200815084016.1">/**
 * * Configuration Defaults used in config.ts
 * Used when setting itself and getting parameters from vscode
 */
public static CONFIG_DEFAULTS = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "none",  // Used in leoBridge scrip,
    DEFAULT_RELOAD_IGNORE: "none", // Used in leoBridge scrip,
    LEO_TREE_BROWSE: true,
    TREE_KEEP_FOCUS: true,
    TREE_KEEP_FOCUS_WHEN_ASIDE: false,

    COLLAPSE_ALL_SHORTCUT: true,
    ACTIVITY_VIEW_SHORTCUT: true,
    GO_ANYWHERE_SHORTCUT: true,

    SHOW_UNL_ON_STATUSBAR: true,
    TREE_IN_EXPLORER: true,
    SHOW_EDIT: true,
    SHOW_ARROWS: false,
    SHOW_ADD: false,
    SHOW_MARK: false,
    SHOW_CLONE: false,
    SHOW_COPY: false,
    SHOW_BRANCH_OUTLINE: false,

    // SHOW_EDITION_BODY: true,
    // SHOW_CLIPBOARD_BODY: true,
    // SHOW_PROMOTE_BODY: true,
    // SHOW_EXECUTE_BODY: true,
    // SHOW_EXTRACT_BODY: true,
    // SHOW_IMPORT_BODY: true,
    // SHOW_REFRESH_BODY: true,
    // SHOW_HOIST_BODY: true,
    // SHOW_MARK_BODY: true,
    // SHOW_SORT_BODY: true,

    INVERT_NODES: false,
    LEO_PYTHON_COMMAND: "",
    LEO_EDITOR_PATH: "",
    AUTO_START_SERVER: false,
    AUTO_CONNECT: false,
    IP_ADDRESS: "localhost",
    IP_LOOPBACK: "127.0.0.1",
    IP_PORT: 32125,

    SET_DETACHED: true,
    LIMIT_USERS: 1
};

</t>
<t tx="ekr.20200815084550.1">/*
    TODO : Should Reproduce those interactive controls that may be asked by Leo, and redo a true UI bridge

def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    return self.simulateDialog("aboutLeoDialog", None)

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog", None)

def runAskOkDialog(self, c, title, message=None, text="Ok"):
    return self.simulateDialog("okDialog", "Ok")

def runAskOkCancelNumberDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
):
    return self.simulateDialog("numberDialog", -1)

def runAskOkCancelStringDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
    default="",
    wide=False,
):
    return self.simulateDialog("stringDialog", '')

def runCompareDialog(self, c):
    return self.simulateDialog("compareDialog", '')

def runOpenFileDialog(self, c, title, filetypes, defaultextension,
    multiple=False,
    startpath=None,
):
    return self.simulateDialog("openFileDialog", None)

def runSaveFileDialog(self, c, initialfile, title, filetypes, defaultextension):
    return self.simulateDialog("saveFileDialog", None)

def runAskYesNoDialog(self, c, title,
    message=None,
    yes_all=False,
    no_all=False,
):
    return self.simulateDialog("yesNoDialog", "no")

def runAskYesNoCancelDialog(self, c, title,
    message=None,
    yesMessage="Yes",
    noMessage="No",
    yesToAllMessage=None,
    defaultButton="Yes",
    cancelMessage=None,
):
    return self.simulateDialog("yesNoCancelDialog", "cancel")

def simulateDialog(self, key, defaultVal):
    return defaultVal

*/
</t>
<t tx="ekr.20200815085229.1"></t>
<t tx="ekr.20200815085316.4">/**
 * * Reveals the log pane if not already visible
 */
public showLogPane(): void {
    if (!this._leoLogPane) {
        // * output channel instantiation
        this._leoLogPane = vscode.window.createOutputChannel(
            Constants.GUI.LOG_PANE_TITLE
        );
        this._context.subscriptions.push(this._leoLogPane);
    }
    this._leoLogPane.show(true);
}

</t>
<t tx="ekr.20200815085316.5">/**
 * * Hides the log pane
 */
public hideLogPane(): void {
    if (this._leoLogPane) {
        this._leoLogPane.hide();
    }
}

</t>
<t tx="ekr.20200815085316.6">/**
 * * Adds a message string to leoInteg's log pane. Used when leoBridge receives an async 'log' command.
 * @param p_message The string to be added in the log
 */
public addLogPaneEntry(p_message: string): void {
    if (this._leoLogPane) {
        this._leoLogPane.appendLine(p_message);
    } else {
        console.log('LEOINTEG ERROR : addLogPaneEntry without log pane!');
    }
}

</t>
<t tx="ekr.20200815085628.1">/**
 * * Handles the opening of a file in vscode, and check if it's a Leo file to suggest opening options
 * @param p_event The opened document event passed by vscode
 */
private _onDidOpenTextDocument(p_document: vscode.TextDocument): void {
    if (
        this.leoStates.leoBridgeReady &amp;&amp;
        p_document.uri.scheme === Constants.URI_FILE_SCHEME &amp;&amp;
        (
            p_document.uri.fsPath.toLowerCase().endsWith('.leo') ||
            p_document.uri.fsPath.toLowerCase().endsWith('.leojs')
        )
    ) {
        if (!this._hasShownContextOpenMessage) {
            vscode.window.showInformationMessage(Constants.USER_MESSAGES.RIGHT_CLICK_TO_OPEN);
            this._hasShownContextOpenMessage = true;
        }
    }
}

</t>
<t tx="ekr.20200815085705.1">/**
 * * Handle the change of visibility of either buttons treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onButtonsTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {
    if (p_explorerView) {
    } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        // this.refreshButtonsPane(); // No need to refresh because no selection needs to be set
    }
}

</t>
<t tx="ekr.20200815085806.1">/**
 * * Refresh tree for 'node hover icons' to show up properly after changing their settings
 */
public configTreeRefresh(): void {
    this._leoTreeProvider.setInvertFlag(this.config.invertNodeContrast);
    if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
        this._preventShowBody = true;
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="ekr.20200815085830.1">/**
 * * Refreshes the outline. A reveal type can be passed along for selected node.
 * @param p_incrementTreeID Flag meaning for the _treeId counter to be incremented
 * @param p_revealType Facultative reveal type to specify type of reveal when the 'selected node' is encountered
 */
private _refreshOutline(p_incrementTreeID: boolean, p_revealType?: RevealType): void {

    if (p_incrementTreeID) {
        this._leoTreeProvider.incTreeId();
    }
    if (p_revealType !== undefined &amp;&amp; p_revealType.valueOf() &gt;= this._revealType.valueOf()) {
        // To check if selected node should self-select while redrawing whole tree
        this._revealType = p_revealType; // To be read/cleared (in arrayToLeoNodesArray instead of directly by nodes)
    }
    try {
        if (!this.isOutlineVisible() &amp;&amp; this.showOutlineIfClosed) {
            this.showOutlineIfClosed = false;
            // Force showing last used Leo outline first
            let w_viewName: string;
            if (this._lastTreeView === this._leoTreeExView) {
                w_viewName = Constants.TREEVIEW_EXPLORER_ID;
            } else {
                w_viewName = Constants.TREEVIEW_ID;
            }
            vscode.commands.executeCommand(w_viewName + ".focus").then(
                () =&gt; {
                    this._revealNodeRetriedRefreshOutline = false;
                    this._leoTreeProvider.refreshTreeRoot();
                },
                (p_reason) =&gt; {
                    // Reveal failed: retry once.
                    console.log('_refreshOutline could not reveal. Rejected reason: ', p_reason);
                    this._leoTreeProvider.refreshTreeRoot();
                }
            );

        } else {
            this.showOutlineIfClosed = false;
            // was visible, just refresh
            this._leoTreeProvider.refreshTreeRoot();
        }
    } catch (error) {
        // Also retry once on error
        console.log('_refreshOutline could not reveal. Catch Error: ', error);
        this._leoTreeProvider.refreshTreeRoot();
    }
}

</t>
<t tx="ekr.20200815085830.2">/**
 * * 'TreeView.reveal' for any opened leo outline that is currently visible
 * @param p_leoNode The node to be revealed
 * @param p_options Options object for the revealed node to either also select it, focus it, and expand it
 * @returns Thenable from the reveal tree node action, resolves directly if no tree visible
 */
private _revealNode(
    p_leoNode: ArchivedPosition,
    p_options?: { select?: boolean; focus?: boolean; expand?: boolean | number }
): Thenable&lt;void&gt; {
    let w_treeview: vscode.TreeView&lt;ArchivedPosition&gt; | undefined;
    if (this._leoTreeView.visible) {
        w_treeview = this._leoTreeView;
    }
    if (this._leoTreeExView.visible &amp;&amp; this.config.treeInExplorer &amp;&amp; !vscode.workspace.getConfiguration('leojs').get('treeInExplorer', false)) {
        w_treeview = this._leoTreeExView;
    }
    if (!w_treeview &amp;&amp; (this.showOutlineIfClosed || (p_options &amp;&amp; p_options.focus))) {
        this.showOutlineIfClosed = false;
        w_treeview = this._lastTreeView;
        if (p_options) {
            p_options.focus = true;
        } else {
            p_options = {
                focus: true,
                select: true
            };
        }
    }
    try {
        if (w_treeview) {
            return w_treeview.reveal(p_leoNode, p_options).then(
                () =&gt; {
                    // ok
                    this._revealNodeRetriedRefreshOutline = false;
                },
                (p_reason) =&gt; {
                    console.log('_revealNode could not reveal. Reason: ', p_reason);

                    if (!this._revealNodeRetriedRefreshOutline) {
                        this._revealNodeRetriedRefreshOutline = true;
                        // Reveal failed. Retry refreshOutline once
                        this._refreshOutline(true, RevealType.RevealSelect);
                    }
                }
            );
        }

    } catch (p_error) {
        console.error("_revealNode error: ", p_error);
        // Retry refreshOutline once
        if (!this._revealNodeRetriedRefreshOutline) {
            this._revealNodeRetriedRefreshOutline = true;
            // Reveal failed. Retry refreshOutline once
            this._refreshOutline(true, RevealType.RevealSelect);
        }
    }
    return Promise.resolve(); // Defaults to resolving even if both are hidden
}

</t>
<t tx="ekr.20200815085830.3">/**
 * * Launches refresh for UI components: treeviews, body, and context states
 */
private async _launchRefresh(): Promise&lt;unknown&gt; {

    this._refreshDetachedBodies();

    if (this._lastCommandFindEndOutline) {
        this._lastCommandFindEndOutline--; // decrement from 2 to 1 the first time, keeping the flag for 1 refresh.
    }

    if (!this.refreshPreserveRange) {
        if (this.findFocusTree) {
            // had a range but now refresh from other than find/replace
            // So make sure tree is also refreshed.
            this._refreshType.tree = true;
        }
        // Clear no matter what.
        this.findFocusTree = false;
    } else {
        this.refreshPreserveRange = false; // preserved once, now cleared.
    }

    // check states for having at least a document opened
    if (!this.serverHasOpenedFile &amp;&amp; this.leoStates.leoBridgeReady &amp;&amp; this.leoStates.fileOpenedReady) {
        return this._setupNoOpenedLeoDocument(); // Had some opened but all closed now!
    }
    if (this.serverHasOpenedFile &amp;&amp; this.leoStates.leoBridgeReady &amp;&amp; !this.leoStates.fileOpenedReady) {
        this._setupOpenedLeoDocument(); // Was all closed but has some opened now!
        await this.leoStates.qLastContextChange; // Has a commander opened, but wait for UI!
    }

    let w_revealType: RevealType;
    if (this.finalFocus.valueOf() === Focus.Outline) {
        w_revealType = RevealType.RevealSelectFocus;
    } else {
        w_revealType = RevealType.RevealSelect;
    }

    if (
        this._refreshNode &amp;&amp;
        this._refreshType.body &amp;&amp;
        this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty
    ) {
        // When this refresh is launched with 'refresh body' requested, we need to lose any pending edits and save on vscode's side.
        // Do this only if gnx is different from what is coming from Leo in this refresh cycle.
        const w_lastChangedDocGnx = utils.leoUriToStr(this._bodyLastChangedDocument.uri);
        if (
            this._refreshNode.gnx !== w_lastChangedDocGnx &amp;&amp; !this._bodyLastChangedDocumentSaved
        ) {
            this._bodyLastChangedDocument.save(); // Voluntarily save to 'clean' any pending body (no await)
            this._bodyLastChangedDocumentSaved = true;
        }
        if (this._refreshNode.gnx === w_lastChangedDocGnx) {
            this._leoFileSystem.preventSaveToLeo = true;
            await this._bodyLastChangedDocument.save(); // SAME GNX : so wait for it! (await)
        }
    }

    // * _focusInterrupt insertNode Override
    if (this._focusInterrupt) {
        // this._focusInterrupt = false; // TODO : Test if reverting this in _gotSelection is 'ok'
        w_revealType = RevealType.RevealSelect;
    }

    const w_showBodyNoFocus: boolean = this.finalFocus.valueOf() !== Focus.Body;

    // * Force refresh tree when body update required for 'navigation/insert node' commands
    if (
        this.showBodyIfClosed &amp;&amp;
        this.showOutlineIfClosed &amp;&amp;
        !this.isOutlineVisible() &amp;&amp;
        this._refreshType.body
    ) {
        // console.log('HAD TO ADJUST!');
        this._refreshType.tree = true;
    }

    // * Either the whole tree refreshes, or a single tree node is revealed when just navigating
    if (this._refreshType.tree) {
        this._refreshType.tree = false;
        this._refreshType.node = false; // Also clears node
        if (!this.isOutlineVisible() &amp;&amp; !this.showOutlineIfClosed &amp;&amp; this._refreshType.body) {
            // wont get 'gotSelectedNode so show body!
            this._refreshType.body = false;
            this._tryApplyNodeToBody(this._refreshNode || this.serverOpenedNode || this.lastSelectedNode!, false, w_showBodyNoFocus);
        }
        this._refreshOutline(true, w_revealType);
    } else if (this._refreshType.node &amp;&amp; this._refreshNode) {
        // * Force single node "refresh" by revealing it, instead of "refreshing" it
        this._refreshType.node = false;
        this.leoStates.setSelectedNodeFlags(this._refreshNode);
        let w_showOutline = this.isOutlineVisible();
        if (!this.isOutlineVisible() &amp;&amp; this.showOutlineIfClosed) {
            this.showOutlineIfClosed = false;
            w_showOutline = true;
        }
        this._revealNode(
            this._refreshNode,
            {
                select: true,
                focus: w_showOutline
            }
        );
        if (this._refreshType.body) {
            // * if no outline visible, just update body pane as needed
            if (!this.isOutlineVisible()) {
                this._refreshType.body = false;
                this._tryApplyNodeToBody(this._refreshNode, false, w_showBodyNoFocus);
            }
        }
    } else if (this._refreshType.body) {
        this._refreshType.body = false;
        this._tryApplyNodeToBody(this._refreshNode || this.serverOpenedNode || this.lastSelectedNode!, false, w_showBodyNoFocus);
    }
    return this.getStates();
}

</t>
<t tx="ekr.20200815090152.1">/**
 * * Makes sure the body now reflects the selected node.
 * This is called after 'selectTreeNode', or after '_gotSelection' when refreshing.
 * @param p_node Node that was just selected
 * @param p_aside Flag to indicate opening 'Aside' was required
 * @param p_preventTakingFocus Flag used to keep focus where it was instead of forcing in body
 * @returns a text editor of the p_node parameter's gnx (As 'leo' file scheme). Or rejects if interrupted.
 */
private _tryApplyNodeToBody(
    p_node: ArchivedPosition,
    p_aside: boolean,
    p_preventTakingFocus: boolean,
): Thenable&lt;void | vscode.TextEditor&gt; {

    this.lastSelectedNode = p_node; // Set the 'lastSelectedNode' this will also set the 'marked' node context
    this._commandStack.newSelection(); // Signal that a new selected node was reached and to stop using the received selection as target for next command

    if (this._bodyTextDocument) {
        // if not first time and still opened - also not somewhat exactly opened somewhere.
        if (
            !this._bodyTextDocument.isClosed &amp;&amp;
            !this._locateOpenedBody(p_node.gnx) // COULD NOT LOCATE NEW GNX
        ) {
            // if needs switching by actually having different gnx
            if (utils.leoUriToStr(this.bodyUri) !== p_node.gnx) {
                // * LOCATE OLD GNX FOR PROPER COLUMN
                this._locateOpenedBody(utils.leoUriToStr(this.bodyUri));
                // Make sure any pending changes in old body are applied before switching
                return this._bodyTextDocument.save().then(() =&gt; {
                    return this._switchBody(p_aside, p_preventTakingFocus);
                });
            }
        }
    }
    // first time or no body opened
    this.bodyUri = utils.strToLeoUri(p_node.gnx);
    if (this._isBodyVisible() === 0 &amp;&amp; !this.showBodyIfClosed) {
        return Promise.resolve();
    }
    return this.showBody(p_aside, p_preventTakingFocus);
}

</t>
<t tx="ekr.20200815090400.1">/**
 * * Tries to add a command to the frontend stack, returns true if added, false otherwise
 * @param p_userCommand Contains command details such as action, node, fromOutline, refresh type, etc.
 * @returns Promise back from command's execution, if added on stack, undefined otherwise.
 * (see command stack 'rules' in commandStack.ts)
 */

public async nodeCommand(p_userCommand: UserCommand, p_isNavigation?: boolean): Promise&lt;LeoBridgePackage | undefined&gt; {
    // No forced vscode save-triggers for direct calls from extension.js
    await this.triggerBodySave();
    if (p_isNavigation) {
        // If any navigation command is used from outline or command palette: show body.
        this.showBodyIfClosed = true;
        // If alt+arrow is used to navigate: SHOW and leave focus on outline.
        this.showOutlineIfClosed = true;

        if (p_userCommand.refreshType.body) {
            // If this is a navigation command, dont refresh DETACHED
            p_userCommand.refreshType.excludeDetached = true;
        }
    }

    const q_result = this._commandStack.add(p_userCommand);
    if (q_result) {
        return q_result;
    } else {
        vscode.window.showInformationMessage(
            Constants.USER_MESSAGES.TOO_FAST + p_userCommand.action
        );
        return undefined;
    }
}

</t>
<t tx="ekr.20200815090517.1">/**
 * * Invoke an '@button' click directly by index string. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was clicked
 * @returns the launchRefresh promise started after it's done running the 'atButton' command
 */
public clickAtButton(p_node: LeoButtonNode): Promise&lt;boolean&gt; {
    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {

            if (p_node.rclicks.length) {
                // Has rclicks so show menu to choose
                this._rclickSelected = [];

                return this._handleRClicks(p_node.rclicks, p_node.button.name).then((p_picked) =&gt; {
                    if (
                        p_picked
                    ) {
                        // Check if only one in this._rclickSelected and is zero: normal press
                        if (this._rclickSelected.length === 1 &amp;&amp; this._rclickSelected[0] === 0) {
                            // Normal button
                            return this.sendAction(
                                Constants.LEOBRIDGE.CLICK_BUTTON,
                                { index: p_node.button.index }
                            );
                        }
                        // If not decrement first one, and send this._rclickSelected as array of choices
                        this._rclickSelected[0] = this._rclickSelected[0] - 1;
                        return this.sendAction(
                            Constants.LEOBRIDGE.CLICK_BUTTON,
                            { index: p_node.button.index, rclick: this._rclickSelected }
                        );
                    }
                    // Escaped
                    return Promise.reject();
                });


            } else {
                // Normal button
                return this.sendAction(
                    Constants.LEOBRIDGE.CLICK_BUTTON,
                    { index: p_node.button.index }
                );
            }
        })
        .then((p_clickButtonResult: LeoBridgePackage) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.DO_NOTHING);
        })
        .then((p_package) =&gt; {
            // Refresh and reveal selection
            this.setupRefresh(
                Focus.NoChange,
                {
                    tree: true,
                    body: true,
                    states: true,
                    buttons: true,
                    documents: true
                },
                p_package.node
            );
            this.launchRefresh();
            return Promise.resolve(true);
        }, (p_error) =&gt; {
            // Pass to catch the rejection if escaped by the user
            return false;
        });
}

</t>
<t tx="ekr.20200815090517.2">/**
 * * Removes an '@button' from Leo's button dict, directly by index string. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was chosen to remove
 * @returns the launchRefresh promise started after it's done removing the button
 */
public async removeAtButton(p_node: LeoButtonNode): Promise&lt;any&gt; {
    await this._isBusyTriggerSave(false);
    const w_package = await this.sendAction(
        Constants.LEOBRIDGE.REMOVE_BUTTON,
        { index: p_node.button.index }
    );
    this.setupRefresh(
        Focus.NoChange,
        {
            buttons: true
        }
    );
    this.launchRefresh();
    return w_package;
}

</t>
<t tx="ekr.20200815091220.1">/**
 * * Splits the received data into lines and parses output to detect server start event
 * * Otherwise just outputs lines to the terminal Output
 * @param p_data Data object (not pure string)
 */
private _processServerOutput(p_data: string): void {
    let w_dataString = p_data.toString().replace(/\n$/, ""); // remove last
    if (!this._skippedFirstEmpty) {
        if (w_dataString &amp;&amp; (w_dataString.charCodeAt(0) === 10 || w_dataString.charCodeAt(0) === 13)) {
            this._skippedFirstEmpty = true; // Skipping first empty line for esthetics only
            return;
        }
    }
    w_dataString.toString().split("\n").forEach(p_line =&gt; {
        if (true || p_line) { // ? std out process line by line: json shouldn't have line breaks
            if (p_line.startsWith(Constants.SERVER_STARTED_TOKEN)) {
                if (this._resolvePromise &amp;&amp; !this._isStarted) {
                    this._isStarted = true;
                    this._resolvePromise(p_line); // * Server confirmed started
                }
            }
            this._leoIntegration.addLogPaneEntry(p_line); // Output message anyways
        }
    });
}

</t>
<t tx="ekr.20200815091408.1">/**
 * * Object sent back from leoInteg's 'getStates' command
 */
export interface LeoPackageStates {

    commanderId: string; // Commander's python 'id'.
    changed: boolean; // Leo document has changed (is dirty)

    canUndo: boolean; // Leo document can undo the last operation done
    canRedo: boolean; // Leo document can redo the last operation 'undone'

    canGoBack: boolean;
    canGoNext: boolean;

    canDemote: boolean; // Currently selected node can have its siblings demoted
    canPromote: boolean; // Currently selected node can have its children promoted

    canDehoist: boolean; // There least least one entry on stack
    canHoist: boolean; // c.p is not root position and not already the hoisted node

    inChapter: boolean; // cc.inChapter returned true
    topHoistChapter: boolean; // Has entry on stack and top begins with '@chapter'

}

</t>
<t tx="ekr.20200815091945.1">/**
 * * Build all possible strings for buttons icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildButtonsIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BUTTON),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BUTTON)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BUTTON_RCLICK),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BUTTON_RCLICK)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BUTTON_ADD),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BUTTON_ADD)
        }
    ];
}

</t>
<t tx="ekr.20200815113156.1">// * Define entries for all commands
[CMD.MINIBUFFER, () =&gt; w_leo.minibuffer()], // Is referenced in package.json
[CMD.STATUS_BAR, () =&gt; w_leo.statusBarOnClick()],
[CMD.EXECUTE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXECUTE_SCRIPT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.NoChange
})],

[CMD.SHORT_GNX_UNL_TO_CLIPBOARD, () =&gt; w_leo.unlToClipboard("shortGnx")], // Not referenced in package.json
[CMD.FULL_GNX_UNL_TO_CLIPBOARD, () =&gt; w_leo.unlToClipboard("fullGnx")], // Not referenced in package.json
[CMD.SHORT_LEGACY_UNL_TO_CLIPBOARD, () =&gt; w_leo.unlToClipboard("shortLegacy")], // Not referenced in package.json
[CMD.FULL_LEGACY_UNL_TO_CLIPBOARD, () =&gt; w_leo.unlToClipboard("fullLegacy")], // Not referenced in package.json

[CMD.IMPORT_ANY_FILE, () =&gt; w_leo.importAnyFile()], // No URL passed from the command definition.
[CMD.READ_FILE_INTO_NODE, () =&gt; w_leo.readFileIntoNode()],

[CMD.EXPORT_HEADLINES, () =&gt; w_leo.exportHeadlines()],
[CMD.FLATTEN_OUTLINE, () =&gt; w_leo.flattenOutline()],
[CMD.OUTLINE_TO_CWEB, () =&gt; w_leo.outlineToCweb()],
[CMD.OUTLINE_TO_NOWEB, () =&gt; w_leo.outlineToNoweb()],
[CMD.REMOVE_SENTINELS, () =&gt; w_leo.removeSentinels()],
[CMD.WEAVE, () =&gt; w_leo.weave()],
[CMD.WRITE_FILE_FROM_NODE, () =&gt; w_leo.writeFileFromNode()],

[CMD.SET_UA, () =&gt; w_leo.setUa()],

[CMD.CLICK_BUTTON, (p_node: LeoButtonNode) =&gt; w_leo.clickAtButton(p_node)], // Not referenced in package.json
[CMD.GOTO_SCRIPT, (p_node: LeoButtonNode) =&gt; w_leo.gotoScript(p_node)],
[CMD.REMOVE_BUTTON, (p_node: LeoButtonNode) =&gt; w_leo.removeAtButton(p_node)],

[CMD.CLOSE_FILE, () =&gt; w_leo.closeLeoFile()],
[CMD.NEW_FILE, () =&gt; w_leo.newLeoFile()],
[CMD.REVERT_TO_SAVED, () =&gt; w_leo.revert()],
[CMD.OPEN_FILE, (p_uri?: vscode.Uri) =&gt; w_leo.openLeoFile(p_uri)],

[CMD.CLEAR_RECENT_FILES, () =&gt; w_leo.clearRecentLeoFiles()],
[CMD.RECENT_FILES, () =&gt; w_leo.showRecentLeoFiles()],
[CMD.SAVE_AS_FILE, () =&gt; w_leo.saveAsLeoFile()],
[CMD.SAVE_AS_LEOJS, () =&gt; w_leo.saveAsLeoJsFile()],
[CMD.SAVE_FILE, () =&gt; w_leo.saveLeoFile()],
[CMD.SAVE_FILE_FO, () =&gt; w_leo.saveLeoFile(true)],
[CMD.SWITCH_FILE, () =&gt; w_leo.switchLeoFile()],

[CMD.SET_OPENED_FILE, (p_index: number) =&gt; w_leo.selectOpenedLeoDocument(p_index)],

[CMD.REFRESH_FROM_DISK, (p_ap: ArchivedPosition) =&gt; w_leo.nodeCommand({
    action: BRIDGE.REFRESH_FROM_DISK_PNODE,
    node: p_ap,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline,
    keepSelection: false
})],
[CMD.REFRESH_FROM_DISK_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REFRESH_FROM_DISK_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Body
})],

[CMD.WRITE_AT_FILE_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.WRITE_AT_FILE_NODES,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Body
})],
[CMD.WRITE_AT_FILE_NODES_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.WRITE_AT_FILE_NODES,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline
})],
[CMD.WRITE_DIRTY_AT_FILE_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.WRITE_DIRTY_AT_FILE_NODES,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Body
})],
[CMD.WRITE_DIRTY_AT_FILE_NODES_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.WRITE_DIRTY_AT_FILE_NODES,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline
})],

[CMD.GIT_DIFF, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GIT_DIFF,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Body
})],

[CMD.TAB_CYCLE_NEXT, () =&gt; w_leo.tabCycle()],

[CMD.HEADLINE, (p_ap: ArchivedPosition) =&gt; w_leo.editHeadline(p_ap, true)],
[CMD.HEADLINE_SELECTION, () =&gt; w_leo.editHeadline(U, false)],
[CMD.HEADLINE_SELECTION_FO, () =&gt; w_leo.editHeadline(U, true)],

// cut/copy/paste/delete given node.
[CMD.COPY, (p_ap: ArchivedPosition) =&gt; w_leo.copyNode(p_ap, true)],
[CMD.CUT, (p_ap: ArchivedPosition) =&gt; w_leo.cutNode(p_ap, true)],

[CMD.DELETE, (p_ap: ArchivedPosition) =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: p_ap,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline,
    keepSelection: true
})],
[CMD.PASTE, (p_ap: ArchivedPosition) =&gt; w_leo.pasteNode(p_ap, true)],
[CMD.PASTE_CLONE, (p_ap: ArchivedPosition) =&gt; w_leo.pasteAsCloneNode(p_ap, true)],

// PASTE_AS_TEMPLATE used without ap position but supports ap given as parameter
[CMD.PASTE_AS_TEMPLATE, (p_ap: ArchivedPosition) =&gt; w_leo.pasteAsTemplate(p_ap, true)],

// cut/copy/paste/delete current selection (self.commander.p)
[CMD.COPY_SELECTION, () =&gt; w_leo.copyNode(U, false)],
[CMD.COPY_AS_JSON, () =&gt; w_leo.copyNodeAsJson()],
[CMD.COPY_GNX, () =&gt; w_leo.copyGnx()], // Not exposed in package.json

[CMD.CUT_SELECTION, () =&gt; w_leo.cutNode(U, false)],
[CMD.CUT_SELECTION_FO, () =&gt; w_leo.cutNode(U, true)],

[CMD.DELETE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Body
})],
[CMD.DELETE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
})],

[CMD.PASTE_SELECTION, () =&gt; w_leo.pasteNode(U, false)],
[CMD.PASTE_SELECTION_FO, () =&gt; w_leo.pasteNode(U, true)],
[CMD.PASTE_CLONE_SELECTION, () =&gt; w_leo.pasteAsCloneNode(U, false)],
[CMD.PASTE_CLONE_SELECTION_FO, () =&gt; w_leo.pasteAsCloneNode(U, true)],

[CMD.CONTRACT_ALL, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Body
})],
[CMD.CONTRACT_ALL_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
})],
[CMD.CONTRACT_OR_GO_LEFT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_OR_GO_LEFT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
}, true)],
[CMD.EXPAND_AND_GO_RIGHT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXPAND_AND_GO_RIGHT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
}, true)],

[CMD.GOTO_NEXT_CLONE, (p_ap: ArchivedPosition) =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: p_ap,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
}, true)],
[CMD.GOTO_NEXT_CLONE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Body
}, true)],
[CMD.GOTO_NEXT_CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
}, true)],

[CMD.GOTO_NEXT_MARKED, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_MARKED,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
}, true)],
[CMD.GOTO_FIRST_SIBLING, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_FIRST_SIBLING,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    finalFocus: Focus.Outline
}, true)],
[CMD.GOTO_LAST_SIBLING, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_LAST_SIBLING,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    finalFocus: Focus.Outline
}, true)],
[CMD.GOTO_FIRST_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_FIRST_VISIBLE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
}, true)],
[CMD.GOTO_LAST_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_LAST_VISIBLE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
}, true)],
[CMD.GOTO_NEXT_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    finalFocus: Focus.Outline
}, true)],
[CMD.GOTO_PREV_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_PREV_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    finalFocus: Focus.Outline
}, true)],

[CMD.PAGE_UP, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PAGE_UP,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    finalFocus: Focus.Outline
}, true)],
[CMD.PAGE_DOWN, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PAGE_DOWN,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    finalFocus: Focus.Outline
}, true)],
[CMD.SCROLL_TOP, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SCROLL_TOP,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    finalFocus: Focus.Outline
}, true)],
[CMD.SCROLL_BOTTOM, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SCROLL_BOTTOM,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    finalFocus: Focus.Outline
}, true)],

[CMD.DEHOIST, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEHOIST,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Body
})],
[CMD.DEHOIST_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEHOIST,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
})],
[CMD.HOIST, (p_ap: ArchivedPosition) =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: p_ap,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
})],
[CMD.HOIST_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Body
})],
[CMD.HOIST_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline
})],

[CMD.CHAPTER_NEXT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CHAPTER_NEXT,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline
})],

[CMD.CHAPTER_BACK, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CHAPTER_BACK,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline
})],

[CMD.CHAPTER_MAIN, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CHAPTER_MAIN,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline
})],
[CMD.CHAPTER_SELECT, () =&gt; w_leo.chapterSelect()],

[CMD.CLONE, (p_ap: ArchivedPosition) =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: p_ap,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline,
    keepSelection: true
})],
[CMD.CLONE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Body
})],
[CMD.CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline
})],

[CMD.INSERT, (p_ap: ArchivedPosition) =&gt; w_leo.insertNode(p_ap, true, false)],
[CMD.INSERT_SELECTION, () =&gt; w_leo.insertNode(U, false, false)],
[CMD.INSERT_SELECTION_FO, () =&gt; w_leo.insertNode(U, true, false)],
[CMD.INSERT_CHILD, (p_ap: ArchivedPosition) =&gt; w_leo.insertNode(p_ap, true, true)],
[CMD.INSERT_CHILD_SELECTION, () =&gt; w_leo.insertNode(U, false, true)],
[CMD.INSERT_CHILD_SELECTION_FO, () =&gt; w_leo.insertNode(U, true, true)],

// Special command for when inserting rapidly more than one node without
// even specifying a headline label, such as spamming CTRL+I rapidly.
// [CMD.INSERT_SELECTION_INTERRUPT, () =&gt; w_leo.insertNode(U, false, false, true)],
// [CMD.INSERT_CHILD_SELECTION_INTERRUPT, () =&gt; w_leo.insertNode(U, false, true, true)],

[CMD.MARK, (p_ap: ArchivedPosition) =&gt; w_leo.changeMark(true, p_ap, true)],
[CMD.MARK_SELECTION, () =&gt; w_leo.changeMark(true, U, false)],
[CMD.MARK_SELECTION_FO, () =&gt; w_leo.changeMark(true, U, true)],

[CMD.UNMARK, (p_ap: ArchivedPosition) =&gt; w_leo.changeMark(false, p_ap, true)],
[CMD.UNMARK_SELECTION, () =&gt; w_leo.changeMark(false, U, false)],
[CMD.UNMARK_SELECTION_FO, () =&gt; w_leo.changeMark(false, U, true)],

[CMD.EXTRACT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXTRACT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Body
})],
[CMD.EXTRACT_NAMES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXTRACT_NAMES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Body
})],

[CMD.MOVE_DOWN, (p_ap: ArchivedPosition) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: p_ap,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline,
    keepSelection: true
})],
[CMD.MOVE_DOWN_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Body
})],
[CMD.MOVE_DOWN_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline
})],

[CMD.MOVE_LEFT, (p_ap: ArchivedPosition) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: p_ap,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline,
    keepSelection: true
})],
[CMD.MOVE_LEFT_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Body
})],
[CMD.MOVE_LEFT_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline
})],

[CMD.MOVE_RIGHT, (p_ap: ArchivedPosition) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: p_ap,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline,
    keepSelection: true
})],
[CMD.MOVE_RIGHT_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Body
})],
[CMD.MOVE_RIGHT_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline
})],

[CMD.MOVE_UP, (p_ap: ArchivedPosition) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: p_ap,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline,
    keepSelection: true
})],
[CMD.MOVE_UP_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Body
})],
[CMD.MOVE_UP_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline
})],

[CMD.DEMOTE, (p_ap: ArchivedPosition) =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: p_ap,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline,
    keepSelection: true
})],
[CMD.DEMOTE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Body
})],
[CMD.DEMOTE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline
})],
[CMD.PROMOTE, (p_ap: ArchivedPosition) =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: p_ap,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline,
    keepSelection: true
})],
[CMD.PROMOTE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Body
})],
[CMD.PROMOTE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline
})],

[CMD.SORT_CHILDREN, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_CHILDREN,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Body,
    keepSelection: true
})],
[CMD.SORT_CHILDREN_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_CHILDREN,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline,
    keepSelection: true
})],
[CMD.SORT_SIBLING, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_SIBLINGS,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Body,
    keepSelection: true
})],
[CMD.SORT_SIBLING_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_SIBLINGS,
    node: U,
    refreshType: REFRESH_TREE,
    finalFocus: Focus.Outline,
    keepSelection: true
})],

[CMD.REDO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Body
})],
[CMD.REDO_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
})],
[CMD.UNDO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Body
})],
[CMD.UNDO_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
})],
[CMD.REVERT_TO_UNDO, (p_undo: LeoUndoNode) =&gt; w_leo.revertToUndo(p_undo)],

[CMD.CONNECT, () =&gt; w_leo.connect()],
[CMD.START_SERVER, () =&gt; w_leo.startServer()],
[CMD.STOP_SERVER, () =&gt; w_leo.killServer()],
[CMD.CHOOSE_LEO_FOLDER, () =&gt; w_leo.chooseLeoFolder()],
[CMD.SET_LEOID, () =&gt; w_leo.setLeoID()],
[CMD.HANDLE_UNL, (p_arg: { unl: string, scheme: string }) =&gt; w_leo.handleUnl(p_arg)],

// Called by nodes in tree when selected either by mouse, or with enter
[CMD.SELECT_NODE, (p_outlineNode: LeoApOutlineNode) =&gt; w_leo.selectTreeNode(p_outlineNode.position, false)], // Select is NOT a Position!
[CMD.OPEN_ASIDE, (p_position?: ArchivedPosition) =&gt; w_leo.openAside(p_position)],

[CMD.SHOW_OUTLINE, () =&gt; w_leo.showOutline(true)], // Also focuses on outline

[CMD.SHOW_LOG, () =&gt; w_leo.showLogPane()],
[CMD.SHOW_BODY, () =&gt; w_leo.showBody(false)], // Also focuses on body

[CMD.SHOW_WELCOME, () =&gt; w_leoSettingsWebview.openWebview()],
[CMD.SHOW_SETTINGS, () =&gt; w_leoSettingsWebview.openWebview()], // Same as SHOW_WELCOME

[CMD.COPY_MARKED, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.COPY_MARKED,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
})],
[CMD.DIFF_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DIFF_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
})],
[CMD.MARK_CHANGED_ITEMS, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MARK_CHANGED_ITEMS,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
})],
[CMD.MARK_SUBHEADS, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MARK_SUBHEADS,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
})],
[CMD.UNMARK_ALL, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNMARK_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
})],
[CMD.CLONE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
})],
[CMD.DELETE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
})],
[CMD.MOVE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.Outline
})],

[CMD.PREV_NODE, () =&gt; w_leo.prevNextNode(false)],
[CMD.PREV_NODE_FO, () =&gt; w_leo.prevNextNode(false)],

[CMD.NEXT_NODE, () =&gt; w_leo.prevNextNode(true)],
[CMD.NEXT_NODE_FO, () =&gt; w_leo.prevNextNode(true)],

[CMD.FIND_QUICK, () =&gt; w_leo.findQuick()],
[CMD.FIND_QUICK_SELECTED, () =&gt; w_leo.findQuickSelected()],
[CMD.FIND_QUICK_TIMELINE, () =&gt; w_leo.findQuickTimeline()],
[CMD.FIND_QUICK_CHANGED, () =&gt; w_leo.findQuickChanged()],
[CMD.FIND_QUICK_HISTORY, () =&gt; w_leo.findQuickHistory()],
[CMD.FIND_QUICK_MARKED, () =&gt; w_leo.findQuickMarked()],
[CMD.FIND_QUICK_GO_ANYWHERE, () =&gt; w_leo.gotoAnywhere()],

[CMD.GOTO_NAV_PREV, () =&gt; w_leo.navigateNavEntry(LeoGotoNavKey.prev)],
[CMD.GOTO_NAV_NEXT, () =&gt; w_leo.navigateNavEntry(LeoGotoNavKey.next)],
[CMD.GOTO_NAV_FIRST, () =&gt; w_leo.navigateNavEntry(LeoGotoNavKey.first)],
[CMD.GOTO_NAV_LAST, () =&gt; w_leo.navigateNavEntry(LeoGotoNavKey.last)],

[CMD.GOTO_NAV_ENTRY, (p_node: LeoGotoNode) =&gt; w_leo.gotoNavEntry(p_node)],

[CMD.START_SEARCH, () =&gt; w_leo.startSearch()],
[CMD.SEARCH_BACKWARD, () =&gt; w_leo.interactiveSearch(true, false, false)],
[CMD.RE_SEARCH, () =&gt; w_leo.interactiveSearch(false, true, false)],
[CMD.RE_SEARCH_BACKWARD, () =&gt; w_leo.interactiveSearch(true, true, false)],
[CMD.WORD_SEARCH, () =&gt; w_leo.interactiveSearch(false, false, true)],
[CMD.WORD_SEARCH_BACKWARD, () =&gt; w_leo.interactiveSearch(true, false, true)],

[CMD.FIND_ALL, () =&gt; w_leo.findAll(false)],
[CMD.FIND_NEXT, () =&gt; w_leo.find(false, false)],
[CMD.FIND_NEXT_FO, () =&gt; w_leo.find(true, false)],
[CMD.FIND_PREVIOUS, () =&gt; w_leo.find(false, true)],
[CMD.FIND_PREVIOUS_FO, () =&gt; w_leo.find(true, true)],
[CMD.FIND_VAR, () =&gt; w_leo.findSymbol(false)],
[CMD.FIND_DEF, () =&gt; w_leo.findSymbol(true)],
[CMD.REPLACE, () =&gt; w_leo.replace(false, false)],
[CMD.REPLACE_FO, () =&gt; w_leo.replace(true, false)],
[CMD.REPLACE_THEN_FIND, () =&gt; w_leo.replace(false, true)],
[CMD.REPLACE_THEN_FIND_FO, () =&gt; w_leo.replace(true, true)],
[CMD.REPLACE_ALL, () =&gt; w_leo.findAll(true)],
[CMD.GOTO_GLOBAL_LINE, () =&gt; w_leo.gotoGlobalLine()],
[CMD.TAG_CHILDREN, () =&gt; w_leo.tagChildren()],

[CMD.TAG_NODE, (p_ap: ArchivedPosition) =&gt; w_leo.tagNode(p_ap)],
[CMD.REMOVE_TAG, (p_ap: ArchivedPosition) =&gt; w_leo.removeTag(p_ap)],
[CMD.REMOVE_TAGS, (p_ap: ArchivedPosition) =&gt; w_leo.removeTags(p_ap)],

[CMD.CLONE_FIND_ALL, () =&gt; w_leo.cloneFind(false, false)],
[CMD.CLONE_FIND_ALL_FLATTENED, () =&gt; w_leo.cloneFind(false, true)],
[CMD.CLONE_FIND_TAG, () =&gt; w_leo.cloneFindTag()],
[CMD.CLONE_FIND_PARENTS, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_FIND_PARENTS,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    finalFocus: Focus.NoChange
})],
[CMD.CLONE_FIND_MARKED, () =&gt; w_leo.cloneFind(true, false)],
[CMD.CLONE_FIND_FLATTENED_MARKED, () =&gt; w_leo.cloneFind(true, true)],

[CMD.SET_FIND_EVERYWHERE_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.ENTIRE_OUTLINE)],
[CMD.SET_FIND_NODE_ONLY_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.NODE_ONLY)],
[CMD.SET_FIND_FILE_ONLY_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.FILE_ONLY)],
[CMD.SET_FIND_SUBOUTLINE_ONLY_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.SUBOUTLINE_ONLY)],
[CMD.TOGGLE_FIND_IGNORE_CASE_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.IGNORE_CASE)],
[CMD.TOGGLE_FIND_MARK_CHANGES_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.MARK_CHANGES)],
[CMD.TOGGLE_FIND_MARK_FINDS_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.MARK_FINDS)],
[CMD.TOGGLE_FIND_REGEXP_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.REG_EXP)],
[CMD.TOGGLE_FIND_WORD_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.WHOLE_WORD)],
[CMD.TOGGLE_FIND_SEARCH_BODY_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.SEARCH_BODY)],
[CMD.TOGGLE_FIND_SEARCH_HEADLINE_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.SEARCH_HEADLINE)],

[CMD.SET_BODY_WRAP_SETTINGS, () =&gt; w_leo.config.setBodyWrap()],
[CMD.SET_ENABLE_PREVIEW, () =&gt; w_leo.config.setEnablePreview()],
[CMD.CLEAR_CLOSE_EMPTY_GROUPS, () =&gt; w_leo.config.clearCloseEmptyGroups()],
</t>
<t tx="ekr.20200815123601.1">@language json
@tabwidth -2
{
  "name": "leointeg",
  "displayName": "Leo Editor Integration with Visual Studio Code",
  "description": "Use Leo, the literate editor with outline, directly in vscode.",
  "version": "1.0.21",
  "author": {
    "name": "Flix Malboeuf"
  },
  "sponsor": {
    "url": "https://boltex.github.io/"
  },
  "publisher": "boltex",
  "license": "SEE LICENSE IN LICENSE",
  "repository": {
    "type": "git",
    "url": "https://github.com/boltex/leointeg"
  },
  "bugs": {
    "url": "https://github.com/boltex/leointeg/issues"
  },
  "homepage": "https://github.com/boltex/leointeg#readme",
  "engines": {
    "vscode": "^1.86.0"
  },
  "keywords": [
    "leo",
    "tree",
    "outline",
    "editor",
    "literate"
  ],
  "categories": [
    "Other"
  ],
  "activationEvents": [
    "onStartupFinished"
  ],
  "qna": false,
  "main": "./dist/extension",
  "icon": "resources/leoapp256px.png",
  "galleryBanner": {
    "color": "#fff3dc",
    "theme": "light"
  },
  "contributes": {
    @others
  },
  "scripts": {
    "vscode:prepublish": "npm run package",
    "compile": "webpack",
    "watch": "webpack --watch",
    "package": "webpack --mode production --devtool hidden-source-map",
    "compile-tests": "tsc -p . --outDir out",
    "watch-tests": "tsc -p . -w --outDir out",
    "pretest": "npm run compile-tests &amp;&amp; npm run compile &amp;&amp; npm run lint",
    "lint": "eslint src --ext ts",
    "test": "node ./out/test/runTest.js"
  },
  "devDependencies": {
    "@types/glob": "^8.1.0",
    "@types/lodash": "^4.14.177",
    "@types/mocha": "^10.0.1",
    "@types/node": "20.2.5",
    "@types/vscode": "^1.86.0",
    "@types/ws": "^7.2.6",
    "@typescript-eslint/eslint-plugin": "^5.59.8",
    "@typescript-eslint/parser": "^5.59.8",
    "eslint": "^8.41.0",
    "glob": "^8.1.0",
    "mocha": "^10.2.0",
    "ts-loader": "^9.4.3",
    "typescript": "^5.1.3",
    "webpack": "^5.85.0",
    "webpack-cli": "^5.1.1",
    "@vscode/test-electron": "^2.3.2"
  },
  "dependencies": {
    "bufferutil": "^4.0.1",
    "hasbin": "^1.2.3",
    "lodash": "^4.17.21",
    "portfinder": "^1.0.28",
    "tree-kill": "^1.2.2",
    "ws": "^7.4.6"
  }
}
</t>
<t tx="ekr.20200815123601.10">"languages": [
  {
    "id": "leobody.plain",
    "aliases": [
      "Leo Body Plain",
      "leobody"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.plain.language-configuration.json"
  },
  {
    "id": "leobody.plain.wrap",
    "aliases": [
      "Leo Body Plain",
      "leobody"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.plain.language-configuration.json"
  },
  {
    "id": "leobody.python",
    "aliases": [
      "Leo Body Python",
      "leobody.python"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.python.language-configuration.json"
  },
  {
    "id": "leobody.python.wrap",
    "aliases": [
      "Leo Body Python",
      "leobody.python"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.python.language-configuration.json"
  },
  {
    "id": "leobody.typescript",
    "aliases": [
      "Leo Body Typescript",
      "leobody.typescript"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.typescript.language-configuration.json"
  },
  {
    "id": "leobody.typescript.wrap",
    "aliases": [
      "Leo Body Typescript",
      "leobody.typescript"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.typescript.language-configuration.json"
  },
  {
    "id": "leobody.javascript",
    "aliases": [
      "Leo Body Javascript",
      "leobody.javascript"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.javascript.language-configuration.json"
  },
  {
    "id": "leobody.javascript.wrap",
    "aliases": [
      "Leo Body Javascript",
      "leobody.javascript"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.javascript.language-configuration.json"
  },
  {
    "id": "leobody.c",
    "aliases": [
      "Leo Body c",
      "leobody.c"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.c.language-configuration.json"
  },
  {
    "id": "leobody.c.wrap",
    "aliases": [
      "Leo Body c",
      "leobody.c"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.c.language-configuration.json"
  },
  {
    "id": "leobody.cpp",
    "aliases": [
      "Leo Body C++",
      "leobody.cpp"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.cpp.language-configuration.json"
  },
  {
    "id": "leobody.cpp.wrap",
    "aliases": [
      "Leo Body C++",
      "leobody.cpp"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.cpp.language-configuration.json"
  },
  {
    "id": "leobody.css",
    "aliases": [
      "Leo Body CSS",
      "leobody.css"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.css.language-configuration.json"
  },
  {
    "id": "leobody.css.wrap",
    "aliases": [
      "Leo Body CSS",
      "leobody.css"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.css.language-configuration.json"
  },
  {
    "id": "leobody.fortran",
    "aliases": [
      "Leo Body Fortran",
      "leobody.fortran"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.fortran.language-configuration.json"
  },
  {
    "id": "leobody.fortran.wrap",
    "aliases": [
      "Leo Body Fortran",
      "leobody.fortran"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.fortran.language-configuration.json"
  },
  {
    "id": "leobody.fortran90",
    "aliases": [
      "Leo Body Fortran90",
      "leobody.fortran90"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.fortran.language-configuration.json"
  },
  {
    "id": "leobody.fortran90.wrap",
    "aliases": [
      "Leo Body Fortran90",
      "leobody.fortran90"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.fortran.language-configuration.json"
  },
  {
    "id": "leobody.html",
    "aliases": [
      "Leo Body HTML",
      "leobody.html"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.html.language-configuration.json"
  },
  {
    "id": "leobody.html.wrap",
    "aliases": [
      "Leo Body HTML",
      "leobody.html"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.html.language-configuration.json"
  },
  {
    "id": "leobody.java",
    "aliases": [
      "Leo Body Java",
      "leobody.java"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.java.language-configuration.json"
  },
  {
    "id": "leobody.java.wrap",
    "aliases": [
      "Leo Body Java",
      "leobody.java"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.java.language-configuration.json"
  },
  {
    "id": "leobody.json",
    "aliases": [
      "Leo Body Json",
      "leobody.json"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.json.language-configuration.json"
  },
  {
    "id": "leobody.json.wrap",
    "aliases": [
      "Leo Body Json",
      "leobody.json"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.json.language-configuration.json"
  },
  {
    "id": "leobody.markdown",
    "aliases": [
      "Leo Body Markdown",
      "leobody.markdown"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.markdown.language-configuration.json"
  },
  {
    "id": "leobody.markdown.wrap",
    "aliases": [
      "Leo Body Markdown",
      "leobody.markdown"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.markdown.language-configuration.json"
  },
  {
    "id": "leobody.php",
    "aliases": [
      "Leo Body PHP",
      "leobody.php"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.php.language-configuration.json"
  },
  {
    "id": "leobody.php.wrap",
    "aliases": [
      "Leo Body PHP",
      "leobody.php"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.php.language-configuration.json"
  },
  {
    "id": "leobody.restructuredtext",
    "aliases": [
      "Leo Body reStructuredText",
      "leobody.restructuredtext"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.rst.language-configuration.json"
  },
  {
    "id": "leobody.restructuredtext.wrap",
    "aliases": [
      "Leo Body reStructuredText",
      "leobody.restructuredtext"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.rst.language-configuration.json"
  },
  {
    "id": "leobody.rust",
    "aliases": [
      "Leo Body Rust",
      "leobody.rust"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.rust.language-configuration.json"
  },
  {
    "id": "leobody.rust.wrap",
    "aliases": [
      "Leo Body Rust",
      "leobody.rust"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.rust.language-configuration.json"
  },
  {
    "id": "leobody.xml",
    "aliases": [
      "Leo Body XML",
      "leobody.xml"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.xml.language-configuration.json"
  },
  {
    "id": "leobody.xml.wrap",
    "aliases": [
      "Leo Body XML",
      "leobody.xml"
    ],
    "extensions": [
      ""
    ],
    "icon": {
      "light": "resources/light/body-pane.svg",
      "dark": "resources/dark/body-pane.svg"
    },
    "configuration": "./language-configurations/leobody.xml.language-configuration.json"
  }
],
</t>
<t tx="ekr.20200815123601.11">"grammars": [
  {
    "language": "leobody.plain",
    "scopeName": "source.leobody.plain",
    "path": "./syntaxes/leobody.plain.tmLanguage.json"
  },
  {
    "language": "leobody.plain.wrap",
    "scopeName": "source.leobody.plain",
    "path": "./syntaxes/leobody.plain.tmLanguage.json"
  },
  {
    "language": "leobody.python",
    "scopeName": "source.leobody.python",
    "path": "./syntaxes/leobody.python.tmLanguage.json"
  },
  {
    "language": "leobody.python.wrap",
    "scopeName": "source.leobody.python",
    "path": "./syntaxes/leobody.python.tmLanguage.json"
  },
  {
    "language": "leobody.typescript",
    "scopeName": "source.leobody.typescript",
    "path": "./syntaxes/leobody.typescript.tmLanguage.json"
  },
  {
    "language": "leobody.typescript.wrap",
    "scopeName": "source.leobody.typescript",
    "path": "./syntaxes/leobody.typescript.tmLanguage.json"
  },
  {
    "language": "leobody.javascript",
    "scopeName": "source.leobody.javascript",
    "path": "./syntaxes/leobody.javascript.tmLanguage.json"
  },
  {
    "language": "leobody.javascript.wrap",
    "scopeName": "source.leobody.javascript",
    "path": "./syntaxes/leobody.javascript.tmLanguage.json"
  },
  {
    "language": "leobody.c",
    "scopeName": "source.leobody.c",
    "path": "./syntaxes/leobody.c.tmLanguage.json"
  },
  {
    "language": "leobody.c.wrap",
    "scopeName": "source.leobody.c",
    "path": "./syntaxes/leobody.c.tmLanguage.json"
  },
  {
    "language": "leobody.cpp",
    "scopeName": "source.leobody.cpp",
    "path": "./syntaxes/leobody.cpp.tmLanguage.json"
  },
  {
    "language": "leobody.cpp.wrap",
    "scopeName": "source.leobody.cpp",
    "path": "./syntaxes/leobody.cpp.tmLanguage.json"
  },
  {
    "language": "leobody.css",
    "scopeName": "source.leobody.css",
    "path": "./syntaxes/leobody.css.tmLanguage.json"
  },
  {
    "language": "leobody.css.wrap",
    "scopeName": "source.leobody.css",
    "path": "./syntaxes/leobody.css.tmLanguage.json"
  },
  {
    "language": "leobody.fortran",
    "scopeName": "source.leobody.fortran",
    "path": "./syntaxes/leobody.fortran.tmLanguage.json"
  },
  {
    "language": "leobody.fortran.wrap",
    "scopeName": "source.leobody.fortran",
    "path": "./syntaxes/leobody.fortran.tmLanguage.json"
  },
  {
    "language": "leobody.fortran90",
    "scopeName": "source.leobody.fortran90",
    "path": "./syntaxes/leobody.fortran90.tmLanguage.json"
  },
  {
    "language": "leobody.fortran90.wrap",
    "scopeName": "source.leobody.fortran90",
    "path": "./syntaxes/leobody.fortran90.tmLanguage.json"
  },
  {
    "language": "leobody.html",
    "scopeName": "source.leobody.html",
    "path": "./syntaxes/leobody.html.tmLanguage.json"
  },
  {
    "language": "leobody.html.wrap",
    "scopeName": "source.leobody.html",
    "path": "./syntaxes/leobody.html.tmLanguage.json"
  },
  {
    "language": "leobody.java",
    "scopeName": "source.leobody.java",
    "path": "./syntaxes/leobody.java.tmLanguage.json"
  },
  {
    "language": "leobody.java.wrap",
    "scopeName": "source.leobody.java",
    "path": "./syntaxes/leobody.java.tmLanguage.json"
  },
  {
    "language": "leobody.json",
    "scopeName": "source.leobody.json",
    "path": "./syntaxes/leobody.json.tmLanguage.json"
  },
  {
    "language": "leobody.json.wrap",
    "scopeName": "source.leobody.json",
    "path": "./syntaxes/leobody.json.tmLanguage.json"
  },
  {
    "language": "leobody.markdown",
    "scopeName": "source.leobody.markdown",
    "path": "./syntaxes/leobody.markdown.tmLanguage.json"
  },
  {
    "language": "leobody.markdown.wrap",
    "scopeName": "source.leobody.markdown",
    "path": "./syntaxes/leobody.markdown.tmLanguage.json"
  },
  {
    "language": "leobody.php",
    "scopeName": "source.leobody.php",
    "path": "./syntaxes/leobody.php.tmLanguage.json"
  },
  {
    "language": "leobody.php.wrap",
    "scopeName": "source.leobody.php",
    "path": "./syntaxes/leobody.php.tmLanguage.json"
  },
  {
    "language": "leobody.restructuredtext",
    "scopeName": "source.leobody.restructuredtext",
    "path": "./syntaxes/leobody.rst.tmLanguage.json"
  },
  {
    "language": "leobody.restructuredtext.wrap",
    "scopeName": "source.leobody.restructuredtext",
    "path": "./syntaxes/leobody.rst.tmLanguage.json"
  },
  {
    "language": "leobody.rust",
    "scopeName": "source.leobody.rust",
    "path": "./syntaxes/leobody.rust.tmLanguage.json"
  },
  {
    "language": "leobody.rust.wrap",
    "scopeName": "source.leobody.rust",
    "path": "./syntaxes/leobody.rust.tmLanguage.json"
  },
  {
    "language": "leobody.xml",
    "scopeName": "source.leobody.xml",
    "path": "./syntaxes/leobody.xml.tmLanguage.json"
  },
  {
    "language": "leobody.xml.wrap",
    "scopeName": "source.leobody.xml",
    "path": "./syntaxes/leobody.xml.tmLanguage.json"
  },
  {
    "injectTo": [
      "source.leobody.c",
      "source.leobody.cpp",
      "source.leobody.css",
      "source.leobody.fortran",
      "source.leobody.fortran90",
      "source.leobody.html",
      "source.leobody.java",
      "source.leobody.javascript",
      "source.leobody.json",
      "source.leobody.markdown",
      "source.leobody.php",
      "source.leobody.plain",
      "source.leobody.python",
      "source.leobody.restructuredtext",
      "source.leobody.rust",
      "source.leobody.typescript",
      "source.leobody.xml",
      "source.leobody.c.wrap",
      "source.leobody.cpp.wrap",
      "source.leobody.css.wrap",
      "source.leobody.fortran.wrap",
      "source.leobody.fortran90.wrap",
      "source.leobody.html.wrap",
      "source.leobody.java.wrap",
      "source.leobody.javascript.wrap",
      "source.leobody.json.wrap",
      "source.leobody.markdown.wrap",
      "source.leobody.php.wrap",
      "source.leobody.plain.wrap",
      "source.leobody.python.wrap",
      "source.leobody.restructuredtext.wrap",
      "source.leobody.rust.wrap",
      "source.leobody.typescript.wrap",
      "source.leobody.xml.wrap"
    ],
    "path": "./syntaxes/leobody.tmLanguage.json",
    "scopeName": "leo.injection"
  }
],
</t>
<t tx="ekr.20200815123601.12">"snippets": [
  {
    "language": "leobody.c",
    "path": "./snippets/c.code-snippets"
  },
  {
    "language": "leobody.c.wrap",
    "path": "./snippets/c.code-snippets"
  },
  {
    "language": "leobody.cpp",
    "path": "./snippets/cpp.code-snippets"
  },
  {
    "language": "leobody.cpp.wrap",
    "path": "./snippets/cpp.code-snippets"
  },
  {
    "language": "leobody.fortran90",
    "path": "./snippets/fortran90.code-snippets"
  },
  {
    "language": "leobody.fortran90.wrap",
    "path": "./snippets/fortran90.code-snippets"
  },
  {
    "language": "leobody.javascript",
    "path": "./snippets/javascript.code-snippets"
  },
  {
    "language": "leobody.javascript.wrap",
    "path": "./snippets/javascript.code-snippets"
  },
  {
    "language": "leobody.typescript",
    "path": "./snippets/typescript.code-snippets"
  },
  {
    "language": "leobody.typescript.wrap",
    "path": "./snippets/typescript.code-snippets"
  },
  {
    "language": "leobody.java",
    "path": "./snippets/java.code-snippets"
  },
  {
    "language": "leobody.java.wrap",
    "path": "./snippets/java.code-snippets"
  },
  {
    "language": "leobody.php",
    "path": "./snippets/php.code-snippets"
  },
  {
    "language": "leobody.php.wrap",
    "path": "./snippets/php.code-snippets"
  },
  {
    "language": "leobody.markdown",
    "path": "./snippets/markdown.code-snippets"
  },
  {
    "language": "leobody.markdown.wrap",
    "path": "./snippets/markdown.code-snippets"
  },
  {
    "language": "leobody.restructuredtext",
    "path": "./snippets/restructuredtext.code-snippets"
  },
  {
    "language": "leobody.restructuredtext.wrap",
    "path": "./snippets/restructuredtext.code-snippets"
  },
  {
    "language": "leobody.rust",
    "path": "./snippets/rust.code-snippets"
  },
  {
    "language": "leobody.rust.wrap",
    "path": "./snippets/rust.code-snippets"
  }
],
</t>
<t tx="ekr.20200815123601.13">"commands": [
  @others
],
</t>
<t tx="ekr.20200815123601.15">{
  "command": "leointeg.showSettingsPage",
  "title": "Open Leo Settings",
  "category": "Leo",
  "icon": "$(leo-gear)"
},
{
  "command": "leointeg.showWelcomePage",
  "title": "Welcome",
  "category": "Leo"
},
</t>
<t tx="ekr.20200815123601.16">{
  "command": "leointeg.chooseLeoFolder",
  "title": "Choose Leo Installation Folder",
  "shortTitle": "Set Leo Folder",
  "category": "Leo"
},
{
  "command": "leointeg.startServer",
  "category": "Leo",
  "title": "Start a Leo Server",
  "enablement": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; !leoServerStarted &amp;&amp; !leoStartingServer",
  "icon": "$(leo-start-server)"
},
{
  "command": "leointeg.stopServer",
  "category": "Leo",
  "title": "Stop the Leo Server",
  "enablement": "leoStartingServer || leoServerStarted &amp;&amp; !leoTreeOpened",
  "icon": "$(leo-close-server)"
},
{
  "command": "leointeg.connectToServer",
  "category": "Leo",
  "title": "Connect to a Leo Server",
  "enablement": "!leoBridgeReady &amp;&amp; !leoTreeOpened",
  "icon": "$(plug)"
},
{
  "command": "leointeg.setLeoID",
  "title": "Set LeoID",
  "enablement": "leoBridgeReady &amp;&amp; leoIDMissing",
  "category": "Leo"
},
</t>
<t tx="ekr.20200815123601.17">{
  "command": "leointeg.executeScript",
  "title": "Execute Script",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "icon": "$(play)"
},
{
  "command": "leointeg.minibuffer",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Minibuffer"
},
{
  "command": "leointeg.gotoScript",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Goto Script"
},
{
  "command": "leointeg.clickButton",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Click Button",
  "icon": "$(play)"
},
{
  "command": "leointeg.removeButton",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Remove Button"
},
</t>
<t tx="ekr.20200815123601.18">{
  "command": "leointeg.showBody",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Focus on Body"
},
{
  "command": "leointeg.showOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Focus on Tree"
},
{
  "command": "leointeg.showLogPane",
  "category": "Leo",
  "title": "Show Log Pane",
  "enablement": "leoBridgeReady",
  "icon": "$(leo-show-log)"
},
</t>
<t tx="ekr.20200815123601.19">{
  "command": "leointeg.openLeoFile",
  "title": "Open with LeoInteg",
  "category": "Leo",
  "enablement": "leoBridgeReady",
  "icon": "$(leo-folder)"
},
{
  "command": "leointeg.clearRecentFiles",
  "category": "Leo",
  "title": "Clear Recent Files",
  "icon": "$(leo-clear-files)"
},
{
  "command": "leointeg.recentLeoFiles",
  "enablement": "leoBridgeReady",
  "category": "Leo",
  "title": "Recent Files",
  "icon": "$(leo-open-recent)"
},
{
  "command": "leointeg.switchLeoFile",
  "title": "Switch Leo File",
  "enablement": "leoTreeOpened",
  "category": "Leo",
  "icon": "$(leo-switch)"
},
{
  "command": "leointeg.newLeoFile",
  "title": "New Leo File",
  "enablement": "leoBridgeReady",
  "category": "Leo",
  "icon": "$(leo-new-file)"
},
{
  "command": "leointeg.closeLeoFile",
  "title": "Close Leo File",
  "enablement": "leoTreeOpened",
  "category": "Leo",
  "icon": "$(leo-close)"
},
{
  "command": "leointeg.revert",
  "title": "Revert to Saved",
  "enablement": "leoTreeOpened &amp;&amp; leoTreeTitled",
  "category": "Leo"
},
{
  "command": "leointeg.saveLeoFile",
  "category": "Leo",
  "title": "Save Leo File",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-save)"
},
{
  "command": "leointeg.saveLeoFileFromOutline",
  "category": "Leo",
  "title": "Save Leo File",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-save)"
},
{
  "command": "leointeg.saveAsLeoFile",
  "category": "Leo",
  "title": "Save Leo File as...",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-save-as)"
},
{
  "command": "leointeg.saveAsLeoJsFile",
  "category": "Leo",
  "title": "Save a Copy as leojs File...",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-save-as-leojs)"
},
{
  "command": "leointeg.refreshFromDisk",
  "category": "Leo",
  "title": "Refresh from Disk",
  "enablement": "leoTreeOpened &amp;&amp; leoTreeTitled",
  "icon": "$(leo-refresh)"
},
{
  "command": "leointeg.refreshFromDiskSelection",
  "category": "Leo",
  "title": "Refresh from Disk",
  "enablement": "leoTreeOpened &amp;&amp; leoAtFile &amp;&amp; leoTreeTitled",
  "icon": "$(leo-refresh)"
},
{
  "command": "leointeg.writeAtFileNodes",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Write @&lt;file&gt; Nodes",
  "icon": "$(leo-write-at-file-nodes)"
},
{
  "command": "leointeg.writeAtFileNodesFromOutline",
  "category": "Leo",
  "title": "Write @&lt;file&gt; Nodes",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-write-at-file-nodes)"
},
{
  "command": "leointeg.writeDirtyAtFileNodes",
  "category": "Leo",
  "title": "Write Dirty @&lt;file&gt; Nodes",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-write-dirty-at-file-nodes)"
},
{
  "command": "leointeg.writeDirtyAtFileNodesFromOutline",
  "category": "Leo",
  "title": "Write Dirty @&lt;file&gt; Nodes",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-write-dirty-at-file-nodes)"
},
{
  "command": "leointeg.gitDiff",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Git Diff"
},
{
  "command": "leointeg.tabCycleNext",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Tab Cycle Next"
},
</t>
<t tx="ekr.20200815123601.2">"configuration": {
  "title": "Leo Editor Integration",
  "properties": {
    @others
  }
},
</t>
<t tx="ekr.20200815123601.20">{
  "command": "leointeg.openAside",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Open to the Side"
},
{
  "command": "leointeg.contractAll",
  "category": "Leo",
  "title": "Contract All",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-collapse)"
},
{
  "command": "leointeg.contractAllFromOutline",
  "category": "Leo",
  "title": "Contract All",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-collapse)"
},
{
  "command": "leointeg.prev",
  "category": "Leo",
  "title": "Prev",
  "enablement": "leoCanGoBack",
  "icon": "$(leo-prev)"
},
{
  "command": "leointeg.prevFromOutline",
  "category": "Leo",
  "title": "Prev",
  "enablement": "leoCanGoBack",
  "icon": "$(leo-prev)"
},
{
  "command": "leointeg.next",
  "category": "Leo",
  "title": "Next",
  "enablement": "leoCanGoNext",
  "icon": "$(leo-next)"
},
{
  "command": "leointeg.nextFromOutline",
  "category": "Leo",
  "title": "Next",
  "enablement": "leoCanGoNext",
  "icon": "$(leo-next)"
},
</t>
<t tx="ekr.20200815123601.21">{
  "command": "leointeg.editHeadline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Edit Headline",
  "icon": "$(leo-edit)"
},
{
  "command": "leointeg.editSelectedHeadline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Edit Headline",
  "icon": "$(leo-edit)"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "enablement": "leoTreeOpened",
  "category": "Leo",
  "title": "Edit Headline",
  "icon": "$(leo-edit)"
},
{
  "command": "leointeg.copyNode",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Copy Node",
  "icon": "$(leo-clipboard)"
},
{
  "command": "leointeg.copyNodeAsJson",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Copy Node As JSON",
  "icon": "$(leo-clipboard)"
},
{
  "command": "leointeg.copyNodeSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Copy Node",
  "icon": "$(leo-clipboard)"
},
{
  "command": "leointeg.cutNode",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Cut Node",
  "icon": "$(leo-cut)"
},
{
  "command": "leointeg.cutNodeSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Cut Node",
  "icon": "$(leo-cut)"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Cut Node",
  "icon": "$(leo-cut)"
},
{
  "command": "leointeg.pasteNode",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Paste Node",
  "icon": "$(leo-paste)"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Paste Node",
  "icon": "$(leo-paste)"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Paste Node",
  "icon": "$(leo-paste)"
},
{
  "command": "leointeg.pasteNodeAsClone",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Paste Node as Clone",
  "icon": "$(leo-paste-clone)"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Paste Node as Clone",
  "icon": "$(leo-paste-clone)"
},
{
  "command": "leointeg.pasteAsTemplate",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Paste Node as template"
},
{
  "command": "leointeg.delete",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Delete",
  "icon": "$(leo-close)"
},
{
  "command": "leointeg.deleteSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Delete Node",
  "icon": "$(leo-delete)"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Delete Node",
  "icon": "$(leo-delete)"
},
{
  "command": "leointeg.setUa",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Set uA"
},
</t>
<t tx="ekr.20200815123601.22">{
  "command": "leointeg.moveOutlineDown",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Move Outline Down",
  "icon": "$(leo-arrow-down)"
},
{
  "command": "leointeg.moveOutlineDownSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Move Outline Down",
  "icon": "$(leo-arrow-down)"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Move Outline Down",
  "icon": "$(leo-arrow-down)"
},
{
  "command": "leointeg.moveOutlineLeft",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Move Outline Left",
  "icon": "$(leo-arrow-left)"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Move Outline Left",
  "icon": "$(leo-arrow-left)"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Move Outline Left",
  "icon": "$(leo-arrow-left)"
},
{
  "command": "leointeg.moveOutlineRight",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Move Outline Right",
  "icon": "$(leo-arrow-right)"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Move Outline Right",
  "icon": "$(leo-arrow-right)"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Move Outline Right",
  "icon": "$(leo-arrow-right)"
},
{
  "command": "leointeg.moveOutlineUp",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Move Outline Up",
  "icon": "$(leo-arrow-up)"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Move Outline Up",
  "icon": "$(leo-arrow-up)"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Move Outline Up",
  "icon": "$(leo-arrow-up)"
},
</t>
<t tx="ekr.20200815123601.23">{
  "command": "leointeg.insertNode",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Insert Node",
  "icon": "$(leo-plus)"
},
{
  "command": "leointeg.insertChildNode",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Insert Child",
  "icon": "$(leo-insert-child)"
},
{
  "command": "leointeg.insertNodeSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Insert Node",
  "icon": "$(leo-plus)"
},
{
  "command": "leointeg.insertChildNodeSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Insert Child",
  "icon": "$(leo-insert-child)"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Insert Node",
  "icon": "$(leo-plus)"
},
{
  "command": "leointeg.insertChildNodeSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Insert Child",
  "icon": "$(leo-insert-child)"
},
{
  "command": "leointeg.cloneNode",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Clone Node",
  "icon": "$(leo-link)"
},
{
  "command": "leointeg.cloneNodeSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Clone Node",
  "icon": "$(leo-link)"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Clone Node",
  "icon": "$(leo-link)"
},
{
  "command": "leointeg.promote",
  "category": "Leo",
  "title": "Promote Children",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-promote)"
},
{
  "command": "leointeg.promoteSelection",
  "category": "Leo",
  "title": "Promote Children",
  "enablement": "leoCanPromote",
  "icon": "$(leo-promote)"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "category": "Leo",
  "title": "Promote Children",
  "enablement": "leoCanPromote",
  "icon": "$(leo-promote)"
},
{
  "command": "leointeg.demote",
  "category": "Leo",
  "title": "Demote Siblings",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-demote)"
},
{
  "command": "leointeg.demoteSelection",
  "category": "Leo",
  "title": "Demote Siblings",
  "enablement": "leoCanDemote",
  "icon": "$(leo-demote)"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "category": "Leo",
  "title": "Demote Siblings",
  "enablement": "leoCanDemote",
  "icon": "$(leo-demote)"
},
{
  "command": "leointeg.sortChildrenSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened &amp;&amp; leoChild",
  "title": "Sort Children",
  "icon": "$(leo-sort-children)"
},
{
  "command": "leointeg.sortChildrenSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened &amp;&amp; leoChild",
  "title": "Sort Children",
  "icon": "$(leo-sort-children)"
},
{
  "command": "leointeg.sortSiblingsSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Sort Siblings",
  "icon": "$(leo-sort-siblings)"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Sort Siblings",
  "icon": "$(leo-sort-siblings)"
},
</t>
<t tx="ekr.20200815123601.24">{
  "command": "leointeg.gotoFirstVisible",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Goto First Visible"
},
{
  "command": "leointeg.gotoLastVisible",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Goto Last Visible"
},
{
  "command": "leointeg.pageUp",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Page Up"
},
{
  "command": "leointeg.pageDown",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Page Down"
},
{
  "command": "leointeg.scrollTop",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Scroll to Outline Top"
},
{
  "command": "leointeg.scrollBottom",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Scroll to Outline Bottom"
},
{
  "command": "leointeg.gotoFirstSibling",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Goto First Sibling"
},
{
  "command": "leointeg.gotoLastSibling",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Goto Last Sibling"
},
{
  "command": "leointeg.gotoNextVisible",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Goto Next Visible"
},
{
  "command": "leointeg.gotoPrevVisible",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Goto Prev Visible"
},
{
  "command": "leointeg.contractOrGoLeft",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Contract Or Go Left"
},
{
  "command": "leointeg.expandAndGoRight",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Expand And Go Right"
},
{
  "command": "leointeg.gotoNextMarked",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Goto Next Marked"
},
{
  "command": "leointeg.gotoNextClone",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Goto Next Clone"
},
</t>
<t tx="ekr.20200815123601.25">{
  "command": "leointeg.hoistNode",
  "category": "Leo",
  "title": "Hoist",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-hoist)"
},
{
  "command": "leointeg.hoistSelection",
  "category": "Leo",
  "title": "Hoist",
  "enablement": "leoCanHoist",
  "icon": "$(leo-hoist)"
},
{
  "command": "leointeg.hoistSelectionFromOutline",
  "category": "Leo",
  "title": "Hoist",
  "enablement": "leoCanHoist",
  "icon": "$(leo-hoist)"
},
{
  "command": "leointeg.deHoist",
  "category": "Leo",
  "title": "De-Hoist",
  "enablement": "leoCanDehoist",
  "icon": "$(leo-dehoist)"
},
{
  "command": "leointeg.deHoistFromOutline",
  "category": "Leo",
  "title": "De-Hoist",
  "enablement": "leoCanDehoist &amp;&amp; !leoTopHoistChapter",
  "icon": "$(leo-dehoist)"
},
{
  "command": "leointeg.chapterNext",
  "category": "Leo",
  "title": "Chapter Next",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-chapter-next)"
},
{
  "command": "leointeg.chapterBack",
  "category": "Leo",
  "title": "Chapter Back",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-chapter-back)"
},
{
  "command": "leointeg.chapterMain",
  "category": "Leo",
  "title": "Chapter Main",
  "enablement": "leoInChapter &amp;&amp; leoTopHoistChapter",
  "icon": "$(leo-chapter-main)"
},
{
  "command": "leointeg.chapterSelect",
  "category": "Leo",
  "title": "Chapter Select",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-chapter-select)"
},
</t>
<t tx="ekr.20200815123601.26">{
  "command": "leointeg.undo",
  "category": "Leo",
  "title": "Undo",
  "enablement": "leoCanUndo",
  "icon": "$(leo-undo)"
},
{
  "command": "leointeg.undoFromOutline",
  "category": "Leo",
  "title": "Undo",
  "enablement": "leoCanUndo",
  "icon": "$(leo-undo)"
},
{
  "command": "leointeg.redo",
  "category": "Leo",
  "title": "Redo",
  "enablement": "leoCanRedo",
  "icon": "$(leo-redo)"
},
{
  "command": "leointeg.redoFromOutline",
  "category": "Leo",
  "title": "Redo",
  "enablement": "leoCanRedo",
  "icon": "$(leo-redo)"
},
{
  "command": "leointeg.revertToUndo",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Revert to Undo State"
},
</t>
<t tx="ekr.20200815123601.28">"viewsWelcome": [
  @others
],
</t>
<t tx="ekr.20200815123601.29"></t>
<t tx="ekr.20200815123601.3">"leoIntegration.checkForChangeExternalFiles": {
  "scope": "application",
  "default": "none",
  "type": "string",
  "description": "Set default for checking changes to external files",
  "enum": [
    "none",
    "force-check",
    "force-ignore"
  ],
  "enumDescriptions": [
    "Default from Leo's config",
    "Check for changes",
    "Ignore all changes"
  ]
},
"leoIntegration.defaultReloadIgnore": {
  "scope": "application",
  "default": "none",
  "type": "string",
  "description": "Set default for derived files so that they reload, or ignore, when changes are detected",
  "enum": [
    "none",
    "yes-all",
    "no-all"
  ],
  "enumDescriptions": [
    "Choose each time",
    "Reload All",
    "Ignore All"
  ]
},
</t>
<t tx="ekr.20200815123601.30">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Start Server](command:leointeg.startServer)\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; leoStartupFinished &amp;&amp; !leoConnecting &amp;&amp; !leoStartingServer || !leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !config.leoIntegration.startServerAutomatically &amp;&amp; !config.leoIntegration.connectToServerAutomatically &amp;&amp; !leoConnecting &amp;&amp; !leoStartingServer"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Start Server](command:leointeg.startServer)\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; leoStartupFinished &amp;&amp; !leoConnecting &amp;&amp; !leoStartingServer || !leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !config.leoIntegration.startServerAutomatically &amp;&amp; !config.leoIntegration.connectToServerAutomatically &amp;&amp; !leoConnecting &amp;&amp; !leoStartingServer"
},
</t>
<t tx="ekr.20200815123601.31">{
  "view": "leoIntegration",
  "contents": "Opening file...",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; leoStartupFinished &amp;&amp; leoOpeningFile"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Opening file...",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; leoStartupFinished &amp;&amp; leoOpeningFile"
},
{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !config.leoIntegration.connectToServerAutomatically &amp;&amp; !leoConnecting &amp;&amp; !leoStartingServer &amp;&amp; !leoStartupFinished || leoStartupFinished &amp;&amp; !leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !leoConnecting &amp;&amp; !leoStartingServer"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !config.leoIntegration.connectToServerAutomatically &amp;&amp; !leoConnecting &amp;&amp; !leoStartingServer &amp;&amp; !leoStartupFinished || leoStartupFinished &amp;&amp; !leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !leoConnecting &amp;&amp; !leoStartingServer"
},
</t>
<t tx="ekr.20200815123601.33">{
  "view": "leoIntegration",
  "contents": "Connecting...",
  "when": "leoConnecting || !leoBridgeReady &amp;&amp; !config.leoIntegration.startServerAutomatically &amp;&amp; config.leoIntegration.connectToServerAutomatically &amp;&amp; !leoStartingServer &amp;&amp; !leoConnecting &amp;&amp; !leoStartupFinished"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Connecting...",
  "when": "leoConnecting || !leoBridgeReady &amp;&amp; !config.leoIntegration.startServerAutomatically &amp;&amp; config.leoIntegration.connectToServerAutomatically &amp;&amp; !leoStartingServer &amp;&amp; !leoConnecting &amp;&amp; !leoStartupFinished"
},
</t>
<t tx="ekr.20200815123601.34">{
  "view": "leoIntegration",
  "contents": "Connected\n[Open Leo File](command:leointeg.openLeoFile)\n[Create Leo File](command:leointeg.newLeoFile)\n[Recent Leo Files](command:leointeg.recentLeoFiles)\nView LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; !leoStartingServer &amp;&amp; !leoConnecting &amp;&amp; leoStartupFinished &amp;&amp; !leoOpeningFile"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Connected\n[Open Leo File](command:leointeg.openLeoFile)\n[Create Leo File](command:leointeg.newLeoFile)\n[Recent Leo Files](command:leointeg.recentLeoFiles)\nView LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; !leoStartingServer &amp;&amp; !leoConnecting &amp;&amp; leoStartupFinished &amp;&amp; !leoOpeningFile"
},
</t>
<t tx="ekr.20200815123601.35"></t>
<t tx="ekr.20200815123601.36">{
  "view": "leoDocuments",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
{
  "view": "leoDocumentsExplorer",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
</t>
<t tx="ekr.20200815123601.37">{
  "view": "leoDocuments",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoDocumentsExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.38"></t>
<t tx="ekr.20200815123601.39">{
  "view": "leoButtons",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
{
  "view": "leoButtonsExplorer",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
</t>
<t tx="ekr.20200815123601.4">"leoIntegration.leoTreeBrowse": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Specifies whether to use Leo's style of tree browsing with the arrow keys"
},
"leoIntegration.treeKeepFocus": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Specifies whether to keep focus in the outline when selecting a node - overridden by \"leoTreeBrowse\""
},
"leoIntegration.treeKeepFocusWhenAside": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Specifies whether to keep focus in the outline when opening a body pane on the side"
},
"leoIntegration.goAnywhereShortcut": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Enables Leo's 'Go Anywhere' to replace 'Go to file' with the Ctrl+P keyboard shortcut when focus in in outline or body"
},
"leoIntegration.collapseAllShortcut": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Enables the Alt+'-' keyboard shortcut for collapsing all folders in the Explorer View"
},
"leoIntegration.activityViewShortcut": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Enables the Ctrl+Shift+L keyboard shortcut for showing the LeoIntegration view"
},
</t>
<t tx="ekr.20200815123601.40">{
  "view": "leoButtons",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoButtonsExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.41">{
  "view": "leoButtons",
  "contents": "There are no @buttons in this outline",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "view": "leoButtonsExplorer",
  "contents": "There are no @buttons in this outline",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.42">"menus": {
  @others
},
</t>
<t tx="ekr.20200815123601.43">"commandPalette": [
  @others
],
</t>
<t tx="ekr.20200815123601.5"></t>
<t tx="ekr.20200815123601.58">{
  "command": "leointeg.clickButton",
  "when": "false"
},
{
  "command": "leointeg.gotoScript",
  "when": "false"
},
{
  "command": "leointeg.removeButton",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.6">"leoIntegration.treeInExplorer": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Show the outline tree in the explorer view"
},
"leoIntegration.showOpenAside": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Offer 'Open to the Side' in nodes context menu"
},
"leoIntegration.showEditOnNodes": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Edit Headline' button on tree nodes"
},
"leoIntegration.showAddOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Insert' button on tree nodes"
},
"leoIntegration.showMarkOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Mark/Unmark' buttons on tree nodes"
},
"leoIntegration.showCloneOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Clone' button on tree nodes"
},
"leoIntegration.showCopyOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Copy' button on tree nodes"
},
"leoIntegration.showBranchInOutlineTitle": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows the current git branch in outline pane's title"
},
"leoIntegration.invertNodeContrast": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Inverts the contrast of the dirty/clean border aspect of tree nodes"
},
"leoIntegration.showUnlOnStatusBar": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Displays an UNL indicator on the status bar"
},
</t>
<t tx="ekr.20200815123601.60">{
  "command": "leointeg.saveLeoFileFromOutline",
  "when": "false"
},
{
  "command": "leointeg.refreshFromDisk",
  "when": "false"
},
{
  "command": "leointeg.writeAtFileNodesFromOutline",
  "when": "false"
},
{
  "command": "leointeg.writeDirtyAtFileNodesFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.61">{
  "command": "leointeg.openAside",
  "when": "false"
},
{
  "command": "leointeg.contractAllFromOutline",
  "when": "false"
},
{
  "command": "leointeg.prevFromOutline",
  "when": "false"
},
{
  "command": "leointeg.nextFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.62">{
  "command": "leointeg.editHeadline",
  "when": "false"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "when": "false"
},
{
  "command": "leointeg.mark",
  "when": "false"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.unmark",
  "when": "false"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.copyNode",
  "when": "false"
},
{
  "command": "leointeg.cutNode",
  "when": "false"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.pasteNode",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAsClone",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.delete",
  "when": "false"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.63">{
  "command": "leointeg.moveOutlineDown",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineLeft",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineRight",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineUp",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.64">{
  "command": "leointeg.insertNode",
  "when": "false"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.insertChildNode",
  "when": "false"
},
{
  "command": "leointeg.insertChildNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.cloneNode",
  "when": "false"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.promote",
  "when": "false"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.demote",
  "when": "false"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.sortChildrenSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.65">{
  "command": "leointeg.gotoNextClone",
  "when": "false"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.gotoFirstVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoLastVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoFirstSibling",
  "when": "false"
},
{
  "command": "leointeg.gotoLastSibling",
  "when": "false"
},
{
  "command": "leointeg.gotoNextVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoPrevVisible",
  "when": "false"
},
{
  "command": "leointeg.contractOrGoLeft",
  "when": "false"
},
{
  "command": "leointeg.expandAndGoRight",
  "when": "false"
},
{
  "command": "leointeg.scrollTop",
  "when": "false"
},
{
  "command": "leointeg.scrollBottom",
  "when": "false"
},
{
  "command": "leointeg.pageUp",
  "when": "false"
},
{
  "command": "leointeg.pageDown",
  "when": "false"
},
{
  "command": "leointeg.gotoNavPrev",
  "when": "false"
},
{
  "command": "leointeg.gotoNavNext",
  "when": "false"
},
{
  "command": "leointeg.gotoNavFirst",
  "when": "false"
},
{
  "command": "leointeg.gotoNavLast",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.66">{
  "command": "leointeg.hoistNode",
  "when": "false"
},
{
  "command": "leointeg.hoistSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.deHoistFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.67">{
  "command": "leointeg.undoFromOutline",
  "when": "false"
},
{
  "command": "leointeg.redoFromOutline",
  "when": "false"
},
{
  "command": "leointeg.revertToUndo",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.68">"explorer/context": [
  {
    "command": "leointeg.openLeoFile",
    "when": "leoBridgeReady &amp;&amp; resourceScheme == file &amp;&amp; resourceExtname == .leo || leoBridgeReady &amp;&amp; resourceScheme == file &amp;&amp; resourceExtname == .leojs",
    "group": "navigation@1"
  }
],
</t>
<t tx="ekr.20200815123601.7">"leoIntegration.leoEditorPath": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Specifies the location of your Leo-Editor installation"
},
"leoIntegration.leoPythonCommand": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Specifies the command to start python (Defaults to 'py' on windows and 'python3' otherwise)"
},
"leoIntegration.startServerAutomatically": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Starts a Leo server automatically, by running the Leo server script"
},
"leoIntegration.connectToServerAutomatically": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Connect automatically to a Leo server on specified 'Connection Port' upon activation of this extension"
},
"leoIntegration.connectionAddress": {
  "default": "localhost",
  "scope": "application",
  "type": "string",
  "description": "Connection host"
},
"leoIntegration.connectionPort": {
  "default": 32125,
  "scope": "application",
  "minimum": 0,
  "maximum": 65535,
  "type": "number",
  "description": "Connection port"
},
"leoIntegration.setDetached": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Starts the server process with the 'detached' flag - Allows a dialog to be shown after closing for unsaved Leo documents"
},
"leoIntegration.limitUsers": {
  "default": 1,
  "scope": "application",
  "minimum": 1,
  "maximum": 255,
  "type": "number",
  "description": "Limit of concurrent connections - Allows for multi-user synchronous editing"
}
</t>
<t tx="ekr.20200815123601.76">"keybindings": [
  @others
],
</t>
<t tx="ekr.20200815123601.77">{
  "command": "leointeg.executeScript",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.minibuffer",
  "key": "alt+x",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
</t>
<t tx="ekr.20200815123601.78">{
  "command": "leointeg.showOutline",
  "key": "alt+t",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme =~ /^leointeg/ || leoFindFocus || focusedView =~ /^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
{
  "command": "leointeg.showOutline",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme =~ /^leointeg/"
},
{
  "command": "leointeg.showBody",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "alt+d",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointegDetached || leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "ctrl+g",
  "mac": "cmd+g",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointegDetached || leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "tab",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.showBody",
  "key": "enter",
  "when": "config.leoIntegration.leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.tabCycleNext",
  "key": "ctrl+tab",
  "mac": "cmd+tab",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme =~ /^leointeg/"
},
</t>
<t tx="ekr.20200815123601.79">{
  "command": "leointeg.saveLeoFileFromOutline",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
{
  "command": "leointeg.saveLeoFile",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme =~ /^leointeg/"
},
{
  "command": "leointeg.newLeoFile",
  "key": "ctrl+n",
  "mac": "cmd+n",
  "when": "leoEditHeadline || editorTextFocus &amp;&amp; resourceScheme =~ /^leointeg/ || leoFindFocus || sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
{
  "command": "leointeg.openLeoFile",
  "key": "ctrl+o",
  "mac": "cmd+o",
  "when": "leoEditHeadline || editorTextFocus &amp;&amp; resourceScheme =~ /^leointeg/ || leoFindFocus || sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
{
  "command": "leointeg.writeAtFileNodes",
  "key": "ctrl+shift+w",
  "mac": "cmd+shift+w",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme =~ /^leointeg/"
},
{
  "command": "leointeg.writeAtFileNodesFromOutline",
  "key": "ctrl+shift+w",
  "mac": "cmd+shift+w",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
{
  "command": "leointeg.writeDirtyAtFileNodes",
  "key": "ctrl+shift+q",
  "mac": "cmd+shift+q",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme =~ /^leointeg/"
},
{
  "command": "leointeg.writeDirtyAtFileNodesFromOutline",
  "key": "ctrl+shift+q",
  "mac": "cmd+shift+q",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
</t>
<t tx="ekr.20200815123601.8">"viewsContainers": {
  "activitybar": [
    {
      "id": "leoIntegrationView",
      "title": "Leo",
      "icon": "$(leo-icon-leo-outline)"
    }
  ]
},
</t>
<t tx="ekr.20200815123601.80">{
  "command": "leointeg.contractAll",
  "key": "alt+-",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme =~ /^leointeg/"
},
{
  "command": "leointeg.contractAllFromOutline",
  "key": "alt+-",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
</t>
<t tx="ekr.20200815123601.81">{
  "command": "leointeg.editSelectedHeadline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.markSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.unmarkSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.82"></t>
<t tx="ekr.20200815123601.83">{
  "command": "leointeg.moveOutlineDownSelection",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.moveOutlineDownSelection",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "shift+down",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.84">{
  "command": "leointeg.moveOutlineLeftSelection",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "shift+left",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.85">{
  "command": "leointeg.moveOutlineRightSelection",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "shift+right",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.86">{
  "command": "leointeg.moveOutlineUpSelection",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "shift+up",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.87">{
  "command": "leointeg.sortSiblingsSelection",
  "key": "alt+a",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "key": "alt+a",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.promoteSelection",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.demoteSelection",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelection",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelection",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "key": "insert",
  "mac": "insert",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.insertChildNodeSelection",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.insertChildNodeSelectionFromOutline",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.cloneNodeSelection",
  "key": "ctrl+`",
  "win": "ctrl+oem_3",
  "linux": "ctrl+`",
  "mac": "cmd+`",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "key": "ctrl+`",
  "win": "ctrl+oem_3",
  "linux": "ctrl+`",
  "mac": "cmd+`",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.cutNodeSelection",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoDocuments/"
},
{
  "command": "leointeg.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoDocuments/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoDocuments/"
},
{
  "command": "leointeg.deleteSelection",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "key": "delete",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.88">{
  "command": "leointeg.scrollTop",
  "key": "alt+home",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoDocuments/ || leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.scrollBottom",
  "key": "alt+end",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoDocuments/ || leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.scrollTop",
  "key": "home",
  "when": "config.leoIntegration.leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.gotoNavFirst",
  "key": "home",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoGoto/"
},
{
  "command": "leointeg.scrollBottom",
  "key": "end",
  "when": "config.leoIntegration.leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.gotoNavLast",
  "key": "end",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoGoto/"
},
{
  "command": "leointeg.pageUp",
  "key": "pageup",
  "when": "config.leoIntegration.leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.gotoNavFirst",
  "key": "pageup",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoGoto/"
},
{
  "command": "leointeg.pageDown",
  "key": "pagedown",
  "when": "config.leoIntegration.leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.gotoNavLast",
  "key": "pagedown",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoGoto/"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "key": "alt+n",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "key": "alt+n",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "down",
  "when": "config.leoIntegration.leoTreeBrowse &amp;&amp; leoEditHeadline || config.leoIntegration.leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.gotoNavNext",
  "key": "down",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoGoto/"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "alt+down",
  "when": "leoTreeOpened &amp;&amp; leoEditHeadline || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoDocuments/ || leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "up",
  "when": "config.leoIntegration.leoTreeBrowse &amp;&amp; leoEditHeadline || config.leoIntegration.leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.gotoNavPrev",
  "key": "up",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoGoto/"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "alt+up",
  "when": "leoTreeOpened &amp;&amp; leoEditHeadline || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoDocuments/ || leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "left",
  "when": "config.leoIntegration.leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "alt+left",
  "when": "leoTreeOpened &amp;&amp; leoEditHeadline || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoDocuments/ || leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "right",
  "when": "config.leoIntegration.leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "alt+right",
  "when": "leoTreeOpened &amp;&amp; leoEditHeadline || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoDocuments/ || leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
</t>
<t tx="ekr.20200815123601.89">"resourceLabelFormatters": [
  {
    "scheme": "leointeg",
    "formatting": {
      "label": "Leo: Body",
      "separator": "/",
      "workspaceSuffix": "",
      "workspaceTooltip": "Leo Body Pane"
    }
  },
  {
    "scheme": "leointegDetached",
    "formatting": {
      "label": "Leo: Detached",
      "separator": "/",
      "workspaceSuffix": "",
      "workspaceTooltip": "Leo Detached Body Pane"
    }
  }
]
</t>
<t tx="ekr.20200815123601.9">"views": {
  "explorer": [
    {
      "id": "leoIntegrationExplorer",
      "name": "Leo Integration",
      "contextualTitle": "Leo",
      "when": "config.leoIntegration.treeInExplorer &amp;&amp; !config.leojs.treeInExplorer",
      "visibility": "visible"
    },
    {
      "type": "webview",
      "id": "leoFindPanelExplorer",
      "contextualTitle": "Leo",
      "name": "Leo Find",
      "title": "Leo Find",
      "when": "config.leoIntegration.treeInExplorer &amp;&amp; leoTreeOpened &amp;&amp; !config.leojs.treeInExplorer",
      "visibility": "collapsed"
    },
    {
      "id": "leoGotoPanelExplorer",
      "name": "Leo Goto",
      "contextualTitle": "Leo",
      "when": "config.leoIntegration.treeInExplorer &amp;&amp; leoTreeOpened &amp;&amp; !config.leojs.treeInExplorer",
      "visibility": "collapsed"
    },
    {
      "id": "leoDocumentsExplorer",
      "name": "Leo Documents",
      "contextualTitle": "Leo",
      "when": "config.leoIntegration.treeInExplorer &amp;&amp; leoTreeOpened &amp;&amp; !config.leojs.treeInExplorer",
      "visibility": "collapsed"
    },
    {
      "id": "leoUndosExplorer",
      "name": "Leo Undo History",
      "contextualTitle": "Leo",
      "when": "config.leoIntegration.treeInExplorer &amp;&amp; leoTreeOpened &amp;&amp; !config.leojs.treeInExplorer",
      "visibility": "collapsed"
    },
    {
      "id": "leoButtonsExplorer",
      "name": "Leo Buttons",
      "contextualTitle": "Leo",
      "when": "config.leoIntegration.treeInExplorer &amp;&amp; leoTreeOpened &amp;&amp; !config.leojs.treeInExplorer",
      "visibility": "collapsed"
    }
  ],
  "leoIntegrationView": [
    {
      "id": "leoIntegration",
      "contextualTitle": "Leo",
      "name": "Integration",
      "visibility": "visible"
    },
    {
      "type": "webview",
      "contextualTitle": "Leo",
      "id": "leoFindPanel",
      "name": "Find",
      "title": "Find",
      "when": "leoTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leoGotoPanel",
      "contextualTitle": "Leo",
      "name": "Goto",
      "when": "leoTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leoDocuments",
      "contextualTitle": "Leo",
      "name": "Documents",
      "when": "leoTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leoUndos",
      "contextualTitle": "Leo",
      "name": "Undo History",
      "when": "leoTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leoButtons",
      "contextualTitle": "Leo",
      "name": "Buttons",
      "when": "leoTreeOpened",
      "visibility": "collapsed"
    }
  ]
},
</t>
<t tx="felix.20200718020912.1">import * as vscode from "vscode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718020912.10">/**
 * * Actions that can be invoked by Leo through leobridge
 */
public static ASYNC_ACTIONS = {
    ASYNC_LOG: "log",
    ASYNC_REFRESH: "refresh",
    ASYNC_ASK: "ask",
    ASYNC_WARN: "warn",
    ASYNC_INFO: "info",
    ASYNC_INTERVAL: "interval"
};

</t>
<t tx="felix.20200718020912.11">/**
 * * When async action was ASYNC_INFO
 */
public static ASYNC_INFO_MESSAGE_CODES = {
    ASYNC_REFRESHED: "refreshed",
    ASYNC_IGNORED: "ignored"
};

</t>
<t tx="felix.20200718020912.12">/**
 * * runAskYesNoDialog or runAskOkDialog result codes, used when async action requires a response
 */
public static ASYNC_ASK_RETURN_CODES = {
    YES: "yes",
    NO: "no",
    YES_ALL: "yes-all",
    NO_ALL: "no-all",
    OK: "ok"
};

</t>
<t tx="felix.20200718020912.13">/**
 * * Commands for leoserver.py
 * A Command is a string, which is either:
 *  - The name of public method in leoserver.py, prefixed with '!'.
 *  - The name of a Leo command, prefixed with '-'
 *  - The name of a method of a Leo class, without prefix.
 */
public static LEOBRIDGE = {
    TEST: "!test",
    DO_NOTHING: "!do_nothing",
    GET_VERSION: "!get_version",
    GET_LEOID: "!get_leoid",
    SET_LEOID: "!set_leoid",
    GET_UNL: "!get_unl",
    HANDLE_UNL: "!handle_unl",
    // * Server Commands
    GET_COMMANDS: "!get_all_leo_commands", // "getCommands",
    APPLY_CONFIG: "!set_config", // "applyConfig",
    ASK_RESULT: "!set_ask_result", // "askResult",
    // * GUI
    GET_IS_VALID: "!get_is_valid",
    GET_ALL_GNX: "!get_all_gnx", // "getAllGnx",
    GET_BODY_LENGTH: "!get_body_length", // "getBodyLength",
    GET_BODY_STATES: "!get_body_states", // "getBodyStates",
    GET_BODY: "!get_body", // "getBody",
    GET_PARENT: "!get_parent", // "getParent",
    GET_CHILDREN: "!get_children", // "getChildren",
    SET_SELECTED_NODE: "!set_current_position", // "setSelectedNode",
    SET_BODY: "!set_body", // "setBody",
    SET_SELECTION: "!set_selection", // "setSelection",
    SET_HEADLINE: "!set_headline", // "setNewHeadline",
    EXPAND_NODE: "!expand_node", // "expandNode",
    COLLAPSE_NODE: "!contract_node", // "collapseNode",
    CONTRACT_ALL: "contractAllHeadlines",
    GET_STATES: "!get_ui_states", // "getStates",
    GET_UNDOS: "!get_undos",
    GET_UA: "!get_ua",
    SET_UA_MEMBER: "!set_ua_member",
    SET_UA: "!set_ua",
    // * Leo Documents
    GET_OPENED_FILES: "!get_all_open_commanders", //"getOpenedFiles",
    SET_OPENED_FILE: "!set_opened_file", // "setOpenedFile",
    GET_BRANCH: "!get_branch",
    OPEN_FILE: "!open_file", // "openFile",
    OPEN_FILES: "!open_files", //  "openFiles",
    CLOSE_FILE: "!close_file", // "closeFile",
    REVERT: "-revert",
    SAVE_FILE: "!save_file", // "saveFile",
    // * @-Buttons
    GET_BUTTONS: "!get_buttons", // "getButtons",
    REMOVE_BUTTON: "!remove_button", // "removeButton",
    GOTO_SCRIPT: "!goto_script", // "goto Script command",
    CLICK_BUTTON: "!click_button", // "clickButton",
    // * Goto operations
    PAGE_UP: "!page_up", // "pageUp",
    PAGE_DOWN: "!page_down", // "pageDown",
    SCROLL_TOP: "!scroll_top", // Utility function
    SCROLL_BOTTOM: "!scroll_bottom", // Utility function
    GOTO_FIRST_VISIBLE: "goToFirstVisibleNode",
    GOTO_LAST_VISIBLE: "goToLastVisibleNode",
    GOTO_FIRST_SIBLING: "goToFirstSibling",
    GOTO_LAST_SIBLING: "goToLastSibling",
    GOTO_NEXT_VISIBLE: "selectVisNext",
    GOTO_PREV_VISIBLE: "selectVisBack",
    GOTO_NEXT_MARKED: "goToNextMarkedHeadline",
    GOTO_NEXT_CLONE: "goToNextClone",
    CONTRACT_OR_GO_LEFT: "contractNodeOrGoToParent",
    EXPAND_AND_GO_RIGHT: "expandNodeAndGoToFirstChild",

    // * Import Export Operations
    IMPORT_ANY_FILE: "!import_any_file", // "importAnyFile",
    READ_FILE_INTO_NODE: "!read_file_into_node",
    EXPORT_HEADLINES: "!export_headlines",
    FLATTEN_OUTLINE: "!flatten_outline",
    OUTLINE_TO_CWEB: "!outline_to_cweb",
    OUTLINE_TO_NOWEB: "!outline_to_noweb",
    REMOVE_SENTINELS: "!remove_sentinels",
    WEAVE: "!weave",
    WRITE_FILE_FROM_NODE: "!write_file_from_node",

    // * Leo Operations, setters and getters
    MARK_PNODE: "!mark_node", // "markPNode",
    UNMARK_PNODE: "!unmark_node", // "unmarkPNode",
    COPY_PNODE: "!copy_node",
    COPY_PNODE_AS_JSON: "!copy_node_as_json",
    CUT_PNODE: "!cut_node", // "cutPNode",
    PASTE_PNODE: "!paste_node",
    PASTE_CLONE_PNODE: "!paste_as_clone_node",
    PASTE_AS_TEMPLATE: "!paste_as_template",
    DELETE_PNODE: "!delete_node", // "deletePNode",
    MOVE_PNODE_DOWN: "moveOutlineDown",
    MOVE_PNODE_LEFT: "moveOutlineLeft",
    MOVE_PNODE_RIGHT: "moveOutlineRight",
    MOVE_PNODE_UP: "moveOutlineUp",
    INSERT_PNODE: "!insert_node", // "insertPNode",
    INSERT_NAMED_PNODE: "!insert_named_node", // "insertNamedPNode",
    INSERT_CHILD_PNODE: "!insert_child_node",
    INSERT_CHILD_NAMED_PNODE: "!insert_child_named_node",
    CLONE_PNODE: "!clone_node", // "clonePNode",
    PROMOTE_PNODE: "promote",
    DEMOTE_PNODE: "demote",
    REFRESH_FROM_DISK_PNODE: "refreshFromDisk",
    WRITE_AT_FILE_NODES: '-write-at-file-nodes',
    WRITE_DIRTY_AT_FILE_NODES: '-write-dirty-at-file-nodes',
    SORT_CHILDREN: "sortChildren",
    SORT_SIBLINGS: "sortSiblings",
    UNDO: "!undo",
    REDO: "!redo",
    EXECUTE_SCRIPT: "executeScript",
    HOIST_PNODE: "hoist",
    DEHOIST: "dehoist",
    CHAPTER_NEXT: "-chapter-next",
    CHAPTER_BACK: "-chapter-back",
    CHAPTER_MAIN: "!chapter_main",
    CHAPTER_SELECT: "!chapter_select",
    GET_CHAPTERS: "!get_chapters",
    EXTRACT: "extract",
    EXTRACT_NAMES: "extractSectionNames",
    COPY_MARKED: "copyMarked",
    DIFF_MARKED_NODES: "-diff-marked-nodes",
    MARK_CHANGED_ITEMS: "markChangedHeadlines",
    MARK_SUBHEADS: "markSubheads",
    UNMARK_ALL: "unmarkAll",
    CLONE_MARKED_NODES: "cloneMarked",
    DELETE_MARKED_NODES: "deleteMarked",
    MOVE_MARKED_NODES: "moveMarked",
    GIT_DIFF: "gitDiff",
    GET_FOCUS: "!get_focus",

    GET_GOTO_PANEL: "!get_goto_panel", // To fill up panel when changing leo documents

    NAV_HEADLINE_SEARCH: "!nav_headline_search",
    NAV_SEARCH: "!nav_search",
    NAV_CLEAR: "!nav_clear",

    FIND_QUICK_TIMELINE: "!find_quick_timeline",
    FIND_QUICK_CHANGED: "!find_quick_changed",
    FIND_QUICK_HISTORY: "!find_quick_history",
    FIND_QUICK_MARKED: "!find_quick_marked",
    GOTO_NAV_ENTRY: "!goto_nav_entry",

    GET_ALL_POSITIONS: "!get_all_positions",
    GET_POSITION_DATA: "!get_position_data",
    GET_SEARCH_SETTINGS: "!get_search_settings",
    SET_SEARCH_SETTINGS: "!set_search_settings",
    INTERACTIVE_SEARCH: "!interactive_search",

    FIND_ALL: "!find_all",
    FIND_NEXT: "!find_next",
    FIND_PREVIOUS: "!find_previous",
    FIND_VAR: "!find_var",
    FIND_DEF: "!find_def",
    REPLACE: "!replace",
    REPLACE_THEN_FIND: "!replace_then_find",
    REPLACE_ALL: "!replace_all",
    GOTO_GLOBAL_LINE: "!goto_global_line",

    TAG_CHILDREN: "!tag_children",
    TAG_NODE: "!tag_node",
    REMOVE_TAG: "!remove_tag",
    REMOVE_TAGS: "!remove_tags",

    CLONE_FIND_TAG: "!clone_find_tag",

    CLONE_FIND_ALL: "!clone_find_all",
    CLONE_FIND_ALL_FLATTENED: "!clone_find_all_flattened",
    CLONE_FIND_MARKED: "!clone_find_all_marked",
    CLONE_FIND_FLATTENED_MARKED: "!clone_find_all_flattened_marked",
    CLONE_FIND_PARENTS: "-clone-find-parents",

    GOTO_PREV_HISTORY: "goToPrevHistory",
    GOTO_NEXT_HISTORY: "goToNextHistory"
};

</t>
<t tx="felix.20200718020912.15">/**
 * * All commands this expansion exposes (in package.json, contributes &gt; commands)
 * * And those not exposed in package.json, like 'gotoNav' which can only be invoked from mouse action
 */
public static COMMANDS = {
    // * Access to the Settings/Welcome Webview
    SHOW_WELCOME: Constants.NAME + ".showWelcomePage", // Always available: not in the commandPalette section of package.json
    SHOW_SETTINGS: Constants.NAME + ".showSettingsPage", // Always available: not in the commandPalette section of package.json
    STATUS_BAR: Constants.NAME + ".statusBar", // Status Bar Click Command
    // * LeoBridge
    CHOOSE_LEO_FOLDER: Constants.NAME + ".chooseLeoFolder",
    START_SERVER: Constants.NAME + ".startServer",
    STOP_SERVER: Constants.NAME + ".stopServer",
    CONNECT: Constants.NAME + ".connectToServer",
    SET_LEOID: Constants.NAME + ".setLeoID",
    HANDLE_UNL: Constants.NAME + ".handleUnl",
    SHORT_GNX_UNL_TO_CLIPBOARD: Constants.NAME + ".shortGnxUnlToClipboard",
    FULL_GNX_UNL_TO_CLIPBOARD: Constants.NAME + ".fullGnxUnlToClipboard",
    SHORT_LEGACY_UNL_TO_CLIPBOARD: Constants.NAME + "shortLegacyUnlToClipboard",
    FULL_LEGACY_UNL_TO_CLIPBOARD: Constants.NAME + "fullLegacyUnlToClipboard",
    SET_OPENED_FILE: Constants.NAME + ".setOpenedFile",
    OPEN_FILE: Constants.NAME + ".openLeoFile", // sets focus on BODY
    CLEAR_RECENT_FILES: Constants.NAME + ".clearRecentFiles",
    RECENT_FILES: Constants.NAME + ".recentLeoFiles", // shows recent Leo files, opens one on selection
    SWITCH_FILE: Constants.NAME + ".switchLeoFile",
    NEW_FILE: Constants.NAME + ".newLeoFile",
    SAVE_FILE: Constants.NAME + ".saveLeoFile",
    SAVE_FILE_FO: Constants.NAME + ".saveLeoFileFromOutline",
    SAVE_AS_FILE: Constants.NAME + ".saveAsLeoFile",
    SAVE_AS_LEOJS: Constants.NAME + ".saveAsLeoJsFile",
    CLOSE_FILE: Constants.NAME + ".closeLeoFile",
    REVERT_TO_SAVED: Constants.NAME + ".revert",
    CLICK_BUTTON: Constants.NAME + ".clickButton",
    REMOVE_BUTTON: Constants.NAME + ".removeButton",
    GOTO_SCRIPT: Constants.NAME + ".gotoScript",
    MINIBUFFER: Constants.NAME + ".minibuffer",
    GIT_DIFF: Constants.NAME + ".gitDiff",
    TAB_CYCLE_NEXT: Constants.NAME + ".tabCycleNext",
    // * Outline selection
    SELECT_NODE: Constants.NAME + ".selectTreeNode",
    OPEN_ASIDE: Constants.NAME + ".openAside", // Opens aside a body pane locked to this gnx &amp; commander.
    // * Goto operations that always finish with focus in outline
    PAGE_UP: Constants.NAME + ".pageUp",
    PAGE_DOWN: Constants.NAME + ".pageDown",
    SCROLL_TOP: Constants.NAME + ".scrollTop",
    SCROLL_BOTTOM: Constants.NAME + ".scrollBottom",
    GOTO_FIRST_VISIBLE: Constants.NAME + ".gotoFirstVisible",
    GOTO_LAST_VISIBLE: Constants.NAME + ".gotoLastVisible",
    GOTO_FIRST_SIBLING: Constants.NAME + ".gotoFirstSibling",
    GOTO_LAST_SIBLING: Constants.NAME + ".gotoLastSibling",
    GOTO_NEXT_VISIBLE: Constants.NAME + ".gotoNextVisible",
    GOTO_PREV_VISIBLE: Constants.NAME + ".gotoPrevVisible",
    GOTO_NEXT_MARKED: Constants.NAME + ".gotoNextMarked",
    GOTO_NEXT_CLONE: Constants.NAME + ".gotoNextClone",
    GOTO_NEXT_CLONE_SELECTION: Constants.NAME + ".gotoNextCloneSelection",
    GOTO_NEXT_CLONE_SELECTION_FO: Constants.NAME + ".gotoNextCloneSelectionFromOutline",
    CONTRACT_OR_GO_LEFT: Constants.NAME + ".contractOrGoLeft",
    EXPAND_AND_GO_RIGHT: Constants.NAME + ".expandAndGoRight",
    // * Import Export Commands
    IMPORT_ANY_FILE: Constants.NAME + ".importAnyFile",
    READ_FILE_INTO_NODE: Constants.NAME + ".readFileIntoNode",
    EXPORT_HEADLINES: Constants.NAME + ".exportHeadlines",
    FLATTEN_OUTLINE: Constants.NAME + ".flattenOutline",
    OUTLINE_TO_CWEB: Constants.NAME + ".outlineToCweb",
    OUTLINE_TO_NOWEB: Constants.NAME + ".outlineToNoweb",
    REMOVE_SENTINELS: Constants.NAME + ".removeSentinels",
    WEAVE: Constants.NAME + ".weave",
    WRITE_FILE_FROM_NODE: Constants.NAME + ".writeFileFromNode",
    // * Leo Operations
    UNDO: Constants.NAME + ".undo", // From command Palette
    UNDO_FO: Constants.NAME + ".undoFromOutline", // from button, return focus on OUTLINE
    REDO: Constants.NAME + ".redo", // From command Palette
    REDO_FO: Constants.NAME + ".redoFromOutline", // from button, return focus on OUTLINE
    REVERT_TO_UNDO: Constants.NAME + ".revertToUndo",
    EXECUTE: Constants.NAME + ".executeScript",
    SHOW_BODY: Constants.NAME + ".showBody",
    SHOW_OUTLINE: Constants.NAME + ".showOutline",
    SHOW_LOG: Constants.NAME + ".showLogPane",
    SORT_CHILDREN: Constants.NAME + ".sortChildrenSelection",
    SORT_CHILDREN_FO: Constants.NAME + ".sortChildrenSelectionFromOutline",
    SORT_SIBLING: Constants.NAME + ".sortSiblingsSelection",
    SORT_SIBLING_FO: Constants.NAME + ".sortSiblingsSelectionFromOutline",
    CONTRACT_ALL: Constants.NAME + ".contractAll", // From command Palette
    CONTRACT_ALL_FO: Constants.NAME + ".contractAllFromOutline", // from button, return focus on OUTLINE
    PREV_NODE: Constants.NAME + ".prev",
    PREV_NODE_FO: Constants.NAME + ".prevFromOutline",
    NEXT_NODE: Constants.NAME + ".next",
    NEXT_NODE_FO: Constants.NAME + ".nextFromOutline",
    // * Commands from tree panel buttons or context: focus on OUTLINE
    MARK: Constants.NAME + ".mark",
    UNMARK: Constants.NAME + ".unmark",
    COPY: Constants.NAME + ".copyNode",
    COPY_AS_JSON: Constants.NAME + ".copyNodeAsJson",
    COPY_GNX: Constants.NAME + ".copyGnx", // Not exposed in commands, only for minibuffer override
    CUT: Constants.NAME + ".cutNode",
    PASTE: Constants.NAME + ".pasteNode",
    PASTE_CLONE: Constants.NAME + ".pasteNodeAsClone",
    PASTE_AS_TEMPLATE: Constants.NAME + ".pasteAsTemplate",
    DELETE: Constants.NAME + ".delete",
    HEADLINE: Constants.NAME + ".editHeadline",
    MOVE_DOWN: Constants.NAME + ".moveOutlineDown",
    MOVE_LEFT: Constants.NAME + ".moveOutlineLeft",
    MOVE_RIGHT: Constants.NAME + ".moveOutlineRight",
    MOVE_UP: Constants.NAME + ".moveOutlineUp",
    INSERT: Constants.NAME + ".insertNode",
    INSERT_CHILD: Constants.NAME + ".insertChildNode",
    CLONE: Constants.NAME + ".cloneNode",
    PROMOTE: Constants.NAME + ".promote",
    DEMOTE: Constants.NAME + ".demote",
    REFRESH_FROM_DISK: Constants.NAME + ".refreshFromDisk",
    WRITE_AT_FILE_NODES: Constants.NAME + ".writeAtFileNodes",
    WRITE_AT_FILE_NODES_FO: Constants.NAME + ".writeAtFileNodesFromOutline",
    WRITE_DIRTY_AT_FILE_NODES: Constants.NAME + ".writeDirtyAtFileNodes",
    WRITE_DIRTY_AT_FILE_NODES_FO: Constants.NAME + ".writeDirtyAtFileNodesFromOutline",
    // * Commands from keyboard, while focus on BODY (command-palette returns to BODY for now)
    SET_UA: Constants.NAME + ".setUa",
    MARK_SELECTION: Constants.NAME + ".markSelection",
    UNMARK_SELECTION: Constants.NAME + ".unmarkSelection",
    COPY_SELECTION: Constants.NAME + ".copyNodeSelection", // Nothing to refresh/focus so no "FO" version
    CUT_SELECTION: Constants.NAME + ".cutNodeSelection",
    PASTE_SELECTION: Constants.NAME + ".pasteNodeAtSelection",
    PASTE_CLONE_SELECTION: Constants.NAME + ".pasteNodeAsCloneAtSelection",
    DELETE_SELECTION: Constants.NAME + ".deleteSelection",
    HEADLINE_SELECTION: Constants.NAME + ".editSelectedHeadline",
    MOVE_DOWN_SELECTION: Constants.NAME + ".moveOutlineDownSelection",
    MOVE_LEFT_SELECTION: Constants.NAME + ".moveOutlineLeftSelection",
    MOVE_RIGHT_SELECTION: Constants.NAME + ".moveOutlineRightSelection",
    MOVE_UP_SELECTION: Constants.NAME + ".moveOutlineUpSelection",
    INSERT_SELECTION: Constants.NAME + ".insertNodeSelection", // Can be interrupted
    INSERT_SELECTION_INTERRUPT: Constants.NAME + ".insertNodeSelectionInterrupt", // Interrupted version
    INSERT_CHILD_SELECTION: Constants.NAME + ".insertChildNodeSelection", // Can be interrupted
    INSERT_CHILD_SELECTION_INTERRUPT: Constants.NAME + ".insertChildNodeSelectionInterrupt", // Can be interrupted
    CLONE_SELECTION: Constants.NAME + ".cloneNodeSelection",
    PROMOTE_SELECTION: Constants.NAME + ".promoteSelection",
    DEMOTE_SELECTION: Constants.NAME + ".demoteSelection",
    REFRESH_FROM_DISK_SELECTION: Constants.NAME + ".refreshFromDiskSelection",
    // * Commands from keyboard, while focus on OUTLINE
    MARK_SELECTION_FO: Constants.NAME + ".markSelectionFromOutline",
    UNMARK_SELECTION_FO: Constants.NAME + ".unmarkSelectionFromOutline",
    CUT_SELECTION_FO: Constants.NAME + ".cutNodeSelectionFromOutline",
    PASTE_SELECTION_FO: Constants.NAME + ".pasteNodeAtSelectionFromOutline",
    PASTE_CLONE_SELECTION_FO: Constants.NAME + ".pasteNodeAsCloneAtSelectionFromOutline",
    DELETE_SELECTION_FO: Constants.NAME + ".deleteSelectionFromOutline",
    HEADLINE_SELECTION_FO: Constants.NAME + ".editSelectedHeadlineFromOutline",
    MOVE_DOWN_SELECTION_FO: Constants.NAME + ".moveOutlineDownSelectionFromOutline",
    MOVE_LEFT_SELECTION_FO: Constants.NAME + ".moveOutlineLeftSelectionFromOutline",
    MOVE_RIGHT_SELECTION_FO: Constants.NAME + ".moveOutlineRightSelectionFromOutline",
    MOVE_UP_SELECTION_FO: Constants.NAME + ".moveOutlineUpSelectionFromOutline",
    INSERT_SELECTION_FO: Constants.NAME + ".insertNodeSelectionFromOutline",
    INSERT_CHILD_SELECTION_FO: Constants.NAME + ".insertChildNodeSelectionFromOutline",
    CLONE_SELECTION_FO: Constants.NAME + ".cloneNodeSelectionFromOutline",
    PROMOTE_SELECTION_FO: Constants.NAME + ".promoteSelectionFromOutline",
    DEMOTE_SELECTION_FO: Constants.NAME + ".demoteSelectionFromOutline",
    HOIST: Constants.NAME + ".hoistNode",
    HOIST_SELECTION: Constants.NAME + ".hoistSelection",
    HOIST_SELECTION_FO: Constants.NAME + ".hoistSelectionFromOutline",
    DEHOIST: Constants.NAME + ".deHoist",
    DEHOIST_FO: Constants.NAME + ".deHoistFromOutline",
    CHAPTER_NEXT: Constants.NAME + ".chapterNext",
    CHAPTER_BACK: Constants.NAME + ".chapterBack",
    CHAPTER_MAIN: Constants.NAME + ".chapterMain",
    CHAPTER_SELECT: Constants.NAME + ".chapterSelect",
    EXTRACT: Constants.NAME + ".extract",
    EXTRACT_NAMES: Constants.NAME + ".extractNames",
    COPY_MARKED: Constants.NAME + ".copyMarked",
    DIFF_MARKED_NODES: Constants.NAME + ".diffMarkedNodes",
    MARK_CHANGED_ITEMS: Constants.NAME + ".markChangedItems",
    MARK_SUBHEADS: Constants.NAME + ".markSubheads",
    UNMARK_ALL: Constants.NAME + ".unmarkAll",
    CLONE_MARKED_NODES: Constants.NAME + ".cloneMarkedNodes",
    DELETE_MARKED_NODES: Constants.NAME + ".deleteMarkedNodes",
    MOVE_MARKED_NODES: Constants.NAME + ".moveMarkedNodes",

    FIND_QUICK: Constants.NAME + ".findQuick",
    FIND_QUICK_SELECTED: Constants.NAME + ".findQuickSelected",
    FIND_QUICK_TIMELINE: Constants.NAME + ".findQuickTimeline",
    FIND_QUICK_CHANGED: Constants.NAME + ".findQuickChanged",
    FIND_QUICK_HISTORY: Constants.NAME + ".history",
    FIND_QUICK_MARKED: Constants.NAME + ".markedList",
    FIND_QUICK_GO_ANYWHERE: Constants.NAME + ".goAnywhere",
    GOTO_NAV_ENTRY: Constants.NAME + ".gotoNav",

    GOTO_NAV_PREV: Constants.NAME + ".gotoNavPrev",
    GOTO_NAV_NEXT: Constants.NAME + ".gotoNavNext",
    GOTO_NAV_FIRST: Constants.NAME + ".gotoNavFirst",
    GOTO_NAV_LAST: Constants.NAME + ".gotoNavLast",

    START_SEARCH: Constants.NAME + ".startSearch",
    SEARCH_BACKWARD: Constants.NAME + ".searchBackward",
    RE_SEARCH: Constants.NAME + ".reSearch",
    RE_SEARCH_BACKWARD: Constants.NAME + ".reSearchBackward",
    WORD_SEARCH: Constants.NAME + ".wordSearch",
    WORD_SEARCH_BACKWARD: Constants.NAME + ".wordSearchBackward",

    FIND_ALL: Constants.NAME + ".findAll",
    FIND_NEXT: Constants.NAME + ".findNext",
    FIND_NEXT_FO: Constants.NAME + ".findNextFromOutline",
    FIND_PREVIOUS: Constants.NAME + ".findPrevious",
    FIND_PREVIOUS_FO: Constants.NAME + ".findPreviousFromOutline",
    FIND_VAR: Constants.NAME + ".findVar",
    FIND_DEF: Constants.NAME + ".findDef",
    REPLACE: Constants.NAME + ".replace",
    REPLACE_FO: Constants.NAME + ".replaceFromOutline",
    REPLACE_THEN_FIND: Constants.NAME + ".replaceThenFind",
    REPLACE_THEN_FIND_FO: Constants.NAME + ".replaceThenFindFromOutline",
    REPLACE_ALL: Constants.NAME + ".replaceAll",

    CLONE_FIND_ALL: Constants.NAME + ".cloneFindAll",
    CLONE_FIND_ALL_FLATTENED: Constants.NAME + ".cloneFindAllFlattened",
    CLONE_FIND_TAG: Constants.NAME + ".cloneFindTag",
    CLONE_FIND_MARKED: Constants.NAME + ".cloneFindMarked",
    CLONE_FIND_FLATTENED_MARKED: Constants.NAME + ".cloneFindFlattenedMarked",
    CLONE_FIND_PARENTS: Constants.NAME + ".cloneFindParents",

    GOTO_GLOBAL_LINE: Constants.NAME + ".gotoGlobalLine",
    TAG_CHILDREN: Constants.NAME + ".tagChildren",
    TAG_NODE: Constants.NAME + ".tagNode",
    REMOVE_TAG: Constants.NAME + ".removeTag",
    REMOVE_TAGS: Constants.NAME + ".removeTags",
    SET_FIND_EVERYWHERE_OPTION: Constants.NAME + ".setFindEverywhereOption",
    SET_FIND_NODE_ONLY_OPTION: Constants.NAME + ".setFindNodeOnlyOption",
    SET_FIND_FILE_ONLY_OPTION: Constants.NAME + ".setFindFileOnlyOption",
    SET_FIND_SUBOUTLINE_ONLY_OPTION: Constants.NAME + ".setFindSuboutlineOnlyOption",
    TOGGLE_FIND_IGNORE_CASE_OPTION: Constants.NAME + ".toggleFindIgnoreCaseOption",
    TOGGLE_FIND_MARK_CHANGES_OPTION: Constants.NAME + ".toggleFindMarkChangesOption",
    TOGGLE_FIND_MARK_FINDS_OPTION: Constants.NAME + ".toggleFindMarkFindsOption",
    TOGGLE_FIND_REGEXP_OPTION: Constants.NAME + ".toggleFindRegexpOption",
    TOGGLE_FIND_WORD_OPTION: Constants.NAME + ".toggleFindWordOption",
    TOGGLE_FIND_SEARCH_BODY_OPTION: Constants.NAME + ".toggleFindSearchBodyOption",
    TOGGLE_FIND_SEARCH_HEADLINE_OPTION: Constants.NAME + ".toggleFindSearchHeadlineOption",
    SET_BODY_WRAP_SETTINGS: Constants.NAME + ".setBodyWrapSettings",
    SET_ENABLE_PREVIEW: Constants.NAME + ".setEnablePreview",
    CLEAR_CLOSE_EMPTY_GROUPS: Constants.NAME + ".clearCloseEmptyGroups",
};

</t>
<t tx="felix.20200718020912.2">/**
 * * Text and numeric constants used throughout leoInteg
 */
export class Constants {

    @others
}
</t>
<t tx="felix.20200718020912.3">public static PUBLISHER: string = "boltex";
public static NAME: string = "leointeg";
public static CONFIG_NAME: string = "leoIntegration";
public static CONFIG_WORKBENCH_ENABLED_PREVIEW: string = "workbench.editor.enablePreview";
public static CONFIG_REFRESH_MATCH: string = "OnNodes"; // substring to distinguish 'on-hover' icon commands

public static TREEVIEW_ID: string = Constants.CONFIG_NAME;
public static TREEVIEW_EXPLORER_ID: string = Constants.CONFIG_NAME + "Explorer";

public static DOCUMENTS_ID: string = "leoDocuments";
public static DOCUMENTS_EXPLORER_ID: string = "leoDocumentsExplorer";

public static BUTTONS_ID: string = "leoButtons";
public static BUTTONS_EXPLORER_ID: string = "leoButtonsExplorer";

public static FIND_ID: string = "leoFindPanel";
public static FIND_EXPLORER_ID: string = "leoFindPanelExplorer";

public static GOTO_ID: string = "leoGotoPanel";
public static GOTO_EXPLORER_ID: string = "leoGotoPanelExplorer";

public static UNDOS_ID: string = "leoUndos";
public static UNDOS_EXPLORER_ID: string = "leoUndosExplorer";

public static VERSION_STATE_KEY: string = "leoIntegVersion";

public static FILE_EXTENSION: string = "leo";
public static DB_FILE_EXTENSION: string = "db";
public static JS_FILE_EXTENSION: string = "leojs";

public static LEO_LANGUAGE_PREFIX: string = "leobody."; // all lowercase
public static LEO_WRAP_SUFFIX: string = ".wrap"; // all lowercase.

public static URI_LEO_SCHEME: string = "leointeg";
public static URI_LEO_DETACHED_SCHEME: string = "leointegDetached";
public static URI_FILE_SCHEME: string = "file";
public static URI_UNTITLED_SCHEME: string = 'untitled';
public static OUTPUT_CHANNEL_LANGUAGE: string = 'Log';
public static URI_SCHEME_HEADER: string = "leointeg:/";
public static URI_SCHEME_DETACHED_HEADER: string = "leointegDetached:/";
public static FILE_OPEN_FILTER_MESSAGE: string = "Leo Files";
public static UNTITLED_FILE_NAME: string = "untitled";
public static RECENT_FILES_KEY: string = "leoRecentFiles";
public static LAST_FILES_KEY: string = "leoLastFiles";
public static LAST_ACTIVE_FILE_KEY: string = "leoLastActiveFile";

public static DEFAULT_PYTHON: string = "python3";
public static WIN32_PYTHON: string = "py";
public static SERVER_NAME: string = "/leoserver.py";
public static LEO_ID_NAME: string = ".leoID.txt";
public static SERVER_PATH: string = "/leo/core";
public static CONFIG_PATH: string = "/leo/config";
public static SERVER_STARTED_TOKEN: string = "LeoBridge started";
public static TCPIP_DEFAULT_PROTOCOL: string = "ws://";

public static ERROR_PACKAGE_ID: number = 0;
public static STARTING_PACKAGE_ID: number = 1;
public static CLEANUP_DEBOUNCE_DELAY: number = 40;
public static DETACHED_LANGUAGE_DELAY: number = 300;
public static DOCUMENTS_DEBOUNCE_DELAY: number = 80;
public static BUTTONS_DEBOUNCE_DELAY: number = 80;
public static UNDOS_DEBOUNCE_DELAY: number = 180;
public static UNDOS_REVEAL_DEBOUNCE_DELAY: number = 50;
public static REFRESH_DEBOUNCE_DELAY: number = 50;
public static STATES_DEBOUNCE_DELAY: number = 100;
public static UNL_DEBOUNCE_DELAY: number = 150;
public static BODY_STATES_DEBOUNCE_DELAY: number = 120;
public static OUTLINE_DESC_DEBOUNCE_DELAY: number = 250;
public static GOTO_DEBOUNCE_DELAY: number = 50;

public static LOG_ALERT_COLOR: string = 'red';

</t>
<t tx="felix.20200718020912.5">/**
 * * Strings used in the workbench interface panels (not for messages or dialogs)
 */
public static GUI = {

    ICON_LIGHT_PARENT: "resources/light/parent.svg",
    ICON_DARK_PARENT: "resources/dark/parent.svg",
    ICON_LIGHT_NODE: "resources/light/node.svg",
    ICON_DARK_NODE: "resources/dark/node.svg",
    ICON_LIGHT_BODY: "resources/light/body.svg",
    ICON_DARK_BODY: "resources/dark/body.svg",
    ICON_LIGHT_TAG: "resources/light/tag.svg",
    ICON_DARK_TAG: "resources/dark/tag.svg",

    ICON_LIGHT_UNDO_ACTIVE: "resources/light/undo.svg",
    ICON_DARK_UNDO_ACTIVE: "resources/dark/undo.svg",
    ICON_LIGHT_UNDO: "resources/dark/undo.svg",
    ICON_DARK_UNDO: "resources/light/undo.svg",
    ICON_LIGHT_REDO_ACTIVE: "resources/light/redo.svg",
    ICON_DARK_REDO_ACTIVE: "resources/dark/redo.svg",
    ICON_LIGHT_REDO: "resources/dark/redo.svg",
    ICON_DARK_REDO: "resources/light/redo.svg",

    ICON_LIGHT_DOCUMENT: "resources/light/document.svg",
    ICON_DARK_DOCUMENT: "resources/dark/document.svg",
    ICON_LIGHT_DOCUMENT_DIRTY: "resources/light/document-dirty.svg",
    ICON_DARK_DOCUMENT_DIRTY: "resources/dark/document-dirty.svg",

    ICON_LIGHT_BUTTON: "resources/light/button.svg",
    ICON_DARK_BUTTON: "resources/dark/button.svg",
    ICON_LIGHT_BUTTON_RCLICK: "resources/light/button-rclick.svg",
    ICON_DARK_BUTTON_RCLICK: "resources/dark/button-rclick.svg",
    ICON_LIGHT_BUTTON_ADD: "resources/light/button-add.svg",
    ICON_DARK_BUTTON_ADD: "resources/dark/button-add.svg",

    ICON_LIGHT_PATH: "resources/light/box",
    ICON_DARK_PATH: "resources/dark/box",
    ICON_FILE_EXT: ".svg",
    STATUSBAR_INDICATOR: "$(link) ", // With trailing space
    QUICK_OPEN_LEO_COMMANDS: "&gt;leo: ",
    EXPLORER_TREEVIEW_PREFIX: "LEO ",
    TREEVIEW_TITLE: "OUTLINE",
    TREEVIEW_TITLE_NOT_CONNECTED: "NOT CONNECTED",
    TREEVIEW_TITLE_CONNECTED: "CONNECTED",
    TREEVIEW_TITLE_INTEGRATION: "INTEGRATION",
    BODY_TITLE: "LEO BODY",
    LOG_PANE_TITLE: "Leo Log Window",
    THEME_STATUSBAR: "statusBar.foreground"
};

</t>
<t tx="felix.20200718020912.6">/**
 * * Basic user messages strings: for messages and dialogs
 */
public static USER_MESSAGES = {
    SCRIPT_BUTTON: "from selected node",
    SCRIPT_BUTTON_TOOLTIP:
        "Creates a new button with the presently selected node.\n" +
        "For example, to run a script on any part of an outline:\n" +
        "\n" +
        "1.  Select the node containing a script. e.g. \"g.es(p.h)\"\n" +
        "2.  Press 'Script Button' to create a new button.\n" +
        "3.  Select another node on which to run the script.\n" +
        "4.  Press the *new* button.",
    SAVE_CHANGES: "Save changes to",
    BEFORE_CLOSING: "before closing?",
    REVERT_PREVIOUS_VERSION: "Revert to previous version of ", // Trailing space intended
    CANNOT_REVERT: "Can not revert unnamed file.",
    CANCEL: "Cancel",
    OPEN_WITH_LEOINTEG: "Open this Leo file with LeoInteg?",
    OPEN_RECENT_FILE: "Open Recent Leo File",
    RIGHT_CLICK_TO_OPEN: "Right-click Leo files to open with LeoInteg",
    FILE_ALREADY_OPENED: "Leo file already opened",
    CHOOSE_OPENED_FILE: "Select an opened Leo File",
    FILE_NOT_OPENED: "No files opened.",
    STATUSBAR_TOOLTIP_UNL: "Click to copy UNL to clipboard",
    STATUSBAR_TOOLTIP_ON: "Leo Key Bindings are in effect", // TODO : Add description of what happens if clicked
    STATUSBAR_TOOLTIP_OFF: "Leo Key Bindings off", // TODO : Add description of what happens if clicked
    PROMPT_EDIT_HEADLINE: "Edit Headline",
    PROMPT_INSERT_NODE: "Insert Node",
    PROMPT_INSERT_CHILD: "Insert Child",
    DEFAULT_HEADLINE: "New Headline",
    TITLE_GOTO_GLOBAL_LINE: "Goto global line",
    PLACEHOLDER_GOTO_GLOBAL_LINE: "#",
    PROMPT_GOTO_GLOBAL_LINE: "Line number",

    REPLACE_TITLE: "Replace with",
    REPLACE_PROMPT: "Type text to replace with and press enter.",
    REPLACE_PLACEHOLDER: "Replace pattern here",

    SEARCH_TITLE: "Search for",
    SEARCH_PROMPT: "Type text to search for and press enter.",
    SEARCH_PLACEHOLDER: "Find pattern here",

    INT_SEARCH_TITLE: "Search",
    INT_SEARCH_PROMPT: "'Enter' to search",
    INT_SEARCH_BACKWARD: " Backward", // Leading space intended
    INT_SEARCH_REGEXP: "Regexp ", // Trailing space intended
    INT_SEARCH_WORD: "Word ", // Trailing space intended

    SEARCH_NOT_FOUND: "Not found",
    FIND_PATTERN_HERE: "&lt;find pattern here&gt;",

    TAGS_CHARACTERS_ERROR: "Cannot add tags containing any of these characters: &amp;|^-",
    NO_TAGS_ON_NODE: "No tags on node: ", // Trailing space intended

    TITLE_TAG_CHILDREN: "Tag Children",
    TITLE_REMOVE_TAG: "Remove Tag",
    TITLE_TAG_NODE: "Tag Node",
    PLACEHOLDER_TAG: "&lt;tag&gt;",
    PROMPT_TAG: "Enter a tag name",
    TITLE_FIND_TAG: "Find Tag",
    PLACEHOLDER_CLONE_FIND_TAG: "&lt;tag&gt;",
    PROMPT_CLONE_FIND_TAG: "Enter a tag name",

    START_SERVER_ERROR: "Error - Cannot start server: ",
    CONNECT_FAILED: "Leo Server Connection Failed",
    CONNECT_ERROR: "Leo Server Connection Error: Incorrect id",
    CONNECTED: "Connected",
    ALREADY_CONNECTED: "Already connected",
    DISCONNECTED: "Disconnected",
    CLEARED_RECENT: "Cleared recent files list",
    CLOSE_ERROR: "Cannot close: No files opened.",
    LEO_PATH_MISSING: "Leo Editor Path Setting Missing",
    CANNOT_FIND_SERVER_SCRIPT: "Cannot find server script",
    YES: "Yes",
    NO: "No",
    YES_ALL: "Yes to all",
    NO_ALL: "No to all",
    CHOOSE_BUTTON: "Choose @button or @rclick",
    SEARCH_POSITION_BY_HEADLINE: "Search positions by headline",
    MINIBUFFER_PROMPT: "Minibuffer Full Command",
    SELECT_CHAPTER_PROMPT: "Select chapter",
    SET_UA_NAME_TITLE: "Set ua",
    SET_UA_NAME_PLACEHOLDER: "Attribute Name",
    SET_UA_NAME_PROMPT: "Set unknown attribute name",
    SET_UA_VAL_TITLE: "Set ua to",
    SET_UA_VAL_PLACEHOLDER: "Attribute Value",
    SET_UA_VAL_PROMPT: "Set unknown attribute value",
    CHANGES_DETECTED: "Changes to external files were detected.",
    REFRESHED: " Nodes refreshed.", // with leading space
    IGNORED: " They were ignored.", // with leading space
    TOO_FAST: "leoInteg is busy! ", // with trailing space
    MINIMUM_LEO_VERSION_STRING: "Please update your Leo Installation: Leo 6.7.8-B1 is recommended.",
    UNKNOWN_LANGUAGE_NOT_SUPPORTED: "Language coloring not yet supported.",
    LANGUAGE_NOT_SUPPORTED: " language coloring not yet supported.", // with leading space
    MINIBUFFER_BUTTON_START: "@button-",
    MINIBUFFER_RCLICK_START: "@rclick-",
    MINIBUFFER_SCRIPT_BUTTON: "script-button",
    MINIBUFFER_DEL_SCRIPT_BUTTON: "delete-script-",
    MINIBUFFER_DEL_BUTTON_START: "delete-@button-",
    MINIBUFFER_COMMAND_START: "@command-",
    MINIBUFFER_USER_DEFINED: "$(run) User defined command.",
    MINIBUFFER_BUTTON: "$(run) @button",
    MINIBUFFER_RCLICK: "$(chevron-right) @rclick",
    MINIBUFFER_COMMAND: "$(zap) @command",
    MINIBUFFER_BAD_COMMAND: "$(error) Not Available",
    MINIBUFFER_HISTORY_LABEL: "Minibuffer History",
    MINIBUFFER_HISTORY_DESC: "Choose from last run commands...",

    BODY_WRAP_RECOMMEND: "'leobody' wordWrap settings are recommended (some currently missing)",
    BODY_WRAP_SET: "'leobody' wordWrap settings were set",
    FIX_IT: "Fix it",
    ENABLE_PREVIEW_SET: "'Enable Preview' setting was set",
    ENABLE_PREVIEW_RECOMMEND: "'Enable Preview' setting is recommended (currently disabled)",
    CLOSE_EMPTY_CLEARED: "'Close Empty Groups' setting was cleared",
    CLOSE_EMPTY_RECOMMEND: "'Close Empty Groups' setting is NOT recommended!",
};

</t>
<t tx="felix.20200718020912.7">/**
 * * Choices offered when about to lose current changes to a Leo Document
 */
public static ASK_SAVE_CHANGES_BUTTONS: vscode.MessageItem[] = [
    {
        title: Constants.USER_MESSAGES.YES,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.NO,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.CANCEL,
        isCloseAffordance: true
    }
];

</t>
<t tx="felix.20200718020912.8">/**
 * * String for JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public static CONFIG_NAMES = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "checkForChangeExternalFiles",
    DEFAULT_RELOAD_IGNORE: "defaultReloadIgnore",
    LEO_TREE_BROWSE: "leoTreeBrowse",
    TREE_KEEP_FOCUS: "treeKeepFocus",
    TREE_KEEP_FOCUS_WHEN_ASIDE: "treeKeepFocusWhenAside",

    COLLAPSE_ALL_SHORTCUT: "collapseAllShortcut",
    ACTIVITY_VIEW_SHORTCUT: "activityViewShortcut",
    GO_ANYWHERE_SHORTCUT: "goAnywhereShortcut",

    TREE_IN_EXPLORER: "treeInExplorer",
    SHOW_EDIT: "showEditOnNodes",
    SHOW_ADD: "showAddOnNodes",
    SHOW_MARK: "showMarkOnNodes",
    SHOW_CLONE: "showCloneOnNodes",
    SHOW_COPY: "showCopyOnNodes",
    SHOW_BRANCH_OUTLINE: "showBranchInOutlineTitle",

    SHOW_UNL_ON_STATUSBAR: "showUnlOnStatusBar",
    // SHOW_EDITION_BODY: "showEditionOnBody",
    // SHOW_CLIPBOARD_BODY: "showClipboardOnBody",
    // SHOW_PROMOTE_BODY: "showPromoteOnBody",
    // SHOW_EXECUTE_BODY: "showExecuteOnBody",
    // SHOW_EXTRACT_BODY: "showExtractOnBody",
    // SHOW_IMPORT_BODY: "showImportOnBody",
    // SHOW_REFRESH_BODY: "showRefreshOnBody",
    // SHOW_HOIST_BODY: "showHoistOnBody",
    // SHOW_MARK_BODY: "showMarkOnBody",
    // SHOW_SORT_BODY: "showSortOnBody",

    INVERT_NODES: "invertNodeContrast",
    LEO_EDITOR_PATH: "leoEditorPath",
    LEO_PYTHON_COMMAND: "leoPythonCommand",
    AUTO_START_SERVER: "startServerAutomatically",
    AUTO_CONNECT: "connectToServerAutomatically",
    IP_ADDRESS: "connectionAddress",
    IP_PORT: "connectionPort",

    SET_DETACHED: "setDetached",
    LIMIT_USERS: "limitUsers"
};

</t>
<t tx="felix.20200718020912.9">/**
 * * Used in 'when' clauses, set with vscode.commands.executeCommand("setContext",...)
 */
public static CONTEXT_FLAGS = {
    // Main flags for connection and opened file
    STARTUP_FINISHED: "leoStartupFinished", // Initial extension finished auto-server-start-connect
    LEO_OPENING_FILE: "leoOpeningFile",
    STARTING_SERVER: "leoStartingServer",
    CONNECTING: "leoConnecting", // Initial extension finished auto-server-start-connect
    BRIDGE_READY: "leoBridgeReady", // Connected to leoBridge
    TREE_OPENED: "leoTreeOpened", // At least one Leo file opened
    TREE_TITLED: "leoTreeTitled", // Tree is a Leo file and not a new untitled document
    SERVER_STARTED: "leoServerStarted", // Auto-start or manually started
    LEOID_MISSING: "leoIDMissing", // To be used as flag for #248

    // 'states' flags for currently opened tree view
    LEO_CHANGED: "leoChanged",
    LEO_CAN_UNDO: "leoCanUndo",
    LEO_CAN_REDO: "leoCanRedo",
    LEO_CAN_BACK: "leoCanGoBack",
    LEO_CAN_NEXT: "leoCanGoNext",
    LEO_CAN_DEMOTE: "leoCanDemote",
    LEO_CAN_PROMOTE: "leoCanPromote",
    LEO_CAN_DEHOIST: "leoCanDehoist",
    LEO_CAN_HOIST: "leoCanHoist", // isNotRoot equivalent
    LEO_IN_CHAPTER: "leoInChapter",
    LEO_TOP_HOIST_CHAPTER: "leoTopHoistChapter",
    LEO_EDIT_HEADLINE: "leoEditHeadline",

    // 'states' flags about current selection, for visibility and commands availability
    SELECTED_MARKED: "leoMarked", // no need for unmarked here, use !leoMarked
    SELECTED_CLONE: "leoCloned",
    SELECTED_DIRTY: "leoDirty",
    SELECTED_EMPTY: "leoEmpty",
    SELECTED_CHILD: "leoChild", // Has children
    SELECTED_ATFILE: "leoAtFile", // Can be refreshed

    // Outline nodes: text Flags for 'when' clauses. Used as concatenated strings.
    NODE_MARKED: "leoNodeMarked",  // Selected node is marked
    NODE_UNMARKED: "leoNodeUnmarked", // Selected node is unmarked (Needed for regexp)
    NODE_ATFILE: "leoNodeAtFile", // Selected node is an @file or @clean, etc...
    NODE_CLONED: "leoNodeCloned",
    NODE_ROOT: "leoNodeRoot",
    NODE_NOT_ROOT: "leoNodeNotRoot",
    NODE_TAGS: "leoNodeTags",

    // Flags for undo nodes
    UNDO_BEAD: "leoUndoNode",
    NOT_UNDO_BEAD: "leoNoUndoNode",

    // Flags for Leo documents tree view icons and hover node command buttons
    DOCUMENT_SELECTED_TITLED: "leoDocumentSelectedTitled",
    DOCUMENT_TITLED: "leoDocumentTitled",
    DOCUMENT_SELECTED_UNTITLED: "leoDocumentSelectedUntitled",
    DOCUMENT_UNTITLED: "leoDocumentUntitled",

    // Flags for focus context
    FOCUS_FIND: "leoFindFocus",

    // Flags that match specific LeoInteg config settings
    // LEO_TREE_BROWSE: Constants.CONFIG_NAMES.LEO_TREE_BROWSE,     // Force ar'jan's suggestion of Leo's tree behavior override
    // TREE_IN_EXPLORER: Constants.CONFIG_NAMES.TREE_IN_EXPLORER,   // Leo outline also in the explorer view
    // SHOW_OPEN_ASIDE: Constants.CONFIG_NAMES.SHOW_OPEN_ASIDE,     // Show 'open aside' in context menu
    // SHOW_EDIT: Constants.CONFIG_NAMES.SHOW_EDIT,                 // Hover Icons on outline nodes
    // SHOW_ARROWS: Constants.CONFIG_NAMES.SHOW_ARROWS,             // Hover Icons on outline nodes
    // SHOW_ADD: Constants.CONFIG_NAMES.SHOW_ADD,                   // Hover Icons on outline nodes
    // SHOW_MARK: Constants.CONFIG_NAMES.SHOW_MARK,                 // Hover Icons on outline nodes
    // SHOW_CLONE: Constants.CONFIG_NAMES.SHOW_CLONE,               // Hover Icons on outline nodes
    // SHOW_COPY: Constants.CONFIG_NAMES.SHOW_COPY,                 // Hover Icons on outline nodes
    // AUTO_START_SERVER: Constants.CONFIG_NAMES.AUTO_START_SERVER, // Used at startup
    // AUTO_CONNECT: Constants.CONFIG_NAMES.AUTO_CONNECT,           // Used at startup

    // AUTO_CONNECT: 'leoAutoConnect',             // Used at startup by 'views-welcome'
    // AUTO_START_SERVER: 'leoAutoStartServer',    // Used at startup by 'views-welcome'

    // SHOW_EDITION_BODY: Constants.CONFIG_NAMES.SHOW_EDITION_BODY,
    // SHOW_CLIPBOARD_BODY: Constants.CONFIG_NAMES.SHOW_CLIPBOARD_BODY,
    // SHOW_PROMOTE_BODY: Constants.CONFIG_NAMES.SHOW_PROMOTE_BODY,
    // SHOW_EXECUTE_BODY: Constants.CONFIG_NAMES.SHOW_EXECUTE_BODY,
    // SHOW_EXTRACT_BODY: Constants.CONFIG_NAMES.SHOW_EXTRACT_BODY,
    // SHOW_IMPORT_BODY: Constants.CONFIG_NAMES.SHOW_IMPORT_BODY,
    // SHOW_REFRESH_BODY: Constants.CONFIG_NAMES.SHOW_REFRESH_BODY,
    // SHOW_HOIST_BODY: Constants.CONFIG_NAMES.SHOW_HOIST_BODY,
    // SHOW_MARK_BODY: Constants.CONFIG_NAMES.SHOW_MARK_BODY,
    // SHOW_SORT_BODY: Constants.CONFIG_NAMES.SHOW_SORT_BODY

};

</t>
<t tx="felix.20200718024635.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { UserCommand, LeoBridgePackage, ReqRefresh, ArchivedPosition, Focus } from "./types";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718024635.2">/**
 * * Front-facing, user command stack of actions
 * This implements a user-facing command stack, (push on top, remove bottom)
 * Commands can also be added while this stack has started resolving.
 * This 'stack' concept is similar to the 'LeoBridge' class used for interacting with Leo.
 */
export class CommandStack {

    private _stack: UserCommand[] = []; // Actual commands array
    private _busy: boolean = false; // Flag stating commands started resolving

    // Refresh type, for use after the last command has done resolving (From highest so far)
    public finalRefreshType: ReqRefresh = {}; // new empty ReqRefresh
    private _allowDetachedExclusion = true;

    // Flag used to set focus on outline instead of body when done resolving (From last pushed)
    private _finalFocus: Focus = Focus.NoChange;

    // Received selection from the last command that finished
    // It will be re-sent as 'target node' instead of lastSelectedNode if present
    public lastReceivedNode: ArchivedPosition | undefined;
    public lastReceivedNodeTS: number = 0;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20200718024635.3">/**
 * * Returns the command stack size
 * @returns number of actions on the command stack
 */
public size(): number {
    return this._stack.length;
}

</t>
<t tx="felix.20200718024635.4">/**
 * * Signal to the command stack that a new selected node was received.
 * Command stack needs to know when to clear its own '_receivedSelection'
 */
public newSelection(): void {
    if (!this._busy) {
        this.lastReceivedNode = undefined;
    }
}

</t>
<t tx="felix.20200718024635.5">/**
 * * Adds on top and try to execute the bottom command if not already running
 * Targeted command (targeting a specific node) can only be added on an empty stack
 * @param p_command Object that has the action, targeted node (if any), refresh type and 'fromOutline' flag
 * @returns true if added, false if it could not (due to front end stack 'rules')
 */
public add(p_command: UserCommand): Promise&lt;LeoBridgePackage&gt; | undefined {
    if (p_command.node &amp;&amp; this.size()) {
        return undefined; // Can only add a command which targets a node if the stack is empty
    } else {
        const q_promise = new Promise&lt;LeoBridgePackage&gt;((p_resolve, p_reject) =&gt; {
            p_command.resolveFn = p_resolve;
            p_command.rejectFn = p_reject;
        });
        this._stack.push(p_command);
        this._finalFocus = p_command.finalFocus; // Set final "focus-placement"
        this._tryStart();
        return q_promise;
    }
}

</t>
<t tx="felix.20200718024635.6">/**
 * * Try to launch commands that were added on the stack, if any.
 */
private _tryStart(): void {
    if (this.size() &amp;&amp; !this._busy) {
        // Ok to start, so set the busy flag and start from the bottom
        this._busy = true; // Cleared when the last command has returned (and the stack is empty)
        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}

</t>
<t tx="felix.20200718024635.7">/**
 * * Run the command at index 0: The bottom of the stack.
 */
private _runStackCommand(): Promise&lt;LeoBridgePackage&gt; {
    // Reference from bottom of stack, but don't remove it yet!
    const w_command: UserCommand = this._stack[0];

    let w_node: ArchivedPosition | undefined; // ap json used in building w_jsonParam

    // First command uses given node or last selected node.
    // Other subsequent commands on stack will use _receivedSelection regardless.
    // (Commands such as 'collapse all' just ignore node parameter)
    if (w_command.node) {
        // Was node specific, so starting a new stack of commands
        w_node = w_command.node;
    } else {
        // Use received "selected node" unless first use, then use last selected node
        if (this.lastReceivedNode) {
            w_node = this.lastReceivedNode;
        } else {
            w_node = this._leoIntegration.lastSelectedNode ? this._leoIntegration.lastSelectedNode : undefined;
        }
        if (!w_node) {
            console.log('ERROR NO ARCHIVED POSITION JSON');
            throw new Error("ERROR NO ARCHIVED POSITION JSON");
        }
    }
    const w_jsonParam = utils.buildNodeCommand(w_node!, w_command); // 'Insert Named Node' or 'Edit Headline'

    // Setup _finalRefreshType, if command requires higher than the one setup so far
    Object.assign(this.finalRefreshType, w_command.refreshType); // add all properties (expecting only 'true' properties)

    // TODO : Maybe implement this in a better way: excludeDetached IS A NEGATIVE FLAG 
    // * Check if we added a body refresh that did not exclude detached. If so make it also refresh detached.
    if (w_command.refreshType.body &amp;&amp; !w_command.refreshType.excludeDetached) {
        this._allowDetachedExclusion = false;
    }
    if (!this._allowDetachedExclusion &amp;&amp; this.finalRefreshType.excludeDetached) {
        delete this.finalRefreshType.excludeDetached;
    }

    // Submit this action to Leo and return a promise of its packaged answer
    return this._leoIntegration.sendAction(w_command.action, w_jsonParam)
        .then((p_package) =&gt; {
            if (w_command.resolveFn) {
                w_command.resolveFn(p_package);
            }
            return p_package;
        },
            (p_reason) =&gt; {
                if (w_command.rejectFn) {
                    w_command.rejectFn(p_reason);
                }
                return p_reason;
            }
        );
}

</t>
<t tx="felix.20200718024635.8">/**
 * * Handle the result from the command that has finished: either launch the next one, or refresh accordingly.
 * @param p_package is the json return 'package' that was just received back from Leo
 */
private _resolveResult(p_package: LeoBridgePackage): void {
    this._stack.shift(); // Finally remove resolved command from stack bottom

    this.lastReceivedNode = p_package.node;
    this.lastReceivedNodeTS = performance.now();

    if (!this.size()) {
        // If last is done then do refresh outline and focus on outline, or body, as required
        this._busy = false;
        if (Object.keys(this.finalRefreshType).length) {
            // At least some type of refresh
            this._leoIntegration.setupRefresh(
                this._finalFocus,
                this.finalRefreshType,
                p_package.node
            );
            this._leoIntegration.launchRefresh();
        }
        // Reset refresh type nonetheless
        this.finalRefreshType = {};
        this._allowDetachedExclusion = true;
    } else {
        // Size &gt; 0, so call _runStackCommand again, keep _busy set to true
        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}

</t>
<t tx="felix.20200718030926.1">import * as vscode from "vscode";
import { ConfigMembers, ConfigSetting } from "./types";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718030926.2">/**
 * * Configuration Settings Service
 */
export class Config implements ConfigMembers {

    // Config settings used in leoserver.py
    public checkForChangeExternalFiles: string = Constants.CONFIG_DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES;
    public defaultReloadIgnore: string = Constants.CONFIG_DEFAULTS.DEFAULT_RELOAD_IGNORE;
    // Config settings used in leoInteg/vscode's side
    public leoTreeBrowse: boolean = Constants.CONFIG_DEFAULTS.LEO_TREE_BROWSE;
    public treeKeepFocus: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS;
    public treeKeepFocusWhenAside: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE;

    public collapseAllShortcut: boolean = Constants.CONFIG_DEFAULTS.COLLAPSE_ALL_SHORTCUT;
    public activityViewShortcut: boolean = Constants.CONFIG_DEFAULTS.ACTIVITY_VIEW_SHORTCUT;
    public goAnywhereShortcut: boolean = Constants.CONFIG_DEFAULTS.GO_ANYWHERE_SHORTCUT;

    public showUnlOnStatusBar: boolean = Constants.CONFIG_DEFAULTS.SHOW_UNL_ON_STATUSBAR;
    public treeInExplorer: boolean = Constants.CONFIG_DEFAULTS.TREE_IN_EXPLORER;
    public showEditOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_EDIT;

    public showAddOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_ADD;
    public showMarkOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_MARK;
    public showCloneOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_CLONE;
    public showCopyOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_COPY;
    public showBranchInOutlineTitle: boolean = Constants.CONFIG_DEFAULTS.SHOW_BRANCH_OUTLINE;

    // public showEditionOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EDITION_BODY;
    // public showClipboardOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_CLIPBOARD_BODY;
    // public showPromoteOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_PROMOTE_BODY;
    // public showExecuteOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EXECUTE_BODY;
    // public showExtractOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EXTRACT_BODY;
    // public showImportOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_IMPORT_BODY;
    // public showRefreshOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_REFRESH_BODY;
    // public showHoistOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_HOIST_BODY;
    // public showMarkOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_MARK_BODY;
    // public showSortOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_SORT_BODY;

    public invertNodeContrast: boolean = Constants.CONFIG_DEFAULTS.INVERT_NODES;
    public leoPythonCommand: string = Constants.CONFIG_DEFAULTS.LEO_PYTHON_COMMAND;
    public leoEditorPath: string = Constants.CONFIG_DEFAULTS.LEO_EDITOR_PATH;
    public startServerAutomatically: boolean = Constants.CONFIG_DEFAULTS.AUTO_START_SERVER;
    public connectToServerAutomatically: boolean = Constants.CONFIG_DEFAULTS.AUTO_CONNECT;
    public connectionAddress: string = Constants.CONFIG_DEFAULTS.IP_ADDRESS;
    public connectionPort: number = Constants.CONFIG_DEFAULTS.IP_PORT;

    public setDetached: boolean = Constants.CONFIG_DEFAULTS.SET_DETACHED;
    public limitUsers: number = Constants.CONFIG_DEFAULTS.LIMIT_USERS;

    public setLeoIntegSettingsPromise: Promise&lt;unknown&gt; = Promise.resolve();

    // public uAsNumber: boolean = true;

    private _isBusySettingConfig: boolean = false;
    // private _needsTreeRefresh: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20200718030926.3">/**
 * * Get actual 'live' Leointeg configuration
 * @returns An object with config settings members such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public getConfig(): ConfigMembers {
    return {
        checkForChangeExternalFiles: this.checkForChangeExternalFiles,  // Used in leoBridge script
        defaultReloadIgnore: this.defaultReloadIgnore,  // Used in leoBridge script
        leoTreeBrowse: this.leoTreeBrowse,
        treeKeepFocus: this.treeKeepFocus,
        treeKeepFocusWhenAside: this.treeKeepFocusWhenAside,

        collapseAllShortcut: this.collapseAllShortcut,
        activityViewShortcut: this.activityViewShortcut,
        goAnywhereShortcut: this.goAnywhereShortcut,

        showUnlOnStatusBar: this.showUnlOnStatusBar,
        treeInExplorer: this.treeInExplorer,
        showEditOnNodes: this.showEditOnNodes,
        showAddOnNodes: this.showAddOnNodes,
        showMarkOnNodes: this.showMarkOnNodes,
        showCloneOnNodes: this.showCloneOnNodes,
        showCopyOnNodes: this.showCopyOnNodes,
        showBranchInOutlineTitle: this.showBranchInOutlineTitle,

        // showEditionOnBody: this.showEditionOnBody,
        // showClipboardOnBody: this.showClipboardOnBody,
        // showPromoteOnBody: this.showPromoteOnBody,
        // showExecuteOnBody: this.showExecuteOnBody,
        // showExtractOnBody: this.showExtractOnBody,
        // showImportOnBody: this.showImportOnBody,
        // showRefreshOnBody: this.showRefreshOnBody,
        // showHoistOnBody: this.showHoistOnBody,
        // showMarkOnBody: this.showMarkOnBody,
        // showSortOnBody: this.showSortOnBody,

        invertNodeContrast: this.invertNodeContrast,
        leoPythonCommand: this.leoPythonCommand,
        leoEditorPath: this.leoEditorPath,
        startServerAutomatically: this.startServerAutomatically,
        connectToServerAutomatically: this.connectToServerAutomatically,
        connectionAddress: this.connectionAddress,
        connectionPort: this.connectionPort,

        setDetached: this.setDetached,
        limitUsers: this.limitUsers,

        // uAsNumber: true
    };
}

</t>
<t tx="felix.20200718030926.4">/**
 * * Apply changes to the expansion config settings and save them in user settings.
 * @param p_changes is an array of codes and values to be changed
 * @returns a promise that resolves upon completion
 */
public setLeoIntegSettings(p_changes: ConfigSetting[]): Promise&lt;void&gt; {
    this._isBusySettingConfig = true;
    const w_promises: Thenable&lt;void&gt;[] = [];
    const w_vscodeConfig = vscode.workspace.getConfiguration(Constants.CONFIG_NAME);
    p_changes.forEach(i_change =&gt; {
        if (w_vscodeConfig.inspect(i_change.code)!.defaultValue === i_change.value) {
            // Set as undefined - same as default
            w_promises.push(w_vscodeConfig.update(i_change.code, undefined, true));
        } else {
            // Set as value which is not default
            w_promises.push(w_vscodeConfig.update(i_change.code, i_change.value, true));
        }
    });
    this.setLeoIntegSettingsPromise = Promise.all(w_promises);
    return this.setLeoIntegSettingsPromise.then(() =&gt; {
        this._isBusySettingConfig = false;
        this.buildFromSavedSettings();
        return Promise.resolve();
    });
}

</t>
<t tx="felix.20200718030926.5">/**
 * * Build config from settings from vscode's saved config settings
 */
public buildFromSavedSettings(): boolean {
    // Shorthand pointers for readability
    const GET = vscode.workspace.getConfiguration;
    const NAME = Constants.CONFIG_NAME;
    const NAMES = Constants.CONFIG_NAMES;
    const DEFAULTS = Constants.CONFIG_DEFAULTS;
    const FLAGS = Constants.CONTEXT_FLAGS;

    if (this._isBusySettingConfig) {
        // * Currently setting config, wait until its done all, and this will be called automatically
        return false;
    } else {
        this.checkForChangeExternalFiles = GET(NAME).get(NAMES.CHECK_FOR_CHANGE_EXTERNAL_FILES, DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES);
        this.defaultReloadIgnore = GET(NAME).get(NAMES.DEFAULT_RELOAD_IGNORE, DEFAULTS.DEFAULT_RELOAD_IGNORE);
        this.leoTreeBrowse = GET(NAME).get(NAMES.LEO_TREE_BROWSE, DEFAULTS.LEO_TREE_BROWSE);
        this.treeKeepFocus = GET(NAME).get(NAMES.TREE_KEEP_FOCUS, DEFAULTS.TREE_KEEP_FOCUS);
        this.treeKeepFocusWhenAside = GET(NAME).get(NAMES.TREE_KEEP_FOCUS_WHEN_ASIDE, DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE);

        this.collapseAllShortcut = GET(NAME).get(NAMES.COLLAPSE_ALL_SHORTCUT, DEFAULTS.COLLAPSE_ALL_SHORTCUT);
        this.activityViewShortcut = GET(NAME).get(NAMES.ACTIVITY_VIEW_SHORTCUT, DEFAULTS.ACTIVITY_VIEW_SHORTCUT);
        this.goAnywhereShortcut = GET(NAME).get(NAMES.GO_ANYWHERE_SHORTCUT, DEFAULTS.GO_ANYWHERE_SHORTCUT);

        this.showUnlOnStatusBar = GET(NAME).get(NAMES.SHOW_UNL_ON_STATUSBAR, DEFAULTS.SHOW_UNL_ON_STATUSBAR);
        // this.statusBarString = GET(NAME).get(NAMES.STATUSBAR_STRING, DEFAULTS.STATUSBAR_STRING);
        // if (this.statusBarString.length &gt; 8) {
        //     this.statusBarString = DEFAULTS.STATUSBAR_STRING;
        // }
        // this.statusBarColor = GET(NAME).get(NAMES.STATUSBAR_COLOR, DEFAULTS.STATUSBAR_COLOR);
        // if (!utils.isHexColor(this.statusBarColor)) {
        //     this.statusBarColor = DEFAULTS.STATUSBAR_COLOR;
        // }
        this.treeInExplorer = GET(NAME).get(NAMES.TREE_IN_EXPLORER, DEFAULTS.TREE_IN_EXPLORER);
        this.showEditOnNodes = GET(NAME).get(NAMES.SHOW_EDIT, DEFAULTS.SHOW_EDIT);
        this.showAddOnNodes = GET(NAME).get(NAMES.SHOW_ADD, DEFAULTS.SHOW_ADD);
        this.showMarkOnNodes = GET(NAME).get(NAMES.SHOW_MARK, DEFAULTS.SHOW_MARK);
        this.showCloneOnNodes = GET(NAME).get(NAMES.SHOW_CLONE, DEFAULTS.SHOW_CLONE);
        this.showCopyOnNodes = GET(NAME).get(NAMES.SHOW_COPY, DEFAULTS.SHOW_COPY);
        this.showBranchInOutlineTitle = GET(NAME).get(NAMES.SHOW_BRANCH_OUTLINE, DEFAULTS.SHOW_BRANCH_OUTLINE);

        // this.showArrowsOnNodes = GET(NAME).get(NAMES.SHOW_ARROWS, DEFAULTS.SHOW_ARROWS);

        // this.showEditionOnBody = GET(NAME).get(NAMES.SHOW_EDITION_BODY, DEFAULTS.SHOW_EDITION_BODY);
        // this.showClipboardOnBody = GET(NAME).get(NAMES.SHOW_CLIPBOARD_BODY, DEFAULTS.SHOW_CLIPBOARD_BODY);
        // this.showPromoteOnBody = GET(NAME).get(NAMES.SHOW_PROMOTE_BODY, DEFAULTS.SHOW_PROMOTE_BODY);
        // this.showExecuteOnBody = GET(NAME).get(NAMES.SHOW_EXECUTE_BODY, DEFAULTS.SHOW_EXECUTE_BODY);
        // this.showExtractOnBody = GET(NAME).get(NAMES.SHOW_EXTRACT_BODY, DEFAULTS.SHOW_EXTRACT_BODY);
        // this.showImportOnBody = GET(NAME).get(NAMES.SHOW_IMPORT_BODY, DEFAULTS.SHOW_IMPORT_BODY);
        // this.showRefreshOnBody = GET(NAME).get(NAMES.SHOW_REFRESH_BODY, DEFAULTS.SHOW_REFRESH_BODY);
        // this.showHoistOnBody = GET(NAME).get(NAMES.SHOW_HOIST_BODY, DEFAULTS.SHOW_HOIST_BODY);
        // this.showMarkOnBody = GET(NAME).get(NAMES.SHOW_MARK_BODY, DEFAULTS.SHOW_MARK_BODY);
        // this.showSortOnBody = GET(NAME).get(NAMES.SHOW_SORT_BODY, DEFAULTS.SHOW_SORT_BODY);

        this.invertNodeContrast = GET(NAME).get(NAMES.INVERT_NODES, DEFAULTS.INVERT_NODES);
        this.leoEditorPath = GET(NAME).get(NAMES.LEO_EDITOR_PATH, DEFAULTS.LEO_EDITOR_PATH);
        this.leoPythonCommand = GET(NAME).get(NAMES.LEO_PYTHON_COMMAND, DEFAULTS.LEO_PYTHON_COMMAND);
        this.startServerAutomatically = GET(NAME).get(NAMES.AUTO_START_SERVER, DEFAULTS.AUTO_START_SERVER);
        this.connectToServerAutomatically = GET(NAME).get(NAMES.AUTO_CONNECT, DEFAULTS.AUTO_CONNECT);
        this.connectionAddress = GET(NAME).get(NAMES.IP_ADDRESS, DEFAULTS.IP_ADDRESS);
        this.connectionPort = GET(NAME).get(NAMES.IP_PORT, DEFAULTS.IP_PORT);

        this.setDetached = GET(NAME).get(NAMES.SET_DETACHED, DEFAULTS.SET_DETACHED);
        this.limitUsers = GET(NAME).get(NAMES.LIMIT_USERS, DEFAULTS.LIMIT_USERS);

        // * Set context for tree items visibility that are based on config options
        if (this._leoIntegration.leoStates.leoBridgeReady) {
            this._leoIntegration.sendConfigToServer(this.getConfig());
        }

        // utils.setContext(FLAGS.LEO_TREE_BROWSE, this.leoTreeBrowse);
        // utils.setContext(FLAGS.TREE_IN_EXPLORER, this.treeInExplorer);
        // utils.setContext(FLAGS.SHOW_OPEN_ASIDE, this.showOpenAside);
        // utils.setContext(FLAGS.SHOW_EDIT, this.showEditOnNodes);
        // utils.setContext(FLAGS.SHOW_ADD, this.showAddOnNodes);
        // utils.setContext(FLAGS.SHOW_MARK, this.showMarkOnNodes);
        // utils.setContext(FLAGS.SHOW_CLONE, this.showCloneOnNodes);
        // utils.setContext(FLAGS.SHOW_COPY, this.showCopyOnNodes);

        // utils.setContext(FLAGS.SHOW_ARROWS, this.showArrowsOnNodes);

        // utils.setContext(FLAGS.SHOW_EDITION_BODY, this.showEditionOnBody);
        // utils.setContext(FLAGS.SHOW_CLIPBOARD_BODY, this.showClipboardOnBody);
        // utils.setContext(FLAGS.SHOW_PROMOTE_BODY, this.showPromoteOnBody);
        // utils.setContext(FLAGS.SHOW_EXECUTE_BODY, this.showExecuteOnBody);
        // utils.setContext(FLAGS.SHOW_EXTRACT_BODY, this.showExtractOnBody);
        // utils.setContext(FLAGS.SHOW_IMPORT_BODY, this.showImportOnBody);
        // utils.setContext(FLAGS.SHOW_REFRESH_BODY, this.showRefreshOnBody);
        // utils.setContext(FLAGS.SHOW_HOIST_BODY, this.showHoistOnBody);
        // utils.setContext(FLAGS.SHOW_MARK_BODY, this.showMarkOnBody);
        // utils.setContext(FLAGS.SHOW_SORT_BODY, this.showSortOnBody);

        // utils.setContext(FLAGS.AUTO_CONNECT, this.connectToServerAutomatically);

        if (!this._leoIntegration.leoStates.leoStartupFinished &amp;&amp; this.leoEditorPath) {
            // Only relevant 'viewWelcome' content at startup.
            // utils.setContext(FLAGS.AUTO_START_SERVER, this.startServerAutomatically);  // ok
            // utils.setContext(FLAGS.AUTO_CONNECT, this.connectToServerAutomatically);
        } else {
            // utils.setContext(FLAGS.AUTO_START_SERVER, false); // Save option but not context flag
            //utils.setContext(FLAGS.AUTO_CONNECT, false);
        }
        return true;
    }
}

</t>
<t tx="felix.20200718031424.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { ArchivedPosition, Focus, LeoGotoNavKey, ReqRefresh } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoSettingsProvider } from "./leoSettingsWebview";
import { LeoButtonNode } from "./leoButtons";
import { LeoGotoNode } from "./leoGoto";
import { LeoUndoNode } from "./leoUndos";
import { LeoApOutlineNode } from "./leoApOutline";

var LeoInteg: LeoIntegration | undefined = undefined;

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718031424.2">/**
 * * Called by vscode when extension is activated
 * It creates the leoIntegration instance
 * Will also open the 'welcome/Settings' webview instance if a new version is opened
 */
export function activate(p_context: vscode.ExtensionContext) {

    // * Reset Extension context flags (used in 'when' clauses in package.json)
    utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, false); // Connected to a leobridge server?
    utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, false); // Having a Leo file opened on that server?

    const w_leoIntegExtension = vscode.extensions.getExtension(Constants.PUBLISHER + '.' + Constants.NAME)!;
    const w_leoIntegVersion = w_leoIntegExtension.packageJSON.version;
    const w_leo: LeoIntegration = new LeoIntegration(p_context);
    if (w_leo) {
        LeoInteg = w_leo;
    }
    const w_leoSettingsWebview: LeoSettingsProvider = w_leo.leoSettingsWebview;
    const w_previousVersion = p_context.globalState.get&lt;string&gt;(Constants.VERSION_STATE_KEY);

    // Shortcut pointers for readability
    const U = undefined;
    const BRIDGE = Constants.LEOBRIDGE;
    const CMD = Constants.COMMANDS;

    // * Refresh helper variables: 'states' refresh will also refresh documents pane.
    const REFRESH_NODE_BODY: ReqRefresh = {
        node: true, // Reveal the returned 'selected position' without changes to the tree
        body: true, // Goto/select another node needs the body pane refreshed
        states: true // * Also refreshes documents pane if node's 'changed' state differ.
    };
    const REFRESH_TREE: ReqRefresh = {
        tree: true,
        states: true // * Also refreshes documents pane if node's 'changed' state differ.
    };
    const REFRESH_TREE_BODY: ReqRefresh = {
        tree: true,
        body: true,
        states: true // * Also refreshes documents pane if node's 'changed' state differ.
    };

    const w_commands: [string, (...args: any[]) =&gt; any][] = [

        &lt;&lt; Define entries for all commands &gt;&gt;
    ];

    w_commands.map(function (p_command) {
        p_context.subscriptions.push(vscode.commands.registerCommand(...p_command));
    });

    // * Close remaining Leo Bodies restored by vscode from last session.
    utils.closeLeoTextEditors();

    // * Show a welcome screen on version updates, then start the actual extension.
    showWelcomeIfNewer(w_leoIntegVersion, w_previousVersion, w_leo)
        .then(() =&gt; {
            // if setting for preview mode enabled is false then show popup
            setTimeout(() =&gt; {
                // A second and a half to make sure first installs have finished setting those
                // and not to try to see if they're set too soon
                w_leo.config.checkEnablePreview();
                w_leo.config.checkCloseEmptyGroups();
                w_leo.config.removeOldBodyWrap();
                w_leo.config.checkBodyWrap();
            }, 1500);

            // Start server and/or connect to it, as per user settings
            w_leo.startNetworkServices();
            // Save version # for next startup comparison
            p_context.globalState.update(Constants.VERSION_STATE_KEY, w_leoIntegVersion);

            // * Log time taken for startup
            // console.log('leoInteg startup launched in ', utils.getDurationMs(w_start), 'ms');

        });
}

</t>
<t tx="felix.20200718031424.24">/**
 * * Called when extension is deactivated
 */
export function deactivate(): Thenable&lt;unknown&gt; {
    const q_closeLeoTabs = utils.closeLeoTextEditors();
    if (LeoInteg) {
        LeoInteg.activated = false;
        LeoInteg.cleanupBody().then(() =&gt; {
            LeoInteg?.stopConnection();
        });
        // Call to LeoInteg.stopServer() is not needed: server should handle disconnects.
        // Server should open tk GUI dialogs if dirty files still remain before closing itself.
        return new Promise((p_resolve, p_reject) =&gt; {
            setTimeout(() =&gt; {
                LeoInteg?.killServer();
                p_resolve(true);
            }, 30000);
        }
        );
    } else {
        return q_closeLeoTabs;
    }
}

</t>
<t tx="felix.20200718031424.25">/**
 * * Show welcome screen if needed, based on last version executed
 * @param p_version Current version, as a string, from packageJSON.version
 * @param p_previousVersion Previous version, as a string, from context.globalState.get service
 * @returns A promise that triggers when command to show the welcome screen is finished, or immediately if not needed
 */
async function showWelcomeIfNewer(p_version: string, p_previousVersion: string | undefined, p_leoInteg: LeoIntegration): Promise&lt;unknown&gt; {
    let w_showWelcomeScreen: boolean = false;
    if (p_previousVersion === undefined) {
        // Force-Set/Clear leointeg's required configuration settings
        p_leoInteg.config.setEnablePreview();
        p_leoInteg.config.clearCloseEmptyGroups();
        w_showWelcomeScreen = true;
    } else {
        if (p_previousVersion !== p_version) {
            vscode.window.showInformationMessage(`leoInteg upgraded from v${p_previousVersion} to v${p_version}`);
            // Force-Set/Clear leointeg's required configuration settings but show info messages

            p_leoInteg.config.checkEnablePreview(true);
            p_leoInteg.config.checkCloseEmptyGroups(true);
            p_leoInteg.config.removeOldBodyWrap();
            p_leoInteg.config.checkBodyWrap(true);

        }
        const [w_major, w_minor] = p_version.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        const [w_prevMajor, w_prevMinor] = p_previousVersion.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        if (
            (w_major === w_prevMajor &amp;&amp; w_minor === w_prevMinor) ||
            // Don't notify on downgrades
            (w_major &lt; w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &lt; w_prevMinor))
        ) {
            w_showWelcomeScreen = false;
        } else if (w_major !== w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &gt; w_prevMinor)) {
            // Will show on major or minor upgrade (Formatted as 'Major.Minor.Revision' eg. 1.2.3)
            w_showWelcomeScreen = true;
        }
    }
    if (w_showWelcomeScreen) {
        return vscode.commands.executeCommand(Constants.COMMANDS.SHOW_WELCOME);
    } else {
        return Promise.resolve();
    }
}
</t>
<t tx="felix.20200718035737.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import {
    AskMessageItem,
    Focus,
    runAskYesNoDialogParameters,
    runWarnMessageDialogParameters,
    runInfoMessageDialogParameters,
    showSaveAsDialogParameters
} from "./types";
import { LeoIntegration } from "./leoIntegration";

@others
</t>
<t tx="felix.20200718040540.1">import * as vscode from "vscode";
import * as utils from "./utils";
import * as path from 'path';
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { BodyTimeInfo } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718040540.10">public stat(p_uri: vscode.Uri): vscode.FileStat | Thenable&lt;vscode.FileStat&gt; {
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        const w_gnx = utils.leoUriToStr(p_uri);
        // console.log('Calling stats for ' + w_gnx);
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            return { type: vscode.FileType.Directory, ctime: 0, mtime: 0, size: 0 };
            // SPECIAL CASE -----------------------------------------------
        } else if (w_gnx === this.lastGnx &amp;&amp; this._openedBodiesInfo[this.lastGnx]) {
            return {
                type: vscode.FileType.File,
                ctime: this._openedBodiesInfo[this.lastGnx].ctime,
                mtime: this._openedBodiesInfo[this.lastGnx].mtime,
                size: this.lastBodyLength
            };
            // ------------------------------------------------------------
        } else if (this._openedBodiesInfo[w_gnx]) {
            // * GETS IT WITH len(w_v.b.encode('utf-8')) 
            // So length should be equivalent
            return this._leoIntegration.sendAction(
                Constants.LEOBRIDGE.GET_BODY_LENGTH,
                { "gnx": w_gnx }
            ).then((p_result) =&gt; {
                return Promise.resolve(
                    {
                        type: vscode.FileType.File,
                        ctime: this._openedBodiesInfo[w_gnx].ctime,
                        mtime: this._openedBodiesInfo[w_gnx].mtime,
                        size: p_result.len ? p_result.len : 0
                    }
                );
            });
        }
    }
    // throw vscode.FileSystemError.FileNotFound();
    // (Instead of FileNotFound) should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
    return { type: vscode.FileType.File, ctime: 0, mtime: 0, size: 0 };
}

</t>
<t tx="felix.20200718040540.11">public async readFile(p_uri: vscode.Uri): Promise&lt;Uint8Array&gt; {
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            throw vscode.FileSystemError.FileIsADirectory(p_uri);
        } else {
            const w_gnx = utils.leoUriToStr(p_uri);

            // * should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
            // if (!this._openedBodiesInfo[w_gnx]) {
            //     console.warn('readFile: ERROR File not in _openedBodiesInfo! gnx: ', w_gnx);
            // }

            // console.log('body read bodyGNX', w_gnx);
            let w_buffer: Uint8Array;

            // * GET FROM SERVER
            const p_result = await this._leoIntegration.sendAction(
                Constants.LEOBRIDGE.GET_BODY,
                { "gnx": w_gnx }
            );

            if (p_result.body) {
                // console.log('back from read gnx: ', w_gnx, '   - read ok has body');

                if (this.lastGnx === w_gnx &amp;&amp; this.lastBodyData === p_result.body) {
                    // If EXACT SAME body has refreshed, clear prevent preventIconChange
                    // (because _onDocumentChanged will not be triggered)
                    // Otherwise, changing a character wont change the icon, until the next change.
                    this._leoIntegration.preventIconChange = false;
                }

                this.lastGnx = w_gnx;
                this.lastBodyData = p_result.body;
                w_buffer = Buffer.from(p_result.body);
                this.lastBodyLength = w_buffer.byteLength;

            } else if (p_result.body === "") {
                // console.log('back from read gnx: ', w_gnx, '  - read ok has empty body');

                this.lastGnx = w_gnx;
                this.lastBodyData = "";
                w_buffer = Buffer.from("");
                this.lastBodyLength = 0;
            } else {
                this._leoIntegration.fullRefresh();
                if (this.lastGnx === w_gnx) {
                    // was last gnx of closed file about to be switched to new document selected
                    w_buffer = Buffer.from(this.lastBodyData || "");
                } else {
                    console.error("ERROR =&gt; readFile of unknown GNX"); // is possibleGnxList updated correctly?
                    //  throw vscode.FileSystemError.FileNotFound();
                    // (Instead of FileNotFound) should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
                    w_buffer = Buffer.from("");
                }
            }

            return w_buffer;
        }
    } else {
        throw vscode.FileSystemError.FileNotFound(p_uri);
    }
}

</t>
<t tx="felix.20200718040540.12">public readDirectory(p_uri: vscode.Uri): Thenable&lt;[string, vscode.FileType][]&gt; {
    if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
        const w_directory: [string, vscode.FileType][] = [];
        w_directory.push([this._lastBodyTimeGnx, vscode.FileType.File]);
        return Promise.resolve(w_directory);
    } else {
        throw vscode.FileSystemError.FileNotFound(p_uri);
    }
}

</t>
<t tx="felix.20200718040540.13">public createDirectory(p_uri: vscode.Uri): void {
    console.warn('Called createDirectory with ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions(p_uri);
}

</t>
<t tx="felix.20200718040540.14">public writeFile(p_uri: vscode.Uri, p_content: Uint8Array, p_options: { create: boolean, overwrite: boolean }): void {
    if (this.preventSaveToLeo) {
        this.preventSaveToLeo = false;
    } else {
        this._leoIntegration.triggerBodySave(true); // Might have been a vscode 'save' via the menu
    }
    const w_gnx = utils.leoUriToStr(p_uri);
    if (!this._openedBodiesInfo[w_gnx]) {
        console.error("Leointeg: Tried to save body other than selected node's body", w_gnx);
    }
    this._setOpenedBodyTime(w_gnx);
    if (w_gnx === this.lastGnx) {
        this.lastBodyLength = p_content.byteLength;
    }
    this._fireSoon({ type: vscode.FileChangeType.Changed, uri: p_uri });
}

</t>
<t tx="felix.20200718040540.15">public rename(p_oldUri: vscode.Uri, p_newUri: vscode.Uri, p_options: { overwrite: boolean }): void {
    console.warn('Called rename on ', p_oldUri.fsPath, p_newUri.fsPath); // should not happen
    this._fireSoon(
        { type: vscode.FileChangeType.Deleted, uri: p_oldUri },
        { type: vscode.FileChangeType.Created, uri: p_newUri }
    );
}

</t>
<t tx="felix.20200718040540.16">public delete(p_uri: vscode.Uri): void {

    const w_gnx = utils.leoUriToStr(p_uri);
    if (this._openedBodiesInfo[w_gnx]) {
        delete this._openedBodiesInfo[w_gnx];
    } else {
        // console.log("not deleted");
    }

    // dirname is just a slash "/"
    let w_dirname = p_uri.with({ path: path.posix.dirname(p_uri.path) });

    this._fireSoon(
        { type: vscode.FileChangeType.Changed, uri: w_dirname },
        { uri: p_uri, type: vscode.FileChangeType.Deleted }
    );
}

</t>
<t tx="felix.20200718040540.17">public copy(p_uri: vscode.Uri): void {
    console.warn('Called copy on ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions(p_uri);
}

</t>
<t tx="felix.20200718040540.18">private _fireSoon(...p_events: vscode.FileChangeEvent[]): void {
    this._bufferedEvents.push(...p_events);
    if (this._fireSoonHandle) {
        clearTimeout(this._fireSoonHandle);
    }
    this._fireSoonHandle = setTimeout(() =&gt; {
        this._onDidChangeFileEmitter.fire(this._bufferedEvents);
        this._bufferedEvents.length = 0; // clearing events array
    }, 5);
}

</t>
<t tx="felix.20200718040540.2">/**
 * * Body panes implementation as a file system using "leo" as a scheme identifier
 */
export class LeoBodyProvider implements vscode.FileSystemProvider {

    // * Flag normally false
    public preventSaveToLeo: boolean = false;

    // * Last file read data with the readFile method
    public lastGnx: string = ""; // gnx of last file read
    public lastBodyData?: string = ""; // body content of last file read
    public lastBodyLength: number = 0; // length of last file read
    // * List of currently VISIBLE opened body panes gnx (from 'watch' &amp; 'dispose' methods)
    public watchedBodiesGnx: string[] = [];

    // * List of gnx open in tab(s) (from tryApplyNodeToBody / switchBody and fs.delete)
    private _openedBodiesInfo: { [key: string]: BodyTimeInfo } = {};

    private _lastBodyTimeGnx: string = "";

    // * An event to signal that a resource has been changed
    // * It should fire for resources that are being [watched](#FileSystemProvider.watch) by clients of this provider
    private _onDidChangeFileEmitter = new vscode.EventEmitter&lt;vscode.FileChangeEvent[]&gt;();
    readonly onDidChangeFile: vscode.Event&lt;vscode.FileChangeEvent[]&gt; = this._onDidChangeFileEmitter.event;
    private _bufferedEvents: vscode.FileChangeEvent[] = [];
    private _fireSoonHandle?: NodeJS.Timer;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718040540.5">/**
 * * Refresh the body pane for a particular gnx by telling vscode that the file from the Leo file provider has changed
 * @param p_gnx Gnx of body associated with this virtual file, mostly Leo's selected node
 */
public fireRefreshFile(p_gnx: string): void {


    this._setOpenedBodyTime(p_gnx);

    if (!this.watchedBodiesGnx.includes(p_gnx)) {
        return; // Document is not being watched (closed tab or non-visible non-dirty tab)
    }
    this._onDidChangeFileEmitter.fire([{
        type: vscode.FileChangeType.Changed,
        uri: utils.strToLeoUri(p_gnx)
    } as vscode.FileChangeEvent]);
}

</t>
<t tx="felix.20200718040540.8">public watch(p_resource: vscode.Uri): vscode.Disposable {
    const w_gnx = utils.leoUriToStr(p_resource);
    if (!this.watchedBodiesGnx.includes(w_gnx)) {
        this.watchedBodiesGnx.push(w_gnx); // add gnx
    } else {
    }
    return new vscode.Disposable(() =&gt; {
        // console.log('DISPOSE watch body  ' + utils.leoUriToStr(p_resource));

        const w_position = this.watchedBodiesGnx.indexOf(w_gnx); // find and remove it
        if (w_position &gt; -1) {
            this.watchedBodiesGnx.splice(w_position, 1);
        }
    });
}

</t>
<t tx="felix.20200718153505.1">import * as vscode from "vscode";
import * as WebSocket from 'ws';
import { Constants } from "./constants";
import { LeoBridgePackage, LeoAction } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoAsync } from "./leoAsync";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718153505.11">/**
 * * Process data that came from the Leo process
 * @param p_data given JSON data
 */
private _processAnswer(p_data: string): void {
    const w_parsedData = this._tryParseJSON(p_data);
    // Check for ServerError

    if (w_parsedData &amp;&amp; w_parsedData['ServerError']) {
        const w_serverError: string = w_parsedData['ServerError'];
        // action not found
        let w_position = w_serverError.indexOf("action not found");
        if (w_position &gt;= 0) {
            let w_action = w_serverError.substring(w_position + 16);
            // Show update suggestion if not already shown
            let w_timeStampSec = Math.floor(Date.now() / 1000);
            if (this._updateWarningShown + 3 &lt; w_timeStampSec) { // Limit to re-show for 3 sec.
                this._updateWarningShown = w_timeStampSec;
                vscode.window.showErrorMessage(
                    Constants.USER_MESSAGES.MINIMUM_LEO_VERSION_STRING + " Command missing: " + w_action
                );
            }
        }
    }

    if (w_parsedData &amp;&amp; (w_parsedData.id === 0 || w_parsedData.id)) {
        this._resolveBridgeReady(w_parsedData);
        this._callAction();
    } else if (w_parsedData &amp;&amp; w_parsedData.async) {
        // * Check for async messages such as log pane entries or other
        this._asyncAction(w_parsedData);
    } else {
        // unprocessed/unknown python output
        console.error("[leoBridge] Unprocessed or unknown JSON received: ", p_data);
    }
}

</t>
<t tx="felix.20200718153505.12">/**
 * * Create a websocket connection to a Leo server
 * @param p_port optional port number to override config port
 * @returns A promise for a LeoBridgePackage object containing only an 'id' member of 1 that will resolve when the 'leoBridge' is established
 */
public initLeoProcess(p_port?: number): Promise&lt;LeoBridgePackage&gt; {
    this._websocket = new WebSocket(
        Constants.TCPIP_DEFAULT_PROTOCOL +
        this._leoIntegration.config.connectionAddress +
        ":" +
        (p_port ? p_port : this._leoIntegration.config.connectionPort)
    );
    // * Capture the python process output
    this._websocket.onmessage = (p_event) =&gt; {
        this._receivedTotal++;
        if (p_event.data) {
            this._processAnswer(p_event.data.toString());
        }
    };
    this._websocket.onerror = (p_event: WebSocket.ErrorEvent) =&gt; {
        console.error(`Websocket error: ${p_event.message}`);
    };
    this._websocket.onclose = (p_event: WebSocket.CloseEvent) =&gt; {
        // * Disconnected from server
        // console.log(`Websocket closed, code: ${p_event.code}`);
        if (!this._leoIntegration.activated) {
            return;
        }
        this._rejectAction(`Websocket closed, code: ${p_event.code}`);
        // TODO : Implement a better connection error handling (optional fileOpenedReady check may be overkill, etc.)
        if (this._leoIntegration.leoStates.leoBridgeReady || this._leoIntegration.leoStates.fileOpenedReady) {
            this._leoIntegration.cancelConnect(`Connection to server closed. Code: ${p_event.code}`);
        }
    };
    // * Start first with 'preventCall' set to true: no need to call anything for the first 'ready'
    this._readyPromise = this.action("", undefined, { id: Constants.STARTING_PACKAGE_ID }, true);
    return this._readyPromise; // This promise will resolve when the started python process starts
}

</t>
<t tx="felix.20200718153505.13">/**
 * * Send into the python process input
 * @param p_data JSON Message string to be sent to leoserver.py
 */
private _send(p_data: string): void {
    if (this._readyPromise) {
        this._readyPromise.then(() =&gt; { // using '.then' that was surely resolved already: to be buffered in case process isn't ready.
            if (this._websocket &amp;&amp; this._websocket.OPEN) {
                this._websocket.send(p_data); // p_message should be json
            }
        });
    }
}

</t>
<t tx="felix.20200718153505.2">/**
 * * Handles communication with the leoserver.py python script via websockets
 * This implements a bridge-facing action stack, (push on top, remove bottom)
 * 'actions' get sent to Leo, and resolve a promise with the result when the answer comes back.
 * This 'stack' concept is similar to the 'CommandStack' class used for vscode's user interactions.
 */
export class LeoBridge {

    private _callStack: LeoAction[] = [];
    private _actionBusy: boolean = false; // Action was started from the bottom, but has yet to resolve

    private _leoBridgeSerialId: number = 0;
    private _readyPromise: Promise&lt;LeoBridgePackage&gt; | undefined;

    private _websocket: WebSocket | null = null;
    private _leoAsync: LeoAsync;

    private _updateWarningShown: number = 0; // timestamp in seconds

    private _receivedTotal: number = 0; // Websocket message received total

    // TODO : #10 @boltex See if this can help with anaconda/miniconda issues
    // private _hasbin = require('hasbin');

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._leoAsync = new LeoAsync(_context, _leoIntegration);
    }

    @others
}
</t>
<t tx="felix.20200718153505.3">/**
 * * Places an action on top of a stack, to be resolved from the bottom
 * @param p_action Command string to be performed by Leo via leoserver.py
 * @param p_param Optional JSON parameter for the specified action
 * @param p_deferredPayload Used to build this._readyPromise that resolves itself at startup
 * @param p_preventCall Flag for special action used to build this._readyPromise that resolves itself at startup
 * @returns a Promise that will contain the JSON package answered back by leoserver.py
 */
public action(p_action: string, p_param?: { [key: string]: any }, p_deferredPayload?: LeoBridgePackage, p_preventCall?: boolean): Promise&lt;LeoBridgePackage&gt; {
    return new Promise((p_resolve, p_reject) =&gt; {
        const w_action: LeoAction = {
            parameter: JSON.stringify(
                {
                    id: ++this._leoBridgeSerialId,
                    action: p_action,
                    param: p_param === undefined ? null : p_param
                }
            ),
            deferredPayload: p_deferredPayload ? p_deferredPayload : undefined,
            resolveFn: p_resolve,
            rejectFn: p_reject
        };

        this._callStack.push(w_action);
        if (!p_preventCall) {
            this._callAction();
        }
    });
}

</t>
<t tx="felix.20200718153505.4">/**
 * * Actions invoked by Leo that can be called asynchronously at any time
 * @param w_parsedData that contains an 'async' string member,
 * that was parsed from a _websocket.onmessage package
 */
private _asyncAction(w_parsedData: any): void {
    if (w_parsedData &amp;&amp; w_parsedData.async &amp;&amp; (typeof w_parsedData.async === "string")) {
        switch (w_parsedData.async) {
            case Constants.ASYNC_ACTIONS.ASYNC_LOG: {
                this._leoAsync.log(w_parsedData.log, w_parsedData.color);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_REFRESH: {
                this._leoAsync.refresh(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_ASK: {
                this._leoAsync.showAskModalDialog(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_WARN: {
                this._leoAsync.showWarnModalMessage(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_INFO: {
                this._leoAsync.showChangesDetectedInfoMessage(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_INTERVAL: {
                console.log("interval ", w_parsedData); // 'ping' interval for debugging
                break;
            }
            default: {
                console.error("[leoIntegration] Unknown async action ", w_parsedData);
                break;
            }
        }
    } else {
        console.error("[leoIntegration] Unknown async command from leoBridge");
    }
}

</t>
<t tx="felix.20200718153505.6">/**
 * * Resolves promises with the answers from an action that was finished
 * @param p_object Parsed data that was given as the answer by the Leo command that finished
 */
private _resolveBridgeReady(p_object: any): void {
    let w_bottomAction = this._callStack.shift();
    if (w_bottomAction) {
        if (w_bottomAction.deferredPayload) {
            // Used when the action already has a return value ready but is also waiting for python's side
            // We check if it's really the initial first, then replace the id and pass the results.
            if (w_bottomAction.deferredPayload.id === Constants.STARTING_PACKAGE_ID) {
                p_object.id = Constants.STARTING_PACKAGE_ID;
            }
            w_bottomAction.resolveFn(p_object); // given back with id=1 !
        } else {
            w_bottomAction.resolveFn(p_object);
        }
        this._actionBusy = false;
    } else {
        console.error("[leoBridge] Error stack empty");
    }
}

</t>
<t tx="felix.20200718153505.7">/**
 * * Rejects an action from the bottom of the stack
 * @param p_reason Given rejection 'reason'
 */
private _rejectAction(p_reason: string): void {
    const w_bottomAction = this._callStack.shift();
    if (w_bottomAction) {
        w_bottomAction.rejectFn(p_reason);
    }
}

</t>
<t tx="felix.20200718153505.8">/**
 * * Sends an action from the bottom of the stack
 */
private _callAction(): void {
    if (this._callStack.length &amp;&amp; !this._actionBusy) {
        this._actionBusy = true; // launch / resolve bottom one
        const w_action = this._callStack[0];
        this._send(w_action.parameter + "\n");
    }
}

</t>
<t tx="felix.20200718153505.9">/**
 * * JSON.parse encased in a Try/Catch block
 * @param p_jsonStr The JSON string to be parsed
 * @returns The resulting object or 'false' if unsuccessful
 */
private _tryParseJSON(p_jsonStr: string): boolean | any {
    try {
        var w_object = JSON.parse(p_jsonStr);
        // JSON.parse(null) returns null, and typeof null === "object", null is falsy, so this suffices:
        if (w_object &amp;&amp; typeof w_object === "object") {
            return w_object;
        }
    }
    catch (e) {
        console.error('[leoBridge] JSON was invalid: ' + p_jsonStr);
    }
    return false;
}

</t>
<t tx="felix.20200718155251.1">/**
 * * Busy state of the leoBridge's command stack
 * @returns true if leoBridge's command stack still has unresolved actions
 */
public isBusy(): boolean {
    return this._actionBusy || !!this._callStack.length;
}

</t>
<t tx="felix.20200718162303.2">/**
 * * Leo @buttons tree view node item implementation, for usage in a TreeDataProvider.
 */
export class LeoButtonNode extends vscode.TreeItem {

    // Context string that is checked in package.json with 'when' clauses
    public contextValue: string;
    public rclicks: RClick[];

    private _id: string;

    // is the special 'add' button used to create button from a given node's script
    private _isAdd: boolean;

    constructor(
        public button: LeoButton,
        private _leoIntegration: LeoIntegration
    ) {
        super(button.name);

        this._id = utils.getUniqueId();

        this._isAdd = (this.button.index.startsWith(Constants.BUTTON_STRINGS.NULL_WIDGET) &amp;&amp;
            this.button.name === Constants.BUTTON_STRINGS.SCRIPT_BUTTON);
        this.rclicks = button.rclicks ? button.rclicks : [];
        this.contextValue = this._isAdd ? Constants.BUTTON_STRINGS.ADD_BUTTON : Constants.BUTTON_STRINGS.NORMAL_BUTTON;
    }

    @others
}

</t>
<t tx="felix.20200718162435.1">// @ts-ignore
public get iconPath(): Icon {
    return this._leoIntegration.buttonIcons[this._isAdd ? 2 : this.rclicks.length ? 1 : 0];
}

</t>
<t tx="felix.20200718162442.1">// @ts-ignore
public get id(): string {
    // Add prefix and suffix salt to index to prevent accidental duplicates
    return this._id;
    // return "p" + this.button.index + "s" + this.button.name;
}

</t>
<t tx="felix.20200718162452.1">// @ts-ignore
public get tooltip(): string {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON_TOOLTIP;
    } else {
        return this.button.name;
    }
}

</t>
<t tx="felix.20200718162459.1">// @ts-ignore
public get description(): string | boolean {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20200718164130.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import * as utils from "./utils";
import { LeoButton, RClick } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718164130.2">/**
 * * '@buttons' shown as a list with this TreeDataProvider implementation
 */
export class LeoButtonsProvider implements vscode.TreeDataProvider&lt;LeoButtonNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoButtonNode | undefined&gt; = new vscode.EventEmitter&lt;LeoButtonNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoButtonNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}

</t>
<t tx="felix.20200718164130.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718164130.4">public getTreeItem(element: LeoButtonNode): Thenable&lt;LeoButtonNode&gt; | LeoButtonNode {
    return element;
}

</t>
<t tx="felix.20200718164130.5">public getChildren(element?: LeoButtonNode): Thenable&lt;LeoButtonNode[]&gt; {
    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

        // call action to get get list, and convert to LeoButtonNode(s) array
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BUTTONS).then(p_package =&gt; {
            if (p_package &amp;&amp; p_package.buttons) {
                const w_list: LeoButtonNode[] = [];
                const w_buttons: LeoButton[] = p_package.buttons;
                if (w_buttons &amp;&amp; w_buttons.length) {
                    w_buttons.forEach((p_button: LeoButton) =&gt; {
                        w_list.push(new LeoButtonNode(p_button, this._leoIntegration));
                    });
                }
                return w_list;
            } else {
                return [];
            }
        });
    } else {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
}

</t>
<t tx="felix.20200718164130.6">public getParent(element: LeoButtonNode): ProviderResult&lt;LeoButtonNode&gt; | null {
    // Buttons are just a list, as such, entries are always child of root so return null
    return null;
}

</t>
<t tx="felix.20200718164509.2">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoDocumentNode extends vscode.TreeItem {

    // Context string is checked in package.json with 'when' clauses
    public contextValue: string;

    constructor(
        public documentEntry: LeoDocument,
        private _leoIntegration: LeoIntegration
    ) {
        super(documentEntry.name);
        // Setup this instance
        const w_isNamed: boolean = !!this.documentEntry.name;
        this.label = w_isNamed ? utils.getFileFromPath(this.documentEntry.name) : Constants.UNTITLED_FILE_NAME;
        this.tooltip = w_isNamed ? this.documentEntry.name : Constants.UNTITLED_FILE_NAME;
        this.command = {
            command: Constants.COMMANDS.SET_OPENED_FILE,
            title: '',
            arguments: [this.documentEntry.index]
        };
        // If this was created as a selected node, make sure it's selected as we may have opened/closed document
        if (this.documentEntry.selected) {
            this._leoIntegration.setDocumentSelection(this);
            this.contextValue = w_isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_UNTITLED;
        } else {
            this.contextValue = w_isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_UNTITLED;
        }
    }

    @others
}
</t>
<t tx="felix.20200718164635.1">// @ts-ignore
public get iconPath(): Icon {
    return this._leoIntegration.documentIcons[this.documentEntry.changed ? 1 : 0];
}

</t>
<t tx="felix.20200718164638.1">// @ts-ignore
public get id(): string {
    // Add prefix and suffix salt to numeric index to prevent accidental duplicates
    // Should be unique when refreshed
    // return this._id;
    return "c" + (this.documentEntry.changed ? "y" : "n") +
        "p" + this.documentEntry.index +
        "s" + this.documentEntry.name;
}

</t>
<t tx="felix.20200718165108.1">import * as vscode from "vscode";
import * as utils from './utils';
import { LeoIntegration } from "./leoIntegration";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoDocument } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718165108.2">/**
 * * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
export class LeoDocumentsProvider implements vscode.TreeDataProvider&lt;LeoDocumentNode&gt; {

    public lastDocumentList: LeoDocumentNode[] = [];

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoDocumentNode | undefined&gt; = new vscode.EventEmitter&lt;LeoDocumentNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoDocumentNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}

</t>
<t tx="felix.20200718165108.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718165108.4">public getTreeItem(element: LeoDocumentNode): Thenable&lt;LeoDocumentNode&gt; | LeoDocumentNode {
    return element;
}

</t>
<t tx="felix.20200718165108.5">public getChildren(element?: LeoDocumentNode): Thenable&lt;LeoDocumentNode[]&gt; {

    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

        // call action to get get list, and convert to LeoDocumentNode(s) array
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_OPENED_FILES).then(p_package =&gt; {
            if (p_package &amp;&amp; p_package.files) {
                const w_list: LeoDocumentNode[] = [];
                const w_files: LeoDocument[] = p_package.files;
                let w_index: number = 0;
                if (w_files &amp;&amp; w_files.length) {
                    w_files.forEach((i_file: LeoDocument) =&gt; {
                        i_file.index = w_index;
                        w_list.push(new LeoDocumentNode(i_file, this._leoIntegration));
                        w_index++;
                    });
                }
                this.lastDocumentList = w_list;
                return w_list;
            } else {
                this.lastDocumentList = [];
                return [];
            }
        });
    } else {
        this.lastDocumentList = [];
        return Promise.resolve([]); // Defaults to an empty list of children
    }
}

</t>
<t tx="felix.20200718165108.6">public getParent(element: LeoDocumentNode): ProviderResult&lt;LeoDocumentNode&gt; | null {
    // Leo documents are just a list, as such, entries are always child of root, so return null
    return null;
}

</t>
<t tx="felix.20200718165721.1"></t>
<t tx="felix.20200718170429.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import * as utils from './utils';
import * as path from "path"; // TODO : Use this to have reliable support for window-vs-linux file-paths

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718170429.2">/**
 * * Handles opening of file browser when choosing which Leo file to open
 */
export class LeoFilesBrowser {

    private _fileBrowserActive: boolean = false;

    constructor(private _context: vscode.ExtensionContext) { }

    @others
}
</t>
<t tx="felix.20200718170429.3">/**
 * * Finds a folder to propose when opening the browse-for-leo-file chooser
 * @returns An Uri for path to a folder for initial opening
 */
private _getBestOpenFolderUri(): vscode.Uri {
    let w_openedFileEnvUri: vscode.Uri | boolean = false;
    let w_activeUri: vscode.Uri | undefined = undefined;

    if (vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders[0]) {
        w_activeUri = vscode.workspace.workspaceFolders[0].uri;
    }

    if (w_activeUri) {
        const w_defaultFolder = vscode.workspace.getWorkspaceFolder(w_activeUri);
        if (w_defaultFolder) {
            w_openedFileEnvUri = w_defaultFolder.uri; // Set as current opened document-path's folder
        }
    }
    if (!w_openedFileEnvUri) {
        w_openedFileEnvUri = vscode.Uri.file("~"); // TODO : set as home folder properly, this doesn't work
        // ! EXAMPLE WITH os : const homedir = require('os').homedir();
    }
    return w_openedFileEnvUri;
}

</t>
<t tx="felix.20200718170429.4">/**
 * * Open a file browser and let the user choose a Leo file or cancel the operation
 * @param p_saveAsFlag Optional flag that will ask for a 'save' path+filename
 * @returns A promise resolving to a chosen path string, or rejected with an empty string if cancelled
 */
public getLeoFileUrl(p_saveAsFlag?: boolean, p_customTitle?: string): Promise&lt;string&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve("");
    }
    this._fileBrowserActive = true;
    return new Promise((p_resolve, p_reject) =&gt; {
        const w_filters: { [name: string]: string[] } = {};
        w_filters[Constants.FILE_OPEN_FILTER_MESSAGE] = [
            Constants.FILE_EXTENSION,
            Constants.JS_FILE_EXTENSION,
            Constants.DB_FILE_EXTENSION
        ];

        if (p_saveAsFlag) {
            // Choose file
            vscode.window.showSaveDialog({
                saveLabel: "Save Leo File",
                defaultUri: this._getBestOpenFolderUri(),
                filters: w_filters,
                title: p_customTitle ? p_customTitle : "Save as Leo File"
            })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // single string
                        p_resolve(utils.fixSlashesDriveLetter(p_chosenLeoFile.fsPath));
                    } else {
                        p_resolve(""); // not rejection - resolve empty string
                    }
                });
        } else {
            vscode.window
                .showOpenDialog({
                    canSelectMany: false,
                    defaultUri: this._getBestOpenFolderUri(),
                    canSelectFolders: false,
                    filters: w_filters,
                    title: p_customTitle ? p_customTitle : "Open Leo File"
                })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // array instead of single string
                        p_resolve(utils.fixSlashesDriveLetter(p_chosenLeoFile[0].fsPath));
                    } else {
                        p_resolve("");
                    }
                });
        }
    });
}

</t>
<t tx="felix.20200718185403.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718185403.2">/**
 * * Statusbar indicator controller service
 */
export class LeoStatusBar {

    private _leoStatusBarItem: vscode.StatusBarItem;
    private _updateStatusBarTimeout: NodeJS.Timeout | undefined;
    public unlString: string = ""; // Use this string with indicator, using this will replace the default from config

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._leoStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
        // this._leoStatusBarItem.color = this._leoIntegration.config.statusBarColor;
        const w_mdToolTip = new vscode.MarkdownString();
        w_mdToolTip.isTrusted = true;
        w_mdToolTip.supportThemeIcons = true;
        w_mdToolTip.value = `\

        #### [Click to copy UNL to clipboard](command:${Constants.COMMANDS.STATUS_BAR})

        ---

        _Or choose a specific UNL type:_

        **[short gnx](command:${Constants.COMMANDS.SHORT_GNX_UNL_TO_CLIPBOARD})** 
        **[full gnx](command:${Constants.COMMANDS.FULL_GNX_UNL_TO_CLIPBOARD})**

        **[short legacy](command:${Constants.COMMANDS.SHORT_LEGACY_UNL_TO_CLIPBOARD})** 
        **[full legacy](command:${Constants.COMMANDS.FULL_LEGACY_UNL_TO_CLIPBOARD})**

        `.replace(/\n {8}/g, '\n');


        this._leoStatusBarItem.command = Constants.COMMANDS.STATUS_BAR;
        this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR;
        this._leoStatusBarItem.tooltip = w_mdToolTip;
        this._context.subscriptions.push(this._leoStatusBarItem);
        this._leoStatusBarItem.hide();
    }

    @others
}
</t>
<t tx="felix.20200718185403.3">/**
 * * Makes the statusbar indicator visible
 */
public show(): void {
    this._leoStatusBarItem.show();
}

</t>
<t tx="felix.20200718185403.4">/**
 * * Hides the statusbar indicator
 */
public hide(): void {
    this._leoStatusBarItem.hide();
}

</t>
<t tx="felix.20200718185403.6">/**
 * * Sets string to replace default from config &amp; refresh it
 * @p_string string to be displayed on Leo's status bar space.
 * @param p_debounceDelay Optional, in milliseconds
 * 
 */
public setString(p_string: string, p_debounceDelay?: number): void {
    if (this.unlString === p_string) {
        return; // cancel
    }
    this.unlString = p_string;
    if (p_debounceDelay) {
        this._updateLeoObjectIndicatorDebounced(p_debounceDelay);
    } else {
        this._updateLeoObjectIndicator();
    }
}
</t>
<t tx="felix.20200718185403.7">/**
 * * Updates the status bar visual indicator flag in a debounced manner
 * @param p_delay number of milliseconds
 */
private _updateLeoObjectIndicatorDebounced(p_delay: number): void {
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }
    this._updateStatusBarTimeout = setTimeout(() =&gt; {
        this._updateLeoObjectIndicator();
    }, p_delay);
}

</t>
<t tx="felix.20200718185403.8">/**
 * * Updates the status bar visual indicator flag directly
 */
private _updateLeoObjectIndicator(): void {
    // Can be called directly, so clear timer if any
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }
    this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR + this.unlString;
}

</t>
<t tx="felix.20200718191946.1">import * as os from 'os';
import * as fs from 'fs';
import * as child from 'child_process';
import * as path from "path"; // TODO : Use this to have reliable support for window-vs-linux file-paths
import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from './leoIntegration';
var kill = require('tree-kill');

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718191946.2">/**
 * * Leo bridge server service
 * Provides simple automatic leo bridge server startup functionality
 */
export class ServerService {
    // TODO : See #10 @boltex Problem starting the leo-bridge server automatically with anaconda/miniconda on windows
    // See https://github.com/yhirose/vscode-filtertext/blob/master/src/extension.ts#L196

    private _platform: string;
    private _isWin32: boolean;
    private _skippedFirstEmpty = false; // if first ever empty line was skipped. (for esthetics only)
    public usingPort: number = 0; // set to other than zero if server is started by leointeg itself

    /**
     * * Leo Bridge Server Process
     */
    private _serverProcess: child.ChildProcess | undefined;

    private _resolvePromise: ((value?: unknown) =&gt; void) | undefined;
    private _rejectPromise: ((reason?: any) =&gt; void) | undefined;

    private _isStarted: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._platform = os.platform();
        this._isWin32 = this._platform === "win32";
    }

    @others
}

</t>
<t tx="felix.20200718191946.4">/**
 * * Get command from settings or best command for the current OS
 * @param p_leoPythonCommand String command to start python on this computer
 * @returns A promise that resolves when the server is started, or that is rejected in case of problem while starting
 */
public startServer(p_leoPythonCommand: string, p_leoEditorPath: string, p_port: number): Promise&lt;any&gt; {

    /*
        * -----------------------------------------------------------------
        * Documentation for child_process.spawn(command[, args][, options])
        * -----------------------------------------------------------------

        The child_process.spawn() method spawns a new process
        using the given command, with command-line arguments in args.
        If omitted, args defaults to an empty array.

        If the shell option is enabled, do not pass unsanitized
        user input to this function. Any input containing shell
        metacharacters may be used to trigger arbitrary command execution.

        A third argument may be used to specify additional options, with these defaults:

        const defaults = {
            cwd: undefined,
            env: process.env
        };
    */

    this._skippedFirstEmpty = false;

    if (!p_leoEditorPath || !p_leoEditorPath.trim()) {
        return Promise.reject(Constants.USER_MESSAGES.LEO_PATH_MISSING);
    }
    p_leoEditorPath = p_leoEditorPath.trim();

    let w_pythonPath = ""; // Command of child.spawn call

    return utils.findNextAvailablePort(p_port).then((p_availablePort) =&gt; {
        if (!p_availablePort) {
            // vscode.window.showInformationMessage("Port " + p_port+" already in use.");
            return Promise.reject("Port " + p_port + " already in use.");
        }

        this.usingPort = p_availablePort;

        // Leo Editor installation path is mandatory - Start with Leo Editor's folder
        let w_serverScriptPath = p_leoEditorPath + Constants.SERVER_PATH;

        try {
            if (fs.existsSync(w_serverScriptPath + Constants.SERVER_NAME)) {
                w_serverScriptPath += Constants.SERVER_NAME;
            } else {
                return Promise.reject(Constants.USER_MESSAGES.CANNOT_FIND_SERVER_SCRIPT);
            }
        } catch (p_err) {
            console.error(p_err);
            return Promise.reject(Constants.USER_MESSAGES.CANNOT_FIND_SERVER_SCRIPT);
        }

        if (p_leoPythonCommand &amp;&amp; p_leoPythonCommand.length) {
            // Start by running command (see executeCommand for multiple useful snippets)
            w_pythonPath = p_leoPythonCommand; // Set path
        } else {
            w_pythonPath = Constants.DEFAULT_PYTHON;
            if (this._isWin32) {
                w_pythonPath = Constants.WIN32_PYTHON;
            }
        }

        const w_serverStartPromise = new Promise((p_resolve, p_reject) =&gt; {
            // Spawn a python child process for a leoBridge server
            this._resolvePromise = p_resolve;
            this._rejectPromise = p_reject;
        });

        // Setup arguments: Order is important!
        let w_args: string[] = []; //  "\"" + w_serverScriptPath + "\"" // For on windows ??

        // on windows, if the default py is used, make sure it's got a '-3'
        if (this._isWin32 &amp;&amp; w_pythonPath === "py") {
            w_args.push("-3");
        }

        // The server script itself
        w_args.push(w_serverScriptPath);

        if (this._leoIntegration.config.limitUsers &gt; 1 &amp;&amp;
            this._leoIntegration.config.limitUsers &lt; 256) {
            w_args.push("--limit");
            w_args.push(this._leoIntegration.config.limitUsers.toString());
        }

        // Add port
        w_args.push("--port");
        w_args.push(this.usingPort.toString());

        const w_options: child.SpawnOptions = {
            // Child to run independently of its parent process.
            // (Depends on the platform)
            detached: this._leoIntegration.config.setDetached,
            // If possible hide the terminal window that could appear
            windowsHide: true,
        };

        this._leoIntegration.addLogPaneEntry(
            'Launching server with command: ' +
            w_pythonPath + " " + w_args.join(" ")
        );

        // Spawn the process
        this._serverProcess = child.spawn(w_pythonPath, w_args, w_options);

        // To prevent the parent from waiting for a given subprocess to exit
        this._serverProcess.unref();

        // Capture the OUTPUT and send it to the "leo server" OutputChannel
        if (this._serverProcess &amp;&amp; this._serverProcess.stdout) {
            this._serverProcess.stdout.on("data", (p_data: string) =&gt; {
                this._processServerOutput(p_data);
            });
        } else {
            console.error("No stdout");
        }
        // Capture the ERROR channel and set flags on server errors
        if (this._serverProcess &amp;&amp; this._serverProcess.stderr) {
            this._serverProcess.stderr.on("data", (p_data: string) =&gt; {
                if (p_data.toLocaleLowerCase().includes('warning:')) {
                    vscode.window.showInformationMessage(
                        "leoserver issued warning: ",
                        p_data
                    );
                    return;
                }
                console.log(`stderr: ${p_data}`);

                if (!this._leoIntegration.activated) {
                    return;
                }

                this.killServer();

                if (this._rejectPromise) {
                    this._rejectPromise(`stderr: ${p_data}`);
                }

            });
        } else {
            console.error("No stderr");
        }
        // Capture the CLOSE event and set flags on server actually closing
        if (this._serverProcess) {

            this._serverProcess.on("close", (p_code: any) =&gt; {
                console.log(`Leo server process closed with code ${p_code}`);
                this._isStarted = false;
                if (!this._leoIntegration.activated) {
                    return;
                }
                utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);

                this._leoIntegration.leoStates.leoConnecting = false;
                this._leoIntegration.leoStates.leoBridgeReady = false;
                this._leoIntegration.leoStates.fileOpenedReady = false;
                this._leoIntegration.leoStates.leoStartingServer = false;

                this._serverProcess = undefined;
                if (this._rejectPromise) {
                    this._rejectPromise(`Leo server exited with code ${p_code}`);
                }
            });

            this._serverProcess.on('error', (err: Error &amp; { code?: string; path?: string }) =&gt; {
                console.error('Failed to start subprocess:', err);

                const errorTable: { [key: string]: string } = {
                    'ENOENT': 'ENOENT: File or command not found.',
                    'EACCES': 'EACCES: Permission denied.',
                    'ENOMEM': 'ENOMEM: Not enough memory to start the process.',
                    'EAGAIN': 'EAGAIN: Resource temporarily unavailable.',
                    'EINVAL': 'EINVAL: Invalid argument.',
                    'EMFILE': 'EMFILE: Too many open files in system.',
                    'ENFILE': 'ENFILE: File table overflow.',
                    'ESRCH': 'ESRCH: No such process.',
                    'EIO': 'EIO: Input/output error.',
                    'EISDIR': 'EISDIR: Illegal operation on a directory.'
                };

                let message;
                if (err.code === 'ENOENT') {
                    message = "System could not resolve path to launch python: " + err.path;
                } else if (err.code &amp;&amp; errorTable[err.code]) {
                    message = "Process exited with error:" + errorTable[err.code];
                } else {
                    message = "Process exited with error:" + err.message;
                }

                this.killServer();

                if (this._rejectPromise) {
                    this._rejectPromise(message);
                }
            });

            // Capture the EXIT event
            this._serverProcess.on('exit', (code, signal) =&gt; {
                console.log(`Leo server process exited with code: ${code}, signal: ${signal}`);
            });

        }
        // Give out the promise that will resolve when the server is started
        return w_serverStartPromise;
    });

}

</t>
<t tx="felix.20200718192351.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { ArchivedPosition, LeoPackageStates } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718192411.1">/**
 * * Global states service
 * Holds state flags used to restrict command availability and icon visibility
 * Changes UI by changing vscode's context variables
 */
export class LeoStates {

    public qLastContextChange: Thenable&lt;unknown&gt;; // Promise that the last state change is applied
    public leoCommanderId: string = "";

    // * Currently starting up a server
    private _leoStartingServer: boolean = false;
    get leoStartingServer(): boolean {
        return this._leoStartingServer;
    }
    set leoStartingServer(p_value: boolean) {
        this._leoStartingServer = p_value;
        this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.STARTING_SERVER, p_value);
    }

    // * Currently establishing connection to a server
    private _leoConnecting: boolean = false;
    get leoConnecting(): boolean {
        return this._leoConnecting;
    }
    set leoConnecting(p_value: boolean) {
        this._leoConnecting = p_value;
        this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.CONNECTING, p_value);
    }

    // * Finished startup check for server-start and auto-connect
    private _leoStartupFinished: boolean = false;
    get leoStartupFinished(): boolean {
        return this._leoStartupFinished;
    }
    set leoStartupFinished(p_value: boolean) {
        this._leoStartupFinished = p_value;
        this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.STARTUP_FINISHED, p_value);
    }

    @others
}
</t>
<t tx="felix.20200718192411.2">public setSelectedNodeFlags(p_node: ArchivedPosition): void {
    this.leoCanHoist = !p_node._isRoot; // * ALSO set in setRoot of LeoNode class

    this.leoMarked = p_node.marked;
    this.leoCloned = p_node.cloned;
    this.leoDirty = p_node.dirty;
    this.leoEmpty = !p_node.hasBody;
    this.leoChild = p_node.hasChildren; // !(p_node.collapsibleState === vscode.TreeItemCollapsibleState.None);
    this.leoAtFile = p_node.atFile;
}

</t>
<t tx="felix.20200718192411.3">public setLeoStateFlags(p_states: LeoPackageStates): void {
    this.leoCommanderId = p_states.commanderId;
    this.leoChanged = p_states.changed; // Documents will be refresh if this changes

    this.leoCanUndo = p_states.canUndo;
    this.leoCanRedo = p_states.canRedo;

    this.leoCanGoBack = p_states.canGoBack;
    this.leoCanGoNext = p_states.canGoNext;

    this.leoCanDemote = p_states.canDemote;
    this.leoCanPromote = p_states.canPromote;

    this.leoCanHoist = p_states.canHoist;
    this.leoCanDehoist = p_states.canDehoist;

    this.leoInChapter = p_states.inChapter;
    this.leoTopHoistChapter = p_states.topHoistChapter;

}
</t>
<t tx="felix.20200718193219.1">// * Connected to a Leo bridge server
private _leoBridgeReady: boolean = false;
get leoBridgeReady(): boolean {
    return this._leoBridgeReady;
}
set leoBridgeReady(p_value: boolean) {
    this._leoBridgeReady = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, p_value);
}

</t>
<t tx="felix.20200718193222.1">// * A Leo file is opened
private _fileOpenedReady: boolean = false; // Sets context flag along with treeview title
get fileOpenedReady(): boolean {
    return this._fileOpenedReady;
}
set fileOpenedReady(p_value: boolean) {
    this._fileOpenedReady = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, p_value);
    this._leoIntegration.setTreeViewTitle(
        p_value ? Constants.GUI.TREEVIEW_TITLE : Constants.GUI.TREEVIEW_TITLE_INTEGRATION
    );
    if (p_value) {
        this._leoIntegration.serverOpenedFileName = this._leoOpenedFileName; // will trigger outline pane title decorations
    } else {
        this._leoIntegration.serverOpenedFileName = "";
    }
}

</t>
<t tx="felix.20200718193226.1">// * Currently opened Leo file path and name, empty string if new unsaved file.
private _leoOpenedFileName: string = "";
get leoOpenedFileName(): string {
    return this._leoOpenedFileName;
}
set leoOpenedFileName(p_name: string) {

    if (!p_name) {
        p_name = "";
    }
    if (p_name === this._leoOpenedFileName) {
        // same!
        return;
    }

    if (p_name &amp;&amp; p_name.length) {
        this._leoOpenedFileName = p_name;
        this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, true);
    } else {
        this._leoOpenedFileName = "";
        this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, false);
    }
    // is new so make sure it's also the same.
    this._leoIntegration.serverOpenedFileName = p_name; // will trigger outline pane title decorations
}

</t>
<t tx="felix.20200718193230.1">// * 'states' flags for currently opened tree view
private _leoChanged: boolean = false;
get leoChanged(): boolean {
    return this._leoChanged;
}
set leoChanged(p_value: boolean) {
    if (this._leoChanged !== p_value) {
        // Refresh Documents Panel
        this._leoIntegration.refreshDocumentsPane();
    }
    this._leoChanged = p_value;
    this._leoIntegration.setTreeViewTitle(); // Will refresh the '*' to signify document changed.
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CHANGED, p_value);
}

</t>
<t tx="felix.20200718193233.1">private _leoCanUndo: boolean = false;
get leoCanUndo(): boolean {
    return this._leoCanUndo;
}
set leoCanUndo(p_value: boolean) {
    this._leoCanUndo = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_UNDO, p_value);
}

</t>
<t tx="felix.20200718193235.1">private _leoCanRedo: boolean = false;
get leoCanRedo(): boolean {
    return this._leoCanRedo;
}
set leoCanRedo(p_value: boolean) {
    this._leoCanRedo = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_REDO, p_value);
}

</t>
<t tx="felix.20200718193238.1">private _leoCanDemote: boolean = false;
get leoCanDemote(): boolean {
    return this._leoCanDemote;
}
set leoCanDemote(p_value: boolean) {
    this._leoCanDemote = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEMOTE, p_value);
}

</t>
<t tx="felix.20200718193241.1">private _leoCanPromote: boolean = false;
get leoCanPromote(): boolean {
    return this._leoCanPromote;
}
set leoCanPromote(p_value: boolean) {
    this._leoCanPromote = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_PROMOTE, p_value);
}

</t>
<t tx="felix.20200718193244.1">private _leoCanDehoist: boolean = false;
get leoCanDehoist(): boolean {
    return this._leoCanDehoist;
}
set leoCanDehoist(p_value: boolean) {
    this._leoCanDehoist = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEHOIST, p_value);
}

</t>
<t tx="felix.20200718193338.1">// * 'states' flags about current selection, for visibility and commands availability=
private _leoMarked: boolean = false;
get leoMarked(): boolean {
    return this._leoMarked;
}
set leoMarked(p_value: boolean) {
    this._leoMarked = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_value);
}

</t>
<t tx="felix.20200718193341.1">private _leoCloned: boolean = false;
get leoCloned(): boolean {
    return this._leoCloned;
}
set leoCloned(p_value: boolean) {
    this._leoCloned = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CLONE, p_value);
}

</t>
<t tx="felix.20200718193343.1">private _leoDirty: boolean = false;
get leoDirty(): boolean {
    return this._leoDirty;
}
set leoDirty(p_value: boolean) {
    this._leoDirty = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_DIRTY, p_value);
}

</t>
<t tx="felix.20200718193348.1">private _leoEmpty: boolean = false;
get leoEmpty(): boolean {
    return this._leoEmpty;
}
set leoEmpty(p_value: boolean) {
    this._leoEmpty = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_EMPTY, p_value);
}

</t>
<t tx="felix.20200718193350.1">private _leoChild: boolean = false; // Has child
get leoChild(): boolean {
    return this._leoChild;
}
set leoChild(p_value: boolean) {
    this._leoChild = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CHILD, p_value);
}

</t>
<t tx="felix.20200718193353.1">private _leoAtFile: boolean = false;
get leoAtFile(): boolean {
    return this._leoAtFile;
}
set leoAtFile(p_value: boolean) {
    this._leoAtFile = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_ATFILE, p_value);
}

</t>
<t tx="felix.20200718193500.1">constructor(
    private _context: vscode.ExtensionContext,
    private _leoIntegration: LeoIntegration
) {
    this.qLastContextChange = Promise.resolve(); // Temporary.
}

</t>
<t tx="felix.20200718193719.1"></t>
<t tx="felix.20200718193731.1"></t>
<t tx="felix.20200718194857.1">import * as vscode from "vscode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718194857.10">/**
 * * Main interface for JSON sent from Leo back to leoInteg
 */
export interface LeoBridgePackage {
    // * Common to all result packages
    id: number;
    // * Possible answers from a "Constants.LEOBRIDGE" command
    leoID?: string;
    valid?: boolean;
    gnx?: string[]; // get_all_gnx
    len?: number; // get_body_length
    body?: string; // get_body
    buttons?: LeoButton[]; // get_buttons
    branch?: string;
    commit?: string;
    chapters?: string[], // get_chapters
    history?: string[],
    navList?: LeoGoto[]; // get_goto
    navText?: string; // get_goto
    messages?: string[]; // get_goto
    navOptions?: { isTag: boolean, showParents: boolean }; // get_goto
    commands?: vscode.QuickPickItem[]; // getCommands
    commander?: {
        changed: boolean,
        fileName: string;
        id: string;
    }
    "position-data-list"?: ArchivedPosition[];
    "position-data-dict"?: { [key: string]: ArchivedPosition };
    filename?: string; // set_opened_file, open_file(s), ?close_file
    files?: LeoDocument[]; // get_all_open_commanders
    focus?: string; // find_next, find_previous
    found?: boolean // find_next, find_previous
    range?: [number, number] // find_next, find_previous
    index?: number; // get_all_open_commanders
    language?: string; // get_body_states
    wrap?: boolean; // get_body_states
    tabWidth?: number | boolean; // get_body_states either the tabwidth or falsy
    node?: ArchivedPosition; // get_parent, set_opened_file, open_file(s), ?close_file
    children?: ArchivedPosition[]; // get_children
    searchSettings?: LeoGuiFindTabManagerSettings // get_search_settings
    selection?: BodySelectionInfo; // get_body_states
    states?: LeoPackageStates; // get_ui_states
    string?: string; // from cut / copy outline
    total?: number; // set_opened_file, open_file(s), close_file
    ua?: any;
    version?: string;
    major?: number;
    minor?: number;
    patch?: number;
    bead?: number;
    undos?: string[];
    unl?: string;
}

</t>
<t tx="felix.20200718194857.11">/**
 * * Leo document structure used in the 'Opened Leo Documents' tree view provider sent back by the server
 */
export interface LeoDocument {
    id: string; // Commander's id
    name: string;
    index: number;
    changed: boolean;
    selected: boolean;
}

</t>
<t tx="felix.20200718194857.12">/**
 * * Leo '@button' structure used in the '@buttons' tree view provider sent back by the server
 */
export interface LeoButton {
    name: string;
    rclicks?: RClick[];
    index: string; // STRING KEY
}

</t>
<t tx="felix.20200718194857.13">/**
 * * Icon path names used in leoNodes for rendering in treeview
 */
export interface Icon {
    light: string | vscode.Uri;
    dark: string | vscode.Uri;
}

</t>
<t tx="felix.20200718194857.14">/**
 * * LeoBody virtual file time information object
 */
export interface BodyTimeInfo {
    ctime: number;
    mtime: number;
    lastBodyLength?: number;
}

</t>
<t tx="felix.20200718194857.15">/**
 * * Parameter structure used in the 'runSaveFileDialog' equivalent when asking user input
 */
export interface showSaveAsDialogParameters {
    // See TODO in leoAsync.ts
    initialFile: string;
    title: string;
    message: string;
    filetypes: string[];
    defaultExtension: string;
}

</t>
<t tx="felix.20200718194857.16">/**
 * * Parameter structure used in the 'runAskYesNoDialog' equivalent when asking user input
 */
export interface runAskYesNoDialogParameters {
    ask: string;
    message: string;
    yes_all: boolean;
    no_all: boolean;
}

</t>
<t tx="felix.20200718194857.17">/**
 * * Parameter structure used in the 'runAskOkDialog' equivalent when showing a warning
 */
export interface runWarnMessageDialogParameters {
    warn: string;
    message: string;
}

</t>
<t tx="felix.20200718194857.18">/**
 * * Parameter structure for non-blocking info message about detected file changes
 */
export interface runInfoMessageDialogParameters {
    message: string;
}

</t>
<t tx="felix.20200718194857.19">/**
 * * Used in showAskModalDialog to get answer from user interaction
 */
export interface AskMessageItem extends vscode.MessageItem {
    value: string;
}

</t>
<t tx="felix.20200718194857.2">/**
 * * Types of the various JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
export interface ConfigMembers {
    checkForChangeExternalFiles: string;
    defaultReloadIgnore: string;
    leoTreeBrowse: boolean;
    treeKeepFocus: boolean;
    treeKeepFocusWhenAside: boolean;

    collapseAllShortcut: boolean;
    activityViewShortcut: boolean;
    goAnywhereShortcut: boolean;

    showUnlOnStatusBar: boolean,
    // statusBarString: string;
    // statusBarColor: string;

    treeInExplorer: boolean;
    showEditOnNodes: boolean;
    // showArrowsOnNodes: boolean;
    showAddOnNodes: boolean;
    showMarkOnNodes: boolean;
    showCloneOnNodes: boolean;
    showCopyOnNodes: boolean;
    showBranchInOutlineTitle: boolean;

    invertNodeContrast: boolean;
    leoEditorPath: string;
    leoPythonCommand: string;
    startServerAutomatically: boolean;
    connectToServerAutomatically: boolean;
    connectionAddress: string;
    connectionPort: number;

    setDetached: boolean;
    limitUsers: number

    uAsNumber?: boolean; // 'true' flag starting at leoInteg 1.0.8
}

</t>
<t tx="felix.20200718194857.20">/**
 * * Used in switch Leo document to get answer from user interaction
 */
export interface ChooseDocumentItem extends vscode.QuickPickItem {
    value: number;
}

</t>
<t tx="felix.20200718194857.3">/**
 * * When refreshing the outline and getting to Leo's selected node
 */
export const enum RevealType {
    NoReveal = 0, // In apToLeoNode conversion, If if the global revealType is "NoReveal" and its the selected node, re-use the old id
    Reveal,
    RevealSelect,
    RevealSelectFocus
}

</t>
<t tx="felix.20200718194857.4">/**
 * * Required Refresh Dictionary of "elements to refresh" flags
 */
export interface ReqRefresh {
    node?: boolean; // Reveal received selected node (Navigation only, no tree change)
    tree?: boolean; // Tree needs refresh
    body?: boolean; // Body needs refresh
    excludeDetached?: boolean; // Body needs refresh EXCLUDE DETACHED
    scroll?: boolean; // Body needs to scroll to selection
    states?: boolean; // States needs refresh (changed, canUndo, canRedo, canDemote, canPromote, canDehoist)
    buttons?: boolean; // Buttons needs refresh
    documents?: boolean; // Documents needs refresh
    goto?: boolean; // Goto pane needs refresh
}

</t>
<t tx="felix.20200718194857.5">/**
 * * Stackable front end commands
 */
export interface UserCommand {
    action: string; // String from Constants.LEOBRIDGE, which are commands for leoserver.py
    node?: ArchivedPosition | undefined;  // We can START a stack with a targeted command
    name?: string | undefined; // If a string is required, for headline, etc.
    refreshType: ReqRefresh; // Minimal refresh level required by this command
    finalFocus: Focus; // Focus back on outline instead of body
    keepSelection?: boolean; // Should bring back selection on node prior to command
    resolveFn?: (result: any) =&gt; void; // call that with an answer from python's (or other) side
    rejectFn?: (reason: any) =&gt; void; // call if problem is encountered
}

</t>
<t tx="felix.20200718194857.6">/**
 * * Stackable leoBridge actions to be performed by Leo
 */
export interface LeoAction {
    parameter: string; // to pass along with action to python's side
    deferredPayload?: any | undefined; // Used when the action already has a return value ready but is also waiting for python's side
    resolveFn: (result: any) =&gt; void; // call that with an answer from python's (or other) side
    rejectFn: (reason: any) =&gt; void; // call if problem is encountered
}

</t>
<t tx="felix.20200718194857.7">/**
 * * Simple 'string log entry' package format
 */
export interface LeoLogEntry {
    log: string;
}

</t>
<t tx="felix.20200718194857.8">/**
 * * ArchivedPosition format package from Leo's leoflexx.py
 */
export interface ArchivedPosition {
    // * From server's _p_to_ap : childIndex, gnx and stack
    childIndex: number;     // p._childIndex
    gnx: string;            // p.v.gnx
    stack: {
        gnx: string;        // stack_v.gnx
        childIndex: number; // stack_childIndex
    }[];                    // for (stack_v, stack_childIndex) in p.stack]

    // * Attributes for UI appearance
    headline: string;       // p.h
    cloned: boolean;        // p.isCloned()
    dirty: boolean;         // p.isDirty()
    expanded: boolean;      // p.isExpanded()
    marked: boolean;        // p.isMarked()
    atFile: boolean         // p.isAnyAtFileNode():
    selected: boolean;      // p == commander.p
    hasBody: boolean;       // bool(p.b),
    hasChildren: boolean;   // p.hasChildren()

    // * ALPHA FEATURE : Only If called with get_structure instead of get_children
    children?: ArchivedPosition[];

    // * ALPHA FEATURE
    _isRoot?: boolean; // Added front side by leoInteg, for internal usage
    _lastBodyData?: string;

    // * unknown attributes
    u?: number;             // User-attributes displayed qty
    nodeTags?: number;      // 'tags' user-attributes displayed qty

}

</t>
<t tx="felix.20200718195558.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { Icon, UserCommand, ArchivedPosition, Version } from "./types";

var portfinder = require('portfinder');

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718195558.10">/**
 * * Builds a 'Leo Scheme' vscode.Uri from a gnx (or strings like 'LEO BODY' or empty strings to decorate breadcrumbs)
 * with a scheme header like "leointeg:/" or 'more:/'
 * @param p_str leo node gnx strings are used to build Uri
 * @returns A vscode 'Uri' object
 */
export function strToLeoUri(p_str: string): vscode.Uri {
    return vscode.Uri.parse(Constants.URI_SCHEME_HEADER + p_str);
}

</t>
<t tx="felix.20200718195558.11">/**
 * * Gets the gnx, (or another string like 'LEO BODY' or other), from a vscode.Uri object
 * @param p_uri Source uri to extract from
 * @returns The string source that was used to build this Uri
 */
export function leoUriToStr(p_uri: vscode.Uri): string {
    // For now, just remove the '/' before the path string
    return p_uri.path.substring(1);
}

</t>
<t tx="felix.20200718195558.12">/**
 * * Sets a vscode context variable with 'vscode.commands.executeCommand' &amp; 'setContext'
 * @param p_key Key string name such as constants 'bridgeReady' or 'treeOpened', etc.
 * @param p_value Value to be assigned to the p_key 'key'
 * @returns A Thenable that is returned by the executeCommand call
 */
export function setContext(p_key: string, p_value: any): Thenable&lt;unknown&gt; {
    return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.SET_CONTEXT, p_key, p_value);
}

</t>
<t tx="felix.20200718195558.2">/**
 * * Build a string for representing a number that's 2 digits wide, padding with a zero if needed
 * @param p_number Between 0 and 99
 * @returns a 2 digit wide string representation of the number, left padded with zeros as needed.
 */
export function padNumber2(p_number: number): string {
    return ("0" + p_number).slice(-2);
}

</t>
<t tx="felix.20200718195558.3">/**
 * * Build all possible strings for node icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array of the 16 vscode node icons used in this vscode expansion
 */
export function buildNodeIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return Array(16).fill("").map((p_val, p_index) =&gt; {
        return {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
        };
    });
}

</t>
<t tx="felix.20200718195558.4">/**
 * * Build all possible strings for documents icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildDocumentIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_DOCUMENT),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_DOCUMENT)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_DOCUMENT_DIRTY),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_DOCUMENT_DIRTY)
        }
    ];
}

</t>
<t tx="felix.20200718195558.7">/**
 * * Extracts the file name from a full path, such as "foo.bar" from "/abc/def/foo.bar"
 * @param p_path Full path such as "/var/drop/foo/boo/moo.js" or "C:\Documents and Settings\img\recycled log.jpg"
 * @returns file name string such as "moo.js" or "recycled log.jpg""
 */
export function getFileFromPath(p_path: string): string {
    return p_path.replace(/^.*[\\\/]/, '');
}

</t>
<t tx="felix.20200718195558.8">/**
 * * Checks if a node would become dirty if it were to now have body content at all
 * @param p_node LeoNode from vscode's outline
 * @param p_newHasBody Flag to signify presence of body content, to be compared with its current state
 * @returns True if it would change the icon with actual body content, false otherwise
 */
export function isIconChangedByEdit(p_node: ArchivedPosition, p_newHasBody: boolean): boolean {
    // hasBody can be undefined so force boolean.
    if (!p_node.dirty || (!!p_node.hasBody === !p_newHasBody)) {
        return true;
    }
    return false;
}

</t>
<t tx="felix.20200718195558.9">/**
 * * Checks if a string is formatted as a valid rrggbb color code.
 * @param p_hexString hexadecimal 6 digits string, without leading '0x'
 * @returns True if the string is a valid representation of an hexadecimal 6 digit number
 */
export function isHexColor(p_hexString: string): boolean {
    return typeof p_hexString === 'string'
        &amp;&amp; p_hexString.length === 6
        &amp;&amp; !isNaN(Number('0x' + p_hexString));
}

</t>
<t tx="felix.20200718220811.1"></t>
<t tx="felix.20200718220818.1">@language md
@tabwidth -4
# ![Leo Editor](https://raw.githubusercontent.com/boltex/leointeg/master/resources/leoapp.png) Leo for Visual Studio Code

_If you find LeoInteg useful, please consider [**sponsoring**](https://boltex.github.io/) it. Also please [write a review](https://marketplace.visualstudio.com/items?itemName=boltex.leointeg#review-details "Write a review") or [star it on GitHub](https://github.com/boltex/leointeg "Star it on GitHub"). (For a JavaScript implementation of the Leo Editor that runs in both VSCode and VSCode for the web, see the [**LeoJS**](https://github.com/boltex/leojs) extension)_

## Literate Programming with _Directed Acyclic Graphs_ ([dag](https://en.wikipedia.org/wiki/Directed_acyclic_graph))

### Break down your code into a structured outline that generates or parses back your source files

&gt; Leo is a fundamentally different way of using and organizing data, programs and scripts. [ Introduction Video](https://www.youtube.com/watch?v=SYwlfdEukD4)

See Leo, the Literate Editor with Outline, at [leo-editor.github.io/leo-editor](https://leo-editor.github.io/leo-editor/)
or on [github](https://github.com/leo-editor/leo-editor), and VS Code at [code.visualstudio.com](https://code.visualstudio.com/).

![Screenshot](https://raw.githubusercontent.com/boltex/leointeg/master/resources/animated-screenshot.gif)

@others
---

##  To sponsor, donate or contribute see my [user page ](https://boltex.github.io/)
</t>
<t tx="felix.20200718220833.1">@language md
@tabwidth -4
# Change Log

@others
</t>
<t tx="felix.20200718220833.2">@language md
@tabwidth -4
# How to install and run the development version

Thanks for trying out the development version of LeoInteg! :sunglasses: Contributions and pull requests are more than welcome!

@others
</t>
<t tx="felix.20200718221645.1">## Requirements

- Leo Editor 6.7.9 or later\
  _Install with :_ `pip install leo`\
   _Or with git._ (See [Installing Leo with git](https://leo-editor.github.io/leo-editor/installing.html#installing-leo-with-git))

- Websocket Python Library\
  _Install with :_ `pip install websockets`\
  (See [websockets.readthedocs.io/](https://websockets.readthedocs.io/))

</t>
<t tx="felix.20200718222035.1">## Features

- UI controls such as a **Leo Outline** in the explorer view, and as a standalone sidebar, **body pane**, **opened documents selector** along with a **Log Window** [output channel](https://code.visualstudio.com/api/extension-capabilities/common-capabilities#output-channel).
- **Detached Body Panes**, independent of the selected node can be opened with the 'Open Aside' command.
- Keybindings that match those of the Leo editor, including arrow keys behavior for outline keyboard navigation. (Can be turned off with the **'Leo Tree Browsing'** option setting)
- **Derived files change detection**. See [External Files](#derive-external-files) below for more details
- **'@button' panel** for [creating your own commands with @buttons](https://leo-editor.github.io/leo-editor/tutorial-tips.html#use-button-nodes)
- **Find panel** that reacts to Leo's typical keybindings, Ctrl+F, F2, F3... when focus is in the outline or body pane
- **Nav and Tag panel** controls are integrated in the Find panel
- **Goto Anywhere panel** to navigate directly from list of nodes, such as the results of Nav or Tag searches
- **Undo History panel**, showing all actions and allowing going back, or forward, to any undo states.

</t>
<t tx="felix.20200718222043.1">
## Keybindings

Listed here are the most useful commands and their keyboard shortcuts.

| Outline Commands |                                                                  |
| :--------------- | :--------------------------------------------------------------- |
| Undo / Redo      | `Ctrl + Z` &amp;nbsp;&amp;nbsp;/&amp;nbsp;&amp;nbsp; `Ctrl + Shift + Z`          |
| Insert Node      | `Ctrl + I` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift + Insert`         |
| Insert Child     | `Ctrl + Insert`                                                  |
| Edit Headline    | `Ctrl + H`                                                       |
| Mark / Unmark    | `Ctrl + M`                                                       |
| Copy Node        | `Ctrl + Shift + C`                                               |
| Cut Node         | `Ctrl + Shift + X`                                               |
| Paste Node       | `Ctrl + Shift + V`                                               |
| Delete Node      | `Ctrl + Shift + Backspace` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Delete` |
| Clone Node       | `Ctrl + Backquote`                                               |
| Promote / Demote | `Ctrl + {` &amp;nbsp;&amp;nbsp;_and_&amp;nbsp;&amp;nbsp; `Ctrl + }`              |

| Moving Nodes       |                                                                 |
| :----------------- | :-------------------------------------------------------------- |
| Move Outline Up    | `Ctrl + U` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift [+ Alt] + Up`    |
| Move Outline Down  | `Ctrl + D` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift [+ Alt] + Down`  |
| Move Outline Left  | `Ctrl + L` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift [+ Alt] + Left`  |
| Move Outline Right | `Ctrl + R` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Shift [+ Alt] + Right` |

_Move-Outline commands need the `Alt` key modifier only when focus is on body pane._

| Changing Focus                  |                                                   |
| :------------------------------ | :------------------------------------------------ |
| Toggle Outline/Body             | `Ctrl + T`                                        |
| Focus on Outline                | `Alt + T`                                         |
| Focus on Body (in any pane)     | `Alt + D` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Ctrl + G` |
| Focus on Body (in Outline pane) | `Tab` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Enter`        |

| Common Operations  |                    |
| :----------------- | :----------------- |
| Contract All       | `Alt + -`          |
| Sort Siblings      | `Alt + A`          |
| Start Search       | `Ctrl + F`         |
| Find Next          | `F3`               |
| Find Previous      | `F2`               |
| Replace            | `Ctrl + =`         |
| Replace then Find  | `Ctrl + -`         |
| Extract            | `Ctrl + Shift + D` |
| Extract Names      | `Ctrl + Shift + N` |
| Execute Script     | `Ctrl + B`         |
| Minibuffer Palette | `Alt + X`          |

| Tree Navigation          |                                                              |
| :----------------------- | :----------------------------------------------------------- |
| Show the LeoInteg View   | `Ctrl+Shift+L`                                               |
| Go Anywhere              | `Ctrl+P`                                                     |
| Go To First Visible Node | `Home` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Alt + Home`             |
| Go To Last Visible Node  | `End` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Alt + End`               |
| Tree page up/down        | `PgUp / pgDn`                                                |
| Go To Next Clone         | `Alt + N`                                                    |
| Browse Tree              | `Arrow Keys` &amp;nbsp;&amp;nbsp;_or_&amp;nbsp;&amp;nbsp; `Alt + Arrow Keys` |
| Go To Global Line        | `Alt + G`                                                    |

_With the **'Leo Tree Browsing'** setting enabled by default, the arrows, home, end, pageUp/Down keys will change the outline's selection directly. Using tree navigation shortcuts from the body pane (with the `Alt` key modifier) will place focus in the outline._

| File Commands       |                    |
| :------------------ | :----------------- |
| Save Leo Document   | `Ctrl + S`         |
| New Leo Document    | `Ctrl + N`         |
| Open Leo Document   | `Ctrl + O`         |
| Cycle Next Document | `Ctrl + Tab`       |
| Write File Nodes    | `Ctrl + Shift + W` |
| Write Dirty Files   | `Ctrl + Shift + Q` |

---

</t>
<t tx="felix.20200718222048.1">## Derive External Files

Use either of the **Save Leo Document**, **Write File Nodes** or **Write Dirty Files** commands to derive external files for any type of **@file** nodes.

| @\&lt;file\&gt; Kind | Sentinels | @others | .leo Data | Write Only |
| :------------- | :-------: | :-----: | :-------: | :--------: |
| @asis          |         |       |         |          |
| @auto          |         |       |         |          |
| @clean         |         |       |         |          |
| @edit          |         |       |         |          |
| @file          |         |       |         |          |
| @nosent        |         |       |         |          |

Leo will detect external file changes, and will ask to either **refresh from disk** or **ignore the changes**.

![Derive files](https://raw.githubusercontent.com/boltex/leointeg/master/resources/derived-file.gif)

</t>
<t tx="felix.20200718222053.1">## Automate External Files Synchronization

The **change detection** process can be automated to always refresh, or ignore file changes:
A **notification** will inform you of the action taken instead.

![Auto sync](https://raw.githubusercontent.com/boltex/leointeg/master/resources/auto-sync.gif)

</t>
<t tx="felix.20200718222102.1">## Extension Settings

### Open the command palette `Ctrl+Shift+P` and start typing `leo settings` to access LeoInteg's welcome/settings screen

&gt; _(Changes are auto-saved to the user's profile after 0.5 seconds)_

- Control the visibility of the outline pane in the explorer view.
- Decide how and when to refresh and synchronize content when derived (external) file are modified.
- Show additional icons on outline nodes (Move, delete, mark, copy, paste...)
- Choose to either focus on the body pane, or keep focus in the outline when a node is selected.
- Hide or show the "Open on the side" command in the context menu to open a node beside the active editor
- Set preferences for setting the address and port, and for automatically starting, and/or connecting to a Leo server.

![Settings](https://raw.githubusercontent.com/boltex/leointeg/master/resources/welcome-settings.gif)

</t>
<t tx="felix.20200718222108.1">## Issues

Common issues are listed below. See the repository's [Issues Page](https://github.com/boltex/leointeg/issues) to submit issues.

### Linux Keybindings

If you're experiencing trouble with the keyboard shortcuts for
the 'Clone Node' or the 'Promote' and 'Demote' commands,
set **"keyboard.dispatch": "keyCode"** in your vscode settings and restart vscode.
See [Troubleshoot Linux Keybindings](https://github.com/microsoft/vscode/wiki/Keybinding-Issues#troubleshoot-linux-keybindings)
for more information.

### Keybindings Conflicts Resolution

If you have a keybinding conflict for a command that you would like **not** to be resolved by Leo when the focus is on the body pane,
add **`&amp;&amp; resourceScheme != 'leointeg'`** to the keybinding's "_when_" condition. (Use **`Ctrl+K Ctrl+S`** in vscode to open the Keyboards Shortcuts panel)

### Move Outline Keyboard Commands

For some users, the **`Alt+[Arrow Keys]`**, **`Ctrl+D`** and **`Ctrl+T`** keybinding are already assigned.

To help with this conflict, tree-browsing, outline-move keyboard commands, and switch focus command will only trigger
with the additional condition of having no text selection in the editor.

So select at least one character to use the previously assigned original keyboard commands, while focus is in the body pane.

&gt; Refer to the [issue tracker](https://github.com/boltex/leointeg/issues) page to learn more about the known issues, or to contribute with additional information if you encounter some yourself.

</t>
<t tx="felix.20200718222113.1">## How It Works

Leo integration into VS Code is done by starting
a [python server script](https://github.com/leo-editor/leo-editor/blob/devel/leo/core/leoserver.py) and connecting to it via
a [websocket](https://websockets.readthedocs.io/en/stable/intro.html)
to exchange JSON data. The server script leverages [leoBridge](https://leo-editor.github.io/leo-editor/leoBridge.html)
and re-uses code from the [leoflexx.py plugin](https://github.com/leo-editor/leo-editor/blob/devel/leo/plugins/leoflexx.py#L893).

The outline pane is made by implementing a
[TreeDataProvider for vscode's TreeView API](https://code.visualstudio.com/api/extension-guides/tree-view#tree-view-api-basics),
while the body-pane's _virtual document_ is made by [implementing a filesystem provider](https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api)
and using the outline's selected node 'gnx' as identifier.

---

</t>
<t tx="felix.20200718222118.1">## Acknowledgments

### _Thanks to_

- [Edward K. Ream](https://github.com/edreamleo) creator of the [Leo Editor](https://leo-editor.github.io/leo-editor/)
- [Eric Amodio](https://github.com/eamodio) for the [welcome screen templates](https://github.com/eamodio/vscode-gitlens/tree/master/src/webviews)
- [Vitalije Miloevi](https://github.com/vitalije) for his contributions and support
- [Arjan Mossel](https://github.com/ar-jan) for his suggestions and ideas
- [Thomas Passin](https://github.com/tbpassin) for his contributions and support
- [Viktor](https://github.com/ranvik14) for his contributions and support
- [Gaurami](https://github.com/ATikhonov2) for his suggestions, bug reports and support
- [Kevin Henderson](https://github.com/kghenderson) for his suggestions and support
- [Ville M. Vainio](https://github.com/vivainio) for his Nav tab original concept
- [Jacob M. Peck](https://github.com/gatesphere) for his Tags tab original concept
- [Matt Wilkie](https://github.com/maphew) for his contributions and support

</t>
<t tx="felix.20200718222417.1">## 0.1.12

- Added support for multiple opened files along with the 'new', 'Close', 'Save-As' commands.
- Improved the icons and commands, which are visible, or invisible depending on context.
- Added 'tree view' listing the opened Leo documents which is available in the Leo view, and the explorer view.
- Added basic leonine syntax coloring. (No specific \@languages yet)
- Added selection support to the 'Execute-Script' command.

</t>
<t tx="felix.20200718222419.1">## 0.1.11

- Fixed undo operation for the _insert_ and _rename_ commands (Some other commands may still need fixes to their 'undo' support)
- Fixed crashing when editing body pane under Leo 6.2.

</t>
<t tx="felix.20200718222422.1">## 0.1.10

- Added more [welcome content](https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content) in outlines panes that have not yet opened a tree for starting a server, connecting to it, and added content to help with automation settings.
- Changed the starting default configuration setting for starting and connecting to the leoBridge server script to false.
- Made starting and connecting to the leoBridge server script easier to access in the interface, and in the welcome/settings webview.
- Added new CONTRIBUTING markdown file for running the development version of the leoInteg extension.
- Closes [#44](https://github.com/boltex/leointeg/issues/44).

</t>
<t tx="felix.20200718222425.1">## 0.1.9

- Added new compilation configuration (server, extension, or both) to help debugging.
- Support async output from leoBridge, for log pane and other events.
- External file change detection with modal dialogs matching Leo's gui dialogs.
- Added config options to bypass derived files change detection dialogs with defaults, allowing automatic synchronization of derived files in both directions.
- Added support for redo, refresh from disk and many any other core Leo commands and operations.
- Added support for rapid outline edition command entry, including 'insert node' command **`Ctrl+I`** and for replacing focus on relevant elements to mimic actual Leo interface workflow.
- Added [welcome content](https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content) in outlines panes that have not yet opened a tree to help with connecting and opening.
- Replaced body-editor content transfer logic and removed the related option in the expansion's settings. The body is sent to Leo when appropriate without need of a timed delay.
- _REMOVED FEATURE_ Rolled back 'multi-body' feature for simultaneous body panes from different gnx. Body panes from the same gnx are still available.

</t>
<t tx="felix.20200718222427.1">## 0.1.8

- Extension now built with webpack. [As recommended by vsCode's extension guidelines](https://code.visualstudio.com/api/working-with-extensions/bundling-extension#using-webpack)
- Added a 'Welcome Screen' webview (also compiled by webpack from html, scss and ts files) to show a greeting with basic info, and provide an easy way to change the configuration settings.
- Added commands accessible via either tree menu, context menu, and 'standard' Leo keyboard shortcuts:
  - Insert, delete
  - Cut/Copy/Paste/Clone/Paste as clone
  - Move, promote, demote node operations
  - Mark, unmark, sort children, sort siblings and undo

</t>
<t tx="felix.20200718222429.1">## 0.1.7

- Changed main mode of communication from stdin/out to tcp/ip websockets.
- Made a standalone 'Leo Server' python script.

</t>
<t tx="felix.20200718222433.1">## 0.1.6

- Major 'Browsing' update before adding outline editing and file saving &amp; derivation (Thanks for testing!)
- Refactored and simplified communication between vscode and leoBridge.
- Stabilized browsing with multiple simultaneous body panes.
- Added Leo Outline into explorer view.
- Supports new command to open a node on the side from the context menu.
- Multiple configuration options: Open Settings with CTRL+',' type 'leo', or look for 'leo integration' in extensions.

_Note: Headline and body edition does not affect the Leo file yet._

</t>
<t tx="felix.20200718222435.1">## 0.1.5

- Stabilized tree browsing, along with headline and body editing.

</t>
<t tx="felix.20200718222437.1">## 0.1.4

- Major Refactor to streamline codebase; Eliminated code duplication.
- Complete rewrite after going trying out most of what is possible with both vscode and leo APIs.
- New body pane system that prevents corrupting undos across different positions: It uses the node's actual gnx instead of a generic "body" string as a file path for the custom filesystem.

</t>
<t tx="felix.20200718222439.1">## 0.1.3

- This version creates a body panel via a custom filesystem: 'leo'. It only has a file, "leo:/body", the body of the currently selected node.

_Note: This editable body panel does not affect Leo file yet._

</t>
<t tx="felix.20200718222440.1">## 0.1.2

- Prototype Goal Achieved!
- Browsing Now shows body text too, just like browsing in Leo without editing body nor headlines. (read only for now)

</t>
<t tx="felix.20200718222442.1">## 0.1.1

- Leo File Opening.
- Basic outline browsing, along with the recognizable node icons.

</t>
<t tx="felix.20200718222445.1">## 0.0.1

- Initial basic skeleton of this extension. Press F5 to view icon and test the startup of the extension!
- Implemented [leoBridge](https://leo-editor.github.io/leo-editor/leoBridge.html) interaction.

![LeoEditor](https://raw.githubusercontent.com/boltex/leointeg/master/resources/leoapp96px.png)
</t>
<t tx="felix.20200718222731.1">## Introduction

[Video tutorial of installation and startup](https://www.youtube.com/watch?v=rutt11xL54I):

[![Installation and startup video](https://img.youtube.com/vi/rutt11xL54I/0.jpg)](https://www.youtube.com/watch?v=rutt11xL54I)

If you're new to vscode and want to try out Leo with this vscode extension, you might want to look at this [Getting Started](https://code.visualstudio.com/docs#vscode-in-action) page to get an overview of vscode.

Furthermore, if you've never ran a vscode extension in an **Extension Development Host**, here is a [short overview about running and modifying a simple extension](https://code.visualstudio.com/api/get-started/your-first-extension).

If you're having problems with the procedures below, try [running this sample extension](https://github.com/Microsoft/vscode-extension-samples/tree/master/helloworld-sample#running-the-sample) first to catch underlying problems or missing dependencies.

</t>
<t tx="felix.20200718222739.1">## Development requirements

- **use Leo's 'devel' branch** (This is temporary until Leo's 6.4 release)

- Make sure you have [Node.js](https://nodejs.org/en/download/) and [Git](https://git-scm.com/downloads) installed. Version up to **14.19** of node works fine for compiling this project.

- Also check your vscode, and other software versions by opening the 'about' dialog from the help menu. You should at least match or exceed the versions below.

On Windows:

![about](https://raw.githubusercontent.com/boltex/leointeg/master/resources/vscode-about-win.png)

On Linux:

![about](https://raw.githubusercontent.com/boltex/leointeg/master/resources/vscode-about.png)

</t>
<t tx="felix.20200718222741.1">## Getting the source and its development dependencies

- Clone the repository using the command line by typing : `git clone https://github.com/boltex/leointeg.git`

![clone](https://raw.githubusercontent.com/boltex/leointeg/master/resources/git-clone.png)

- Although you could 'cd' into the leoInteg folder and run some commands from the same terminal, let's instead use the terminal from within vscode. So open the leoInteg folder with vscode instead, either with the context menu as shown below, or by choosing "Open Folder..." from within vscode:

![open with vscode](https://raw.githubusercontent.com/boltex/leointeg/master/resources/open-with-vscode.png)

- With vscode now opened with the **leoInteg folder as its workspace**, use the `ctrl+shift+p` keyboard shortcut to open command palette and toggle the terminal. (You can find any command through the command palette)

![open terminal](https://raw.githubusercontent.com/boltex/leointeg/master/resources/open-terminal.png)

- Install the development dependencies by entering the `npm install` command in the terminal. **(Important if you also just _pulled_ updated sources)**

- When the command has finished running, you should see logged results in the terminal and also that a new **node_modules** folder was created.

![dependencies](https://raw.githubusercontent.com/boltex/leointeg/master/resources/node-modules.png)

- You're now ready to **compile and run** the development version of the leoInteg extension.

</t>
<t tx="felix.20200718222745.1">## Choosing a debug profile

- Bring up the **Run view**, by selecting the Run icon in the **Activity Bar**. _(Screenshot below)_

- When simply running the extension, choose the **Run Extension** profile.

![profile](https://raw.githubusercontent.com/boltex/leointeg/master/resources/debug-profile.png)

&gt; (**Optional**) To contribute code to the python server script, or run it through the vscode debugger, you may need to install the [python development extension](https://marketplace.visualstudio.com/items?itemName=ms-python.python).

- For simply running and using leoInteg, just start the extension and the server as shown below.

</t>
<t tx="felix.20200718222748.1">## Starting the extension

- Use the **Start Debugging** command (or press **F5**) to start another vscode window with the expansion _installed and running_ within it.

![extension started](https://raw.githubusercontent.com/boltex/leointeg/master/resources/leointeg-started.png)

- If any problems occurred during the extension compilation it will be logged in the vscode instance that started the debug process in its **task-webpack** terminal panel. Otherwise if its running, the extension itself will be logging any messages in the **debug-console** panel. (See animation below)

![extension logs](https://raw.githubusercontent.com/boltex/leointeg/master/resources/debug-anim.gif)

</t>
<t tx="felix.20200718222754.1">## The python server script

- This extension needs the **`leobridgeserver.py`** or the **`leoserver.py`** script to be running from Leo's own installation folder. That is where the two extra extension requirements come into play:

## Server Script Requirement

- Having the [Websocket Python Library installed](https://websockets.readthedocs.io/en/stable/intro.html)

### 3 ways to start the server script

1. You can have LeoInteg try to start a server script instance itself via the **Start Leo Server** command or button. It will use the 'py' command on Windows and 'python3' command on other OSes by default. _You can automate this process via leoInteg's configuration settings._
2. You can have vscode's **Debug View** start it, as a debug session starts, by choosing a debug profile that includes the server script. It's then possible to step in, inspect and debug the python server script. _The [python development extension](https://marketplace.visualstudio.com/items?itemName=ms-python.python) may be required._
   **If using those debug view profiles, the server files have to be de-commented from the leointeg.leo file, or copied from the leo-editor/leo/core folder.**
3. You can also start it yourself manually, by running the leoserver.py script (preferably from your leo-editor/leo/core folder) in a terminal or command prompt of your liking.

For more details about all possible arguments, run it from a command prompt with the 'help' argument like so:\
**`...leo-editor/leo/core/leoserver.py --help`**

For more information about the Leo server see [Using leoserver.py](https://leo-editor.github.io/leo-editor/leoserver.html) from Leo's official documentation.

### Using Anaconda or other custom python installations

- LeoInteg provides configuration options to specify how to launch python interpreter but this may not be enough to get it to start on your system, see [#10](https://github.com/boltex/leointeg/issues/10) and other issues relating to configurations in _sitecustomize.py_ file as noted in [Leo's google group forum](https://groups.google.com/d/msg/leo-editor/FAP8lVnWLyQ/lWHWEYH9AgAJ).

- If Leointeg or vscode cannot start running the server script on you system or OS, a **workaround** is to start the server script beforehand manually with whichever python interpreter you have installed.

![launch server](https://raw.githubusercontent.com/boltex/leointeg/master/resources/manual-server-start.png)

- It will terminate automatically when a user disconnect.

**Note**: If force-closing the server from the integrated vscode terminal, use the 'Kill terminal' button instead of the 'X' that just hides the panel.

![kill terminal](https://raw.githubusercontent.com/boltex/leointeg/master/resources/kill-terminal.png)

</t>
<t tx="felix.20200718222757.1">## Issues

More information can be found on the repository's [Issues Page](https://github.com/boltex/leointeg/issues), where details and troubleshooting can be addressed more directly.
</t>
<t tx="felix.20200719025231.1">import * as vscode from 'vscode';
import { execSync } from 'child_process';
import { debounce } from "lodash";
import * as fs from 'fs';
import * as path from "path";
import * as utils from './utils';
import { Constants } from './constants';
import {
    LeoBridgePackage,
    RevealType,
    Focus,
    ArchivedPosition,
    Icon,
    ConfigMembers,
    ReqRefresh,
    ChooseDocumentItem,
    LeoDocument,
    UserCommand,
    BodySelectionInfo,
    LeoGuiFindTabManagerSettings,
    LeoSearchSettings,
    ChooseRClickItem,
    RClick,
    LeoGotoNavKey,
    ChosePositionItem,
    UnlType
} from './types';
import { Config } from './config';
import { LeoFilesBrowser } from './leoFileBrowser';
import { LeoApOutlineProvider } from './leoApOutline';
import { LeoBodyProvider } from './leoBody';
import { LeoBodyDetachedProvider } from "./leoBodyDetached";
import { LeoBridge } from './leoBridge';
import { ServerService } from './serverManager';
import { LeoStatusBar } from './leoStatusBar';
import { CommandStack } from './commandStack';
import { LeoDocumentsProvider, LeoDocumentNode } from './leoDocuments';
import { LeoStates } from './leoStates';
import { LeoButtonsProvider, LeoButtonNode } from './leoButtons';
import { LeoFindPanelProvider } from './leoFindPanelWebview';
import { LeoSettingsProvider } from './leoSettingsWebview';
import { LeoGotoProvider, LeoGotoNode } from './leoGoto';
import { LeoUndosProvider, LeoUndoNode } from './leoUndos';
import { UnlProvider } from "./unlProvider";

@others
@language typescript
@tabwidth -4
</t>
<t tx="felix.20200719025231.10"></t>
<t tx="felix.20200719025231.11">/**
 * * Open Leo files found in "context.workspaceState.leoFiles"
 * @returns promise that resolves immediately, or rejects if empty, or files not opened.
 */
private _openLastFiles(): Promise&lt;LeoBridgePackage&gt; {
    // Loop through context.workspaceState.&lt;something&gt; and check if they exist: open them
    const w_lastFiles: string[] = this._context.workspaceState.get(Constants.LAST_FILES_KEY) || [];
    if (w_lastFiles.length) {
        return this.sendAction(
            Constants.LEOBRIDGE.OPEN_FILES,
            { files: w_lastFiles }
        ).then(
            (p_openFileResult: LeoBridgePackage) =&gt; {

                if (p_openFileResult.total) {

                    let q_finalResult: Promise&lt;LeoBridgePackage&gt;;

                    // Check for last active Leo document
                    const w_lastActive = utils.getGlobalLastActiveFile(this._context);

                    //  Need to switch ?
                    if (w_lastActive &amp;&amp; p_openFileResult.filename! !== w_lastActive) {
                        // Call server "get all opened commanders"
                        q_finalResult = this.sendAction(
                            Constants.LEOBRIDGE.GET_OPENED_FILES
                        ).then((p_openedFiles) =&gt; {
                            const w_files: LeoDocument[] = p_openedFiles.files || [];
                            let w_index: number = 0;
                            let w_indexToSelect: number = -1;
                            if (w_files &amp;&amp; w_files.length) {
                                w_files.forEach((i_file: LeoDocument) =&gt; {
                                    i_file.index = w_index;
                                    if (i_file.name === w_lastActive) {
                                        w_indexToSelect = w_index;
                                    }
                                    w_index++;
                                });
                            }
                            if (w_indexToSelect &gt;= 0) {
                                // found it!

                                // Select from list if present, by index with "set opened file"
                                return this.sendAction(
                                    Constants.LEOBRIDGE.SET_OPENED_FILE, { index: w_indexToSelect }
                                );
                            } else {
                                // return default package
                                return p_openedFiles;
                            }
                        });
                    } else {
                        q_finalResult = Promise.resolve(p_openFileResult);
                    }

                    q_finalResult.then((p_fileResult) =&gt; {

                        this.serverHasOpenedFile = true;
                        this.serverOpenedFileName = p_fileResult.filename!;
                        this.serverOpenedNode = p_fileResult.node!;
                        this._finishOpenLastFiles();

                        this.loadSearchSettings();
                        this.setupRefresh(
                            this.finalFocus,
                            {
                                tree: true,
                                body: true,
                                documents: true,
                                buttons: true,
                                states: true,
                                goto: true,
                            },
                            p_fileResult.node
                        );
                        this.launchRefresh();
                        return p_fileResult;
                    });

                    return q_finalResult;

                } else {
                    this.serverHasOpenedFile = false;
                    this.serverOpenedFileName = "";
                    this.serverOpenedNode = undefined;
                    this._finishOpenLastFiles();
                    this.launchRefresh();
                    return Promise.reject('Recent files list is empty');
                }

            },
            (p_errorOpen) =&gt; {
                this._finishOpenLastFiles();
                this.launchRefresh();

                console.log('in .then not opened or already opened');
                return Promise.reject(p_errorOpen);
            }
        );
    } else {
        return Promise.reject('Recent files list is empty');
    }
}

</t>
<t tx="felix.20200719025231.12">/**
 * * Adds to the context.workspaceState.&lt;xxx&gt;files if not already in there (no duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when all workspace storage modifications are done
 */
private async _addRecentAndLastFile(p_file: string): Promise&lt;void&gt; {

    if (!p_file.length) {
        return Promise.resolve();
    }

    await Promise.all([
        utils.addFileToWorkspace(this._context, p_file, Constants.RECENT_FILES_KEY),
        utils.addFileToWorkspace(this._context, p_file, Constants.LAST_FILES_KEY),
    ]);

    return Promise.resolve();
}

</t>
<t tx="felix.20200719025231.13">/**
 * * Removes from context.workspaceState.leoRecentFiles if found (should not have duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when the workspace storage modification is done
 */
private _removeRecentFile(p_file: string): Thenable&lt;void&gt; {
    return utils.removeFileFromWorkspace(this._context, p_file, Constants.RECENT_FILES_KEY);
}

</t>
<t tx="felix.20200719025231.14">/**
 * * Removes from context.workspaceState.leoLastFiles if found (should not have duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when the workspace storage modification is done
 */
private _removeLastFile(p_file: string): Thenable&lt;void&gt; {
    return utils.removeFileFromWorkspace(this._context, p_file, Constants.LAST_FILES_KEY);
}

</t>
<t tx="felix.20200719025231.15">/**
 * * Shows the recent Leo files list, choosing one will open it
 * @returns A promise that resolves when the a file is finally opened, rejected otherwise
 */
public async showRecentLeoFiles(): Promise&lt;LeoBridgePackage | undefined&gt; {
    // TODO showRecentLeoFiles USE REAL RECENT FILES LIST FROM LEO
    // console.log("TODO : showRecentLeoFiles USE REAL RECENT FILES LIST FROM LEO");
    const w_recentFiles: string[] =
        this._context.workspaceState.get(Constants.RECENT_FILES_KEY) || [];
    let q_chooseFile: Thenable&lt;string | undefined&gt;;
    if (w_recentFiles.length) {
        q_chooseFile = vscode.window.showQuickPick(w_recentFiles, {
            placeHolder: Constants.USER_MESSAGES.OPEN_RECENT_FILE,
        });
    } else {
        // No file to list
        return Promise.resolve(undefined);
    }
    const w_result = await q_chooseFile;
    if (w_result) {
        return this.openLeoFile(vscode.Uri.file(w_result));
    } else {
        // Canceled
        return Promise.resolve(undefined);
    }
}

</t>
<t tx="felix.20200719025231.19">/**
 * * 'getStates' action for use in debounced method call
 */
private _triggerGetStates(): void {

    if (this._refreshType.documents) {
        this._refreshType.documents = false;
        this.refreshDocumentsPane();
    }
    if (this._refreshType.goto) {
        this._refreshType.goto = false;
        this.refreshGotoPane();
    }
    if (this._refreshType.buttons) {
        this._refreshType.buttons = false;
        this.refreshButtonsPane();
    }
    if (this._refreshType.states) {
        this._refreshType.states = false;
        this.sendAction(Constants.LEOBRIDGE.GET_STATES)
            .then((p_package: LeoBridgePackage) =&gt; {
                if (p_package.states) {
                    this.leoStates.setLeoStateFlags(p_package.states);
                }
            });
        this.refreshUndoPane();
        this.getUNL();
    }
    this.refreshBodyStates(); // Set language and wrap states, if different.

}

</t>
<t tx="felix.20200719025231.2">/**
 * * Orchestrates Leo integration into vscode
 */
export class LeoIntegration {
    // * Status Flags
    public activated: boolean = true; // Set to false when deactivating the extension
    private _leoBridgeReadyPromise: Promise&lt;LeoBridgePackage&gt; | undefined; // Is set when leoBridge has a leo controller ready
    private _currentOutlineTitle: string = Constants.GUI.TREEVIEW_TITLE_INTEGRATION; // Might need to be re-set when switching visibility
    private _hasShownContextOpenMessage: boolean = false; // Used to show this information only once

    // * State flags
    public leoStates: LeoStates;

    // * UNL link provider
    public linkProvider: UnlProvider;

    // * General integration usage variables
    private _clipboardContent: string = "";

    // * Frontend command stack
    private _commandStack: CommandStack;

    // * Configuration Settings Service
    public config: Config; // Public configuration service singleton, used in leoSettingsWebview, leoBridge, for inverted contrast

    // * Icon Paths
    public nodeIcons: Icon[] = []; // Singleton static array of all icon paths used for rendering in treeview
    public undoIcons: Icon[] = [];
    public documentIcons: Icon[] = [];
    public buttonIcons: Icon[] = [];
    public gotoIcons: Icon[] = [];

    // * File Browser
    private _leoFilesBrowser: LeoFilesBrowser; // Browsing dialog service singleton used in the openLeoFile and save-as methods

    // * LeoBridge
    private _leoBridge: LeoBridge; // Singleton service to access the Leo server.

    // * Commands stack finishing resolving "refresh flags", for type of refresh after finishing stack
    public finalFocus: Focus = Focus.NoChange; // Set in _setupRefresh : Last command issued had focus on outline, as opposed to the body
    public showBodyIfClosed: boolean = false;
    public showOutlineIfClosed: boolean = false;
    public refreshPreserveRange = false; // this makes the next refresh cycle preserve the "findFocusTree" flag once.

    private _refreshType: ReqRefresh = {}; // Set in _setupRefresh : Flags for commands to require parts of UI to refresh

    private __refreshNode: ArchivedPosition | undefined; // Set in _setupRefresh : Last command issued a specific node to reveal
    private _lastRefreshNodeTS: number = 0;
    get _refreshNode(): ArchivedPosition | undefined {
        return this.__refreshNode;
    }
    set _refreshNode(p_ap: ArchivedPosition | undefined) {
        // Needs undefined type because it cannot be set in the constructor
        this.__refreshNode = p_ap;
        this._lastRefreshNodeTS = performance.now();
    }

    // * Automatic leoserver startup management service
    private _serverService: ServerService;
    public serverVersion: {
        major: number;
        minor: number;
        patch: number;
    } = {
            major: 0,
            minor: 0,
            patch: 0
        };

    public serverHasOpenedFile: boolean = false; // Server reported at least one opened file: for fileOpenedReady transition check.

    private _serverOpenedFileName: string = ""; // Server last reported opened file name.
    get serverOpenedFileName(): string {
        return this._serverOpenedFileName;
    }
    set serverOpenedFileName(s: string) {
        let w_isNew = false;
        if (this._serverOpenedFileName !== s) {
            this._serverOpenedFileName = s;
            this.leoStates.leoOpenedFileName = s; // In case context flag not set yet.
            w_isNew = true;
        }

        // Add to desc.
        let w_desc = "";
        const w_filename = s ? utils.getFileFromPath(s) : Constants.UNTITLED_FILE_NAME;
        let w_path = "";
        const n = s ? s.lastIndexOf(w_filename) : -1;
        if (n &gt;= 0 &amp;&amp; n + w_filename.length &gt;= s.length) {
            w_path = s.substring(0, n);
        }
        w_desc = w_filename + (w_path ? " in " + w_path : '');

        if (this._titleDesc !== w_desc) {
            this._titleDesc = w_desc;
            this.refreshDesc();
        }
        if (w_isNew &amp;&amp; s) {
            // save to workspace 'last active file' momento.
            utils.setGlobalLastActiveFile(this._context, s);
        }

    }
    private _titleDesc = "";

    public serverOpenedNode: ArchivedPosition | undefined; // Server last reported opened node.
    private _focusInterrupt: boolean = false; // Flag for preventing setting focus when interrupting (canceling) an 'insert node' text input dialog with another one

    // * Outline Pane
    private _leoTreeProvider: LeoApOutlineProvider; // TreeDataProvider single instance
    private _leoTreeView: vscode.TreeView&lt;ArchivedPosition&gt;; // Outline tree view added to the Tree View Container with an Activity Bar icon
    private _leoTreeExView: vscode.TreeView&lt;ArchivedPosition&gt;; // Outline tree view added to the Explorer Sidebar
    private _lastTreeView: vscode.TreeView&lt;ArchivedPosition&gt;; // Last visible treeview
    private _renamingHeadline: string = "";

    private _revealNodeRetriedRefreshOutline: boolean = false; // USED IN _refreshOutline and _revealNode

    // Last selected node we got a hold of;
    //  -  leoTreeView.selection maybe newer (user click) and unprocessed
    //  -  this._refreshNode maybe newer (refresh from server) and unprocessed
    private _lastSelectedNode: ArchivedPosition | undefined;
    private _lastSelectedNodeTS: number = 0;
    get lastSelectedNode(): ArchivedPosition | undefined {
        return this._lastSelectedNode;
    }
    set lastSelectedNode(p_ap: ArchivedPosition | undefined) {
        // Needs undefined type because it cannot be set in the constructor
        this._lastSelectedNode = p_ap;
        this._lastSelectedNodeTS = performance.now();
    }

    // * Outline Pane redraw/refresh flags. Also set when calling refreshTreeRoot
    // If there's no reveal and its the selected node, the old id will be re-used for the node. (see _id property in LeoNode)
    private _revealType: RevealType = RevealType.NoReveal; // to be read/cleared in arrayToLeoNodesArray, to check if any should self-select

    private _preventShowBody = false; // Used when refreshing treeview from config: It requires not to open the body pane when refreshing

    // * Reveal Timers
    private _gotSelectedNodeBodyTimer: undefined | NodeJS.Timeout;
    private _gotSelectedNodeRevealTimer: undefined | NodeJS.Timeout;
    private _showBodySwitchBodyTimer: undefined | NodeJS.Timeout;
    private _leoDocumentsRevealTimer: undefined | NodeJS.Timeout;

    // * Reveal Promises
    private _documentPaneReveal: Thenable&lt;void&gt; | undefined;
    private _undoPaneReveal: Thenable&lt;void&gt; | undefined;

    // * Documents Pane
    private _leoDocumentsProvider: LeoDocumentsProvider;
    private _leoDocuments: vscode.TreeView&lt;LeoDocumentNode&gt;;
    private _leoDocumentsExplorer: vscode.TreeView&lt;LeoDocumentNode&gt;;

    // * Goto nav panel
    private _leoGotoProvider: LeoGotoProvider;
    private _leoGoto: vscode.TreeView&lt;LeoGotoNode&gt;;
    private _leoGotoExplorer: vscode.TreeView&lt;LeoGotoNode&gt;;

    // * Undos pane
    private _leoUndosProvider!: LeoUndosProvider;
    private _leoUndos!: vscode.TreeView&lt;LeoUndoNode&gt;;
    private _leoUndosShown = false;
    private _leoUndosExplorer!: vscode.TreeView&lt;LeoUndoNode&gt;;
    private _leoUndosExplorerShown = false;
    private _lastLeoUndos: vscode.TreeView&lt;LeoUndoNode&gt; | undefined;

    // * '@button' pane
    private _leoButtonsProvider: LeoButtonsProvider;
    private _leoButtons: vscode.TreeView&lt;LeoButtonNode&gt;;
    private _leoButtonsExplorer: vscode.TreeView&lt;LeoButtonNode&gt;;
    private _rclickSelected: number[] = [];

    // * Find panel
    private _findPanelWebviewView: vscode.WebviewView | undefined;
    private _findPanelWebviewExplorerView: vscode.WebviewView | undefined;
    private _lastFindView: vscode.WebviewView | undefined;  // ? Maybe unused ?
    private _findNeedsFocus: boolean = false;
    private _lastSettingsUsed: LeoSearchSettings | undefined; // Last settings loaded / saved for current document
    public findFocusTree = false;
    public findHeadlineRange: [number, number] = [0, 0];
    public findHeadlinePosition: ArchivedPosition | undefined;
    private _lastCommandFindEndOutline: number = 0; // Means that last command resolved as a find operation with selection on outline

    // * Interactive Find Input
    private _interactiveSearchInputBox: vscode.InputBox | undefined;

    // * Leo Find Panel
    private _leoFindPanelProvider: vscode.WebviewViewProvider;

    // * Body Pane
    private _changedBodyWithMirrorDetached: string | undefined = undefined; // "id/gnx" string as true
    private _changedDetachedWithMirrorBody: string | undefined = undefined; // "id/gnx" string as true
    private _bodyFileSystemStarted: boolean = false;
    private _detachedFileSystemStarted: boolean = false;
    private _bodyEnablePreview: boolean = true;
    private _leoFileSystem: LeoBodyProvider; // as per https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api
    private _leoDetachedFileSystem!: LeoBodyDetachedProvider; // as per https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api
    private _bodyTextDocument: vscode.TextDocument | undefined; // Set when selected in tree by user, or opening a Leo file in showBody. and by _locateOpenedBody.
    public bodyDetachedTextDocument: vscode.TextDocument | undefined; // Last active detached body.
    private _bodyMainSelectionColumn: vscode.ViewColumn | undefined; // Column of last body 'textEditor' found, set to 1

    private _languageFlagged: string[] = [];

    private _bodyPreviewMode: boolean = true;

    private _editorTouched: boolean = false; // Flag for applying editor changes to body when 'icon' state change and 'undo' back to untouched

    private _bodyStatesTimer: NodeJS.Timeout | undefined;

    public preventIconChange: boolean = false; // Prevent refresh outline to keep selected node icon

    private _bodyUri: vscode.Uri = utils.strToLeoUri('');
    get bodyUri(): vscode.Uri {
        return this._bodyUri;
    }
    set bodyUri(p_uri: vscode.Uri) {
        this._leoFileSystem.setNewBodyUriTime(p_uri);
        this._bodyUri = p_uri;
    }

    // * Selection &amp; scroll
    private _selectionDirty: boolean = false; // Flag set when cursor selection is changed
    private _selectionGnx: string = ''; // Packaged into 'BodySelectionInfo' structures, sent to Leo
    private _selection: vscode.Selection | undefined; // also packaged into 'BodySelectionInfo'
    private _scrollDirty: boolean = false; // Flag set when cursor selection is changed
    private _scrollGnx: string = '';
    private _scroll: vscode.Range | undefined;

    // * Settings / Welcome webview
    public leoSettingsWebview: LeoSettingsProvider;

    // * Log and terminal Panes
    private _leoLogPane: undefined | vscode.OutputChannel;

    // * Status Bar
    private _leoStatusBar: LeoStatusBar; // removed until proper API for knowing focus placement

    // * Edit/Insert Headline Input Box System made with 'createInputBox'.
    private _hib: undefined | vscode.InputBox;
    private _hibResolve: undefined | ((value: string | PromiseLike&lt;string | undefined&gt; | undefined) =&gt; void);
    private _onDidHideResolve: undefined | ((value: PromiseLike&lt;void&gt; | undefined) =&gt; void);
    private _hibLastValue: undefined | string;
    private _hibInterrupted = false;
    private _hibDisposables: vscode.Disposable[] = [];

    // * Timing
    private _needLastSelectedRefresh = false; // USED IN showBody
    private _bodyLastChangedDocument: vscode.TextDocument | undefined; // Only set in _onDocumentChanged
    private _bodyLastChangedDocumentSaved: boolean = true; // don't use 'isDirty' of the document!

    // * Debounced method used to check for closed detached/body tabs
    public checkClosedTabs: (() =&gt; void);

    // * Debounced method used to refresh language of the active commander's detached bodies 
    public refreshCommanderDetachedLanguage: (() =&gt; void);

    // * Debounced method used to refresh the outline-tree title desc
    public refreshDesc: (() =&gt; void);

    // * Debounced method used to get states for UI display flags (commands such as undo, redo, save, ...)
    public getStates: (() =&gt; void);

    // * Debounced method used to get set status bar with the current UNL
    public getUNL: (() =&gt; void);

    // * Debounced method used to get opened Leo Files for the documents pane
    public refreshDocumentsPane: (() =&gt; void);

    // * Debounced method used to get content of the at-buttons pane
    public refreshButtonsPane: (() =&gt; void);

    // * Debounced method used to get content of the goto pane
    public refreshGotoPane: (() =&gt; void);

    // * Debounced method used to get content of the undos pane
    public refreshUndoPane: (() =&gt; void);

    // * Debounced method used to set focused element of the undos pane
    public setUndoSelection: ((p_node: LeoUndoNode) =&gt; void);

    // * Debounced method for refreshing the UI
    public launchRefresh: (() =&gt; void);

    @others

}
</t>
<t tx="felix.20200719025231.20">/**
 * * Returns the 'busy' state flag of the command stack, and leoBridge stack, while showing a message if it is.
 * Needed by special unstackable commands such as new, open,...
 * @param p_all Flag to also return true if either front command stack or bridge stack is busy
 * @returns true if command stack is busy, also returns true if p_all flag is set and bridge is busy
 */
private _isBusy(p_all?: boolean): boolean {
    if (this._commandStack.size() || (p_all &amp;&amp; this._leoBridge.isBusy())) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.TOO_FAST);
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20200719025231.21">/**
 * * Check if the current file is an already saved/named file
 * @returns true if the current opened Leo document's filename has some content. (not a new unnamed file)
 */
private _isCurrentFileNamed(): boolean {
    return !!this.leoStates.leoOpenedFileName.length; // checks if it's an empty string
}

</t>
<t tx="felix.20200719025231.22">/**
 * * Setup leoInteg's UI for having no opened Leo documents
 */
private _setupNoOpenedLeoDocument(): void {
    // Close ALL detached bodies.
    const w_foundTabs: Set&lt;vscode.Tab&gt; = new Set();
    const w_foundUri: Set&lt;vscode.Uri&gt; = new Set();
    for (const p_tabGroup of vscode.window.tabGroups.all) {
        for (const p_tab of p_tabGroup.tabs) {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_DETACHED_SCHEME
            ) {
                w_foundTabs.add(p_tab);
                w_foundUri.add((p_tab.input as vscode.TabInputText).uri);
            }
        }
    }
    if (w_foundTabs.size) {
        void vscode.window.tabGroups.close([...w_foundTabs], true);
        for (const w_uri of w_foundUri) {
            void vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_uri);
        }
    }
    this.leoStates.fileOpenedReady = false;
    this.leoStates.leoCommanderId = "";
    this._bodyTextDocument = undefined;
    this.bodyDetachedTextDocument = undefined;
    this.lastSelectedNode = undefined;
    utils.setGlobalLastActiveFile(this._context, "");
    this._refreshOutline(false, RevealType.NoReveal);
    this.refreshDocumentsPane();
    this.refreshButtonsPane();
    this.refreshUndoPane();
    this._leoStatusBar.hide();
    this.closeBody();
}

</t>
<t tx="felix.20200719025231.23">/**
 * * A Leo file was opened: setup leoInteg's UI accordingly.
 * @return a promise that resolves to an opened body pane text editor
 */
private _setupOpenedLeoDocument(): void {
    this._needLastSelectedRefresh = true;
    // const w_selectedLeoNode = this.apToLeoNode(p_openFileResult.node!, false); // Just to get gnx for the body's fist appearance
    this.leoStates.leoOpenedFileName = this.serverOpenedFileName;
    // * Startup flag
    if (!this.leoStates.fileOpenedReady) {
        this.leoStates.fileOpenedReady = true;
    }
    this.showBodyIfClosed = true;
    this.showOutlineIfClosed = true;
    this.setupRefresh(
        Focus.Body, // Original Leo seems to open itself with focus in body.
        {
            tree: true,
            body: true,
            states: true,
            buttons: true,
            documents: true,
            goto: true
        },
        this.serverOpenedNode
    );
    // * Start body pane system
    if (!this._bodyFileSystemStarted) {
        this._context.subscriptions.push(
            vscode.workspace.registerFileSystemProvider(
                Constants.URI_LEO_SCHEME,
                this._leoFileSystem,
                { isCaseSensitive: true }
            )
        );
        this._bodyFileSystemStarted = true;
    }
    if (!this._detachedFileSystemStarted) {
        this._context.subscriptions.push(
            vscode.workspace.registerFileSystemProvider(
                Constants.URI_LEO_DETACHED_SCHEME,
                this._leoDetachedFileSystem,
                { isCaseSensitive: true }
            )
        );
        this._detachedFileSystemStarted = true;
    }
    if (this.config.showUnlOnStatusBar &amp;&amp; utils.compareVersions(this.serverVersion, { major: 1, minor: 0, patch: 10 })) {
        this._leoStatusBar.show();
    }
    this.sendConfigToServer(this.config.getConfig());
    this.loadSearchSettings();

}

</t>
<t tx="felix.20200719025231.24">/**
 * * Handles the change of vscode config: a onDidChangeConfiguration event triggered
 * @param p_event The configuration-change event passed by vscode
 */
private _onChangeConfiguration(p_event: vscode.ConfigurationChangeEvent): void {

    if (
        p_event.affectsConfiguration(Constants.CONFIG_NAME)
        // ||
        // p_event.affectsConfiguration('editor.fontSize') ||
        // p_event.affectsConfiguration('window.zoomLevel')
    ) {
        this.config.setLeoIntegSettingsPromise.then(
            () =&gt; {
                this.config.buildFromSavedSettings();
                this.leoSettingsWebview.changedConfiguration();

                if (p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_BRANCH_OUTLINE)) {
                    this._refreshDesc();
                }

                if (
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.INVERT_NODES) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_EDIT) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_ADD) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_MARK) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_CLONE) ||
                    p_event.affectsConfiguration(Constants.CONFIG_NAME + "." + Constants.CONFIG_NAMES.SHOW_COPY)
                ) {
                    this.configTreeRefresh();
                }

                if (this.config.showUnlOnStatusBar &amp;&amp; this.leoStates.fileOpenedReady &amp;&amp; this._leoStatusBar) {
                    this._leoStatusBar.show();
                }
                if (!this.config.showUnlOnStatusBar &amp;&amp; this._leoStatusBar) {
                    this._leoStatusBar.hide();
                }
            }
        );

    }

    // also check if workbench.editor.enablePreview
    this._bodyEnablePreview = !!vscode.workspace
        .getConfiguration('workbench.editor')
        .get('enablePreview');

    // Check For "workbench.editor.enablePreview" to be true.
    // Leave small delay for multiple possible forced changes at startup
    setTimeout(() =&gt; {
        this.config.checkEnablePreview();
        this.config.checkCloseEmptyGroups();
        this.config.checkBodyWrap();
    }, 150);
}

</t>
<t tx="felix.20200719025231.25">/**
 * * Handles the node expanding and collapsing interactions by the user in the treeview
 * @param p_event The event passed by vscode
 * @param p_expand True if it was an expand, false if it was a collapse event
 * @param p_treeView Pointer to the treeview itself, either the standalone treeview or the one under the explorer
 */
private async _onChangeCollapsedState(
    p_event: vscode.TreeViewExpansionEvent&lt;ArchivedPosition&gt;,
    p_expand: boolean,
    p_treeView: vscode.TreeView&lt;ArchivedPosition&gt;
): Promise&lt;unknown&gt; {
    // * Expanding or collapsing via the treeview interface selects the node to mimic Leo
    await this.triggerBodySave(true);
    // * Set expanded flag even on leointeg's vscode side of things, mostly for 'insert node'.
    if (p_expand) {
        p_event.element.expanded = true;
    } else {
        p_event.element.expanded = false;
    }
    // * distinguish between: changing expand state on already-selected node -vs- selecting at the same time as clicking caret.
    if (p_treeView.selection[0] &amp;&amp; utils.buildApId(p_treeView.selection[0]) === utils.buildApId(p_event.element)) {
        // * This happens if the tree selection is already the same as the expanded/collapsed node
        // Pass
    } else {
        if (this.config.leoTreeBrowse) {
            // * This part only happens if the user clicked on the arrow without trying to select the node
            this._revealNode(p_event.element, { select: true, focus: false }); // No force focus : it breaks collapse/expand when direct parent
            this.selectTreeNode(p_event.element, true); // not waiting for a .then(...) so not to add any lag
        }
    }

    // * vscode will update its tree by itself, but we need to change Leo's model of its outline
    return this.sendAction(
        p_expand ? Constants.LEOBRIDGE.EXPAND_NODE : Constants.LEOBRIDGE.COLLAPSE_NODE,
        utils.buildNodeCommand(p_event.element)
    );

}

</t>
<t tx="felix.20200719025231.26">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flag to signify that the treeview who triggered this event is the one in the explorer view
 */
private _onTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {
    if (p_event.visible) {
        this._lastTreeView = p_explorerView ? this._leoTreeExView : this._leoTreeView;
        this.setTreeViewTitle();
        this._needLastSelectedRefresh = true; // Its a new node in a new tree so refresh lastSelectedNode too
        if (this.leoStates.fileOpenedReady) {
            this.loadSearchSettings();
        }
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="felix.20200719025231.27">/**
 * * Handle the change of visibility of either leo-documents treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onDocTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {
    if (p_explorerView) {
    } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this.refreshDocumentsPane(); // Have to force refresh to force selection!
    }
}

</t>
<t tx="felix.20200719025231.29">/**
 * * Handles detection of the active editor having changed from one to another, or closed
 * @param p_editor The editor itself that is now active
 * @param p_internalCall Flag used to signify the it was called voluntarily by leoInteg itself
 */
private _onActiveEditorChanged(
    p_editor: vscode.TextEditor | undefined,
    p_internalCall?: boolean
): void {
    if (p_editor) {
        this._hideBodiesUnknownToFileSys([p_editor]);
    }
    if (!p_internalCall) {
        this.triggerBodySave(true, true); // Save in case edits were pending
    }
    // removed until proper API for knowing focus placement
    // // * Status flag check
    // if (!p_editor &amp;&amp; this._leoStatusBar.statusBarFlag) {
    //     return;
    //     // this._leoStatusBar.update(false);
    // }
    // // * Status flag check
    // setTimeout(() =&gt; {
    //     if (vscode.window.activeTextEditor) {
    //         this._leoStatusBar.update(
    //             vscode.window.activeTextEditor.document.uri.scheme === Constants.URI_LEO_SCHEME
    //         );
    //     }
    // }, 0);
}

</t>
<t tx="felix.20200719025231.3">constructor(private _context: vscode.ExtensionContext) {

    const w_effectiveLeojsInExplorer = vscode.workspace.getConfiguration('leojs').get('treeInExplorer', false);

    // * Setup States
    this.leoStates = new LeoStates(_context, this);

    // * Get configuration settings
    this.config = new Config(_context, this);

    // * also check workbench.editor.enablePreview
    this.config.buildFromSavedSettings();
    this._bodyEnablePreview = !!vscode.workspace
        .getConfiguration('workbench.editor')
        .get('enablePreview');

    // * Build Icon filename paths
    this.nodeIcons = utils.buildNodeIconPaths(_context);
    this.undoIcons = utils.buildUndoIconPaths(_context);
    this.documentIcons = utils.buildDocumentIconPaths(_context);
    this.buttonIcons = utils.buildButtonsIconPaths(_context);
    this.gotoIcons = utils.buildGotoIconPaths(_context);

    // * Create file browser instance
    this._leoFilesBrowser = new LeoFilesBrowser(_context);

    // * Setup leoBridge
    this._leoBridge = new LeoBridge(_context, this);

    // * Setup frontend command stack
    this._commandStack = new CommandStack(_context, this);

    // * UNL and URL link handler provider
    this.linkProvider = new UnlProvider();
    this._context.subscriptions.push(
        vscode.languages.registerDocumentLinkProvider(
            [
                { scheme: Constants.URI_FILE_SCHEME },
                { scheme: Constants.URI_UNTITLED_SCHEME },
                { scheme: Constants.URI_LEO_SCHEME },
                { scheme: Constants.URI_LEO_DETACHED_SCHEME },
                { language: Constants.OUTPUT_CHANNEL_LANGUAGE }
            ],
            this.linkProvider
        )
    );

    // * Create a single data provider for both outline trees, Leo view and Explorer view
    this._leoTreeProvider = new LeoApOutlineProvider(this.nodeIcons, !!this.config.invertNodeContrast, this);

    // * Create Leo stand-alone view and Explorer view outline panes
    // Uses 'select node' command, so 'onDidChangeSelection' is not used
    this._leoTreeView = vscode.window.createTreeView(Constants.TREEVIEW_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoTreeProvider,
    });
    this._context.subscriptions.push(
        this._leoTreeView,
        this._leoTreeView.onDidExpandElement((p_event) =&gt;
            this._onChangeCollapsedState(p_event, true, this._leoTreeView)
        ),
        this._leoTreeView.onDidCollapseElement((p_event) =&gt;
            this._onChangeCollapsedState(p_event, false, this._leoTreeView)
        ),
        this._leoTreeView.onDidChangeVisibility((p_event) =&gt;
            this._onTreeViewVisibilityChanged(p_event, false)
        )
    );

    this._leoTreeExView = vscode.window.createTreeView(Constants.TREEVIEW_EXPLORER_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoTreeProvider,
    });
    this._context.subscriptions.push(
        this._leoTreeExView,
        this._leoTreeExView.onDidExpandElement((p_event) =&gt;
            this._onChangeCollapsedState(p_event, true, this._leoTreeExView)
        ),
        this._leoTreeExView.onDidCollapseElement((p_event) =&gt;
            this._onChangeCollapsedState(p_event, false, this._leoTreeExView)
        ),
        this._leoTreeExView.onDidChangeVisibility((p_event) =&gt;
            this._onTreeViewVisibilityChanged(p_event, true)
        )
    );

    // * Init this._lastTreeView based on config only assuming explorer is default sidebar view
    this._lastTreeView = (this.config.treeInExplorer &amp;&amp; !w_effectiveLeojsInExplorer) ? this._leoTreeExView : this._leoTreeView;

    // * Create Leo Opened Documents Treeview Providers and tree views
    this._leoDocumentsProvider = new LeoDocumentsProvider(this);
    this._leoDocuments = vscode.window.createTreeView(Constants.DOCUMENTS_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoDocumentsProvider,
    });
    this._context.subscriptions.push(
        this._leoDocuments,
        this._leoDocuments.onDidChangeVisibility((p_event) =&gt;
            this._onDocTreeViewVisibilityChanged(p_event, false)
        )
    );
    this._leoDocumentsExplorer = vscode.window.createTreeView(Constants.DOCUMENTS_EXPLORER_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoDocumentsProvider,
    });
    this._context.subscriptions.push(
        this._leoDocumentsExplorer,
        this._leoDocumentsExplorer.onDidChangeVisibility((p_event) =&gt;
            this._onDocTreeViewVisibilityChanged(p_event, true)
        )
    );

    // * Create '@buttons' Treeview Providers and tree views
    this._leoButtonsProvider = new LeoButtonsProvider(this);
    this._leoButtons = vscode.window.createTreeView(Constants.BUTTONS_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoButtonsProvider,
    });
    this._context.subscriptions.push(
        this._leoButtons,
        this._leoButtons.onDidChangeVisibility((p_event) =&gt;
            this._onButtonsTreeViewVisibilityChanged(p_event, false)
        )
    );
    this._leoButtonsExplorer = vscode.window.createTreeView(Constants.BUTTONS_EXPLORER_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoButtonsProvider,
    });
    this._context.subscriptions.push(
        this._leoButtonsExplorer,
        this._leoButtonsExplorer.onDidChangeVisibility((p_event) =&gt;
            this._onButtonsTreeViewVisibilityChanged(p_event, true)
        )
    );

    // * Create goto Treeview Providers and tree views
    this._leoGotoProvider = new LeoGotoProvider(this);
    this._leoGoto = vscode.window.createTreeView(Constants.GOTO_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoGotoProvider,
    });
    this._context.subscriptions.push(
        this._leoGoto,
        this._leoGoto.onDidChangeVisibility((p_event) =&gt;
            this._onGotoTreeViewVisibilityChanged(p_event, false)
        )
    );
    this._leoGotoExplorer = vscode.window.createTreeView(Constants.GOTO_EXPLORER_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoGotoProvider,
    });
    this._context.subscriptions.push(
        this._leoGotoExplorer,
        this._leoGotoExplorer.onDidChangeVisibility((p_event) =&gt;
            this._onGotoTreeViewVisibilityChanged(p_event, true)
        )
    );
    // * Set 'last' goto tree view visible
    this._leoGotoProvider.setLastGotoView((this.config.treeInExplorer &amp;&amp; !w_effectiveLeojsInExplorer) ? this._leoGotoExplorer : this._leoGoto);

    // * Create 'Undo History' Treeview Providers and tree views
    this._leoUndosProvider = new LeoUndosProvider(this);
    this._context.subscriptions.push(
        this._leoUndos,
        this._leoUndos = vscode.window.createTreeView(Constants.UNDOS_ID, {
            showCollapseAll: false,
            treeDataProvider: this._leoUndosProvider,
        }),
        this._leoUndos.onDidChangeVisibility((p_event) =&gt;
            this._onUndosTreeViewVisibilityChanged(p_event, false)
        )
    );
    this._context.subscriptions.push(
        this._leoUndosExplorer,
        this._leoUndosExplorer = vscode.window.createTreeView(Constants.UNDOS_EXPLORER_ID, {
            showCollapseAll: false,
            treeDataProvider: this._leoUndosProvider,
        }),
        this._leoUndosExplorer.onDidChangeVisibility((p_event) =&gt;
            this._onUndosTreeViewVisibilityChanged(p_event, true)
        )
    );

    // * Create Body Pane
    this._leoFileSystem = new LeoBodyProvider(this);
    this._leoDetachedFileSystem = new LeoBodyDetachedProvider(this);

    this._bodyMainSelectionColumn = 1;

    // * Create Status bar Entry
    this._leoStatusBar = new LeoStatusBar(_context, this);

    // * Automatic server start service
    this._serverService = new ServerService(_context, this);

    // * Leo Find Panel
    this._leoFindPanelProvider = new LeoFindPanelProvider(
        _context.extensionUri,
        _context,
        this
    );
    this._context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(
            Constants.FIND_ID,
            this._leoFindPanelProvider,
            { webviewOptions: { retainContextWhenHidden: true } }
        )
    );
    this._context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(
            Constants.FIND_EXPLORER_ID,
            this._leoFindPanelProvider,
            { webviewOptions: { retainContextWhenHidden: true } }
        )
    );

    // * Configuration / Welcome webview
    this.leoSettingsWebview = new LeoSettingsProvider(_context, this);

    // * 'onDid' event detections. All pushed as disposables in context.subscription
    this._context.subscriptions.push(

        vscode.window.tabGroups.onDidChangeTabGroups((p_tabGroupEvent) =&gt;
            this._onTabGroupsChanged(p_tabGroupEvent)
        ),
        vscode.window.tabGroups.onDidChangeTabs((p_tabEvent) =&gt;
            this._onTabsChanged(p_tabEvent)
        ),

        // * React to change in active panel/text editor (window.activeTextEditor) - also fires when the active editor becomes undefined
        vscode.window.onDidChangeActiveTextEditor((p_editor) =&gt;
            this._onActiveEditorChanged(p_editor)
        ),

        // * React to change in selection, cursor position and scroll position
        vscode.window.onDidChangeTextEditorSelection((p_event) =&gt;
            this._onChangeEditorSelection(p_event)
        ),
        vscode.window.onDidChangeTextEditorVisibleRanges((p_event) =&gt;
            this._onChangeEditorScroll(p_event)
        ),

        // * Triggers when a different text editor/vscode window changed focus or visibility, or dragged
        // This is also what triggers after drag and drop, see '_onChangeEditorViewColumn'
        vscode.window.onDidChangeTextEditorViewColumn((p_columnChangeEvent) =&gt;
            this._changedTextEditorViewColumn(p_columnChangeEvent)
        ), // Also triggers after drag and drop
        vscode.window.onDidChangeVisibleTextEditors((p_editors) =&gt;
            this._changedVisibleTextEditors(p_editors)
        ), // Window.visibleTextEditors changed
        vscode.window.onDidChangeWindowState((p_windowState) =&gt;
            this._changedWindowState(p_windowState)
        ), // Focus state of the current window changes

        // * React when typing and changing body pane
        vscode.workspace.onDidChangeTextDocument((p_textDocumentChange) =&gt;
            this._onDocumentChanged(p_textDocumentChange)
        ),

        // * React to configuration settings events
        vscode.workspace.onDidChangeConfiguration((p_configChange) =&gt;
            this._onChangeConfiguration(p_configChange)
        ),

        // * React to opening of any file in vscode
        vscode.workspace.onDidOpenTextDocument((p_document) =&gt;
            this._onDidOpenTextDocument(p_document)
        )
    );
    // * Debounced refresh flags and UI parts, other than the tree and body
    this.checkClosedTabs = debounce(
        this._checkClosedTabs,
        Constants.CLEANUP_DEBOUNCE_DELAY
    );
    this.refreshCommanderDetachedLanguage = debounce(
        this._refreshCommanderDetachedLanguage,
        Constants.DETACHED_LANGUAGE_DELAY
    );
    this.refreshDesc = debounce(
        this._refreshDesc,
        Constants.OUTLINE_DESC_DEBOUNCE_DELAY
    );
    this.getStates = debounce(
        this._triggerGetStates,
        Constants.STATES_DEBOUNCE_DELAY
    );
    this.getUNL = debounce(
        this._getUNL,
        Constants.UNL_DEBOUNCE_DELAY
    );
    this.refreshDocumentsPane = debounce(
        this._refreshDocumentsPane,
        Constants.DOCUMENTS_DEBOUNCE_DELAY
    );
    this.refreshButtonsPane = debounce(
        this._refreshButtonsPane,
        Constants.BUTTONS_DEBOUNCE_DELAY
    );
    this.refreshGotoPane = debounce(
        this._refreshGotoPane,
        Constants.GOTO_DEBOUNCE_DELAY
    );
    this.refreshUndoPane = debounce(
        this._refreshUndoPane,
        Constants.UNDOS_DEBOUNCE_DELAY
    );
    this.setUndoSelection = debounce(
        this._setUndoSelection,
        Constants.UNDOS_REVEAL_DEBOUNCE_DELAY
    );
    this.launchRefresh = debounce(
        this._launchRefresh,
        Constants.REFRESH_DEBOUNCE_DELAY
    );

}

</t>
<t tx="felix.20200719025231.31">/**
 * * Handle typing, undos and read-from-file refreshes that was detected as a document change
 * @param p_textDocumentChange Text changed event passed by vscode
 */
private _onDocumentChanged(p_textDocumentChange: vscode.TextDocumentChangeEvent): void {

    if (
        p_textDocumentChange.contentChanges.length &amp;&amp;
        (p_textDocumentChange.document.uri.scheme === Constants.URI_LEO_DETACHED_SCHEME)
    ) {
        const w_detachedGnx = utils.leoUriToStr(p_textDocumentChange.document.uri);
        const [unused, id, gnx] = p_textDocumentChange.document.uri.path.split("/");
        const w_bodyText = p_textDocumentChange.document.getText().replace(/\r\n/g, "\n");
        const w_hasBody = !!w_bodyText.length;

        const w_selectedCId = this.leoStates.leoCommanderId; // g.app.windowList[this.frameIndex].c.id.toString();
        const w_sameCommander = w_selectedCId === id;
        let w_needDocRefresh = false;
        let w_alreadySaved = false;
        let w_v: ArchivedPosition | undefined;

        w_v = this._leoDetachedFileSystem.openedBodiesVNodes[w_detachedGnx];

        // console.log(this._changedBodyWithMirrorDetached, (w_v &amp;&amp; (w_bodyText === w_v._lastBodyData)));

        if (this._changedBodyWithMirrorDetached || (w_v &amp;&amp; (w_bodyText === w_v._lastBodyData))) {
            // console.log('document changed DETACHED not user modification ' + (this.changedBodyWithMirrorDetached ? " Cleared changedBodyWithMirrorDetached" : ""), (w_v &amp;&amp; (w_bodyText === w_v._lastBodyData)));
            // WAS NOT A USER MODIFICATION?
            this._changedBodyWithMirrorDetached = undefined;
            this._bodySaveDocument(p_textDocumentChange.document);
            return;
        } else if (w_v._lastBodyData) {
            w_v._lastBodyData = undefined;
        }

        this.bodyDetachedTextDocument = p_textDocumentChange.document;

        // * If body changed a line with and '@' directive, set w_needsRefresh
        let w_needsRefresh = false;

        for (const p_change of p_textDocumentChange.contentChanges) {
            if (p_change.rangeLength || p_change.text.includes('@')) {
                // is replacing a chunk. (pasting, deleting a range)
                w_needsRefresh = true;
                break;
            }
        }

        // * Detect in active editor if current cursor line is language related, set w_needsRefresh if so.
        const w_textEditor = vscode.window.activeTextEditor;
        if (
            w_textEditor &amp;&amp; w_textEditor.selections &amp;&amp; w_textEditor.selections.length &amp;&amp;
            !w_needsRefresh &amp;&amp; p_textDocumentChange.document.uri.fsPath === w_textEditor.document.uri.fsPath
        ) {
            for (const p_selection of w_textEditor.selections) {
                if (p_selection.active.line &lt; w_textEditor.document.lineCount) {
                    // TRY TO DETECT IF LANGUAGE RESET NEEDED!
                    let w_line = w_textEditor.document.lineAt(p_selection.active.line).text;
                    if (w_line.trim().startsWith('@') || w_line.includes('language') || w_line.includes('wrap') || w_line.includes('killcolor') || w_line.includes('nocolor-node')) {
                        w_needsRefresh = true;
                        break;
                    }
                }
            }
        }

        const w_uriKey = utils.leoUriToStr(this.bodyDetachedTextDocument.uri);
        const w_node = this._leoDetachedFileSystem.openedBodiesVNodes[w_uriKey];
        const w_detachedIconChanged = !w_node.dirty || (!!w_node.hasBody === !w_hasBody);

        // If same commander, and node icon changed (or whole document was unchanged)
        if (w_sameCommander) {
            if (!this.leoStates.leoChanged || w_detachedIconChanged) {
                if (!w_alreadySaved) {
                    // console.log(
                    //     'bodySAVE DETACHED because icon changed:\n' +
                    //     ' this.leoStates.leoChanged: ' + this.leoStates.leoChanged +
                    //     '\n w_node.dirty' + w_node.dirty +
                    //     "\n!!w_node.hasBody === !w_hasBody" + (!!w_node.hasBody === !w_hasBody)
                    // );

                    void this._bodySaveDocument(this.bodyDetachedTextDocument);
                    w_alreadySaved = true;
                }
                if (w_detachedIconChanged) {
                    this.findFocusTree = false;
                    // NOT incrementing this.treeID to keep ids intact
                    // NoReveal since we're keeping the same id.
                    this._refreshOutline(false, RevealType.NoReveal);
                }
            }
        } else {
            for (const doc of this._leoDocumentsProvider.lastDocumentList) {
                if (doc.documentEntry.id.toString() === id) {
                    // found it.
                    if (!doc.documentEntry.changed) {
                        // not changed, so needs refresh of documents.
                        w_needDocRefresh = true;
                        if (!w_alreadySaved) {
                            void this._bodySaveDocument(this.bodyDetachedTextDocument);
                            w_alreadySaved = true;
                        }
                    }
                    break;
                }
            }
        }

        // * SET NEW VSNODE STATES FOR FUTURE w_detachedIconChanged DETECTION!
        w_node.dirty = true;
        w_node.hasBody = w_hasBody;

        if (w_needsRefresh) {
            if (!w_alreadySaved) {
                void this._bodySaveDocument(this.bodyDetachedTextDocument);
                w_alreadySaved = true;
            }
            // REFRESH LANGUAGE OF THIS DETACHED BODY
            const w_foundVnode = this._leoDetachedFileSystem.openedBodiesVNodes[utils.leoUriToStr(p_textDocumentChange.document.uri)];
            if (w_foundVnode) {
                if (!w_alreadySaved) {
                    // console.log('bodySAVE DETACHED because w_needsRefresh');

                    void this._bodySaveDocument(this.bodyDetachedTextDocument);
                    w_alreadySaved = true;
                }

                this._getBodyLanguage(w_v, id).then((p_language) =&gt; {
                    if (this.bodyDetachedTextDocument &amp;&amp; p_language !== this.bodyDetachedTextDocument.languageId) {
                        void this._setBodyLanguage(this.bodyDetachedTextDocument, p_language);
                    }
                });

            } else {
                console.log('DETACHED VNODE not found when resetting language');
            }
            // REFRESH LANGUAGE OF OTHER DETACHED BODIES WITH DELAY
            this.refreshCommanderDetachedLanguage();
        }

        // * CHECK FOR BODY THAT MATCHES! set w_sameBodyTabOpened if so.
        let w_sameBodyTabOpened = false;
        for (const p_tabGroup of vscode.window.tabGroups.all) {
            for (const p_tab of p_tabGroup.tabs) {
                if (p_tab.input &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                    ((p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME)
                ) {
                    if (gnx === utils.leoUriToStr((p_tab.input as vscode.TabInputText).uri)) {
                        w_sameBodyTabOpened = true;
                        break;
                    }
                }
            }
            if (w_sameBodyTabOpened) {
                // console.log('found same body that MATCHES!');
                break;
            }
        }

        // Check if exact same commander AND same gnx: BOTH THE SAME so refresh the body!
        if (w_sameCommander) {
            if (w_sameBodyTabOpened &amp;&amp; this.lastSelectedNode &amp;&amp; gnx === this.lastSelectedNode.gnx) {
                // Same commander AND same gnx  !  
                if (!w_alreadySaved) {
                    // console.log('bodySAVE DETACHED because same tab opened');
                    void this._bodySaveDocument(this.bodyDetachedTextDocument);
                    w_alreadySaved = true;
                }
                if (this._leoFileSystem.watchedBodiesGnx.includes(gnx)) {
                    // console.log("setting changedDetachedWithMirrorBody");

                    this._changedDetachedWithMirrorBody = `${id}/${gnx}`; // PREVENT DOUBLE REFRESH
                }
                // console.log('fire refresh of body');
                this._leoFileSystem.fireRefreshFile(this.lastSelectedNode.gnx);
            }

            if (w_needsRefresh) {
                this.debouncedRefreshBodyStates(50); // And maybe changed in other node of same commander!
            }

        } else if (w_needDocRefresh) {
            this.refreshDocumentsPane();
        }

        if (!this.leoStates.leoChanged) {
            // also refresh document panel (icon may be dirty now)
            this.leoStates.leoChanged = true;
            this.refreshDocumentsPane();
        }

    }

    // ".length" check necessary, see https://github.com/microsoft/vscode/issues/50344
    if (
        this.lastSelectedNode &amp;&amp;
        p_textDocumentChange.contentChanges.length &amp;&amp;
        p_textDocumentChange.document.uri.scheme === Constants.URI_LEO_SCHEME
    ) {

        // * There was a on a Leo Body by the user OR FROM LEO REFRESH FROM FILE
        this._bodyLastChangedDocument = p_textDocumentChange.document;
        this._bodyLastChangedDocumentSaved = false;
        this._editorTouched = true; // To make sure to transfer content to Leo even if all undone
        this._bodyPreviewMode = false;
        let w_hasSameDetachedTab = false;
        const c_id = this.leoStates.leoCommanderId;
        const w_lastSelNodeGnx = this.lastSelectedNode.gnx;


        // CHECK FOR DETACHED THAT MATCHES! 
        for (const p_tabGroup of vscode.window.tabGroups.all) {
            for (const p_tab of p_tabGroup.tabs) {
                if (p_tab.input &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_DETACHED_SCHEME
                ) {
                    const [unused, id, gnx] = (p_tab.input as vscode.TabInputText).uri.path.split("/");
                    if (id === c_id &amp;&amp; gnx === w_lastSelNodeGnx) {
                        w_hasSameDetachedTab = true;
                        break;
                    }
                }
            }
            if (w_hasSameDetachedTab) {
                // console.log('found same DETACHED that MATCHES!');
                break;
            }
        }

        // * If icon should change then do it now (if there's no document edit pending)
        if (
            utils.leoUriToStr(p_textDocumentChange.document.uri) === this.lastSelectedNode.gnx
        ) {
            const w_bodyText = p_textDocumentChange.document.getText().replace(/\r\n/g, "\n");
            const w_hasBody = !!w_bodyText.length;
            const w_iconChanged = utils.isIconChangedByEdit(this.lastSelectedNode, w_hasBody);

            let w_skipSave = false;

            if (
                this._changedDetachedWithMirrorBody ||
                (this._leoFileSystem.lastGnx === this.lastSelectedNode.gnx &amp;&amp;
                    w_bodyText === this._leoFileSystem.lastBodyData)
            ) {
                // WAS NOT A USER MODIFICATION? (external file change, replace, replace-then-find)
                // console.log(
                //     '--------- document changed BODY not user modification ' +
                //     (this.changedDetachedWithMirrorBody ? " Cleared changedDetachedWithMirrorBody ! " : ""),
                //     (this._leoFileSystem.lastGnx === this.lastSelectedNode.gnx &amp;&amp;
                //         w_bodyText === this._leoFileSystem.lastBodyData)
                // );
                // Set proper cursor insertion point and selection range.
                this._changedDetachedWithMirrorBody = undefined;
                // this._bodySaveDocument(p_textDocumentChange.document);
                // ALSO check if the icon would change!
                this.showBody(false, true, true);
                // this.refreshCommanderDetachedLanguage();
                // w_skipSave = true;
                return; // ! TEST WITH / WITHOUT RETURN !

            } else {
                this._leoFileSystem.lastBodyData = undefined;
                // console.log('document changed BODY !');
            }

            if (!this.leoStates.leoChanged || w_iconChanged || w_hasSameDetachedTab) {
                // console.log('need to change icon');

                if (this.preventIconChange &amp;&amp; !w_skipSave) {
                    // TODO : CLEANUP "preventIconChange" IF NOT NEEDED !
                    // this.preventIconChange = false;

                } else {
                    // this.preventIconChange = false;
                    if (this.lastSelectedNode) {
                        this.lastSelectedNode.dirty = true;
                        this.lastSelectedNode.hasBody = w_hasBody;
                    }

                    let q_save = Promise.resolve(true);
                    if (w_skipSave &amp;&amp; w_iconChanged) {
                        q_save = Promise.resolve(true);
                    } else {
                        // Document pane icon needs refresh (changed) and/or outline icon changed
                        q_save = this._bodySaveDocument(p_textDocumentChange.document);
                    }
                    q_save.then(() =&gt; {
                        if (w_hasSameDetachedTab &amp;&amp; this.lastSelectedNode) {
                            const gnxString = `${c_id}/${w_lastSelNodeGnx}`;
                            if (this._leoDetachedFileSystem.watchedBodiesGnx.includes(gnxString)) {
                                // console.log("setting changedBodyWithMirrorDetached");
                                this._changedBodyWithMirrorDetached = gnxString; // PREVENT DOUBLE REFRESH
                            }
                            // console.log('fire refresh of DETACHED');

                            this._leoDetachedFileSystem.fireRefreshFile(gnxString);
                        }
                        if (w_iconChanged) {
                            // NOT incrementing this.treeID to keep ids intact
                            // NoReveal since we're keeping the same id.
                            this._refreshOutline(false, RevealType.NoReveal);
                        }
                    });
                }
                this.preventIconChange = false; // SET FALSE AFTER NO MATTER WHAT

                if (!this.leoStates.leoChanged) {
                    // also refresh document panel (icon may be dirty now)
                    this.leoStates.leoChanged = true;
                    this.refreshDocumentsPane();
                }
            }
        }

        // * If body changed a line with and '@' directive refresh body states
        let w_needsRefresh = false;
        for (const p_change of p_textDocumentChange.contentChanges) {
            if (p_change.rangeLength || p_change.text.includes('@')) {
                // There may have been an @
                w_needsRefresh = true;
                break;
            }
        }

        const w_textEditor = vscode.window.activeTextEditor;

        if (w_textEditor &amp;&amp; p_textDocumentChange.document.uri.fsPath === w_textEditor.document.uri.fsPath) {
            for (const p_selection of w_textEditor.selections) {
                // TRY TO DETECT IF LANGUAGE RESET NEEDED!
                if (p_selection.active.line &lt; w_textEditor.document.lineCount) {
                    let w_line = w_textEditor.document.lineAt(p_selection.active.line).text;
                    if (w_line.trim().startsWith('@') || w_line.includes('language') || w_line.includes('wrap') || w_line.includes('killcolor') || w_line.includes('nocolor-node')) {
                        w_needsRefresh = true;
                        break;
                    }
                }
            }
        }
        if (w_needsRefresh) {
            this.debouncedRefreshBodyStates(Constants.BODY_STATES_DEBOUNCE_DELAY);
            this.refreshCommanderDetachedLanguage();
        }

    }
}

</t>
<t tx="felix.20200719025231.32">/**
 * * Validate headline edit input box if active, or, Save body to the Leo app if its dirty.
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the possible saving process is finished
 */
public triggerBodySave(p_forcedVsCodeSave?: boolean, p_fromFocusChange?: boolean): Promise&lt;unknown&gt; {

    // * Check if headline edit input box is active. Validate it with current value.
    if (!p_fromFocusChange &amp;&amp; this._hib &amp;&amp; this._hib.enabled) {
        this._hibInterrupted = true;
        this._hib.enabled = false;
        this._hibLastValue = this._hib.value;
        this._hib.hide();
        if (this._onDidHideResolve) {
            console.error('IN triggerBodySave AND _onDidHideResolve PROMISE ALREADY EXISTS!');
        }
        const w_resolveAfterEditHeadline = new Promise&lt;void&gt;((p_resolve, p_reject) =&gt; {
            this._onDidHideResolve = p_resolve;
        });
        return w_resolveAfterEditHeadline;
    }

    // * Save any 'detached' dirty panels to leo
    for (const doc of vscode.workspace.textDocuments) {
        if (!doc.isClosed &amp;&amp; doc.isDirty &amp;&amp; doc.uri.scheme === Constants.URI_LEO_DETACHED_SCHEME) {
            void this._bodySaveDocument(doc, p_forcedVsCodeSave);
        }
    }

    // * Save body to Leo if a change has been made to the body 'document' so far
    let q_savePromise: Promise&lt;boolean&gt;;
    if (
        this._bodyLastChangedDocument &amp;&amp;
        (this._bodyLastChangedDocument.isDirty || this._editorTouched) &amp;&amp;
        !this._bodyLastChangedDocumentSaved
    ) {
        // * Is dirty and unsaved, so proper save is in order
        const w_document = this._bodyLastChangedDocument; // backup for bodySaveDocument before reset
        this._bodyLastChangedDocumentSaved = true;
        this._editorTouched = false;
        q_savePromise = this._bodySaveDocument(w_document, p_forcedVsCodeSave);
    } else if (
        p_forcedVsCodeSave &amp;&amp;
        this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty &amp;&amp;
        this._bodyLastChangedDocumentSaved
    ) {
        // * Had 'forcedVsCodeSave' and isDirty only, so just clean up dirty VSCODE document flag.
        this._bodyLastChangedDocument.save(); // ! USED INTENTIONALLY: This trims trailing spaces
        q_savePromise = this._bodySaveSelection(); // just save selection if it's changed
    } else {
        this._bodyLastChangedDocumentSaved = true;
        q_savePromise = this._bodySaveSelection();  // just save selection if it's changed
    }
    return q_savePromise.then((p_result) =&gt; {
        // this.debouncedRefreshBodyStates(); // ! test this !

        return p_result;
    }, (p_reason) =&gt; {
        console.log('BodySave rejected :', p_reason);
        return false;
    });
}

</t>
<t tx="felix.20200719025231.33">/**
 * * Sets new body text (or detached body) on leo's side, and may optionally save vsCode's body editor (which will trim spaces)
 * @param p_document Vscode's text document which content will be used to be the new node's body text in Leo
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the complete saving process is finished
 */
private async _bodySaveDocument(
    p_document: vscode.TextDocument,
    p_forcedVsCodeSave?: boolean
): Promise&lt;boolean&gt; {

    if (p_document) {

        let id: string = ""; // STARTS FALSY
        let w_gnx: string;

        if (p_document.uri.scheme === Constants.URI_LEO_DETACHED_SCHEME) {
            // detached body
            id = p_document.uri.path.split("/")[1];
            // find commander
            w_gnx = p_document.uri.path.split("/")[2];

        } else {
            // regular body
            w_gnx = utils.leoUriToStr(p_document.uri);
        }

        const w_param: Record&lt;string, string&gt; = {
            gnx: w_gnx,
            body: p_document.getText().replace(/\r\n/g, "\n"),
        };
        if (id) {
            w_param["commanderId"] = id;
        }
        //@ts-expect-error
        //@ts-expect-error
        //@ts-expect-error
        //@ts-expect-error
        //@ts-expect-error
        //@ts-expect-error
        //@ts-expect-error
        //@ts-expect-error
        //@ts-expect-error
        //@ts-expect-error
        // Don't wait for promise!
        this.sendAction(Constants.LEOBRIDGE.SET_BODY, w_param);

        // await for bodySaveSelection that is placed on the stack right after saving body
        await this._bodySaveSelection();

        if (!id) {
            // if NOT detached
            this._refreshType.states = true;
            this.getStates();
        }

        if (p_forcedVsCodeSave) {
            return p_document.save(); // ! USED INTENTIONALLY: This trims trailing spaces
        }

        return Promise.resolve(p_document.isDirty);
    } else {
        return Promise.resolve(false);
    }
}

</t>
<t tx="felix.20200719025231.35">/**
 * * Show the outline, with Leo's selected node also selected, and optionally focussed
 * @param p_focusOutline Flag for focus to be placed in outline
 */
public async showOutline(p_focusOutline?: boolean): Promise&lt;unknown&gt; {

    this._revealType = RevealType.RevealSelectFocus;
    let q_outline: Thenable&lt;unknown&gt;;

    if (!this.isOutlineVisible()) {
        let w_viewName: string;
        if (this._lastTreeView === this._leoTreeExView) {
            w_viewName = Constants.TREEVIEW_EXPLORER_ID;
        } else {
            w_viewName = Constants.TREEVIEW_ID;
        }
        q_outline = vscode.commands.executeCommand(w_viewName + ".focus");
    } else {
        q_outline = Promise.resolve();
    }
    q_outline.then(() =&gt; {
        if (this.lastSelectedNode) {
            return this._lastTreeView.reveal(this.lastSelectedNode, {
                select: true,
                focus: !!p_focusOutline,
            }).then(
                () =&gt; { }, // ok
                (p_reason) =&gt; {
                    console.log('showOutline could not reveal. Reason: ', p_reason);
                }
            );
        }
        return Promise.resolve();
    });
    return q_outline;
}

</t>
<t tx="felix.20200719025231.4"></t>
<t tx="felix.20200719025231.47">/**
 * * Close body pane document and change the bodyUri to this.lastSelectedNode's gnx
 * This blocks 'undos' from crossing over
 * @param p_aside From 'Open Aside'.
 * @param p_preventTakingFocus prevents forcing focus on text body.
 */
private _switchBody(
    p_aside: boolean,
    p_preventTakingFocus?: boolean
): Thenable&lt;void | vscode.TextEditor&gt; {
    const w_oldUri: vscode.Uri = this.bodyUri;
    const w_newUri: vscode.Uri = utils.strToLeoUri(this.lastSelectedNode!.gnx);
    const w_newTS = performance.now();
    const w_visibleCount = this._isBodyVisible();

    this.bodyUri = w_newUri; // New GLOBAL BODY URI

    if (w_visibleCount === 0 &amp;&amp; !this.showBodyIfClosed) {
        return Promise.resolve();
    }

    if (w_visibleCount === 1) {
        this._bodyPreviewMode = this._isBodyPreview(); // recheck in case user double clicked on title
    }

    if (this.lastSelectedNode &amp;&amp; this._bodyPreviewMode &amp;&amp; this._bodyEnablePreview &amp;&amp; w_visibleCount &lt; 2) {

        // just show in same column and delete after
        const q_showBody = this.showBody(p_aside, p_preventTakingFocus);

        if (w_oldUri.fsPath !== this.bodyUri.fsPath) {
            q_showBody.then(() =&gt; {
                const w_tabsToCloseFound: vscode.Tab[] = [];
                let q_lastSecondSaveFound: Thenable&lt;boolean&gt; = Promise.resolve(true);
                vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
                    p_tabGroup.tabs.forEach((p_tab) =&gt; {
                        if (p_tab.input &amp;&amp;
                            (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                            (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME &amp;&amp;
                            (p_tab.input as vscode.TabInputText).uri.fsPath === w_oldUri.fsPath
                        ) {
                            // Make sure it's saved AGAIN!!
                            if (
                                p_tab.isDirty &amp;&amp;
                                this._bodyLastChangedDocument &amp;&amp;
                                (p_tab.input as vscode.TabInputText).uri.fsPath === this._bodyLastChangedDocument.uri.fsPath
                            ) {
                                // console.log('LAST SECOND SAVE1!');
                                this._leoFileSystem.preventSaveToLeo = true;
                                this._editorTouched = false;
                                q_lastSecondSaveFound = this._bodyLastChangedDocument.save();
                            }
                            w_tabsToCloseFound.push(p_tab);
                        }
                    });
                });
                if (w_tabsToCloseFound.length) {
                    q_lastSecondSaveFound.then(() =&gt; {
                        vscode.window.tabGroups.close(w_tabsToCloseFound, true);
                    });
                }
                // Remove from potential 'recently opened'
                vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_oldUri);

            });
        }
        return q_showBody;
    } else {
        // Close ALL LEO EDITORS first !
        const w_tabsToCloseAll: vscode.Tab[] = [];
        let q_lastSecondSaveAll: Thenable&lt;boolean&gt; = Promise.resolve(true);

        vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
            p_tabGroup.tabs.forEach((p_tab) =&gt; {
                if (p_tab.input &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME &amp;&amp;
                    w_newUri.fsPath !== (p_tab.input as vscode.TabInputText).uri.fsPath // Maybe useless to check if different!
                ) {

                    if (
                        p_tab.isDirty &amp;&amp;
                        this._bodyLastChangedDocument &amp;&amp;
                        (p_tab.input as vscode.TabInputText).uri.fsPath === this._bodyLastChangedDocument.uri.fsPath
                    ) {
                        // console.log('LAST SECOND SAVE2!');
                        this._leoFileSystem.preventSaveToLeo = true;
                        this._editorTouched = false;
                        q_lastSecondSaveAll = this._bodyLastChangedDocument.save();
                    }

                    w_tabsToCloseAll.push(p_tab);
                }
            });
        });

        let q_closeAll: Thenable&lt;unknown&gt;;
        if (w_tabsToCloseAll.length) {
            q_closeAll = q_lastSecondSaveAll.then(() =&gt; {
                return vscode.window.tabGroups.close(w_tabsToCloseAll, true);
            });

        } else {
            q_closeAll = Promise.resolve();
        }

        // async, so don't wait for this to finish
        if (w_oldUri.fsPath !== w_newUri.fsPath) {
            vscode.commands.executeCommand(
                'vscode.removeFromRecentlyOpened',
                w_oldUri
            );
        }

        return q_closeAll.then(() =&gt; {
            this._bodyPreviewMode = true;
            // * CHECK ALL 3 POSSIBLE NEW PLACES FOR BODY SWITCH AFTER q_bodyStates &amp; q_showTextDocument
            if (
                // Should the gnx be relevant?  !this.isGnxStillValid(w_newGnx, w_newTS)
                !this.isTsStillValid(w_newTS)
            ) {
                return;
            }
            return this.showBody(p_aside, p_preventTakingFocus);
        });
    }
}

</t>
<t tx="felix.20200719025231.48">/**
 * * Sets globals if the current body is found opened in an editor panel for a particular gnx
 * @param p_gnx gnx to match
 * @returns true if located and found, false otherwise
 */
private _locateOpenedBody(p_gnx: string): boolean {
    let w_found = false;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME &amp;&amp;
                utils.leoUriToStr((p_tab.input as vscode.TabInputText).uri) === p_gnx
            ) {
                vscode.workspace.textDocuments.forEach((p_textDocument) =&gt; {
                    if (
                        utils.leoUriToStr(p_textDocument.uri) === p_gnx
                    ) {
                        w_found = true;
                        this._bodyTextDocument = p_textDocument; // vscode.workspace.openTextDocument
                        this._bodyMainSelectionColumn = p_tab.group.viewColumn;
                    }
                });
            }
        });
    });
    return w_found;
}

</t>
<t tx="felix.20200719025231.49">
/**
 * * Closes any body pane opened in this vscode window instance
 * @returns a promise that resolves when the file is closed and removed from recently opened list
 */
public closeBody(): Thenable&lt;any&gt; {

    const w_foundTabs: vscode.Tab[] = [];
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME
            ) {
                w_foundTabs.push(p_tab);
            }
        });
    });

    let q_closedTabs;
    if (w_foundTabs.length) {
        q_closedTabs = vscode.window.tabGroups.close(w_foundTabs, true);
        w_foundTabs.forEach((p_tab) =&gt; {
            if (p_tab.input) {

                vscode.commands.executeCommand(
                    'vscode.removeFromRecentlyOpened',
                    (p_tab.input as vscode.TabInputText).uri
                );
                // Delete to close all other body tabs.
                // (w_oldUri will be deleted last below)
                const w_edit = new vscode.WorkspaceEdit();
                w_edit.deleteFile((p_tab.input as vscode.TabInputText).uri, { ignoreIfNotExists: true });
                vscode.workspace.applyEdit(w_edit);
            }
        });
    } else {
        q_closedTabs = Promise.resolve(true);

    }

    let q_closedBody;
    if (this.bodyUri) {
        q_closedBody = vscode.commands.executeCommand(
            'vscode.removeFromRecentlyOpened',
            this.bodyUri
        );
    } else {
        q_closedBody = Promise.resolve(true);
    }

    return Promise.all([q_closedTabs, q_closedBody]);
}

</t>
<t tx="felix.20200719025231.5">/**
 * * Core of the integration of Leo into vscode: Sends an action to the leoBridge in leoserver.py.
 * @param p_action is the action string constant, from Constants.LEOBRIDGE
 * @param p_param (optional) JSON string to be given to the python script action call
 * @param p_deferredPayload (optional) a pre-made package that will be given back as the response, instead of package coming back from python
 * @param p_preventCall (optional) Flag for special case, only used at startup
 * @returns a Promise that will contain the JSON package answered back by the leoBridge in leoserver.py
 */
public sendAction(
    p_action: string,
    p_param?: { [key: string]: any },
    p_deferredPayload?: LeoBridgePackage,
    p_preventCall?: boolean
): Promise&lt;LeoBridgePackage&gt; {
    return this._leoBridge.action(p_action, p_param, p_deferredPayload, p_preventCall);
}

</t>
<t tx="felix.20200719025231.50">/**
 * * Opens an an editor for the currently selected node: "this.bodyUri". If already opened, this just 'reveals' it
 * @param p_aside Flag for opening the editor beside any currently opened and focused editor
 * @param p_preventTakingFocus flag that when true will stop the editor from taking focus once opened
 * @returns a promise of an editor, or void if body had been changed again in the meantime.
 */
public async showBody(p_aside: boolean, p_preventTakingFocus?: boolean, p_preventReveal?: boolean): Promise&lt;vscode.TextEditor | void&gt; {

    const w_openedDocumentTS = performance.now();
    const w_openedDocumentGnx = utils.leoUriToStr(this.bodyUri);
    let q_saved: Thenable&lt;unknown&gt; | undefined;

    // First setup timeout asking for gnx file refresh in case we were resolving a refresh of type 'RefreshTreeAndBody'
    if (this._refreshType.body) {
        this._refreshType.body = false;

        if (this._bodyLastChangedDocument &amp;&amp;
            !this._bodyLastChangedDocument.isClosed &amp;&amp;
            (this._bodyLastChangedDocument.isDirty || this._editorTouched) &amp;&amp;
            w_openedDocumentGnx === utils.leoUriToStr(this._bodyLastChangedDocument.uri)
        ) {

            // ! FAKE SAVE to make sure body is not dirty !
            this._leoFileSystem.preventSaveToLeo = true;
            this._editorTouched = false;
            q_saved = this._bodyLastChangedDocument.save();
        }

        if (q_saved) {
            await q_saved;
            this.preventIconChange = true;
            // console.log('fire refresh body in showBody1');
            this._leoFileSystem.fireRefreshFile(w_openedDocumentGnx);
        }

    }
    // Handle 'Prevent Show Body flag' and return
    if (this._preventShowBody) {
        this._preventShowBody = false;
        return Promise.resolve(vscode.window.activeTextEditor!);
    }

    // * Step 1 : Open the document
    const w_openedDocument = await vscode.workspace.openTextDocument(this.bodyUri);
    this._bodyLastChangedDocument = undefined;
    this._bodyLastChangedDocumentSaved = false;

    this._bodyTextDocument = w_openedDocument;

    // * Set document language along with the proper cursor position, selection range and scrolling position
    let q_bodyStates: Promise&lt;LeoBridgePackage&gt; | undefined;
    if (!this._needLastSelectedRefresh) {

        q_bodyStates = this.sendAction(
            Constants.LEOBRIDGE.GET_BODY_STATES,
            utils.buildNodeCommand(this.lastSelectedNode!)
        );

        q_bodyStates.then((p_bodyStates: LeoBridgePackage) =&gt; {

            let w_language: string = p_bodyStates.language!;
            let w_wrap: boolean = !!p_bodyStates.wrap;
            let w_tabWidth: number | boolean = p_bodyStates.tabWidth || !!p_bodyStates.tabWidth;

            let w_gnx: string | undefined = p_bodyStates.selection?.gnx; // ? To verify if better than w_openedDocumentGnx ?

            // Replace language string if in 'exceptions' array
            w_language = Constants.LEO_LANGUAGE_PREFIX +
                (Constants.LANGUAGE_CODES[w_language] || w_language) +
                (w_wrap ? Constants.LEO_WRAP_SUFFIX : "");

            let w_debugMessage = "";
            let w_needRefreshFlag = false;

            // Apply language if the selected node is still the same after all those events
            if (!w_openedDocument.isClosed) {
                // w_openedDocument still OPEN
                if (this.isTsStillValid(w_openedDocumentTS)) { // No need to check gnx of command stack){
                    // command stack last node is still valid
                    if (this.lastSelectedNode &amp;&amp; w_openedDocumentGnx === this.lastSelectedNode.gnx) {
                        // still same gnx as this.bodyUri
                        this._setBodyLanguage(w_openedDocument, w_language);
                    } else {
                        // NOT SAME GNX!
                        w_debugMessage = "all good but not same GNX!?!";
                        w_needRefreshFlag = true;
                    }

                } else {
                    // NOT VALID : NEW NODE SELECTED SINCE THIS STARTED!
                    w_debugMessage = "New node selected since this started!";
                    w_needRefreshFlag = false;

                }

            } else {
                w_debugMessage = "w_openedDocument is CLOSED " + w_openedDocument.uri.fsPath;
                w_needRefreshFlag = false;
            }

            // * Debug Info
            // if (w_debugMessage) {
            //     console.log(w_debugMessage);
            //     console.log("w_openedDocumentGnx", w_openedDocumentGnx);
            //     console.log("this.lastSelectedNode.gnx", this.lastSelectedNode!.gnx);
            //     console.log("w_gnx", w_gnx);
            // }

            if (w_needRefreshFlag) {
                if (this._showBodySwitchBodyTimer) {
                    clearTimeout(this._showBodySwitchBodyTimer);
                }
                // redo apply to body!
                this._showBodySwitchBodyTimer = setTimeout(() =&gt; {
                    if (this.lastSelectedNode) {
                        this._switchBody(false, p_preventTakingFocus);
                    }
                }, 0);

            }
            return p_bodyStates;
        });
    }

    // Find body pane's position if already opened with same gnx (language still needs to be set per position)
    let w_foundDocOpened = false;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {

            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.fsPath === w_openedDocument.uri.fsPath) {
                vscode.workspace.textDocuments.forEach((p_textDocument) =&gt; {
                    if (
                        p_textDocument.uri.scheme === Constants.URI_LEO_SCHEME &amp;&amp;
                        p_textDocument.uri.fsPath === (p_tab.input as vscode.TabInputText).uri.fsPath
                    ) {
                        this._bodyTextDocument = p_textDocument; // vscode.workspace.openTextDocument
                        this._bodyMainSelectionColumn = p_tab.group.viewColumn;
                        if (p_preventReveal) {
                            if (p_tab.isActive) {
                                w_foundDocOpened = true;
                            }
                        } else {
                            w_foundDocOpened = true;
                        }
                    }
                });
            }
        });
    });

    if (!w_foundDocOpened &amp;&amp; p_preventReveal) {
        return; // ! HAD PREVENT REVEAL !
    }

    if (w_foundDocOpened &amp;&amp; !q_saved) {
        // Was the same and was asked to show body (and did not already had to fake-save and refresh)
        // this.preventIconChange = true; // ? NEEDED ?
        // console.log('fire refresh body in showBody2');

        this._leoFileSystem.fireRefreshFile(w_openedDocumentGnx);
    }

    // Setup options for the preview state of the opened editor, and to choose which column it should appear
    const w_showOptions: vscode.TextDocumentShowOptions = p_aside
        ? {
            viewColumn: vscode.ViewColumn.Beside,
            preserveFocus: p_preventTakingFocus,
            preview: true, // should text document be in preview only? set false for fully opened
        }
        : {
            viewColumn: this._bodyMainSelectionColumn
                ? this._bodyMainSelectionColumn
                : 1,
            preserveFocus: p_preventTakingFocus,
            preview: true, // should text document be in preview only? set false for fully opened
        };

    // * CHECK ALL 3 POSSIBLE NEW PLACES FOR BODY SWITCH AFTER "await vscode.workspace.openTextDocument"
    if (
        w_openedDocument.isClosed ||
        !this.isTsStillValid(w_openedDocumentTS) // No need to check gnx

        // Should the gnx be relevant? -&gt; !this.isGnxStillValid(w_openedDocumentGnx, w_openedDocumentTS)

    ) {
        this.preventIconChange = false;
        return;
    }

    // * Actually Show the body pane document in a text editor
    const q_showTextDocument = vscode.window.showTextDocument(
        this._bodyTextDocument,
        w_showOptions
    ).then(
        (p_result) =&gt; {
            this.showBodyIfClosed = false;
            return p_result;
        },
        (p_reason) =&gt; {
            console.log('showTextDocument rejected: ', p_reason);
        }
    );

    // else q_bodyStates will exist.
    if (q_bodyStates &amp;&amp; !this._needLastSelectedRefresh) {
        Promise.all([q_bodyStates, q_showTextDocument]).then(
            (p_values: [LeoBridgePackage, vscode.TextEditor | void]) =&gt; {

                // * Set text selection range
                const w_resultBodyStates = p_values[0];
                const w_bodyTextEditor = p_values[1];
                if (!w_resultBodyStates.selection) {
                    console.log("no selection in returned package from get_body_states");
                }

                const w_leoBodySel: BodySelectionInfo = w_resultBodyStates.selection!;

                // * CHECK ALL 3 POSSIBLE NEW PLACES FOR BODY SWITCH AFTER q_bodyStates &amp; q_showTextDocument
                if (
                    w_openedDocument.isClosed ||
                    !this.isTsStillValid(w_openedDocumentTS) ||
                    (this.lastSelectedNode &amp;&amp; w_leoBodySel.gnx !== this.lastSelectedNode.gnx)
                    // Should the gnx be relevant? -&gt; !this.isGnxStillValid(w_openedDocumentGnx, w_openedDocumentTS)
                ) {
                    return;
                }

                // Cursor position and selection range
                const w_activeRow: number = w_leoBodySel.insert.line;
                const w_activeCol: number = w_leoBodySel.insert.col;
                let w_anchorLine: number = w_leoBodySel.start.line;
                let w_anchorCharacter: number = w_leoBodySel.start.col;

                if (w_activeRow === w_anchorLine &amp;&amp; w_activeCol === w_anchorCharacter) {
                    // Active insertion same as start selection, so use the other ones
                    w_anchorLine = w_leoBodySel.end.line;
                    w_anchorCharacter = w_leoBodySel.end.col;
                }

                const w_selection = new vscode.Selection(
                    w_anchorLine,
                    w_anchorCharacter,
                    w_activeRow,
                    w_activeCol
                );

                let w_scrollRange: vscode.Range | undefined;

                // Build scroll position from selection range.
                w_scrollRange = new vscode.Range(
                    w_activeRow,
                    w_activeCol,
                    w_activeRow,
                    w_activeCol
                );

                if (w_bodyTextEditor) {
                    // this._revealType = RevealType.NoReveal; // ! IN CASE THIS WAS STILL UP FROM SHOW_OUTLINE

                    w_bodyTextEditor.selection = w_selection; // set cursor insertion point &amp; selection range
                    if (!w_scrollRange) {
                        w_scrollRange = w_bodyTextEditor.document.lineAt(0).range;
                    }

                    if (this._refreshType.scroll) {
                        this._refreshType.scroll = false;
                        // Set scroll approximation
                        w_bodyTextEditor.revealRange(w_scrollRange, vscode.TextEditorRevealType.InCenterIfOutsideViewport);
                    }

                } else {
                    console.log("no selection in returned package from showTextDocument");
                }

            }
        );
    }

    return q_showTextDocument;
}

</t>
<t tx="felix.20200719025231.51"></t>
<t tx="felix.20200719025231.52">/**
 * * Select a tree node. Either called from user interaction, or used internally (p_internalCall flag)
 * @param p_node Node that was just selected
 * @param p_internalCall Flag used to indicate the selection is forced, and NOT originating from user interaction
 * @param p_aside Flag to force opening the body "Aside", i.e. when the selection was made from choosing "Open Aside"
 * @returns a promise with the package gotten back from Leo when asked to select the tree node
 */
public async selectTreeNode(
    p_node: ArchivedPosition,
    p_internalCall?: boolean,
    //p_aside?: boolean
): Promise&lt;void | LeoBridgePackage | vscode.TextEditor&gt; {

    await this.triggerBodySave(true);

    // * check if used via context menu's "open-aside" on an unselected node: check if p_node is currently selected, if not select it
    // if (p_aside &amp;&amp; p_node !== this.lastSelectedNode) {
    //     this._revealNode(p_node, { select: true, focus: false }); // no need to set focus: tree selection is set to right-click position
    // }

    this.leoStates.setSelectedNodeFlags(p_node);

    // removed until proper API for knowing focus placement
    // this._leoStatusBar.update(true); // Just selected a node directly, or via expand/collapse

    // const w_showBodyKeepFocus = p_aside
    //     ? this.config.treeKeepFocusWhenAside
    //     : this.config.treeKeepFocus;

    // * Check if having already this exact node position selected : Just show the body and exit
    // (other tree nodes with same gnx may have different syntax language coloring because of parents lineage)
    if (p_node === this.lastSelectedNode) {
        this._locateOpenedBody(p_node.gnx); // LOCATE NEW GNX
        // MAYBE DETACHED BODY CHANGED THAT CONTENT!
        this._leoFileSystem.setNewBodyUriTime(utils.strToLeoUri(p_node.gnx));

        return this.showBody(false, this.config.treeKeepFocus).catch((p_error) =&gt; {
            return Promise.resolve(); // intercept cancellation as success: next one is going to replace anyways.
        });
        // Voluntary exit
    }

    // * Set selected node in Leo via leoBridge
    const q_setSelectedNode = this.sendAction(
        Constants.LEOBRIDGE.SET_SELECTED_NODE,
        utils.buildNodeCommand(p_node)
    ).then((p_setSelectedResult) =&gt; {
        if (!p_internalCall) {
            if (this.findFocusTree) {
                // had a range but now refresh from other than find/replace
                // So make sure tree is also refreshed.
                this.findFocusTree = false;
                this.setupRefresh(
                    Focus.Outline,
                    {
                        tree: true,
                        body: true,
                        // documents: false,
                        // buttons: false,
                        // states: false,
                    }
                );
                this._launchRefresh();
                return p_setSelectedResult;
            }


            this._refreshType.states = true;
            this.getStates();
        }
        return p_setSelectedResult;
    });

    // * Apply the node to the body text without waiting for the selection promise to resolve
    this.showBodyIfClosed = true;
    this._tryApplyNodeToBody(p_node, false, this.config.treeKeepFocus);
    return q_setSelectedNode;
}

</t>
<t tx="felix.20200719025231.54">/**
 * * Changes the marked state of a specified, or currently selected node
 * @param p_isMark Set 'True' to mark, otherwise unmarks the node
 * @param p_node Specifies which node use, or leave undefined to mark or unmark the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @returns Promise of LeoBridgePackage from execution on the Leo server.
 */
public changeMark(
    p_isMark: boolean,
    p_node?: ArchivedPosition,
    p_fromOutline?: boolean
): Promise&lt;LeoBridgePackage | undefined&gt; {
    // No need to wait for body-save trigger for marking/un-marking a node
    const q_commandResult = this.nodeCommand({
        action: p_isMark ? Constants.LEOBRIDGE.MARK_PNODE : Constants.LEOBRIDGE.UNMARK_PNODE,
        node: p_node,
        refreshType: { tree: true, states: true },
        finalFocus: p_fromOutline ? Focus.Outline : Focus.Body
    });
    if (q_commandResult) {
        if (!p_node || p_node === this.lastSelectedNode) {
            utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_isMark);
        }
        return q_commandResult;
    } else {
        return Promise.reject('Change mark on node not added on command stack');
    }
}

</t>
<t tx="felix.20200719025231.55">/**
 * * Asks for a new headline label, and replaces the current label with this new one one the specified, or currently selected node
 * @param p_node Specifies which node to rename, or leave undefined to rename the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @returns Promise of LeoBridgePackage from execution on the server.
 */
public async editHeadline(
    p_node?: ArchivedPosition,
    p_fromOutline?: boolean,
    p_prompt?: string
): Promise&lt;LeoBridgePackage | undefined&gt; {

    if (this._hib &amp;&amp; this._hib.enabled) {
        return Promise.resolve(undefined); // DO NOT REACT IF ALREADY EDITING A HEADLINE! 
    }

    await this._isBusyTriggerSave(false, true);

    let w_finalFocus: Focus = p_fromOutline ? Focus.Outline : Focus.Body; // Use w_fromOutline for where we intend to leave focus when done with the insert

    if (!p_node &amp;&amp; this.lastSelectedNode) {
        p_node = this.lastSelectedNode; // Gets last selected node if called via keyboard shortcut or command palette (not set in command stack class)
    }
    if (!p_node) {
        return Promise.reject('No node selected');
    }

    const w_headlineInputOptions: vscode.InputBoxOptions = {
        ignoreFocusOut: false,
        value: p_node.headline,  // preset input pop up
        valueSelection: undefined,
        prompt: p_prompt || Constants.USER_MESSAGES.PROMPT_EDIT_HEADLINE,
    };
    let w_newHeadline = await this._showHeadlineInputBox(w_headlineInputOptions);

    let q_commandResult;
    if ((typeof w_newHeadline !== "undefined") &amp;&amp; w_newHeadline !== this._renamingHeadline) {
        // Is different!
        p_node!.headline = w_newHeadline;
        q_commandResult = this.nodeCommand({
            action: Constants.LEOBRIDGE.SET_HEADLINE,
            node: p_node,
            refreshType: { tree: true, states: true },
            finalFocus: w_finalFocus,
            name: w_newHeadline,
        });
        q_commandResult;

    } else {
        // Canceled
        q_commandResult = Promise.resolve(undefined);
    }
    q_commandResult.then(() =&gt; {
        if (this._onDidHideResolve) {
            this._onDidHideResolve(undefined);
            this._onDidHideResolve = undefined;
        }
    });
}

</t>
<t tx="felix.20200719025231.56">/**
 * * Asks for a headline label to be entered and creates (inserts) a new node under the current, or specified, node
 * @param p_node specified under which node to insert, or leave undefined to use whichever is currently selected
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_interrupt Signifies the insert action is actually interrupting itself (e.g. rapid CTRL+I actions by the user)
 * @returns Promise of LeoBridgePackage from execution the server.
 */
public async insertNode(
    p_node?: ArchivedPosition,
    p_fromOutline?: boolean,
    p_asChild?: boolean
): Promise&lt;LeoBridgePackage | undefined&gt; {

    let w_hadHib = false;
    if (this._hib &amp;&amp; this._hib.enabled) {
        w_hadHib = true;
    }

    if (!this.isOutlineVisible()) {
        p_fromOutline = false;
    }

    let w_finalFocus: Focus = p_fromOutline ? Focus.Outline : Focus.Body;
    if (w_hadHib) {
        this._focusInterrupt = true; // this will affect next refresh by triggerbodysave, not the refresh of this pass
    }

    // if no node parameter, the front command stack CAN be busy, but if a node is passed, stack must be free
    if (!p_node || !this._isBusy()) {
        await this.triggerBodySave(true); // Don't wait for saving to resolve because we're waiting for user input anyways
        // this._headlineInputOptions.prompt = Constants.USER_MESSAGES.PROMPT_INSERT_NODE;

        const w_headlineInputOptions: vscode.InputBoxOptions = {
            ignoreFocusOut: false,
            value: Constants.USER_MESSAGES.DEFAULT_HEADLINE,
            valueSelection: undefined,
            prompt: p_asChild ? Constants.USER_MESSAGES.PROMPT_INSERT_CHILD : Constants.USER_MESSAGES.PROMPT_INSERT_NODE
        };

        const p_newHeadline = await this._showHeadlineInputBox(w_headlineInputOptions);

        // return new Promise&lt;LeoBridgePackage|undefined&gt;((p_resolve, p_reject) =&gt; {

        if (this._hibInterrupted) {
            w_finalFocus = Focus.NoChange;
            this._hibInterrupted = false;
        }

        // * if node has child and is expanded: turn p_asChild to true!
        if (
            p_node &amp;&amp;
            p_node.expanded // === vscode.TreeItemCollapsibleState.Expanded
        ) {
            p_asChild = true;
        }
        if (
            !p_node &amp;&amp;
            this.lastSelectedNode &amp;&amp;
            this.lastSelectedNode.expanded //  === vscode.TreeItemCollapsibleState.Expanded
        ) {
            p_asChild = true;
        }
        let w_action = p_newHeadline
            ? (p_asChild ? Constants.LEOBRIDGE.INSERT_CHILD_NAMED_PNODE : Constants.LEOBRIDGE.INSERT_NAMED_PNODE)
            : (p_asChild ? Constants.LEOBRIDGE.INSERT_CHILD_PNODE : Constants.LEOBRIDGE.INSERT_PNODE);

        let q_commandResult;
        const w_refreshType: ReqRefresh = { states: true };

        if (this.isOutlineVisible()) {
            w_refreshType.tree = true;
        } else {
            w_refreshType.body = true;
        }

        q_commandResult = this.nodeCommand(
            {
                action: w_action,
                node: p_node,
                refreshType: w_refreshType,
                finalFocus: w_finalFocus,
                name: p_newHeadline,
            }
        );

        return q_commandResult.then((p_package) =&gt; {
            if (this._onDidHideResolve) {
                this._onDidHideResolve(undefined);
                this._onDidHideResolve = undefined;
            }
            // p_resolve(p_package);
            return p_package;
        });

        // });

    } else {
        return Promise.reject('Insert node not added on command stack');
    }
}

</t>
<t tx="felix.20200719025231.57"></t>
<t tx="felix.20200719025231.58">/**
 * * Asks for file name and path, then saves the Leo file
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns a promise from saving the file results, or that will resolve to undefined if cancelled
 */
public saveAsLeoFile(p_fromOutline?: boolean): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
                return this._leoFilesBrowser.getLeoFileUrl(true);
            } else {
                // 'when-conditions' should prevent this
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            }
        })
        .then((p_chosenLeoFile) =&gt; {
            if (p_chosenLeoFile.trim()) {
                const w_hasDot = p_chosenLeoFile.indexOf('.') !== -1;
                if (
                    !w_hasDot ||
                    ((p_chosenLeoFile.split('.').pop() !== Constants.FILE_EXTENSION) &amp;&amp;
                        (p_chosenLeoFile.split('.').pop() !== Constants.JS_FILE_EXTENSION) &amp;&amp;
                        (p_chosenLeoFile.split('.').pop() !== Constants.DB_FILE_EXTENSION))
                ) {
                    if (!p_chosenLeoFile.endsWith('.')) {
                        p_chosenLeoFile += '.'; // Add dot if needed
                    }
                    p_chosenLeoFile += Constants.FILE_EXTENSION; // Add extension
                }
                if (this.leoStates.leoOpenedFileName) {
                    this._removeLastFile(this.leoStates.leoOpenedFileName);
                    this._removeRecentFile(this.leoStates.leoOpenedFileName);
                }
                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.SAVE_FILE,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    finalFocus: p_fromOutline ? Focus.Outline : Focus.Body,
                    name: p_chosenLeoFile,
                });
                this.leoStates.leoOpenedFileName = p_chosenLeoFile.trim();
                // this._leoStatusBar.update(true, 0, true); // removed until proper API for knowing focus placement
                this._addRecentAndLastFile(p_chosenLeoFile.trim());
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject('Save file not added on command stack');
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20200719025231.59">/**
 * * Invokes the self.commander.save() Leo command
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns Promise that resolves when the save command is placed on the front-end command stack
 */
public async saveLeoFile(p_fromOutline?: boolean): Promise&lt;LeoBridgePackage | undefined&gt; {

    await this._isBusyTriggerSave(true, true);

    if (this.leoStates.fileOpenedReady) {
        if (this.lastSelectedNode &amp;&amp; this._isCurrentFileNamed()) {
            const q_commandResult = this.nodeCommand({
                action: Constants.LEOBRIDGE.SAVE_FILE,
                node: undefined,
                refreshType: { tree: true, states: true, documents: true },
                finalFocus: p_fromOutline ? Focus.Outline : Focus.Body,
                name: '',
            });
            return q_commandResult;
        } else {
            return this.saveAsLeoFile(p_fromOutline); // Override this command call if file is unnamed!
        }
    } else {
        // 'when-conditions' should prevent this
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
        return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    }
}

</t>
<t tx="felix.20200719025231.6">/**
 * * leoInteg starting entry point
 * Starts a leoBridge server, and/or establish a connection to a server, based on config settings.
 */
public startNetworkServices(): void {

    let q_checkPath;
    if (!this.config.leoEditorPath.trim()) {
        q_checkPath = this.findInstallPath();
    } else {
        q_checkPath = Promise.resolve();
    }

    // * Check settings and start a server accordingly
    q_checkPath.then(() =&gt; {
        if (this.config.startServerAutomatically) {
            if (this.config.limitUsers &gt; 1) {
                utils.findSingleAvailablePort(this.config.connectionPort)
                    .then((p_availablePort) =&gt; {
                        this.startServer();
                    }, (p_reason) =&gt; {
                        // Rejected: Multi user port IN USE so skip start
                        if (this.config.connectToServerAutomatically) {
                            // Still try to connect if auto-connect is 'on'
                            this.connect();
                        }
                    });
            } else {
                this.startServer();
            }
        } else if (this.config.connectToServerAutomatically) {
            // * (via settings) Connect to Leo Bridge server automatically without starting one first
            this.connect();
        } else {
            this.leoStates.leoStartupFinished = true;
        }
    });
}

</t>
<t tx="felix.20200719025231.60">/**
 * * Show switch document 'QuickPick' dialog and switch file if selection is made, or just return if no files are opened.
 * @returns A promise that resolves with a LeoBridgePackage if document switched, or undefined if no switch/canceled.
 */
public async switchLeoFile(): Promise&lt;LeoBridgePackage | undefined&gt; {
    await this._isBusyTriggerSave(true, true);
    const w_package = await this.sendAction(Constants.LEOBRIDGE.GET_OPENED_FILES);
    const w_entries: ChooseDocumentItem[] = []; // Entries to offer as choices.
    const w_files: LeoDocument[] = w_package.files!;
    let w_index: number = 0;
    let w_chosenDocument;
    if (w_files &amp;&amp; w_files.length) {
        w_files.forEach(function (p_filePath: LeoDocument) {
            w_entries.push({
                label: w_index.toString(),
                description: p_filePath.name
                    ? p_filePath.name
                    : Constants.UNTITLED_FILE_NAME,
                value: w_index,
                alwaysShow: true,
            });
            w_index++;
        });
        const w_pickOptions: vscode.QuickPickOptions = {
            matchOnDescription: true,
            placeHolder: Constants.USER_MESSAGES.CHOOSE_OPENED_FILE,
        };
        w_chosenDocument = await vscode.window.showQuickPick(w_entries, w_pickOptions);
    } else {
        // "No opened documents"
        return undefined;
    }
    if (w_chosenDocument) {
        this.finalFocus = Focus.Outline;
        return this.selectOpenedLeoDocument(w_chosenDocument.value);
    }
}

</t>
<t tx="felix.20200719025231.61">/**
 * * Switches Leo document directly by index number. Used by document treeview and switchLeoFile command.
 * @param p_index position of the opened Leo document in the document array
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly opened document
 */
public async selectOpenedLeoDocument(p_index: number): Promise&lt;LeoBridgePackage&gt; {
    await this._isBusyTriggerSave(true, true);
    const w_openFileResult = await this.sendAction(
        Constants.LEOBRIDGE.SET_OPENED_FILE,
        { index: p_index }
    );
    // Like we just opened or made a new file
    if (w_openFileResult.total) {
        this.serverHasOpenedFile = true;
        this.serverOpenedFileName = w_openFileResult.filename!;
        this.serverOpenedNode = w_openFileResult.node!;
        this.loadSearchSettings();
        this.setupRefresh(
            this.finalFocus,
            {
                tree: true,
                body: true,
                documents: true,
                buttons: true,
                states: true,
                goto: true

            }
        );
        this.launchRefresh();
        return w_openFileResult; //
    } else {
        this.serverHasOpenedFile = false;
        this.serverOpenedFileName = "";
        this.serverOpenedNode = undefined;
        this.launchRefresh();
        console.log('Select Opened Leo File Error');
        return Promise.reject('Select Opened Leo File Error');
    }
}

</t>
<t tx="felix.20200719025231.64">/**
* * Close an opened Leo file
* @returns the launchRefresh promise started after it's done closing the Leo document
*/
public closeLeoFile(): Promise&lt;boolean&gt; {
    let w_removeLastFileName: string = '';
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (!this.leoStates.fileOpenedReady) {
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLOSE_ERROR);
                return Promise.reject(Constants.USER_MESSAGES.CLOSE_ERROR);
            }
            w_removeLastFileName = this.leoStates.leoOpenedFileName;
            return this.sendAction(
                Constants.LEOBRIDGE.CLOSE_FILE,
                { forced: false }
            );
        })
        .then((p_tryCloseResult) =&gt; {
            // Has a total member: closed file
            if (p_tryCloseResult.total || p_tryCloseResult.total === 0) {
                this._removeLastFile(w_removeLastFileName);
                if (p_tryCloseResult.total) {
                    // Still has opened Leo document(s)
                    this.loadSearchSettings();
                    this.setupRefresh(
                        Focus.Body,
                        {
                            tree: true,
                            body: true,
                            documents: true,
                            buttons: true,
                            states: true,
                            goto: true
                        }
                    );
                } else {
                    this.serverHasOpenedFile = false;
                    this.serverOpenedFileName = "";
                    this.serverOpenedNode = undefined;
                    // this._setupNoOpenedLeoDocument();
                }
                // Start refresh either way: opened/no opened is set in refresh.
                this.launchRefresh();
                return Promise.resolve(true);
            } else {
                // No total member: did not close file
                const q_askSaveChangesInfoMessage: Thenable&lt;vscode.MessageItem | undefined&gt; =
                    vscode.window.showInformationMessage(
                        Constants.USER_MESSAGES.SAVE_CHANGES +
                        ' ' +
                        this.leoStates.leoOpenedFileName +
                        ' ' +
                        Constants.USER_MESSAGES.BEFORE_CLOSING,
                        { modal: true },
                        ...Constants.ASK_SAVE_CHANGES_BUTTONS
                    );
                return Promise.resolve(q_askSaveChangesInfoMessage)
                    .then((p_askSaveResult: vscode.MessageItem | undefined) =&gt; {
                        if (p_askSaveResult &amp;&amp; p_askSaveResult.title === Constants.USER_MESSAGES.YES) {
                            // save and then force-close
                            let w_savePromise: Promise&lt;LeoBridgePackage | undefined&gt;;
                            if (this._isCurrentFileNamed()) {
                                w_savePromise = this.sendAction(
                                    Constants.LEOBRIDGE.SAVE_FILE,
                                    { name: '' }
                                );
                            } else {
                                w_savePromise = this._leoFilesBrowser
                                    .getLeoFileUrl(true)
                                    .then((p_chosenLeoFile) =&gt; {
                                        if (p_chosenLeoFile.trim()) {
                                            return this.sendAction(
                                                Constants.LEOBRIDGE.SAVE_FILE,
                                                { name: p_chosenLeoFile.trim() }
                                            );
                                        } else {
                                            // Canceled
                                            return Promise.resolve(undefined);
                                        }
                                    });
                            }
                            return w_savePromise.then(
                                (p_packageAfterSave) =&gt; {
                                    return this.sendAction(
                                        Constants.LEOBRIDGE.CLOSE_FILE,
                                        { forced: true }
                                    );
                                },
                                () =&gt; {
                                    return Promise.reject('Save failed');
                                }
                            );
                        } else if (p_askSaveResult &amp;&amp; p_askSaveResult.title === Constants.USER_MESSAGES.NO) {
                            // Don't want to save so just force-close directly
                            return this.sendAction(
                                Constants.LEOBRIDGE.CLOSE_FILE,
                                { forced: true }
                            );
                        } else {
                            // Canceled dialog
                            return Promise.resolve(undefined);
                        }
                    })
                    .then((p_closeResult: LeoBridgePackage | undefined) =&gt; {
                        if (p_closeResult) {
                            // * back from CLOSE_FILE action, the last that can be performed (after saving if dirty or not)
                            this._removeLastFile(w_removeLastFileName);
                            if (p_closeResult &amp;&amp; p_closeResult.total) {
                                // Still has opened Leo document(s)
                                this.loadSearchSettings();
                                this.setupRefresh(
                                    Focus.Body,
                                    {
                                        tree: true,
                                        body: true,
                                        documents: true,
                                        buttons: true,
                                        states: true,
                                        goto: true
                                    }
                                );
                            } else {
                                this.serverHasOpenedFile = false;
                                this.serverOpenedFileName = "";
                                this.serverOpenedNode = undefined;
                                // this._setupNoOpenedLeoDocument();
                            }
                            // * Refresh either way.
                            this.launchRefresh();
                            return Promise.resolve(true);
                        }
                        // Canceled
                        return Promise.resolve(false);
                    });
            }
        });
}

</t>
<t tx="felix.20200719025231.65">/**
 * * Creates a new untitled Leo document
 * * If not shown already, it also shows the outline, body and log panes along with leaving focus in the outline
 * @returns A promise that resolves with a textEditor of the new file
 */
public async newLeoFile(): Promise&lt;LeoBridgePackage&gt; {
    await this._isBusyTriggerSave(true, true);
    await utils.setContext(Constants.CONTEXT_FLAGS.LEO_OPENING_FILE, true);
    const w_openFileResult = await this.sendAction(Constants.LEOBRIDGE.OPEN_FILE, { filename: "" });
    if (w_openFileResult.total) {
        this.serverHasOpenedFile = true;
        this.serverOpenedFileName = w_openFileResult.filename!;
        this.serverOpenedNode = w_openFileResult.node!;

        this.loadSearchSettings();

        this.showBodyIfClosed = true;
        this.showOutlineIfClosed = true;

        this.setupRefresh(
            Focus.NoChange,
            {
                tree: true,
                body: true,
                documents: true,
                buttons: true,
                states: true,
                goto: true
            }
        );
        this.launchRefresh();
        setTimeout(() =&gt; {
            void utils.setContext(Constants.CONTEXT_FLAGS.LEO_OPENING_FILE, false);
        }, 60);
        return w_openFileResult;
    } else {
        this.serverHasOpenedFile = false;
        this.serverOpenedFileName = "";
        this.serverOpenedNode = undefined;
        this.launchRefresh();
        setTimeout(() =&gt; {
            void utils.setContext(Constants.CONTEXT_FLAGS.LEO_OPENING_FILE, false);
        }, 60);
        return Promise.reject('New Leo File Error');
    }
}

</t>
<t tx="felix.20200719025231.66">/**
 * * Shows an 'Open Leo File' dialog window and opens the chosen file
 * * If not shown already, it also shows the outline, body and log panes
 * @param p_leoFileUri optional uri for specifying a file, if missing, a dialog will open
 * @returns A promise that resolves with a LeoBridgePackage from the open file command
 */
public openLeoFile(p_leoFileUri?: vscode.Uri): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (p_leoFileUri &amp;&amp; p_leoFileUri.scheme &amp;&amp; p_leoFileUri.scheme.startsWith("leo")) {
                p_leoFileUri = undefined; // Was used in the editor/title menu!
            }
            let q_openedFile: Promise&lt;LeoBridgePackage | undefined&gt;; // Promise for opening a file
            if (p_leoFileUri &amp;&amp; p_leoFileUri.fsPath &amp;&amp; p_leoFileUri.fsPath.trim()) {
                const w_fixedFilePath: string = p_leoFileUri.fsPath.replace(/\\/g, '/');
                void utils.setContext(Constants.CONTEXT_FLAGS.LEO_OPENING_FILE, true);
                q_openedFile = this.sendAction(
                    Constants.LEOBRIDGE.OPEN_FILE,
                    { filename: w_fixedFilePath }
                );
            } else {
                q_openedFile = this._leoFilesBrowser.getLeoFileUrl().then(
                    (p_chosenLeoFile) =&gt; {
                        if (p_chosenLeoFile.trim()) {
                            void utils.setContext(Constants.CONTEXT_FLAGS.LEO_OPENING_FILE, true);
                            return this.sendAction(
                                Constants.LEOBRIDGE.OPEN_FILE,
                                { filename: p_chosenLeoFile }
                            );
                        } else {
                            return Promise.resolve(undefined);
                        }
                    },
                    (p_errorGetFile) =&gt; {
                        return Promise.reject(p_errorGetFile);
                    }
                );
            }
            return q_openedFile;
        })
        .then(
            (p_openFileResult: LeoBridgePackage | undefined) =&gt; {
                if (p_openFileResult) {
                    if (p_openFileResult.total) {
                        this.serverHasOpenedFile = true;
                        this.serverOpenedFileName = p_openFileResult.filename!;
                        this.serverOpenedNode = p_openFileResult.node!;
                        this._addRecentAndLastFile(this.serverOpenedFileName);

                        this.loadSearchSettings();

                        this.showBodyIfClosed = true;
                        this.showOutlineIfClosed = true;

                        this.setupRefresh(
                            Focus.Body,
                            {
                                tree: true,
                                body: true,
                                documents: true,
                                buttons: true,
                                states: true,
                                goto: true
                            }
                        );
                    } else {
                        this.serverHasOpenedFile = false;
                        this.serverOpenedFileName = "";
                        this.serverOpenedNode = undefined;
                    }
                    this.launchRefresh();
                    setTimeout(() =&gt; {
                        void utils.setContext(Constants.CONTEXT_FLAGS.LEO_OPENING_FILE, false);
                    }, 60);
                    return p_openFileResult;
                } else {
                    setTimeout(() =&gt; {
                        void utils.setContext(Constants.CONTEXT_FLAGS.LEO_OPENING_FILE, false);
                    }, 60);
                    return Promise.resolve(undefined); // User cancelled chooser.
                }
            },
            (p_errorOpen) =&gt; {
                // TODO : IS REJECTION BEHAVIOR NECESSARY HERE TOO?
                console.log('in .then not opened or already opened');
                void utils.setContext(Constants.CONTEXT_FLAGS.LEO_OPENING_FILE, false);
                return Promise.reject(p_errorOpen);
            }
        );
}

</t>
<t tx="felix.20200719025231.69">/**
 * * StatusBar click handler
 * @returns Thenable from the statusBar click customizable behavior
 */
public statusBarOnClick(): Thenable&lt;unknown&gt; {

    if (this._leoStatusBar) {
        return this.replaceClipboardWith(this._leoStatusBar.unlString);
    }
    return Promise.resolve(undefined);

    // this.showLogPane();
    // return Promise.resolve(true);

    /*
    if (this.leoStates.fileOpenedReady) {
        return this.minibuffer();
        // return this.switchLeoFile();
    } else {
        return vscode.commands.executeCommand(
            Constants.VSCODE_COMMANDS.QUICK_OPEN,
            Constants.GUI.QUICK_OPEN_LEO_COMMANDS
        );
    }
    */
}
</t>
<t tx="felix.20200719025231.7">/**
 * * Starts an instance of a leoBridge server, and may connect to it afterwards, based on configuration flags.
 */
public startServer(): void {
    if (this.leoStates.leoStartingServer) {
        return;
    }
    this.leoStates.leoStartingServer = true;
    this.leoStates.leoStartupFinished = false;
    this.showLogPane();
    this._serverService
        .startServer(
            this.config.leoPythonCommand,
            this.config.leoEditorPath,
            this.config.connectionPort
        )
        .then(
            (p_message) =&gt; {
                utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, true); // server started
                if (this.config.connectToServerAutomatically) {
                    setTimeout(() =&gt; {
                        // wait a few milliseconds
                        this.connect();
                        this.leoStates.leoStartingServer = false;
                    }, 1500);
                } else {
                    this.leoStates.leoStartingServer = false;
                    this.leoStates.leoStartupFinished = true;
                }
            },
            (p_reason) =&gt; {
                // This context flag will remove the 'Starting server' welcome view
                this.leoStates.leoStartingServer = false;
                this.leoStates.leoStartupFinished = true;
                if (
                    [Constants.USER_MESSAGES.LEO_PATH_MISSING,
                    Constants.USER_MESSAGES.CANNOT_FIND_SERVER_SCRIPT].includes(p_reason)
                ) {
                    vscode.window.showErrorMessage(Constants.USER_MESSAGES.START_SERVER_ERROR + p_reason, "Choose Folder")
                        .then(p_chosenButton =&gt; {
                            if (p_chosenButton === 'Choose Folder') {
                                vscode.commands.executeCommand(Constants.COMMANDS.CHOOSE_LEO_FOLDER);
                            }
                        });
                } else {
                    vscode.window.showErrorMessage(
                        Constants.USER_MESSAGES.START_SERVER_ERROR + p_reason,
                    );
                }
            }
        );
}

</t>
<t tx="felix.20200719025231.8">/**
 * * Initiate a connection to the leoBridge server, then show view title, log pane, and set 'bridge ready' flags.
 */
public connect(): void {
    this.showLogPane();

    if (this.leoStates.leoBridgeReady || this.leoStates.leoConnecting) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.ALREADY_CONNECTED);
        return;
    }
    this.leoStates.leoConnecting = true;
    this.leoStates.leoStartupFinished = false;
    this._leoBridgeReadyPromise = this._leoBridge.initLeoProcess(
        this._serverService.usingPort // This will be zero if no port found
    );
    this._leoBridgeReadyPromise.then(
        (p_package) =&gt; {
            // Check if hard-coded first package signature / id
            if (p_package.id !== Constants.STARTING_PACKAGE_ID) {
                this.cancelConnect(Constants.USER_MESSAGES.CONNECT_ERROR);
            } else {
                // Connected ok
                let q_leoID: Thenable&lt;unknown&gt;;
                // Check for missing leoID: if set explicitly to null
                if (p_package['leoID'] === null) {
                    // Unset leoID !
                    this.leoStates.leoIDMissing = true;
                    q_leoID = this.setLeoID();

                } else {
                    q_leoID = Promise.resolve();
                }

                q_leoID.then(() =&gt; {
                    this.serverHasOpenedFile = !!p_package.commander;
                    const w_lastFiles: string[] =
                        this._context.workspaceState.get(Constants.LAST_FILES_KEY) || [];
                    if (w_lastFiles.length &amp;&amp; !this.serverHasOpenedFile) {
                        // This context flag will trigger 'Connecting...' placeholder
                        // utils.setContext(Constants.CONTEXT_FLAGS.AUTO_CONNECT, true);
                        setTimeout(() =&gt; {
                            // Try to open last opened files, if any
                            this._openLastFiles().catch(error =&gt; {
                                // No open files
                            });
                        }, 0);
                    } else {
                        this.leoStates.leoConnecting = false;
                        this.leoStates.leoBridgeReady = true;
                        this.leoStates.leoStartupFinished = true;
                    }

                    if (this.serverHasOpenedFile) {
                        this.serverOpenedFileName = p_package.commander!.fileName;
                        this.serverOpenedNode = p_package.node!;
                        // will provoke _setupOpenedLeoDocument
                        this.loadSearchSettings();
                        // Server already had opened files.
                        this.setupRefresh(
                            this.finalFocus,
                            {
                                tree: true,
                                body: true,
                                documents: true,
                                buttons: true,
                                states: true,
                            }
                        );
                        this.launchRefresh();
                    }

                    if (!this.config.connectToServerAutomatically) {
                        vscode.window.showInformationMessage(Constants.USER_MESSAGES.CONNECTED);
                    }

                    this.checkVersion();
                });

            }

        },
        (p_reason) =&gt; {
            this.cancelConnect(Constants.USER_MESSAGES.CONNECT_FAILED + ': ' + p_reason);
        }
    );
}

</t>
<t tx="felix.20200719025231.9">/**
 * * Cancels websocket connection and reverts context flags.
 * Called from leoBridge.ts when its websocket reports disconnection.
 * @param p_message
 */
public cancelConnect(p_message?: string): void {
    // 'disconnect error' versus 'failed to connect'
    const showMessageFn = this.leoStates.leoBridgeReady ? vscode.window.showErrorMessage : vscode.window.showInformationMessage;
    showMessageFn(
        p_message ? p_message : Constants.USER_MESSAGES.DISCONNECTED
    );
    this.leoStates.leoStartupFinished = true;
    this.leoStates.leoConnecting = false;
    this.leoStates.fileOpenedReady = false;
    this.leoStates.leoBridgeReady = false;
    this._leoBridgeReadyPromise = undefined;
    this._leoStatusBar.hide();
    this._refreshOutline(false, RevealType.NoReveal);
}

</t>
<t tx="felix.20200719030811.1"></t>
<t tx="felix.20200719030842.1"></t>
<t tx="felix.20200719030902.1"></t>
<t tx="felix.20200719031115.1"></t>
<t tx="felix.20200719031346.1">/**
 * * Send user's configuration through leoBridge to the server script
 * @param p_config A config object containing all the configuration settings
 * @returns promise that will resolves with the package from "applyConfig" call in Leo bridge server
 */
public sendConfigToServer(p_config: ConfigMembers): Promise&lt;LeoBridgePackage&gt; {
    if (this.leoStates.leoBridgeReady) {
        p_config.uAsNumber = true; // Force uAsNumber to be true starting at leoInteg 1.0.8
        return this.sendAction(Constants.LEOBRIDGE.APPLY_CONFIG, p_config);
    } else {
        return Promise.reject('Leo Bridge Not Ready');
    }
}

</t>
<t tx="felix.20200719031802.1"></t>
<t tx="felix.20200719033306.1"></t>
<t tx="felix.20200719033511.1"></t>
<t tx="felix.20200928004727.1">/**
 * * Handles detection of the active editor's selection change or cursor position
 * @param p_event a change event containing the active editor's selection, if any.
 */
private _onChangeEditorSelection(p_event: vscode.TextEditorSelectionChangeEvent): void {
    if (
        p_event.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME ||
        p_event.textEditor.document.uri.scheme === Constants.URI_LEO_DETACHED_SCHEME
    ) {
        if (p_event.selections.length) {
            this._selectionDirty = true;
            this._selection = p_event.selections[0];
            this._selectionGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20200928133238.1">/**
 * * Saves the cursor position along with the text selection range and scroll position
 * of the last body, or detached body pane, that had its cursor info set in this._selection, etc.
 * @returns Promise that resolves when the "setSelection" action returns from Leo's side
 */
private async _bodySaveSelection(): Promise&lt;boolean&gt; {
    if (this._selectionDirty &amp;&amp; this._selection) {
        // Prepare scroll data separately
        // ! TEST NEW SCROLL WITH SINGLE LINE NUMBER
        let w_scroll: number;
        if (this._selectionGnx === this._scrollGnx &amp;&amp; this._scrollDirty) {
            w_scroll = this._scroll?.start.line || 0;
        } else {
            w_scroll = 0;
        }

        let gnx: string | undefined;
        let id: string = "";

        if (!this._selectionGnx.includes('/')) {
            // leo body
            gnx = this._selectionGnx;
        } else {
            // DETACHED
            [id, gnx] = this._selectionGnx.split('/');

        }

        const w_param: BodySelectionInfo = {
            gnx: gnx,
            scroll: w_scroll,
            insert: {
                line: this._selection.active.line || 0,
                col: this._selection.active.character || 0,
            },
            start: {
                line: this._selection.start.line || 0,
                col: this._selection.start.character || 0,
            },
            end: {
                line: this._selection.end.line || 0,
                col: this._selection.end.character || 0,
            },
        };

        if (id) {
            w_param["commanderId"] = id;
        }

        this._scrollDirty = false;
        this._selectionDirty = false; // don't wait for return of this call

        await this.sendAction(Constants.LEOBRIDGE.SET_SELECTION, w_param);

        return Promise.resolve(true);
    } else {
        return Promise.resolve(true);
    }
}

</t>
<t tx="felix.20201006195046.1">/**
 * * LeoBody cursor active position and text selection state, along with gnx
 */
export interface BodySelectionInfo {
    commanderId?: string,
    gnx: string;
    // scroll is stored as-is as the 'scrollBarSpot' in Leo
    // ! TEST scroll as single number only (for Leo vertical scroll value)
    scroll: number;
    // scroll: {
    //     start: BodyPosition;
    //     end: BodyPosition;
    // }
    insert: BodyPosition;
    start: BodyPosition;
    end: BodyPosition;
}

</t>
<t tx="felix.20201014020145.1">/**
 * * Handles detection of the active editor's scroll position changes
 * @param p_event a change event containing the active editor's visible range, if any.
 */
private _onChangeEditorScroll(p_event: vscode.TextEditorVisibleRangesChangeEvent): void {
    if (
        p_event.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME ||
        p_event.textEditor.document.uri.scheme === Constants.URI_LEO_DETACHED_SCHEME
    ) {
        if (p_event.visibleRanges.length) {
            this._scrollDirty = true;
            this._scroll = p_event.visibleRanges[0];
            this._scrollGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20201017224340.1">/**
 * * Structure for configuration settings changes used along with welcome/settings webview.
 */
export interface ConfigSetting {
    code: string;
    value: any;
}

</t>
<t tx="felix.20201018163510.1">/**
 * * Returns the milliseconds between a given starting process.hrtime tuple and the current call to process.hrtime
 * @param p_start starting process.hrtime to subtract from current immediate time
 * @returns number of milliseconds passed since the given start hrtime
 */
export function getDurationMs(p_start: [number, number]): number {
    const [w_secs, w_nanosecs] = process.hrtime(p_start);
    return w_secs * 1000 + Math.floor(w_nanosecs / 1000000);
}

</t>
<t tx="felix.20201103000337.1">/**
 * * Table for converting Leo languages names for the currently opened body pane
 * Used in showBody method of leoIntegration.ts
 */
public static LANGUAGE_CODES: { [key: string]: string | undefined } = {
    cplusplus: 'cpp',
    md: 'markdown',
    rest: 'restructuredtext',
    rst: 'restructuredtext'
};

</t>
<t tx="felix.20201105010253.1">{
  "command": "leointeg.extract",
  "key": "ctrl+shift+d",
  "mac": "cmd+shift+d",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.extractNames",
  "key": "ctrl+shift+n",
  "mac": "cmd+shift+n",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leointeg"
},
</t>
<t tx="felix.20201105010614.1">{
  "command": "leointeg.extract",
  "category": "Leo",
  "title": "Extract",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-extract)"
},
{
  "command": "leointeg.extractNames",
  "category": "Leo",
  "title": "Extract Names",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-extract-name)"
},
</t>
<t tx="felix.20201106200100.1">/**
 * * Performs the actual addition into workspaceState context
 * @param p_context Needed to get to vscode workspace storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the workspace storage modification is done
 */
export function addFileToWorkspace(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Just push that string into the context.workspaceState.&lt;something&gt; array
    const w_contextEntry: string[] = p_context.workspaceState.get(p_key) || [];
    if (w_contextEntry) {
        if (!w_contextEntry.includes(p_file)) {
            w_contextEntry.push(p_file);
            if (w_contextEntry.length &gt; 10) {
                w_contextEntry.shift();
            }
        }
        return p_context.workspaceState.update(p_key, w_contextEntry); // Added file
    } else {
        // First so create key entry with an array of single file
        return p_context.workspaceState.update(p_key, [p_file]);
    }
}

</t>
<t tx="felix.20201106200109.1">/**
 * * Removes file entry from workspaceState context
 * @param p_context Needed to get to vscode workspace storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the workspace storage modification is done
  */
export function removeFileFromWorkspace(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Check if exist in context.workspaceState.&lt;something&gt; and remove if found
    const w_files: string[] = p_context.workspaceState.get(p_key) || [];
    if (w_files &amp;&amp; w_files.includes(p_file)) {
        w_files.splice(w_files.indexOf(p_file), 1); // Splice and update
        return p_context.workspaceState.update(p_key, w_files);
    }
    return Promise.resolve(); // not even in list so just resolve
}

</t>
<t tx="felix.20201107224112.1">/**
 * * Promise that triggers body save (rejects if busy), and resolves when done
 * @param p_all Flag for 'isBusy' check: will block if bridge is busy, not just commands on stack
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the possible saving process is finished
 */
private _isBusyTriggerSave(p_all: boolean, p_forcedVsCodeSave?: boolean): Promise&lt;unknown&gt; {
    if (this._isBusy(p_all)) {
        return Promise.reject('Command stack busy'); // Warn user to wait for end of busy state
    }
    return this.triggerBodySave(p_forcedVsCodeSave);
}

</t>
<t tx="felix.20201114185218.1">/**
 * * Sets the outline pane top bar string message or refreshes with existing title if no title passed
 * * This includes the '*' asterisk that signifies 'document changed'
 * @param p_title new string to replace the current title
 */
public setTreeViewTitle(p_title?: string): void {
    if (p_title) {
        this._currentOutlineTitle = p_title;
    }
    // * Set/Change outline pane title e.g. "INTEGRATION", "OUTLINE"
    const w_changed = this.leoStates.fileOpenedReady &amp;&amp; this._serverOpenedFileName &amp;&amp; this.leoStates.leoChanged ? "*" : "";
    if (this._leoTreeView) {
        this._leoTreeView.title = this._currentOutlineTitle + w_changed;
    }
    if (this._leoTreeExView) {
        this._leoTreeExView.title =
            Constants.GUI.EXPLORER_TREEVIEW_PREFIX + this._currentOutlineTitle + w_changed;
    }
    this.refreshDesc();
}

</t>
<t tx="felix.20201114185813.1">/**
 * * Opens quickPick minibuffer pallette to choose from all commands in this file's commander
 * @returns Promise that resolves when the chosen command is placed on the front-end command stack
 */
public async minibuffer(): Promise&lt;LeoBridgePackage | undefined&gt; {

    // Wait for _isBusyTriggerSave resolve because the full body save may change available commands
    await this._isBusyTriggerSave(false, true);

    let w_history: string[] = [];
    if (utils.compareVersions(this.serverVersion, { major: 1, minor: 0, patch: 8 })) {
        const w_historyPackage = await this.sendAction("!get_history");
        w_history = w_historyPackage.history || [];
    }

    const q_commandList: Thenable&lt;vscode.QuickPickItem[]&gt; = this.sendAction(
        Constants.LEOBRIDGE.GET_COMMANDS
    ).then((p_result: LeoBridgePackage) =&gt; {
        if (p_result.commands &amp;&amp; p_result.commands.length) {
            const w_regexp = new RegExp('\\s+', 'g');
            p_result.commands.forEach(p_command =&gt; {
                if (p_command.detail) {
                    p_command.detail = p_command.detail.trim().replace(w_regexp, ' ');
                }
            });
            // Remove unsupported commands
            for (const p_name of Constants.unsupportedMinibufferCommands) {
                const i_command = p_result.commands.findIndex((object) =&gt; {
                    return object.label === p_name;
                });
                if (i_command !== -1) {
                    p_result.commands.splice(i_command, 1);
                }
            }
            // Add some commands traditionally from plugins or other sources
            p_result.commands.push(...Constants.addMinibufferCommands);

            // Keep only without details and remove @buttons and delete-@buttons
            // (keeps the minibuffer list cleaner)
            const w_noDetails: vscode.QuickPickItem[] = [];
            const stash_button: string[] = [];
            const stash_rclick: string[] = [];
            const stash_command: string[] = [];

            for (const w_com of p_result.commands) {
                if (
                    !w_com.detail &amp;&amp; !(
                        w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_BUTTON_START) ||
                        w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_RCLICK_START) ||
                        w_com.label === Constants.USER_MESSAGES.MINIBUFFER_SCRIPT_BUTTON ||
                        w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_DEL_SCRIPT_BUTTON) ||
                        w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_DEL_BUTTON_START) ||
                        w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_COMMAND_START)
                    )
                ) {
                    w_noDetails.push(w_com);
                }

                if (w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_BUTTON_START)) {
                    stash_button.push(w_com.label);
                }
                if (w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_RCLICK_START)) {
                    stash_rclick.push(w_com.label);
                }
                if (w_com.label.startsWith(Constants.USER_MESSAGES.MINIBUFFER_COMMAND_START)) {
                    stash_command.push(w_com.label);
                }
            }

            for (const p_command of w_noDetails) {
                if (stash_button.includes(Constants.USER_MESSAGES.MINIBUFFER_BUTTON_START + p_command.label)) {
                    p_command.description = Constants.USER_MESSAGES.MINIBUFFER_BUTTON;
                }
                if (stash_rclick.includes(Constants.USER_MESSAGES.MINIBUFFER_RCLICK_START + p_command.label)) {
                    p_command.description = Constants.USER_MESSAGES.MINIBUFFER_RCLICK;
                }
                if (stash_command.includes(Constants.USER_MESSAGES.MINIBUFFER_COMMAND_START + p_command.label)) {
                    p_command.description = Constants.USER_MESSAGES.MINIBUFFER_COMMAND;
                }
                if (!p_command.description) {
                    p_command.description = Constants.USER_MESSAGES.MINIBUFFER_USER_DEFINED;
                }
            }

            const w_withDetails = p_result.commands.filter(p_command =&gt; !!p_command.detail);

            // Only sort 'regular' Leo commands, leaving custom commands at the top
            w_withDetails.sort((a, b) =&gt; {
                return a.label &lt; b.label ? -1 : (a.label === b.label ? 0 : 1);
            });

            const w_result: vscode.QuickPickItem[] = [];

            if (w_history.length) {
                w_result.push(Constants.MINIBUFFER_QUICK_PICK);
            }

            // Finish minibuffer list
            if (w_noDetails.length) {
                w_result.push(...w_noDetails);
            }

            // Separator above real commands, if needed...
            if (w_noDetails.length || w_history.length) {
                w_result.push({
                    label: "", kind: vscode.QuickPickItemKind.Separator
                });
            }

            w_result.push(...w_withDetails);

            return w_result;
        } else {
            return [];
        }
    });

    const w_choices = await q_commandList;

    const w_disposables: vscode.Disposable[] = [];

    const q_minibufferQuickPick: Promise&lt;vscode.QuickPickItem | undefined&gt; = new Promise((resolve, reject) =&gt; {
        const quickPick = vscode.window.createQuickPick();
        quickPick.items = w_choices;
        quickPick.placeholder = Constants.USER_MESSAGES.MINIBUFFER_PROMPT;
        quickPick.matchOnDetail = true;

        w_disposables.push(
            quickPick.onDidChangeSelection(selection =&gt; {
                if (selection[0]) {
                    resolve(selection[0]);
                    quickPick.hide();
                }
            }),
            quickPick.onDidAccept(accepted =&gt; {
                if (/^\d+$/.test(quickPick.value)) {
                    // * Was an integer
                    this.gotoGlobalLine(Number(quickPick.value));
                    resolve(undefined);
                    quickPick.hide();
                }
            }),
            quickPick.onDidChangeValue(changed =&gt; {
                if (/^\d+$/.test(changed)) {
                    if (quickPick.items.length) {
                        quickPick.items = [];
                    }
                } else if (quickPick.items !== w_choices) {
                    quickPick.items = w_choices;
                }
            }),
            quickPick.onDidHide(() =&gt; {
                resolve(undefined);
            }),
            quickPick
        );
        quickPick.show();

    });

    const w_picked: vscode.QuickPickItem | undefined = await q_minibufferQuickPick;

    w_disposables.forEach(d =&gt; d.dispose());

    // First, check for undo-history list being requested
    if (w_picked &amp;&amp; w_picked.label === Constants.USER_MESSAGES.MINIBUFFER_HISTORY_LABEL) {
        return this._showMinibufferHistory(w_choices, w_history);
    }
    if (w_picked) {
        return this._doMinibufferCommand(w_picked);
    }
}

</t>
<t tx="felix.20201119002510.1">/**
 * * Body position
 * Used in BodySelectionInfo interface
 */
export interface BodyPosition {
    line: number;
    col: number;
}

</t>
<t tx="felix.20201126235315.1">/**
 * * Strings used in 'at-button' panel display in LeoButtonNode
 */
public static BUTTON_STRINGS = {
    NULL_WIDGET: "nullButtonWidget",
    SCRIPT_BUTTON: "script-button",
    ADD_BUTTON: "leoButtonAdd",
    NORMAL_BUTTON: "leoButtonNode"
};

</t>
<t tx="felix.20201208235246.1">/**
 * * Command strings to be used with vscode.commands.executeCommand
 * See https://code.visualstudio.com/api/extension-guides/command#programmatically-executing-a-command
 */
public static VSCODE_COMMANDS = {
    SET_CONTEXT: "setContext",
    CLOSE_ACTIVE_EDITOR: "workbench.action.closeActiveEditor",
    QUICK_OPEN: "workbench.action.quickOpen"
};

</t>
<t tx="felix.20201215210439.1">"view/title": [
  {
    "command": "leointeg.showSettingsPage",
    "when": "view =~ /^leoDocuments|^leoButtons/ &amp;&amp; leoBridgeReady",
    "group": "navigation@9"
  },
  {
    "command": "leointeg.showLogPane",
    "when": "view =~ /^leoDocuments|^leoButtons/ &amp;&amp; leoBridgeReady",
    "group": "navigation@9"
  },
  {
    "command": "leointeg.recentLeoFiles",
    "when": "view =~ /^leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@8"
  },
  {
    "command": "leointeg.recentLeoFiles",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoBridgeReady &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.findQuickSelected",
    "when": "view =~ /^leoGotoPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.findQuickTimeline",
    "when": "view =~ /^leoGotoPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.findQuickChanged",
    "when": "view =~ /^leoGotoPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.history",
    "when": "view =~ /^leoGotoPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.markedList",
    "when": "view =~ /^leoGotoPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.showSettingsPage",
    "when": "view =~ /^leoIntegration/ &amp;&amp; !leoTreeOpened",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.clearRecentFiles",
    "when": "view =~ /^leoIntegration/ &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.connectToServer",
    "when": "view =~ /^leoIntegration/ &amp;&amp; !leoBridgeReady &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.startServer",
    "when": "view =~ /^leoIntegration/ &amp;&amp; !leoBridgeReady &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.stopServer",
    "when": "view =~ /^leoIntegration/ &amp;&amp; !leoBridgeReady &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.openLeoFile",
    "when": "view =~ /^leoIntegration|^leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "view =~ /^leoIntegration|^leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "view =~ /^leoIntegration|^leoDocuments/ &amp;&amp; leoTreeOpened &amp;&amp; leoTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "view =~ /^leoIntegration|^leoDocuments/ &amp;&amp; leoTreeOpened &amp;&amp; !leoTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.saveAsLeoJsFile",
    "when": "view =~ /^leoIntegration|^leoDocuments/ &amp;&amp; leoTreeOpened &amp;&amp; !leoTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.prevFromOutline",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened",
    "group": "navigation@3"
  },
  {
    "command": "leointeg.nextFromOutline",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened",
    "group": "navigation@4"
  },
  {
    "command": "leointeg.undoFromOutline",
    "when": "view =~ /^leoIntegration|^leoUndo/ &amp;&amp; leoTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leointeg.redoFromOutline",
    "when": "view =~ /^leoIntegration|^leoUndo/ &amp;&amp; leoTreeOpened",
    "group": "navigation@6"
  },
  {
    "command": "leointeg.deHoistFromOutline",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoTopHoistChapter",
    "group": "navigation@7"
  },
  {
    "command": "leointeg.chapterMain",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoTopHoistChapter",
    "group": "navigation@7"
  },
  {
    "command": "leointeg.hoistSelectionFromOutline",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened",
    "group": "navigation@8"
  },
  {
    "command": "leointeg.findNextFromOutline",
    "when": "view =~ /^leoFindPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.findPreviousFromOutline",
    "when": "view =~ /^leoFindPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.chapterBack",
    "when": "view =~ /^leoFindPanel|^leoGotoPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leointeg.chapterNext",
    "when": "view =~ /^leoFindPanel|^leoGotoPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leointeg.chapterSelect",
    "when": "view =~ /^leoFindPanel|^leoGotoPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leointeg.chapterMain",
    "when": "view =~ /^leoFindPanel|^leoGotoPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@6"
  },
  {
    "command": "leointeg.promoteSelectionFromOutline",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened",
    "group": "navigation@9"
  },
  {
    "command": "leointeg.demoteSelectionFromOutline",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened",
    "group": "navigation@10"
  },
  {
    "command": "leointeg.importAnyFile",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened",
    "group": "navigation@11"
  },
  {
    "command": "leointeg.contractAllFromOutline",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened",
    "group": "navigation@12"
  }
],
</t>
<t tx="felix.20201215210510.1">"view/item/context": [
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "viewItem =~ /^leoDocumentSelectedTitled/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "viewItem =~ /^leoDocumentSelected/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.saveAsLeoJsFile",
    "when": "viewItem =~ /^leoDocumentSelectedUntitled/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.closeLeoFile",
    "when": "viewItem =~ /^leoDocumentSelected/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.revert",
    "when": "viewItem =~ /^leoDocumentSelected/",
    "group": "leoDocumentContext1@1"
  },
  {
    "command": "leointeg.editHeadline",
    "when": "config.leoIntegration.showEditOnNodes &amp;&amp; viewItem =~ /^leoNode/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.insertNode",
    "when": "config.leoIntegration.showAddOnNodes &amp;&amp; viewItem =~ /^leoNode/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.copyNode",
    "when": "config.leoIntegration.showCopyOnNodes &amp;&amp; viewItem =~ /^leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "config.leoIntegration.showCloneOnNodes &amp;&amp; viewItem =~ /^leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.mark",
    "when": "config.leoIntegration.showMarkOnNodes &amp;&amp; viewItem =~ /^leoNodeUnmarked/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.unmark",
    "when": "config.leoIntegration.showMarkOnNodes &amp;&amp; viewItem =~ /^leoNodeMarked/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.openAside",
    "when": "config.leoIntegration.showOpenAside &amp;&amp; viewItem =~ /^leoNode/",
    "group": "leoNodeContext1@1"
  },
  {
    "command": "leointeg.hoistNode",
    "when": "viewItem =~ /leoNodeNotRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.deHoist",
    "when": "leoCanDehoist &amp;&amp; viewItem =~ /leoNodeRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.refreshFromDisk",
    "when": "viewItem =~ /leoNodeAtFile/",
    "group": "leoNodeContext1@3"
  },
  {
    "command": "leointeg.mark",
    "when": "viewItem =~ /^leoNodeUnmarked/",
    "group": "leoNodeContext2@1"
  },
  {
    "command": "leointeg.unmark",
    "when": "viewItem =~ /^leoNodeMarked/",
    "group": "leoNodeContext2@1"
  },
  {
    "command": "leointeg.tagNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@2"
  },
  {
    "command": "leointeg.removeTag",
    "when": "viewItem =~ /leoNodeTags/",
    "group": "leoNodeContext2@3"
  },
  {
    "command": "leointeg.removeTags",
    "when": "viewItem =~ /leoNodeTags/",
    "group": "leoNodeContext2@4"
  },
  {
    "command": "leointeg.copyNode",
    "when": "viewItem =~ /^leoNode/",
    "group": "leoNodeContext2@5"
  },
  {
    "command": "leointeg.cutNode",
    "when": "viewItem =~ /^leoNode/",
    "group": "leoNodeContext2@6"
  },
  {
    "command": "leointeg.pasteNode",
    "when": "viewItem =~ /^leoNode/",
    "group": "leoNodeContext2@7"
  },
  {
    "command": "leointeg.pasteNodeAsClone",
    "when": "viewItem =~ /^leoNode/",
    "group": "leoNodeContext2@8"
  },
  {
    "command": "leointeg.delete",
    "when": "viewItem =~ /^leoNode/",
    "group": "leoNodeContext2@9"
  },
  {
    "command": "leointeg.insertNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /^leoNode/",
    "group": "leoNodeContext3@1"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /^leoNode/",
    "group": "leoNodeContext3@2"
  },
  {
    "command": "leointeg.gotoNextClone",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNodeCloned/",
    "group": "leoNodeContext3@3"
  },
  {
    "command": "leointeg.clickButton",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /^leoButtonNode|^leoButtonAdd/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.removeButton",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /^leoButtonNode/",
    "group": "leoButtonContext1@1"
  },
  {
    "command": "leointeg.gotoScript",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /^leoButtonNode/",
    "group": "leoButtonContext1@2"
  },
  {
    "command": "leointeg.revertToUndo",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /^leoUndoNode/",
    "group": "leoUndosContext1@1"
  }
],
</t>
<t tx="felix.20210418013332.1">/**
 * * Closes non-existing text-editor body if it doesn't match bodyUri
 * @param p_textEditor the editor to close
 * @returns promise that resolves to true if it closed tabs, false if none were found
 */
private _hideDeleteBody(p_textEditor: vscode.TextEditor): void {
    const w_foundTabs: vscode.Tab[] = [];
    const w_editorFsPath = p_textEditor.document.uri.fsPath;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme.startsWith(Constants.URI_LEO_SCHEME) &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.fsPath === w_editorFsPath
            ) {
                w_foundTabs.push(p_tab);
            }
        });
    });

    // * Make sure the closed/deleted body is not remembered as vscode's recent files!
    vscode.commands.executeCommand(
        'vscode.removeFromRecentlyOpened',
        p_textEditor.document.uri
    );

    if (w_foundTabs.length) {
        vscode.window.tabGroups.close(w_foundTabs, true);
        return;
    }

    return;
}

</t>
<t tx="felix.20210418014039.1">/**
 * * Moved a document to another column
 * @param p_columnChangeEvent  event describing the change of a text editor's view column
 */
public _changedTextEditorViewColumn(
    p_columnChangeEvent: vscode.TextEditorViewColumnChangeEvent
): void {
    if (p_columnChangeEvent &amp;&amp; p_columnChangeEvent.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        this._checkPreviewMode(p_columnChangeEvent.textEditor);
    }
    this.triggerBodySave(true, true);
}

</t>
<t tx="felix.20210418014040.1">/**
 * * Tabbed on another editor
 * @param p_editors text editor array (to be checked for changes in this method)
 */
public _changedVisibleTextEditors(p_editors: readonly vscode.TextEditor[]): void {
    if (p_editors &amp;&amp; p_editors.length) {
        this._hideBodiesUnknownToFileSys(p_editors);
    }
    this.triggerBodySave(true, true);
}

</t>
<t tx="felix.20210418014040.2">/**
 * * Whole window has been minimized/restored
 * @param p_windowState the state of the window that changed
 */
public _changedWindowState(p_windowState: vscode.WindowState): void {
    // no other action
    this.triggerBodySave(true, true);
}

</t>
<t tx="felix.20210418220343.1">/**
 * * Clears the global 'Preview Mode' flag if the given editor is not in the main body column
 * @param p_editor is the editor to check for is in the same column as the main one
 */
private _checkPreviewMode(p_editor: vscode.TextEditor): void {
    // if selected gnx but in another column
    if (
        p_editor.document.uri.scheme === Constants.URI_LEO_SCHEME &amp;&amp;
        p_editor.document.uri.fsPath === this.bodyUri.fsPath &amp;&amp;
        p_editor.viewColumn !== this._bodyMainSelectionColumn
    ) {
        this._bodyPreviewMode = false;
        this._bodyMainSelectionColumn = p_editor.viewColumn;
    }
}

</t>
<t tx="felix.20210509210502.1">## 0.1.13

- Added support for precise focus placement, focus switch between tree/body.
- Made the extension more aware of the current selection state, to have strictly relevant buttons visible shown only.
- Made the 'edit headline' hover icon removable, in order to enable 'Tab' keybinding to go from tree to body directly.
- Added commands and keybindings for 'goto' operations 'hoist/dehoist' [#25](https://github.com/boltex/leointeg/issues/25) and other commands. [#30](https://github.com/boltex/leointeg/issues/30)
- Added support for Leo-Style outline navigation. [#43](https://github.com/boltex/leointeg/issues/43) Has to be enabled with an option in the config settings: "Use Leo Tree Browsing" which makes the arrow keys, pgUp/pgDn, home/end move the selection instead of a cursor when focus is on Leo's outline.
- Implemented @buttons in it's own panel, visible where the already existing 'outline' and 'opened leo documents' panels reside.
- Added (basic) unknown attributes support as hover tooltip and small description on node headlines.
- Added a 'leoBridge Server Terminal Panel' to gather output of the leoBridge stdOut pipe. It's displayed among the 'output panels', along with the standard 'leo log window', when the server is started by leoInteg. (either with the auto-start config setting, or by calling the 'start server' command via buttons or the command-palette.)
- Syntax coloring and Snippets are now enabled for those languages : C, C++, CSS, HTML, Java, Javascript, json, Markdown, PHP, Python, Rust and Typescript. They are taken from the default extension for that language, or if non-existent, from the most popular extension for that language
- Recent files are now remembered and restored upon re-opening vscode.
- Leo files can be opened from the explorer pane directly.
- Added 'minibuffer' feature with the usual alt-x command from Leo.
- Added cursor position, selected range and scrolling position to be captured and restored when navigating the outline. [#39](https://github.com/boltex/leointeg/issues/39) This allows for commands that use the currently selected text, [#61](https://github.com/boltex/leointeg/issues/61) such as run script and extract/extract name, etc.
- Redid the body display and switching logic to support new vscode API features. (vscode now does not block 'undo' operations between file-rename operations, which were used to switch body pane content.)

</t>
<t tx="felix.20210516233931.1">/**
 * * Opens the find panel and focuses on the "find/replace" field, selecting all it's content.
 */
public startSearch(): void {
    this._isBusyTriggerSave(false, true);
    // already instantiated &amp; shown ?
    let w_panel: vscode.WebviewView | undefined;

    if (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) {
        w_panel = this._findPanelWebviewView;
    } else if (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible) {
        w_panel = this._findPanelWebviewExplorerView;
    }

    if (w_panel) {
        // ALREADY VISIBLE FIND PANEL
        this._findNeedsFocus = false;
        w_panel.webview.postMessage({ type: 'selectFind' });
        return;
    }

    this._findNeedsFocus = true;
    let w_panelID = '';
    if (this._lastTreeView === this._leoTreeExView) {
        w_panelID = Constants.FIND_EXPLORER_ID;
    } else {
        w_panelID = Constants.FIND_ID;
    }
    vscode.commands.executeCommand(w_panelID + '.focus');
    return;
}

</t>
<t tx="felix.20210516234059.1">/**
 * * Find next / previous commands
 * @param p_fromOutline
 * @param p_reverse
 * @returns Promise that resolves when the "launch refresh" is started
 */
public async find(p_fromOutline: boolean, p_reverse: boolean): Promise&lt;any&gt; {
    const w_action: string = p_reverse
        ? Constants.LEOBRIDGE.FIND_PREVIOUS
        : Constants.LEOBRIDGE.FIND_NEXT;

    await this._isBusyTriggerSave(false, true);

    const p_findResult = await this.sendAction(w_action, { fromOutline: !!p_fromOutline });

    this.findFocusTree = false; // Reset flag for headline range

    if (!p_findResult.found || !p_findResult.focus) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.SEARCH_NOT_FOUND);
    } else {
        let w_finalFocus = Focus.Body;
        const w_focus = p_findResult.focus.toLowerCase();
        if (w_focus.includes('tree') || w_focus.includes('head')) {
            // tree
            this._lastCommandFindEndOutline = 2;
            w_finalFocus = Focus.Outline;
            this.showOutlineIfClosed = true;
            // * SETUP HEADLINE RANGE
            this.findFocusTree = true;
            // Default to 0,0 if range not available
            const range = p_findResult.range ? p_findResult.range : [0, 0];
            this.findHeadlineRange = [range[0], range[1]];
            this.findHeadlinePosition = p_findResult.node;
        } else {
            this.showBodyIfClosed = true;
        }
        this.setupRefresh(
            w_finalFocus, // ! Unlike gotoNavEntry, this sets focus in outline -or- body.
            {
                tree: true, // HAVE to refresh tree because find folds/unfolds only result outline paths
                body: true,
                scroll: p_findResult.found &amp;&amp; w_finalFocus === Focus.Body,
                // documents: false,
                // buttons: false,
                states: true,
            },
            p_findResult.node!,
            this.findFocusTree
        );
        this.launchRefresh();
    }
}

</t>
<t tx="felix.20210517001143.1">{
  "command": "leointeg.startSearch",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Start Search"
},
{
  "command": "leointeg.searchBackward",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Search Backward"
},
{
  "command": "leointeg.reSearch",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Regexp Search"
},
{
  "command": "leointeg.reSearchBackward",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Regexp Search Backward"
},
{
  "command": "leointeg.wordSearch",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Word Search"
},
{
  "command": "leointeg.wordSearchBackward",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Word Search Backward"
},
{
  "command": "leointeg.findAll",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Find All"
},
{
  "command": "leointeg.findNext",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Find Next"
},
{
  "command": "leointeg.findNextFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Find Next",
  "icon": "$(leo-find-next)"
},
{
  "command": "leointeg.findPrevious",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Find Previous"
},
{
  "command": "leointeg.findPreviousFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Find Previous",
  "icon": "$(leo-find-previous)"
},
{
  "command": "leointeg.findVar",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Find the var under the cursor"
},
{
  "command": "leointeg.findDef",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "Find Definition",
  "title": "Find the def or class under the cursor"
},
{
  "command": "leointeg.replace",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Replace"
},
{
  "command": "leointeg.replaceFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Replace"
},
{
  "command": "leointeg.replaceThenFind",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Replace Then Find"
},
{
  "command": "leointeg.replaceThenFindFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Replace Then Find"
},
{
  "command": "leointeg.replaceAll",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Replace All"
},
{
  "command": "leointeg.gotoGlobalLine",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Goto Global Line"
},
{
  "command": "leointeg.cloneFindAll",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "cfa",
  "title": "Clone Find All"
},
{
  "command": "leointeg.cloneFindAllFlattened",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "cff",
  "title": "Clone Find All Flattened"
},
{
  "command": "leointeg.cloneFindMarked",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "cfam",
  "title": "Clone Find All Marked Nodes"
},
{
  "command": "leointeg.cloneFindFlattenedMarked",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "cffm",
  "title": "Clone Find All Flattened Marked"
},
{
  "command": "leointeg.cloneFindParents",
  "category": "Leo",
  "enablement": "leoTreeOpened &amp;&amp; leoCloned",
  "title": "Clone Find Parents"
},
{
  "command": "leointeg.cloneFindTag",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "cft",
  "title": "Clone Find Tag"
},
{
  "command": "leointeg.tagChildren",
  "category": "Leo",
  "enablement": "leoTreeOpened &amp;&amp; leoChild",
  "title": "Tag Children"
},
{
  "command": "leointeg.tagNode",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Tag Node"
},
{
  "command": "leointeg.removeTag",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Remove Tag"
},
{
  "command": "leointeg.removeTags",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Remove All Tags"
},
{
  "command": "leointeg.setFindEverywhereOption",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "Find Everywhere",
  "title": "Set Find Everywhere Option"
},
{
  "command": "leointeg.setFindNodeOnlyOption",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "Find in Node",
  "title": "Set Find in Node Only Option"
},
{
  "command": "leointeg.setFindFileOnlyOption",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "Find in External Files",
  "title": "Set Find in External Files Only Option"
},
{
  "command": "leointeg.setFindSuboutlineOnlyOption",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "Find in SubOutline",
  "title": "Set Find in SubOutline Only Option"
},
{
  "command": "leointeg.toggleFindIgnoreCaseOption",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "Find Ignore Case",
  "title": "Toggle Find Ignore Case Option"
},
{
  "command": "leointeg.toggleFindMarkChangesOption",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "Find Mark Changes",
  "title": "Toggle Find Mark Changes Option"
},
{
  "command": "leointeg.toggleFindMarkFindsOption",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "Find Mark Finds",
  "title": "Toggle Find Mark Finds Option"
},
{
  "command": "leointeg.toggleFindRegexpOption",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "Find RegExp",
  "title": "Toggle Find RegExp Option"
},
{
  "command": "leointeg.toggleFindWordOption",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "Find Whole Word",
  "title": "Toggle Find Whole Word Option"
},
{
  "command": "leointeg.toggleFindSearchBodyOption",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "Find Search Body",
  "title": "Toggle Find Search Body Option"
},
{
  "command": "leointeg.toggleFindSearchHeadlineOption",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "shortTitle": "Find Search Headline",
  "title": "Toggle Find Search Headline Option"
},
</t>
<t tx="felix.20210517001459.1">{
  "command": "leointeg.mark",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Mark",
  "icon": "$(leo-mark)"
},
{
  "command": "leointeg.markSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened &amp;&amp; !leoMarked",
  "title": "Mark",
  "icon": "$(leo-mark)"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened &amp;&amp; !leoMarked",
  "title": "Mark",
  "icon": "$(leo-mark)"
},
{
  "command": "leointeg.unmark",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Unmark",
  "icon": "$(leo-unmark)"
},
{
  "command": "leointeg.unmarkSelection",
  "category": "Leo",
  "enablement": "leoTreeOpened &amp;&amp; leoMarked",
  "title": "Unmark",
  "icon": "$(leo-unmark)"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened &amp;&amp; leoMarked",
  "title": "Unmark",
  "icon": "$(leo-unmark)"
},
{
  "command": "leointeg.unmarkAll",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Unmark All"
},
{
  "command": "leointeg.markSubheads",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Mark Subheads"
},
{
  "command": "leointeg.markChangedItems",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Mark Changed Items"
},
{
  "command": "leointeg.copyMarked",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Copy Marked"
},
{
  "command": "leointeg.cloneMarkedNodes",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Clone Marked Nodes"
},
{
  "command": "leointeg.diffMarkedNodes",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Diff Marked Nodes"
},
{
  "command": "leointeg.deleteMarkedNodes",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Delete Marked Nodes"
},
{
  "command": "leointeg.moveMarkedNodes",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Move Marked Nodes"
}
</t>
<t tx="felix.20210517004335.1">{
  "command": "leointeg.goAnywhere",
  "key": "ctrl+p",
  "mac": "cmd+p",
  "when": "config.leoIntegration.goAnywhereShortcut &amp;&amp; leoEditHeadline || config.leoIntegration.goAnywhereShortcut &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !editorFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || config.leoIntegration.goAnywhereShortcut &amp;&amp; leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.startSearch",
  "key": "ctrl+f",
  "mac": "cmd+f",
  "when": "leoEditHeadline || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !editorFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.findNextFromOutline",
  "key": "f3",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
{
  "command": "leointeg.findNext",
  "key": "f3",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.findPreviousFromOutline",
  "key": "f2",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
{
  "command": "leointeg.findPrevious",
  "key": "f2",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.replace",
  "key": "ctrl+=",
  "mac": "cmd+=",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.replaceFromOutline",
  "key": "ctrl+=",
  "mac": "cmd+=",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
{
  "command": "leointeg.replaceThenFind",
  "key": "ctrl+-",
  "mac": "cmd+-",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.replaceThenFindFromOutline",
  "key": "ctrl+-",
  "mac": "cmd+-",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
{
  "command": "leointeg.gotoGlobalLine",
  "key": "alt+g",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.setFindEverywhereOption",
  "key": "ctrl+alt+e",
  "mac": "cmd+alt+e",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.setFindNodeOnlyOption",
  "key": "ctrl+alt+n",
  "mac": "cmd+alt+n",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.setFindFileOnlyOption",
  "key": "ctrl+alt+l",
  "mac": "cmd+alt+l",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.setFindSuboutlineOnlyOption",
  "key": "ctrl+alt+s",
  "mac": "cmd+alt+s",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.toggleFindIgnoreCaseOption",
  "key": "ctrl+alt+i",
  "mac": "cmd+alt+i",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.toggleFindMarkChangesOption",
  "key": "ctrl+alt+c",
  "mac": "cmd+alt+c",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.toggleFindMarkFindsOption",
  "key": "ctrl+alt+f",
  "mac": "cmd+alt+f",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.toggleFindRegexpOption",
  "key": "ctrl+alt+x",
  "mac": "cmd+alt+x",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.toggleFindWordOption",
  "key": "ctrl+alt+w",
  "mac": "cmd+alt+w",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.toggleFindSearchBodyOption",
  "key": "ctrl+alt+b",
  "mac": "cmd+alt+b",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
{
  "command": "leointeg.toggleFindSearchHeadlineOption",
  "key": "ctrl+alt+h",
  "mac": "cmd+alt+h",
  "when": "leoEditHeadline || leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leointeg"
},
</t>
<t tx="felix.20210522001751.1">import * as vscode from 'vscode';
import { Constants } from './constants';
import { LeoIntegration } from './leoIntegration';
import * as utils from './utils';

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20210522001814.1">/**
 * Leo Find Panel provider
 */
export class LeoFindPanelProvider implements vscode.WebviewViewProvider {
    private _view?: vscode.WebviewView;

    constructor(
        private readonly _extensionUri: vscode.Uri,
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20210522152739.1">/**
 * * LeoInteg search settings structure for use with the 'find' webview
 */
export interface LeoSearchSettings {
    // Nav options
    navText: string;
    isTag: boolean;
    showParents: boolean;
    searchOptions: number;
    // Find/change strings...
    findText: string;
    replaceText: string;
    // Find options...
    wholeWord: boolean;
    ignoreCase: boolean;
    regExp: boolean;
    markFinds: boolean;
    markChanges: boolean;
    searchHeadline: boolean;
    searchBody: boolean;
    searchScope: LeoSearchScope; // 0, 1, 2  or 3 for outline, sub-outline, node-only or file-only.
}

</t>
<t tx="felix.20210522152922.1">/**
 * * LeoInteg's Enum type for the search scope radio buttons of the find panel.
 */
export const enum LeoSearchScope {
    entireOutline = 0,
    subOutlineOnly,
    nodeOnly,
    fileOnly
}

</t>
<t tx="felix.20210522233604.1"></t>
<t tx="felix.20210522233744.1">{
  "view": "leoGotoPanel",
  "contents": "Not connected",
  "when": "!leoTreeOpened"
},
{
  "view": "leoGotoPanelExplorer",
  "contents": "Not connected",
  "when": "!leoTreeOpened"
},
{
  "view": "leoGotoPanel",
  "contents": "No Results",
  "when": "leoTreeOpened"
},
{
  "view": "leoGotoPanelExplorer",
  "contents": "No Results",
  "when": "leoTreeOpened"
},
{
  "view": "leoFindPanel",
  "contents": "Not connected",
  "when": "!leoTreeOpened"
},
{
  "view": "leoFindPanelExplorer",
  "contents": "Not connected",
  "when": "!leoTreeOpened"
},
</t>
<t tx="felix.20210523162125.1">/**
 * * Leo's GUI search settings internal structure
 */
export interface LeoGuiFindTabManagerSettings {
    // Nav options
    nav_text: string;
    is_tag: boolean;
    show_parents: boolean;
    search_options: number;
    //Find/change strings...
    find_text: string,
    change_text: string,
    // Find options...
    ignore_case: boolean,
    mark_changes: boolean,
    mark_finds: boolean,
    node_only: boolean,
    file_only: boolean,
    pattern_match: boolean,
    search_body: boolean,
    search_headline: boolean,
    suboutline_only: boolean,
    whole_word: boolean
}

</t>
<t tx="felix.20210524215215.1">/**
 * * Send the settings to the Leo Bridge Server
 * @param p_settings the search settings to be set server side to affect next results
 * @returns the promise from the server call
 */
public saveSearchSettings(p_settings: LeoSearchSettings): Promise&lt;LeoBridgePackage&gt; {
    this._lastSettingsUsed = p_settings;
    // convert to LeoGuiFindTabManagerSettings
    const w_settings: LeoGuiFindTabManagerSettings = {
        // Nav settings
        is_tag: p_settings.isTag,
        nav_text: p_settings.navText,
        show_parents: p_settings.showParents,
        search_options: p_settings.searchOptions,
        // Find/change strings...
        find_text: p_settings.findText,
        change_text: p_settings.replaceText,
        // Find options...
        ignore_case: p_settings.ignoreCase,
        mark_changes: p_settings.markChanges,
        mark_finds: p_settings.markFinds,
        node_only: !!(p_settings.searchScope === 2),
        file_only: !!(p_settings.searchScope === 3),
        pattern_match: p_settings.regExp,
        search_body: p_settings.searchBody,
        search_headline: p_settings.searchHeadline,
        suboutline_only: !!(p_settings.searchScope === 1),
        whole_word: p_settings.wholeWord,
    };
    return this.sendAction(
        Constants.LEOBRIDGE.SET_SEARCH_SETTINGS,
        { searchSettings: w_settings }
    );
}

</t>
<t tx="felix.20210525232728.1">/**
 * * Gets the search settings from Leo, and applies them to the find panel webviews
 */
public loadSearchSettings(): void {
    this.sendAction(Constants.LEOBRIDGE.GET_SEARCH_SETTINGS).then(
        (p_result: LeoBridgePackage) =&gt; {
            const w_searchSettings: LeoGuiFindTabManagerSettings = p_result.searchSettings!;
            const w_settings: LeoSearchSettings = {
                isTag: w_searchSettings.is_tag,
                navText: w_searchSettings.nav_text,
                showParents: w_searchSettings.show_parents,
                searchOptions: w_searchSettings.search_options,
                //Find/change strings...
                findText: w_searchSettings.find_text,
                replaceText: w_searchSettings.change_text,
                // Find options...
                wholeWord: w_searchSettings.whole_word,
                ignoreCase: w_searchSettings.ignore_case,
                regExp: w_searchSettings.pattern_match,
                markFinds: w_searchSettings.mark_finds,
                markChanges: w_searchSettings.mark_changes,
                searchHeadline: w_searchSettings.search_headline,
                searchBody: w_searchSettings.search_body,
                // 0, 1, 2 or 3 for outline, sub-outline, node-only or file-only.
                searchScope:
                    0 +
                    (w_searchSettings.suboutline_only ? 1 : 0) +
                    (w_searchSettings.node_only ? 2 : 0) +
                    (w_searchSettings.file_only ? 3 : 0),
            };
            if (w_settings.searchScope &gt; 3) {
                console.error('searchScope SHOULD BE 0, 1, 2, 3 only: ', w_settings.searchScope);
            }
            this._lastSettingsUsed = w_settings;
            if (this._findPanelWebviewExplorerView) {
                this._findPanelWebviewExplorerView.webview.postMessage({
                    type: 'setSettings',
                    value: w_settings,
                });
            }
            if (this._findPanelWebviewView) {
                this._findPanelWebviewView.webview.postMessage({
                    type: 'setSettings',
                    value: w_settings,
                });
            }
        }
    );
}

</t>
<t tx="felix.20210530161800.1">{
  "command": "leointeg.findNextFromOutline",
  "when": "false"
},
{
  "command": "leointeg.findPreviousFromOutline",
  "when": "false"
},
{
  "command": "leointeg.replaceFromOutline",
  "when": "false"
},
{
  "command": "leointeg.replaceThenFindFromOutline",
  "when": "false"
}
</t>
<t tx="felix.20210530223726.1">/**
 * * Replace / Replace-Then-Find commands
 * @param p_fromOutline
 * @param p_thenFind
 * @returns Promise that resolves when the "launch refresh" is started
 */
public async replace(p_fromOutline: boolean, p_thenFind: boolean): Promise&lt;any&gt; {
    const w_action: string = p_thenFind
        ? Constants.LEOBRIDGE.REPLACE_THEN_FIND
        : Constants.LEOBRIDGE.REPLACE;

    await this._isBusyTriggerSave(false, true);

    const w_replaceResult = await this.sendAction(w_action, { fromOutline: !!p_fromOutline });

    this.findFocusTree = false; // Reset flag for headline range

    let w_finalFocus = Focus.Body;
    let w_focus = w_replaceResult.focus ? w_replaceResult.focus : "body";
    w_focus = w_focus.toLowerCase();
    if (w_focus.includes('tree') || w_focus.includes('head')) {
        // tree
        this._lastCommandFindEndOutline = 2;
        w_finalFocus = Focus.Outline;
        this.showOutlineIfClosed = true;
        // * SETUP HEADLINE RANGE
        this.findFocusTree = true;
        // Default to 0,0 if range not available
        const range = w_replaceResult.range ? w_replaceResult.range : [0, 0];
        this.findHeadlineRange = [range[0], range[1]];
        this.findHeadlinePosition = w_replaceResult.node;
    } else {
        this.showBodyIfClosed = true;
    }
    this.setupRefresh(
        w_finalFocus, // ! Unlike gotoNavEntry, this sets focus in outline -or- body.
        {
            tree: true, // HAVE to refresh tree because find folds/unfolds only result outline paths
            body: true,
            scroll: w_replaceResult.found &amp;&amp; w_finalFocus === Focus.Body,
            // documents: false,
            // buttons: false,
            states: true,
        },
        w_replaceResult.node!,
        this.findFocusTree
    );
    this.launchRefresh();
}

</t>
<t tx="felix.20210530225306.1">/**
 * * Set search setting in the search webview
 * @param p_id string id of the setting name
 */
public async setSearchSetting(p_id: string): Promise&lt;unknown&gt; {
    this._isBusyTriggerSave(false, true);
    // already instantiated &amp; shown ?
    let w_panel: vscode.WebviewView | undefined;

    if (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) {
        w_panel = this._findPanelWebviewView;
    } else if (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible) {
        w_panel = this._findPanelWebviewExplorerView;
    }

    if (w_panel) {
        // ALREADY VISIBLE FIND PANEL
        w_panel!.webview.postMessage({ type: 'setSearchSetting', id: p_id });
        return;
    }
    // Find panel to show based on last regular outline pane visible.
    let w_panelID = '';
    if (this._lastTreeView === this._leoTreeExView) {
        w_panelID = Constants.FIND_EXPLORER_ID;
    } else {
        w_panelID = Constants.FIND_ID;
    }
    await vscode.commands.executeCommand(w_panelID + '.focus');

    return new Promise((p_resolve, p_reject) =&gt; {
        setTimeout(() =&gt; {
            if (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) {
                w_panel = this._findPanelWebviewView;
            } else if (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible) {
                w_panel = this._findPanelWebviewExplorerView;
            }
            if (w_panel) {
                w_panel!.webview.postMessage({ type: 'setSearchSetting', id: p_id });
            }
            p_resolve(undefined);
        }, 250);
    });
}

</t>
<t tx="felix.20210530225640.1"></t>
<t tx="felix.20210530230354.1">/**
 * * Find / Replace All
 * @returns Promise of LeoBridgePackage from execution or undefined if cancelled
 */
public findAll(p_replace: boolean): Promise&lt;any&gt; {
    const w_action: string = p_replace
        ? Constants.LEOBRIDGE.REPLACE_ALL
        : Constants.LEOBRIDGE.FIND_ALL;

    let w_searchString: string = this._lastSettingsUsed!.findText;
    let w_replaceString: string = this._lastSettingsUsed!.replaceText;

    const w_startValue = this._lastSettingsUsed!.findText === Constants.USER_MESSAGES.FIND_PATTERN_HERE ? '' : this._lastSettingsUsed!.findText;
    const w_startReplace = this._lastSettingsUsed?.replaceText;

    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            return this._inputFindPattern(false, w_startValue)
                .then((p_findString) =&gt; {
                    if (!p_findString) {
                        return true; // Cancelled with escape or empty string.
                    }
                    w_searchString = p_findString;
                    if (p_replace) {
                        return this._inputFindPattern(true, w_startReplace).then((p_replaceString) =&gt; {
                            if (p_replaceString === undefined) {
                                return true;
                            }
                            w_replaceString = p_replaceString;
                            return false;
                        });
                    }
                    return false;
                });
        })
        .then((p_cancelled: boolean) =&gt; {
            if (this._lastSettingsUsed &amp;&amp; !p_cancelled) {
                this._lastSettingsUsed.findText = w_searchString;
                this._lastSettingsUsed.replaceText = w_replaceString;
                this.saveSearchSettings(this._lastSettingsUsed); // No need to wait, will be stacked.
                return this.sendAction(w_action)
                    .then((p_findResult: LeoBridgePackage) =&gt; {
                        let w_finalFocus = Focus.Body;
                        const w_focus = p_findResult.focus!.toLowerCase();
                        if (w_focus.includes('tree') || w_focus.includes('head')) {
                            // tree
                            w_finalFocus = Focus.Outline;
                        }
                        this.loadSearchSettings();
                        this.setupRefresh(
                            w_finalFocus,
                            {
                                tree: true,
                                body: true,
                                // documents: false,
                                // buttons: false,
                                states: true
                            }
                        );
                        this.launchRefresh();
                    });
            }
        });
}

</t>
<t tx="felix.20210530230400.1">/**
 * * Clone Find All / Marked / Flattened
 * @param p_marked flag for finding marked nodes
 * @param p_flat flag to get flattened results
 * @returns Promise of LeoBridgePackage from execution or undefined if cancelled
 */
public cloneFind(p_marked: boolean, p_flat: boolean): Promise&lt;any&gt; {
    let w_searchString: string = this._lastSettingsUsed!.findText;
    let w_action: string;
    if (p_marked) {
        w_action = p_flat
            ? Constants.LEOBRIDGE.CLONE_FIND_FLATTENED_MARKED
            : Constants.LEOBRIDGE.CLONE_FIND_MARKED;
    } else {
        w_action = p_flat
            ? Constants.LEOBRIDGE.CLONE_FIND_ALL_FLATTENED
            : Constants.LEOBRIDGE.CLONE_FIND_ALL;
    }

    if (p_marked) {
        // don't use find methods.
        return this.nodeCommand({
            action: w_action,
            node: undefined,
            refreshType: { tree: true, body: true, states: true },
            finalFocus: Focus.NoChange,
        }) || Promise.resolve();
    }

    const w_startValue = this._lastSettingsUsed!.findText === Constants.USER_MESSAGES.FIND_PATTERN_HERE ? '' : this._lastSettingsUsed!.findText;

    return this._isBusyTriggerSave(false, true)
        .then(() =&gt; {
            return this._inputFindPattern(false, w_startValue)
                .then((p_findString) =&gt; {
                    if (!p_findString) {
                        return true; // Cancelled with escape or empty string.
                    }
                    w_searchString = p_findString;
                    return false;
                });
        })
        .then((p_cancelled: boolean) =&gt; {
            if (this._lastSettingsUsed &amp;&amp; !p_cancelled) {
                this._lastSettingsUsed.findText = w_searchString;
                this.saveSearchSettings(this._lastSettingsUsed); // No need to wait, will be stacked.
                return this.sendAction(w_action)
                    .then((p_cloneFindResult: LeoBridgePackage) =&gt; {
                        let w_finalFocus = Focus.Body;
                        const w_focus = p_cloneFindResult.focus!.toLowerCase();
                        if (w_focus.includes('tree') || w_focus.includes('head')) {
                            // tree
                            w_finalFocus = Focus.Outline;
                        }
                        this.loadSearchSettings();
                        this.setupRefresh(
                            w_finalFocus,
                            {
                                tree: true,
                                body: true,
                                // documents: false,
                                // buttons: false,
                                states: true
                            }
                        );
                        this.launchRefresh();
                    });
            }
        });
}

</t>
<t tx="felix.20210530233134.1">/**
 * * Find panel controls ids
 */
public static FIND_INPUTS_IDS = {
    FIND_TEXT: "findText",
    REPLACE_TEXT: "replaceText",
    ENTIRE_OUTLINE: "entireOutline",
    FILE_ONLY: "fileOnly",
    NODE_ONLY: "nodeOnly",
    SUBOUTLINE_ONLY: "subOutlineOnly",
    IGNORE_CASE: "ignoreCase",
    MARK_CHANGES: "markChanges",
    MARK_FINDS: "markFinds",
    REG_EXP: "regExp",
    WHOLE_WORD: "wholeWord",
    SEARCH_BODY: "searchBody",
    SEARCH_HEADLINE: "searchHeadline"
};

</t>
<t tx="felix.20210601164915.1">/**
 * * Goto Global Line
 */
public gotoGlobalLine(p_lineNumber?: number): void {
    if (p_lineNumber === null || p_lineNumber === undefined) {
        this.triggerBodySave(false)
            .then(() =&gt; {
                return vscode.window.showInputBox({
                    title: Constants.USER_MESSAGES.TITLE_GOTO_GLOBAL_LINE,
                    placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_GOTO_GLOBAL_LINE,
                    prompt: Constants.USER_MESSAGES.PROMPT_GOTO_GLOBAL_LINE,
                });
            })
            .then((p_inputResult?: string) =&gt; {
                if (p_inputResult) {
                    const w_line = parseInt(p_inputResult);
                    if (!isNaN(w_line)) {
                        this.sendAction(Constants.LEOBRIDGE.GOTO_GLOBAL_LINE, { line: w_line }).then((p_resultGoto: LeoBridgePackage) =&gt; {
                            this.setupRefresh(Focus.Body, { tree: true, body: true, states: true, });
                            this.launchRefresh();
                        });
                    }
                }
            });
    } else if (!isNaN(p_lineNumber)) {
        // p_lineNumber is a number
        this.sendAction(Constants.LEOBRIDGE.GOTO_GLOBAL_LINE, { line: p_lineNumber }).then((p_resultGoto: LeoBridgePackage) =&gt; {
            this.setupRefresh(Focus.Body, { tree: true, body: true, states: true, });
            this.launchRefresh();
        });
    }
}

</t>
<t tx="felix.20210602151654.1">/**
 * * Overridden 'good' minibuffer commands
 */
public static MINIBUFFER_OVERRIDDEN_COMMANDS: { [key: string]: string } = {
    "find-quick": Constants.COMMANDS.FIND_QUICK,
    "find-quick-selected": Constants.COMMANDS.FIND_QUICK,

    "focus-to-body": Constants.COMMANDS.SHOW_BODY,
    "focus-to-find": Constants.COMMANDS.START_SEARCH,
    "focus-to-log": Constants.COMMANDS.SHOW_LOG,
    "focus-to-nav": Constants.COMMANDS.FIND_QUICK,
    "focus-to-tree": Constants.COMMANDS.SHOW_OUTLINE,

    "find-quick-timeline": Constants.COMMANDS.FIND_QUICK_TIMELINE,
    "find-quick-changed": Constants.COMMANDS.FIND_QUICK_CHANGED,
    "history": Constants.COMMANDS.FIND_QUICK_HISTORY,
    "marked-list": Constants.COMMANDS.FIND_QUICK_MARKED,

    "goto-global-line": Constants.COMMANDS.GOTO_GLOBAL_LINE,

    "goto-prev-history-node": Constants.COMMANDS.PREV_NODE_FO,
    "goto-next-history-node": Constants.COMMANDS.NEXT_NODE_FO,

    "chapter-select": Constants.COMMANDS.CHAPTER_SELECT,
    "copy-node": Constants.COMMANDS.COPY_SELECTION,
    "copy-node-as-json": Constants.COMMANDS.COPY_AS_JSON,
    "copy-gnx": Constants.COMMANDS.COPY_GNX,
    "cut-node": Constants.COMMANDS.CUT_SELECTION,
    "paste-node": Constants.COMMANDS.PASTE_SELECTION_FO,
    "paste-retaining-clones": Constants.COMMANDS.PASTE_CLONE_SELECTION_FO,
    "paste-as-template": Constants.COMMANDS.PASTE_AS_TEMPLATE,

    "tag-children": Constants.COMMANDS.TAG_CHILDREN,
    "tag-node": Constants.COMMANDS.TAG_NODE,
    "remove-tag": Constants.COMMANDS.REMOVE_TAG,
    "remove-all-tags": Constants.COMMANDS.REMOVE_TAGS,
    "clone-find-tag": Constants.COMMANDS.CLONE_FIND_TAG,
    "import-file": Constants.COMMANDS.IMPORT_ANY_FILE,
    "redo": Constants.COMMANDS.REDO,
    "undo": Constants.COMMANDS.UNDO,
    "clone-find-all": Constants.COMMANDS.CLONE_FIND_ALL,
    "clone-find-all-flattened": Constants.COMMANDS.CLONE_FIND_ALL_FLATTENED,

    'import-MORE-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-free-mind-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-legacy-external-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-mind-jet-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-tabbed-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-todo-text-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-zim-folder': Constants.COMMANDS.IMPORT_ANY_FILE,

    'export-headlines': Constants.COMMANDS.EXPORT_HEADLINES,
    'flatten-outline': Constants.COMMANDS.FLATTEN_OUTLINE,
    'outline-to-cweb': Constants.COMMANDS.OUTLINE_TO_CWEB,
    'outline-to-noweb': Constants.COMMANDS.OUTLINE_TO_NOWEB,
    'remove-sentinels': Constants.COMMANDS.REMOVE_SENTINELS,
    'weave': Constants.COMMANDS.WEAVE,

    'read-file-into-node': Constants.COMMANDS.READ_FILE_INTO_NODE,
    'write-file-from-node': Constants.COMMANDS.WRITE_FILE_FROM_NODE,

    'file-new': Constants.COMMANDS.NEW_FILE,
    'file-open-by-name': Constants.COMMANDS.OPEN_FILE,
    'revert': Constants.COMMANDS.REVERT_TO_SAVED,
    'new': Constants.COMMANDS.NEW_FILE,
    'open-outline': Constants.COMMANDS.OPEN_FILE,
    'file-save': Constants.COMMANDS.SAVE_FILE,
    'file-save-as': Constants.COMMANDS.SAVE_AS_FILE,
    'file-save-as-leojs': Constants.COMMANDS.SAVE_AS_LEOJS,
    'file-save-as-zipped': Constants.COMMANDS.SAVE_AS_FILE,
    'file-save-by-name': Constants.COMMANDS.SAVE_AS_FILE,
    'file-save-to': Constants.COMMANDS.SAVE_AS_FILE,
    'save': Constants.COMMANDS.SAVE_FILE,
    'save-as': Constants.COMMANDS.SAVE_AS_FILE,
    'save-file': Constants.COMMANDS.SAVE_FILE,
    'save-file-as': Constants.COMMANDS.SAVE_AS_FILE,
    'save-file-as-leojs': Constants.COMMANDS.SAVE_AS_LEOJS,
    'save-file-as-zipped': Constants.COMMANDS.SAVE_AS_FILE,
    'save-file-by-name': Constants.COMMANDS.SAVE_AS_FILE,
    'save-file-to': Constants.COMMANDS.SAVE_AS_FILE,
    'save-to': Constants.COMMANDS.SAVE_AS_FILE,

    'set-ua': Constants.COMMANDS.SET_UA,

    'clone-find-all-flattened-marked': Constants.COMMANDS.CLONE_FIND_FLATTENED_MARKED,
    'clone-find-all-marked': Constants.COMMANDS.CLONE_FIND_MARKED,

    'clone-marked-nodes': Constants.COMMANDS.CLONE_MARKED_NODES,

    'cfa': Constants.COMMANDS.CLONE_FIND_ALL,
    'cfam': Constants.COMMANDS.CLONE_FIND_MARKED,
    'cff': Constants.COMMANDS.CLONE_FIND_ALL_FLATTENED,
    'cffm': Constants.COMMANDS.CLONE_FIND_FLATTENED_MARKED,
    'cft': Constants.COMMANDS.CLONE_FIND_TAG,

    'git-diff': Constants.COMMANDS.GIT_DIFF,
    'gd': Constants.COMMANDS.GIT_DIFF,

    'find-tab-open': Constants.COMMANDS.START_SEARCH,
    'find-clone-all': Constants.COMMANDS.CLONE_FIND_ALL,
    'find-clone-all-flattened': Constants.COMMANDS.CLONE_FIND_ALL_FLATTENED,
    'find-clone-tag': Constants.COMMANDS.CLONE_FIND_TAG,
    'find-all': Constants.COMMANDS.FIND_ALL,
    'start-search': Constants.COMMANDS.START_SEARCH,
    'find-next': Constants.COMMANDS.FIND_NEXT,
    'find-prev': Constants.COMMANDS.FIND_PREVIOUS,

    'search-forward': Constants.COMMANDS.START_SEARCH, // In Leo also, this is like ctrl+F.
    'search-backward': Constants.COMMANDS.SEARCH_BACKWARD,
    're-search': Constants.COMMANDS.RE_SEARCH,
    're-search-forward': Constants.COMMANDS.RE_SEARCH,
    're-search-backward': Constants.COMMANDS.RE_SEARCH_BACKWARD,
    'word-search': Constants.COMMANDS.WORD_SEARCH,
    'word-search-forward': Constants.COMMANDS.WORD_SEARCH,
    'word-search-backward': Constants.COMMANDS.WORD_SEARCH_BACKWARD,

    'find-var': Constants.COMMANDS.FIND_VAR,
    'find-def': Constants.COMMANDS.FIND_DEF,
    'replace': Constants.COMMANDS.REPLACE,
    'replace-all': Constants.COMMANDS.REPLACE_ALL,
    'change-all': Constants.COMMANDS.REPLACE_ALL,
    'change-then-find': Constants.COMMANDS.REPLACE_THEN_FIND,
    'replace-then-find': Constants.COMMANDS.REPLACE_THEN_FIND,
    'show-find-options': Constants.COMMANDS.START_SEARCH,


    'set-find-everywhere': Constants.COMMANDS.SET_FIND_EVERYWHERE_OPTION,
    'set-find-node-only': Constants.COMMANDS.SET_FIND_NODE_ONLY_OPTION,
    'set-find-file-only': Constants.COMMANDS.SET_FIND_FILE_ONLY_OPTION,
    'set-find-suboutline-only': Constants.COMMANDS.SET_FIND_SUBOUTLINE_ONLY_OPTION,
    'toggle-find-ignore-case-option': Constants.COMMANDS.TOGGLE_FIND_IGNORE_CASE_OPTION,
    'toggle-find-in-body-option': Constants.COMMANDS.TOGGLE_FIND_SEARCH_BODY_OPTION,
    'toggle-find-in-headline-option': Constants.COMMANDS.TOGGLE_FIND_SEARCH_HEADLINE_OPTION,
    'toggle-find-mark-changes-option': Constants.COMMANDS.TOGGLE_FIND_MARK_CHANGES_OPTION,
    'toggle-find-mark-finds-option': Constants.COMMANDS.TOGGLE_FIND_MARK_FINDS_OPTION,
    'toggle-find-regex-option': Constants.COMMANDS.TOGGLE_FIND_REGEXP_OPTION,
    'toggle-find-word-option': Constants.COMMANDS.TOGGLE_FIND_WORD_OPTION,

};

</t>
<t tx="felix.20210602155312.1">/**
 * * Import any File(s)
 * No URL passed from the command definition.
 * @param p_leoFileUri is offered for internal use only
 */
public importAnyFile(p_leoFileUri?: vscode.Uri): Thenable&lt;unknown&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            let q_importFile: Promise&lt;LeoBridgePackage | undefined&gt;; // Promise for opening a file
            if (p_leoFileUri &amp;&amp; p_leoFileUri.fsPath.trim()) {
                const w_fixedFilePath: string = p_leoFileUri.fsPath.replace(/\\/g, '/');
                // Array of a single filename
                q_importFile = this.sendAction(
                    Constants.LEOBRIDGE.IMPORT_ANY_FILE,
                    { filenames: [w_fixedFilePath] }
                );
            } else {
                q_importFile = this._leoFilesBrowser.getImportFileUrls().then(
                    (p_chosenLeoFiles) =&gt; {
                        if (p_chosenLeoFiles.length) {
                            // Can be multiple files, so array of string is sent
                            return this.sendAction(
                                Constants.LEOBRIDGE.IMPORT_ANY_FILE,
                                { filenames: p_chosenLeoFiles }
                            );
                        } else {
                            return Promise.resolve(undefined);
                        }
                    },
                    (p_errorGetFile) =&gt; {
                        return Promise.reject(p_errorGetFile);
                    }
                );
            }
            return q_importFile;
        })
        .then(
            (p_importFileResult: LeoBridgePackage | undefined) =&gt; {
                if (p_importFileResult) {
                    this.setupRefresh(
                        Focus.NoChange,
                        {
                            tree: true,
                            body: true,
                            goto: true,
                            states: true,
                            documents: true,
                            buttons: true
                        }
                    );
                    return this.launchRefresh();
                } else {
                    return Promise.resolve(undefined);
                }
            },
            (p_errorImport) =&gt; {
                console.log('Rejection for import file');
                return Promise.reject(p_errorImport);
            }
        );
}

</t>
<t tx="felix.20210602160216.1">/**
 * * Open a file browser to let user choose file(s) to import
 * @param p_fileTypes can be used to restrict to particular file types
 * @param p_single can be used to force single file selection
 * @param p_title to specify a window title
 * @returns a promise of an array of filepath+name string(s)
 */
public getImportFileUrls(p_fileTypes?: { [name: string]: string[]; }, p_single?: boolean, p_title?: string): Promise&lt;string[]&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve([]);
    }
    this._fileBrowserActive = true;
    let w_types: { [name: string]: string[]; };
    if (p_fileTypes) {
        w_types = p_fileTypes;
    } else {
        w_types = Constants.IMPORT_FILE_TYPES;
    }
    return new Promise((p_resolve, p_reject) =&gt; {
        vscode.window
            .showOpenDialog({
                canSelectMany: p_single ? false : true,
                openLabel: "Import",
                canSelectFolders: false,
                filters: w_types,
                defaultUri: this._getBestOpenFolderUri(),
                title: p_title ? p_title : "Import File"
            })
            .then(p_chosenLeoFiles =&gt; {
                this._fileBrowserActive = false;
                if (p_chosenLeoFiles) {
                    // array instead of single string
                    const w_result = p_chosenLeoFiles.map(function (e) {
                        return utils.fixSlashesDriveLetter(e.fsPath);
                    });
                    p_resolve(w_result); // Replace backslashes for windows support
                } else {
                    p_resolve([]);
                }
            });
    });
}

</t>
<t tx="felix.20210602213308.1">/**
 * * Possible import file types
 */
public static IMPORT_FILE_TYPES: { [name: string]: string[]; } = {
    "All files": ["*"],
    "C/C++ files": ["c", "cpp", "h", "hpp"],
    "FreeMind files": ["mm.html"],
    "Java files": ["java"],
    "JavaScript files": ["js"],
    "Mindjet files": ["csv"],
    "MORE files": ["MORE"],
    "Lua files": ["lua"],
    "Pascal files": ["pas"],
    "Python files": ["py"],
    "Text files": ["txt"],
};

</t>
<t tx="felix.20210610022645.1">"editor/title": [
  {
    "command": "leointeg.prev",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.next",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.executeScript",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "navigation@3"
  },
  {
    "command": "leointeg.extract",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "navigation@4"
  },
  {
    "command": "leointeg.extractNames",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leointeg.importAnyFile",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "navigation@6"
  },
  {
    "command": "leointeg.chapterSelect",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "navigation@7"
  },
  {
    "command": "leointeg.writeDirtyAtFileNodes",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "navigation@8"
  },
  {
    "command": "leointeg.refreshFromDiskSelection",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "navigation@9"
  },
  {
    "command": "leointeg.showSettingsPage",
    "when": "resourceScheme == leointeg",
    "group": "1_leoInteg@1"
  },
  {
    "command": "leointeg.showLogPane",
    "when": "resourceScheme == leointeg &amp;&amp; leoBridgeReady",
    "group": "1_leoInteg@2"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "resourceScheme == leointeg &amp;&amp; leoBridgeReady",
    "group": "1_leoInteg1@1"
  },
  {
    "command": "leointeg.openLeoFile",
    "when": "resourceScheme == leointeg &amp;&amp; leoBridgeReady",
    "group": "1_leoInteg1@2"
  },
  {
    "command": "leointeg.saveLeoFile",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg1@3"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg1@4"
  },
  {
    "command": "leointeg.sortChildrenSelection",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg2@1"
  },
  {
    "command": "leointeg.sortSiblingsSelection",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg2@2"
  },
  {
    "command": "leointeg.promoteSelection",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg2@3"
  },
  {
    "command": "leointeg.demoteSelection",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg2@4"
  },
  {
    "command": "leointeg.cloneNodeSelection",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg3@1"
  },
  {
    "command": "leointeg.cutNodeSelection",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg3@2"
  },
  {
    "command": "leointeg.copyNodeSelection",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg3@3"
  },
  {
    "command": "leointeg.pasteNodeAtSelection",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg3@4"
  },
  {
    "command": "leointeg.pasteNodeAsCloneAtSelection",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg3@5"
  },
  {
    "command": "leointeg.readFileIntoNode",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg4@2"
  },
  {
    "command": "leointeg.writeFileFromNode",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg4@3"
  },
  {
    "command": "leointeg.writeAtFileNodes",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg4@4"
  },
  {
    "command": "leointeg.writeDirtyAtFileNodes",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg4@5"
  },
  {
    "command": "leointeg.cloneFindAll",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg5@1"
  },
  {
    "command": "leointeg.cloneFindAllFlattened",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg5@2"
  },
  {
    "command": "leointeg.cloneFindMarked",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg5@3"
  },
  {
    "command": "leointeg.cloneFindFlattenedMarked",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg5@4"
  },
  {
    "command": "leointeg.cloneFindParents",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg5@5"
  },
  {
    "command": "leointeg.cloneFindTag",
    "when": "resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "1_leoInteg5@6"
  }
],
</t>
<t tx="felix.20210612000127.1">## 0.1.14

- Rewrite of the leobridgeserver script to be made compatible with the standards in leoserver script from Leo.
- Added option for specifying server file and path. Defaults to the internal leobridgeserver server script.
- Fixed cursor position and selection bugs.
- Fixed automatic server startup and connection bugs.
- Added Search functionality along with a 'find' panel.
- Added goto global line and other clone-find related commands from Leo's 'Search' menu.
- Added import-file(s) command - an alias of the import-any-file command form Leo.
- Temporary fix for some minibuffer commands to override the widgets interactions (ex. clone-find-all, etc.)
- Undo and redo icons are now faded out instead of disappearing when unavailable - to help with button shifting when clicking rapidly.
- Many other small bugfixes.

</t>
<t tx="felix.20210612214028.1">/**
 * * Find next available port starting with p_startingPort inclusively,
 * * check next (max 5) additional ports and return port number, or 0 if none.
 * @param p_startingPort the port number at which to start looking for a free port
 * @returns a promise of an opened port number
 */
export function findNextAvailablePort(p_startingPort: number): Promise&lt;number&gt; {
    return portfinder.getPortPromise({
        port: p_startingPort,
        startPort: p_startingPort,
        stopPort: p_startingPort + 5
    });
}

</t>
<t tx="felix.20210613205741.1">/**
 * * Get a find pattern string input from the user
 * @param p_replace flag for doing a 'replace' instead of a 'find'
 * @param p_uniqueRegex flag for using the "all unique regex" commands
 * @returns Promise of string or undefined if cancelled
 */
private _inputFindPattern(p_replace?: boolean, p_value?: string): Thenable&lt;string | undefined&gt; {
    let w_title, w_prompt, w_placeHolder;
    w_title = p_replace ? Constants.USER_MESSAGES.REPLACE_TITLE : Constants.USER_MESSAGES.SEARCH_TITLE;
    w_prompt = p_replace ? Constants.USER_MESSAGES.REPLACE_PROMPT : Constants.USER_MESSAGES.SEARCH_PROMPT;
    w_placeHolder = p_replace ? Constants.USER_MESSAGES.REPLACE_PLACEHOLDER : Constants.USER_MESSAGES.SEARCH_PLACEHOLDER;
    return vscode.window.showInputBox({
        title: w_title,
        prompt: w_prompt,
        value: p_value,
        placeHolder: w_placeHolder,
    });
}

</t>
<t tx="felix.20210613210351.1">/**
 * * Popup browser to choose Leo-Editor installation folder path
 */
public chooseLeoFolder(): void {
    utils.chooseLeoFolderDialog().then(p_chosenPath =&gt; {
        if (p_chosenPath &amp;&amp; p_chosenPath.length) {
            this.config.setLeoIntegSettings(
                [{
                    code: Constants.CONFIG_NAMES.LEO_EDITOR_PATH,
                    value: p_chosenPath[0].fsPath
                }]
            ).then(() =&gt; {
                this.leoSettingsWebview.changedConfiguration();
                vscode.window.showInformationMessage("Leo-Editor installation folder chosen as " + p_chosenPath[0].fsPath);
                if (!this.leoStates.leoStartupFinished &amp;&amp; this.config.startServerAutomatically) {
                    this.startServer();
                }
            });
        }
    });
}

</t>
<t tx="felix.20210614235023.1">/**
 * * Shows dialog for choosing the Leo Editor installation folder path
 * @returns A promise that resolves to the selected resources or undefined
 */
export function chooseLeoFolderDialog(): Thenable&lt;vscode.Uri[] | undefined&gt; {
    return vscode.window.showOpenDialog(
        {
            title: "Locate Leo-Editor Installation Folder",
            canSelectMany: false,
            openLabel: "Choose Folder",
            canSelectFiles: false,
            canSelectFolders: true
        }
    );
}

</t>
<t tx="felix.20210620220655.1">/**
 * * Tag Children
 */
public tagChildren(): void {
    this.triggerBodySave(false)
        .then(() =&gt; {
            return vscode.window.showInputBox({
                title: Constants.USER_MESSAGES.TITLE_TAG_CHILDREN,
                placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_TAG,
                prompt: Constants.USER_MESSAGES.PROMPT_TAG,
            });
        })
        .then((p_inputResult?: string) =&gt; {
            if (p_inputResult &amp;&amp; p_inputResult.trim()) {
                p_inputResult = p_inputResult.trim();
                // check for special chars first
                if (p_inputResult.split(/(&amp;|\||-|\^)/).length &gt; 1) {
                    vscode.window.showInformationMessage(Constants.USER_MESSAGES.TAGS_CHARACTERS_ERROR);
                    return;
                }
                this.sendAction(
                    Constants.LEOBRIDGE.TAG_CHILDREN,
                    { tag: p_inputResult }
                ).then((p_resultTag: LeoBridgePackage) =&gt; {
                    this.setupRefresh(
                        Focus.NoChange,
                        {
                            tree: true,
                            // body: false,
                            // documents: false,
                            // buttons: false,
                            states: true,
                        }
                    );
                    this.launchRefresh();
                });
            }
        });
}


</t>
<t tx="felix.20210620220702.1">/**
 * * Clone Find Tag
 */
public cloneFindTag(): void {
    this.triggerBodySave(false)
        .then(() =&gt; {
            const w_startValue = this._lastSettingsUsed!.findText === Constants.USER_MESSAGES.FIND_PATTERN_HERE ? '' : this._lastSettingsUsed!.findText;
            return vscode.window.showInputBox({
                value: w_startValue,
                title: Constants.USER_MESSAGES.TITLE_FIND_TAG,
                placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_CLONE_FIND_TAG,
                prompt: Constants.USER_MESSAGES.PROMPT_CLONE_FIND_TAG,
            });
        })
        .then((p_inputResult?: string) =&gt; {
            if (p_inputResult &amp;&amp; p_inputResult.trim()) {
                this.sendAction(
                    Constants.LEOBRIDGE.CLONE_FIND_TAG,
                    { tag: p_inputResult.trim() }
                ).then((p_resultFind: LeoBridgePackage) =&gt; {
                    if (!p_resultFind.found) {
                        // Not found
                    }
                    this.setupRefresh(
                        Focus.NoChange,
                        {
                            tree: true,
                            body: true,
                            // documents: false,
                            // buttons: false,
                            states: true,
                        }
                    );
                    this.launchRefresh();
                });
            }
        });
}

</t>
<t tx="felix.20210706233101.1">/**
 * * Unique numeric Id
 */
var uniqueId: number = 0;

</t>
<t tx="felix.20210706233106.1">/**
 * * Get new uniqueID
 */
export function getUniqueId(): string {
    const id = uniqueId++;
    return id.toString();
}

</t>
<t tx="felix.20210713000442.1">/**
 * * find-var or find-def commands
 * @param p_def find-def instead of find-var
 * @returns Promise that resolves when the "launch refresh" is started
 */
public async findSymbol(p_def: boolean): Promise&lt;any&gt; {
    const w_action: string = p_def
        ? Constants.LEOBRIDGE.FIND_DEF
        : Constants.LEOBRIDGE.FIND_VAR;

    await this._isBusyTriggerSave(false, true);

    const p_findResult = await this.sendAction(w_action, { fromOutline: false });

    if (!p_findResult.found || !p_findResult.focus) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.SEARCH_NOT_FOUND);
    } else {
        let w_finalFocus = Focus.Body;
        const w_focus = p_findResult.focus.toLowerCase();
        if (w_focus.includes('tree') || w_focus.includes('head')) {
            // tree
            w_finalFocus = Focus.Outline;
        }
        this.loadSearchSettings();
        this.setupRefresh(
            w_finalFocus,
            {
                tree: true,
                body: true,
                scroll: p_findResult.found &amp;&amp; w_finalFocus === Focus.Body,
                // documents: false,
                // buttons: false,
                states: true,
            });
        this.launchRefresh();
    }
}

</t>
<t tx="felix.20210713005825.1">"editor/context": [
  {
    "command": "leointeg.findVar",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.findDef",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.extract",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.extractNames",
    "when": "editorHasSelection &amp;&amp; !editorHasMultipleSelections &amp;&amp; resourceScheme == leointeg &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  }
],
</t>
<t tx="felix.20210717192921.1">/**
 * * Kills the server if it was started by this instance of leoInteg
 */
public killServer(): void {
    if (this._serverProcess) {
        // this._serverProcess.kill(); // Replaced by the tree-kill lib
        if (typeof this._serverProcess.pid === 'number') {
            kill(this._serverProcess.pid);
        } else {
            // console.log('this._serverProcess.pid --&gt;', this._serverProcess.pid);
        }
        this._isStarted = false;
        if (!this._leoIntegration.activated) {
            return;
        }
        utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);

        this._leoIntegration.leoStates.leoConnecting = false;
        this._leoIntegration.leoStates.leoBridgeReady = false;
        this._leoIntegration.leoStates.fileOpenedReady = false;
        this._leoIntegration.leoStates.leoStartingServer = false;

        this._serverProcess = undefined;
    } else {
        console.error("No Server");
    }

}

</t>
<t tx="felix.20210717204048.1">/**
 * * Kills the server process if it was started by this instance of the extension
 */
public killServer(): void {
    this._serverService.killServer();
}

</t>
<t tx="felix.20210718155134.1">/**
 * * cleanupBody closes all remaining body pane to shut down this vscode window
 * @returns a promise that resolves when done saving and closing
 */
public cleanupBody(): Thenable&lt;any&gt; {
    let q_save: Thenable&lt;any&gt;;
    //
    if (this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty &amp;&amp;
        utils.leoUriToStr(this.bodyUri) === utils.leoUriToStr(this._bodyLastChangedDocument.uri)
    ) {
        q_save = this._bodySaveDeactivate(this._bodyLastChangedDocument);
    } else {
        q_save = Promise.resolve(true);
    }

    // Adding log in the chain of events
    let q_edit: Thenable&lt;boolean&gt;;
    if (this.bodyUri) {
        const w_edit = new vscode.WorkspaceEdit();
        w_edit.deleteFile(this.bodyUri, { ignoreIfNotExists: true });
        q_edit = vscode.workspace.applyEdit(w_edit).then(() =&gt; {
            return true;
        }, () =&gt; {
            return false;
        });
    } else {
        q_edit = Promise.resolve(true);
    }
    Promise.all([q_save, q_edit])
        .then(() =&gt; {
            return this.closeBody();
        }, () =&gt; {
            return true;
        });

    return q_save;
}

</t>
<t tx="felix.20210718163005.1">## 0.1.15

- Modified server location logic
- Fixed find-prev, next, find all / clone-find commands
- Fixed extract name command.
- Fixed body being re-written to same string and being marked dirty when 'safety-saving' before switching docs.
- Detection of .Leo documents themselves now works by closing and re-opening the .leo file if reloading is chosen by the user. (or automatic via options)
- Added icons and commands for top of body pane menu.
- Added new commands such as insert-child along with their keybindings.
- Also added more keybindings to the 'insert-node' command such as 'insert' and 'shift-insert'.
- Added find-var and find-def commands.
- Made some text-related commands available through the right-click context menu in the body pane. (extract, find-var, find-def, etc.)

</t>
<t tx="felix.20210725153617.1">## 0.1.16

- Added procedures to cleanup when closing a vscode window. (closes server and body panes)

</t>
<t tx="felix.20210727225050.1">/**
 * * For simple interactions in webviews into vscode API
 */
export interface IVsCodeApi {
    postMessage(msg: {}): void;
    setState(state: {}): void;
    getState(): { [key: string]: any };
}

</t>
<t tx="felix.20210802162424.1">/**
 * * Disconnects from the server
 */
public stopConnection(): void {
    this._leoBridge.closeLeoProcess();
}

</t>
<t tx="felix.20210802163703.1">/**
 * * Closes the websocket connection
 */
public closeLeoProcess(): void {
    if (this._websocket) {
        this._websocket.close(1001, "Quitting LeoInteg");
        // console.log('websocket closed');
    } else {
        // console.warn('LeoInteg websocket close called without websocket active');
    }
}

</t>
<t tx="felix.20210804175113.1">/**
 * * Server announced the multi-user content changed: Debounce a refresh cycle.
 * The 'action' string can be checked to determine what kind, if any, is required.
 * Note: 'Getters' and the 'do_nothing' actions are NOT shared by the server.
 * @param p_serverPackage the package sent along by the server
 */
public refresh(p_serverPackage: any): Promise&lt;unknown&gt; {
    if (p_serverPackage.opened) {
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.DO_NOTHING)
            .then((p_doNothingPackage) =&gt; {
                p_doNothingPackage.filename = p_doNothingPackage.commander!.fileName;
                const w_gotoNeeded = (this._leoIntegration.serverHasOpenedFile === false) ||
                    this._leoIntegration.serverOpenedFileName === p_doNothingPackage.filename!;
                this._leoIntegration.serverHasOpenedFile = true;
                this._leoIntegration.serverOpenedFileName = p_doNothingPackage.filename!;
                this._leoIntegration.serverOpenedNode = p_doNothingPackage.node!;
                this._leoIntegration.setupRefresh(
                    Focus.NoChange,
                    {
                        tree: true,
                        body: true,
                        states: true,
                        buttons: true,
                        documents: true,
                        goto: w_gotoNeeded
                    },
                    p_doNothingPackage.node!
                );

                return this._leoIntegration.launchRefresh();
            });
    } else {
        this._leoIntegration.serverHasOpenedFile = false;
        this._leoIntegration.serverOpenedFileName = "";
        this._leoIntegration.serverOpenedNode = undefined;
    }
    this._leoIntegration.launchRefresh();
    return Promise.resolve();
}

</t>
<t tx="felix.20210806175431.1">/**
 * * Sets new body text on leo's side before vscode closes itself if body is dirty
 * @param p_document Vscode's text document which content will be used to be the new node's body text in Leo
 * @returns a promise that resolves when the complete saving process is finished
 */
private _bodySaveDeactivate(
    p_document: vscode.TextDocument
): Promise&lt;LeoBridgePackage&gt; {
    const w_param = {
        gnx: utils.leoUriToStr(p_document.uri),
        body: p_document.getText().replace(/\r\n/g, "\n"),
    };
    return this.sendAction(Constants.LEOBRIDGE.SET_BODY, w_param);
}

</t>
<t tx="felix.20210812004050.1">{
  "command": "workbench.files.action.collapseExplorerFolders",
  "key": "alt+-",
  "when": "config.leoIntegration.collapseAllShortcut &amp;&amp; !inSearchEditor &amp;&amp; !sideBarFocus &amp;&amp; resourceScheme == untitled || config.leoIntegration.collapseAllShortcut &amp;&amp; !inSearchEditor &amp;&amp; !sideBarFocus &amp;&amp; resourceScheme == file || config.leoIntegration.collapseAllShortcut &amp;&amp; !inSearchEditor &amp;&amp; explorerViewletFocus"
},
{
  "command": "workbench.view.extension.leoIntegrationView",
  "key": "ctrl+shift+l",
  "when": "!config.leojs.activityViewShortcut &amp;&amp; config.leoIntegration.activityViewShortcut &amp;&amp; !editorHasSelection &amp;&amp; !inSearchEditor &amp;&amp; focusedView != workbench.view.search"
}
</t>
<t tx="felix.20210816230003.1">## 0.1.17

- Saves recently opened Leo files list per workspace, instead of globally.
- Changed the default visible command icons above the body pane. Also makes sure 'settings' is visible.
- Added global zoom level and editor font-size in the LeoInteg settings panel to help change the body &amp; outline font sizes.
- Server now opens modal dialogs for saving dirty documents on exit.
- Added experimental server option settings (cwd, shell, detach) to help with various python setups.
- Server now started with a CWD of the current workspace by default (fixes git-diff).

</t>
<t tx="felix.20210818223534.1">/**
 * * Set the workbench.editor.enablePreview vscode setting
 */
public setEnablePreview(): Thenable&lt;void&gt; {
    return vscode.workspace.getConfiguration("workbench.editor")
        .update("enablePreview", true, true);
}

</t>
<t tx="felix.20210818225820.1">/**
 * * Check if the workbench.editor.enablePreview flag is set
 * @param p_forced Forces the setting instead of just suggesting with a message
 */
public checkEnablePreview(p_forced?: boolean): void {
    let w_result: any = true;
    const w_setting = vscode.workspace.getConfiguration("workbench.editor");
    if (w_setting.inspect("enablePreview")!.globalValue === undefined) {
        w_result = w_setting.inspect("enablePreview")!.defaultValue;
    } else {
        w_result = w_setting.inspect("enablePreview")!.globalValue;
    }
    if (w_result === false) {
        if (p_forced) {
            this.setEnablePreview();
            vscode.window.showInformationMessage(Constants.USER_MESSAGES.ENABLE_PREVIEW_SET);
        } else {
            if (!this._leoIntegration.leoStates.leoStartupFinished) {
                return;
            }
            vscode.window.showWarningMessage(Constants.USER_MESSAGES.ENABLE_PREVIEW_RECOMMEND, Constants.USER_MESSAGES.FIX_IT)
                .then(p_chosenButton =&gt; {
                    if (p_chosenButton === Constants.USER_MESSAGES.FIX_IT) {
                        vscode.commands.executeCommand(Constants.COMMANDS.SET_ENABLE_PREVIEW);
                        vscode.window.showInformationMessage(Constants.USER_MESSAGES.ENABLE_PREVIEW_SET);
                    }
                });
        }
    }
}

</t>
<t tx="felix.20210820231649.1">/**
 * * Check for unique port #
 * @param p_port the port number at which to look for
 * @returns a promise of an opened port number - or rejection if busy port
 */
export function findSingleAvailablePort(p_port: number): Promise&lt;number&gt; {
    return portfinder.getPortPromise({
        port: p_port,
        startPort: p_port,
        stopPort: p_port
    });
}

</t>
<t tx="felix.20210821202347.1">/**
 * * Check if the 'workbench.editor.closeEmptyGroups' setting is false
 * @param p_forced Forces the setting instead of just suggesting with a message
 */
public checkCloseEmptyGroups(p_forced?: boolean): void {
    let w_result: any = false;
    const w_setting = vscode.workspace.getConfiguration("workbench.editor");
    if (w_setting.inspect("closeEmptyGroups")!.globalValue === undefined) {
        w_result = w_setting.inspect("closeEmptyGroups")!.defaultValue;
    } else {
        w_result = w_setting.inspect("closeEmptyGroups")!.globalValue;
    }
    if (w_result === true) {
        if (p_forced) {
            this.clearCloseEmptyGroups();
            vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLOSE_EMPTY_CLEARED);
        } else {
            if (!this._leoIntegration.leoStates.leoStartupFinished) {
                return;
            }
            vscode.window.showWarningMessage(Constants.USER_MESSAGES.CLOSE_EMPTY_RECOMMEND, Constants.USER_MESSAGES.FIX_IT)
                .then(p_chosenButton =&gt; {
                    if (p_chosenButton === Constants.USER_MESSAGES.FIX_IT) {
                        vscode.commands.executeCommand(Constants.COMMANDS.CLEAR_CLOSE_EMPTY_GROUPS);
                        vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLOSE_EMPTY_CLEARED);
                    }
                });
        }
    }
}

</t>
<t tx="felix.20210821203119.1">/**
 * * Clears the workbench.editor.closeEmptyGroups vscode setting
 */
public clearCloseEmptyGroups(): Thenable&lt;void&gt; {
    return vscode.workspace.getConfiguration("workbench.editor")
        .update("closeEmptyGroups", false, true);
}

</t>
<t tx="felix.20210821212114.1">"extension/context": [
  {
    "command": "leointeg.showSettingsPage",
    "when": "extension =~ /^boltex.leointeg/ &amp;&amp; extensionStatus == installed",
    "group": "3_leointeg@1"
  }
]
</t>
<t tx="felix.20210829192609.1">## Server Settings

Although the Leo integration has one instance of the leoserver script per vscode 'project'
window by default, the server settings also has features that allows you to use the same instance
of Leo in multiple client (vscode) windows simultaneously, with real-time updates and interaction.

(See [Multiple concurrent connections](https://leo-editor.github.io/leo-editor/leoserver.html#multiple-concurrent-connections))

### Auto Start

**When auto-start is set, a vscode window will start a new instance of Leo server for itself on the next available network port.**
If the connection limit is set to anything above the default of one (1),
then the auto-start logic will consider a port being in use as
being already started and will not start another one.
_(Letting you connect, or auto-connect to it from any additional opened vscode window.)_

The server, located in your Leo-Editor installation folder, also has other options unrelated to
LeoInteg that allows you to create a stand-alone internet server for other uses such as
multi-user interaction over a network/internet, and more.

Run the server directly with the '--help' argument to view all server options and capabilities:\
`.../leo-editor/leo/core/leoserver.py --help`

For more information about the Leo server see [Using leoserver.py](https://leo-editor.github.io/leo-editor/leoserver.html) from Leo's official documentation.

</t>
<t tx="felix.20210901215735.1">## 0.1.19

- Fixed 'tab' press from the sidebar: if pressing from the outline it tabs to possible icons on the node, then goes to the body pane. If pressed from the search panel, it cycles through the fields of the search panel.
- Made the server output channel and the Leo Log Window not show up and open automatically anymore unless the text in the Log Window is 'red' (For Errors to be shown).
- Added icon for the 'show Log Pane' command and made it available, along with the 'Show Leointeg Settings', on title bar of documents and buttons views.
- Automatic detection of VSCode's workbench.editor.closeOnFileDelete if its missing/disabled.
- Fixed pressing shift+insert while in terminal, which triggered the 'insert node' command instead of letting the usual vscode 'paste in terminal' command take effect.

</t>
<t tx="felix.20210915233602.1">/**
 * * Asks for .leojs file name and path, then saves the JSON Leo file
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns a promise from saving the file results, or that will resolve to undefined if cancelled
 */
public saveAsLeoJsFile(p_fromOutline?: boolean): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
                return this._leoFilesBrowser.getLeoJsFileUrl();
            } else {
                // 'when-conditions' should prevent this
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            }
        })
        .then((p_chosenLeoFile) =&gt; {
            if (p_chosenLeoFile.trim()) {
                const w_hasDot = p_chosenLeoFile.indexOf('.') !== -1;
                if (
                    !w_hasDot ||
                    (p_chosenLeoFile.split('.').pop() !== Constants.JS_FILE_EXTENSION &amp;&amp; w_hasDot)
                ) {
                    if (!p_chosenLeoFile.endsWith('.')) {
                        p_chosenLeoFile += '.'; // Add dot if needed
                    }
                    p_chosenLeoFile += Constants.JS_FILE_EXTENSION; // Add extension
                }
                if (this.leoStates.leoOpenedFileName) {
                    this._removeLastFile(this.leoStates.leoOpenedFileName);
                    this._removeRecentFile(this.leoStates.leoOpenedFileName);
                }
                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.SAVE_FILE,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    finalFocus: p_fromOutline ? Focus.Outline : Focus.Body,
                    name: p_chosenLeoFile,
                });
                this.leoStates.leoOpenedFileName = p_chosenLeoFile.trim();
                // this._leoStatusBar.update(true, 0, true);// removed until proper API for knowing focus placement
                this._addRecentAndLastFile(p_chosenLeoFile.trim());
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject('Save file not added on command stack');
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20210915234252.1">/**
 * * Open a file browser and let the user choose a JSON leojs file name to save as.
 * @returns A promise resolving to a chosen path string, or rejected with an empty string if cancelled
 */
public getLeoJsFileUrl(): Promise&lt;string&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve("");
    }
    this._fileBrowserActive = true;
    return new Promise((p_resolve, p_reject) =&gt; {
        // Choose file
        vscode.window.showSaveDialog({
            saveLabel: "Save Copy as leojs File",
            defaultUri: this._getBestOpenFolderUri(),
            filters: { 'JSON Leo File': ['leojs'] },
            title: "Save Copy as leojs File"
        })
            .then(p_chosenLeoFile =&gt; {
                this._fileBrowserActive = false;
                if (p_chosenLeoFile) {
                    // single string
                    p_resolve(utils.fixSlashesDriveLetter(p_chosenLeoFile.fsPath));
                } else {
                    p_resolve(""); // not rejection - resolve empty string
                }
            });

    });
}

</t>
<t tx="felix.20210916004954.1">## 0.1.18

- Git-diff is now fixed in Leo so the experimental option 'Set CWD' has been removed
- The somewhat unnecessary experimental option 'Shell' has been removed.
- Automatic detection of VSCode's workbench.editor.enablePreview if its missing/disabled.
- Automatic detection of VSCode's workbench.editor.closeEmptyGroups if its missing/enabled.
- Easier access to the leo settings through the extension config title strings and the extension view menu.

</t>
<t tx="felix.20210919194259.1">## 0.1.20

- Added .leojs JSON file format support.
- Fixed various smaller/invisible bugs.

</t>
<t tx="felix.20210919194446.1">## 1.0.1

- Fixed double check for vscode settings recommendations at startup.

</t>
<t tx="felix.20210923233342.1">## 1.0.0

- Fixed 'body-undo-modification-bug' when triggering outline icon change before undoing.
- Version 1.0, First Official Release!

</t>
<t tx="felix.20210928231455.1">## 1.0.2

- Cleaned up command palette's insert 'child' choices.
- Fixed 'insert node' command to insert as child if the targeted (or current) node is expanded.

</t>
<t tx="felix.20211007215423.1">## 1.0.3

- Fixed 'F3' bug: findNext didn't trigger because the context was not (re)set properly on focus-out from the 'find panel'.
- Changed all context 'when' clauses to be more 'precise &amp; unique' in relation to other extensions, such as leojs.
- Added the reStructuredText (rest) .rst language support. (syntax coloring and snippets)
- Fixed at-button panel to refresh after adding a button
- Added 'Goto Script' command to the context menu of at-buttons, to 'find and goto' the source node of the button script.

</t>
<t tx="felix.20211017002435.1">/**
 * * Finds and goes to the script of an at-button. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was right-clicked
 * @returns the launchRefresh promise started after it's done finding the node
 */
public async gotoScript(p_node: LeoButtonNode): Promise&lt;any&gt; {
    await this._isBusyTriggerSave(false);
    this.sendAction(
        Constants.LEOBRIDGE.GOTO_SCRIPT,
        { index: p_node.button.index }
    );

    const w_package = await this.sendAction(Constants.LEOBRIDGE.DO_NOTHING);

    // Refresh and reveal selection
    this.setupRefresh(
        Focus.Body,
        {
            tree: true,
            body: true,
            goto: true,
            states: true,
            documents: true,
            buttons: true
        },
        w_package.node
    );

    this.launchRefresh();
    return w_package;
}

</t>
<t tx="felix.20211018004333.1">## 1.0.4

- Fixed typos and small bugs.
- Fixed refresh type for mark/unmark node.
- Fixed bug that prevented context some menu items on \@\&lt;files\&gt; nodes and other special nodes.
- Added Write (dirty) \@\&lt;file\&gt; commands and keybindings.
- Fixed flags and icons shown above the body pane for hoist/dehoist commands.
- Fixed 'clean/dirty' state of leo body documents with the 'triggerBodySave' method which makes sure the body text is sent to the leo server before anything would close or destroy the body pane. (when focusing on another document or outside of vscode, etc.)
- Fixed "view welcome-content" of outline for contexts before the bridge is connected, and settings were changed. (e.g. when auto start and/or auto-connect were off at startup)
- Fixed Leo's comment/code blocks directives "@doc"/"@code" and their shorthand versions "@"/"@c".
- Fixed color syntax to match Leo's PR #2303 which removes @raw and @end_raw and adds @section-delims.

</t>
<t tx="felix.20211111214657.1">/**
 * * Refreshes body pane's statuses such as applied language file type, word-wrap state, etc.
 */
public refreshBodyStates(): void {
    if (!this._bodyTextDocument || !this.lastSelectedNode) {
        return;
    }

    // * Set document language along with the proper cursor position, selection range and scrolling position
    this._getBodyLanguage(this.lastSelectedNode!).then((p_language) =&gt; {
        // Apply language if the selected node is still the same after all those events
        if (this._bodyTextDocument &amp;&amp;
            !this._bodyTextDocument.isClosed &amp;&amp;
            this.lastSelectedNode &amp;&amp;
            p_language !== this._bodyTextDocument.languageId &amp;&amp;
            utils.leoUriToStr(this._bodyTextDocument.uri) === this.lastSelectedNode.gnx
        ) {
            this._setBodyLanguage(this._bodyTextDocument, p_language);
        }
    });
}

</t>
<t tx="felix.20211111233213.1">/**
 * * Refresh body states after a small debounced delay.
 */
public debouncedRefreshBodyStates(p_delay?: number) {

    if (!p_delay) {
        p_delay = 0;
    }

    if (this._bodyStatesTimer) {
        clearTimeout(this._bodyStatesTimer);
    }
    if (p_delay === 0) {
        if (this._bodyLastChangedDocument &amp;&amp; !this._bodyLastChangedDocument.isClosed &amp;&amp; this.leoStates.fileOpenedReady) {
            this._bodySaveDocument(this._bodyLastChangedDocument);
        }
        this.refreshBodyStates();
    } else {
        this._bodyStatesTimer = setTimeout(() =&gt; {
            if (this._bodyLastChangedDocument &amp;&amp; !this._bodyLastChangedDocument.isClosed &amp;&amp; this.leoStates.fileOpenedReady) {
                this._bodySaveDocument(this._bodyLastChangedDocument);
            }
            this.refreshBodyStates();
        }, p_delay);
    }

}

</t>
<t tx="felix.20211114150842.1">{
  "command": "leointeg.undoFromOutline",
  "key": "ctrl+z",
  "mac": "cmd+z",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !inputFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
{
  "command": "leointeg.redoFromOutline",
  "key": "ctrl+shift+z",
  "mac": "cmd+shift+z",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !inputFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoUndos|^leoFindPanel|^leoDocuments|^leoGoto|^leoButtons/"
},
</t>
<t tx="felix.20211210001626.1">## 1.0.5

- Fixed bug where the selection could not change (visual update in outline) when hoisted on a node deeper than top-level of tree (sibling of root node).

</t>
<t tx="felix.20220215235325.1">/**
 * * Sets vscode's body-pane editor's language
 */
private _setBodyLanguage(p_document: vscode.TextDocument, p_language: string): Thenable&lt;vscode.TextDocument&gt; {

    return vscode.languages.setTextDocumentLanguage(p_document, p_language).then(
        (p_mewDocument) =&gt; { return p_mewDocument; }, // ok - language found
        (p_error) =&gt; {
            // ERROR: Output error info
            let w_langName: string = p_error.toString().split('\n')[0];
            if (w_langName.length &gt; 36 &amp;&amp; w_langName.includes(Constants.LEO_LANGUAGE_PREFIX)) {
                w_langName = w_langName.substring(36);
            } else {
                w_langName = "";
            }
            if (w_langName &amp;&amp; !this._languageFlagged.includes(w_langName)) {
                this._languageFlagged.push(w_langName);
                if (w_langName.endsWith(Constants.LEO_WRAP_SUFFIX)) {
                    w_langName = w_langName.slice(0, -Constants.LEO_WRAP_SUFFIX.length);
                }
                if (w_langName.startsWith(Constants.LEO_LANGUAGE_PREFIX)) {
                    w_langName = w_langName.slice(Constants.LEO_LANGUAGE_PREFIX.length);
                }
                vscode.window.showInformationMessage(
                    w_langName + Constants.USER_MESSAGES.LANGUAGE_NOT_SUPPORTED
                );
            } else if (!w_langName) {
                // Document was closed: refresh after a timeout cycle (should not happen!)
                setTimeout(() =&gt; {
                    this.setupRefresh(
                        this.finalFocus,
                        {
                            // tree: true,
                            body: true,
                            // documents: true,
                            // buttons: false,
                            states: true,
                        }
                    );
                    this.launchRefresh();
                }, 0);
            }
            return p_document;
        }
    );
}

</t>
<t tx="felix.20220216005511.1">## 1.0.6

- Prevent reappearance of unknown-language warnings in a session, for a given language.
- Added Fortran and Fortran90 syntax-coloring and snippets support.
- Clicking on LeoInteg's status bar indicator now shows the log pane.
- Added support for "@rclick" nodes along "@button" nodes, by presenting a menu if they are present when clicking one.
- Copy paste from/to anywhere! Clipboard operations are now using the system's clipboard instead of Leo's internal clipboard. (Requires Leo minimal version of at least 6.6-b2)
- Removed LeoBridge server output pane: The server and 'Print' terminal outputs from leo now appears in the log pane.
- Headlines can now be changed to an empty string, as per Leo's standards.

</t>
<t tx="felix.20220220191549.1">/**
 * * Used to select a button's rclick by index
 */
export interface ChooseRClickItem extends vscode.QuickPickItem {
    index: number;
    rclick?: RClick;
}

</t>
<t tx="felix.20220221001803.1">/**
 * * Returned from Leo with buttons data
 */
export interface RClick {
    name: string;
    children: RClick[];
}

</t>
<t tx="felix.20220221003719.1">/**
 * * Show input window to select the @buttons's right-click item
 */
private async _handleRClicks(p_rclicks: RClick[], topLevelName?: string): Promise&lt;ChooseRClickItem&gt; {
    const w_choices: ChooseRClickItem[] = [];
    let w_index = 0;
    if (topLevelName) {
        w_choices.push(
            { label: topLevelName, picked: true, alwaysShow: true, index: w_index++ }
        );
    }
    w_choices.push(
        ...p_rclicks.map((p_rclick): ChooseRClickItem =&gt; { return { label: p_rclick.name, index: w_index++, rclick: p_rclick }; })
    );

    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.CHOOSE_BUTTON
    };

    const w_picked = await vscode.window.showQuickPick(w_choices, w_options);

    if (w_picked) {
        this._rclickSelected.push(w_picked.index);
        if (topLevelName &amp;&amp; w_picked.index === 0) {
            return Promise.resolve(w_picked);
        }
        if (w_picked.rclick &amp;&amp; w_picked.rclick.children &amp;&amp; w_picked.rclick.children.length) {
            return this._handleRClicks(w_picked.rclick.children);
        } else {
            return Promise.resolve(w_picked);
        }
    }
    return Promise.reject();
}

</t>
<t tx="felix.20220222012528.1">/**
 * * Place the XML or JSON Leo outline tree on the clipboard for the given node, and removes it.
 */
public async cutNode(
    p_node?: ArchivedPosition,
    p_fromOutline?: boolean
): Promise&lt;LeoBridgePackage | undefined&gt; {

    await this._isBusyTriggerSave(false, true);

    const w_commandResult = this.nodeCommand({
        action: Constants.LEOBRIDGE.CUT_PNODE,
        node: p_node,
        refreshType: { tree: true, body: true, states: true },
        finalFocus: p_fromOutline ? Focus.Outline : Focus.Body,
    });

    return w_commandResult.then(p_package =&gt; {
        if (p_package &amp;&amp; p_package.string) {
            this.replaceClipboardWith(p_package.string);
        }
        return p_package;
    });

}

</t>
<t tx="felix.20220222012540.1">/**
 * * Place the XML or JSON Leo outline tree on the clipboard for the given node.
 */
public async copyNode(
    p_node?: ArchivedPosition,
    p_fromOutline?: boolean
): Promise&lt;LeoBridgePackage | undefined&gt; {

    await this._isBusyTriggerSave(false, true);

    const w_commandResult = this.nodeCommand({
        action: Constants.LEOBRIDGE.COPY_PNODE,
        node: p_node,
        refreshType: {},
        finalFocus: p_fromOutline ? Focus.Outline : Focus.Body
    });
    return w_commandResult.then(p_package =&gt; {
        if (p_package &amp;&amp; p_package.string) {
            this.replaceClipboardWith(p_package.string);
        } else {
        }
        return p_package;
    });
}

</t>
<t tx="felix.20220222012552.1">/**
 * * Creates a section of tree outline from the XML or JSON Leo outline on the clipboard.
 */
public async pasteNode(
    p_node?: ArchivedPosition,
    p_fromOutline?: boolean
): Promise&lt;LeoBridgePackage | undefined&gt; {

    await this._isBusyTriggerSave(false, true);

    const text = await this.asyncGetTextFromClipboard();

    const w_commandResult = this.nodeCommand({
        action: Constants.LEOBRIDGE.PASTE_PNODE,
        node: p_node,
        refreshType: { tree: true, body: true, states: true },
        name: text,
        finalFocus: p_fromOutline ? Focus.Outline : Focus.Body,
    });
    return w_commandResult;

}

</t>
<t tx="felix.20220222012602.1">/**
 * * Creates, while preserving the top gnx of a section of tree outline, from the clipboard content.
 */
public async pasteAsCloneNode(
    p_node?: ArchivedPosition,
    p_fromOutline?: boolean
): Promise&lt;LeoBridgePackage | undefined&gt; {

    await this._isBusyTriggerSave(false, true);

    const text = await this.asyncGetTextFromClipboard();

    const w_commandResult = this.nodeCommand({
        action: Constants.LEOBRIDGE.PASTE_CLONE_PNODE,
        node: p_node,
        refreshType: { tree: true, body: true, states: true },
        name: text,
        finalFocus: p_fromOutline ? Focus.Outline : Focus.Body,
    });
    return w_commandResult;
}

</t>
<t tx="felix.20220222014050.1"></t>
<t tx="felix.20220222014050.2">/**
 * * Replaces the system's clipboard with the given string
 * @param p_string actual string content to go onto the clipboard
 * @returns a promise that resolves when the string is put on the clipboard
 */
public replaceClipboardWith(p_string: string): Thenable&lt;void&gt; {
    this._clipboardContent = p_string; // also set immediate clipboard string
    return vscode.env.clipboard.writeText(p_string);
}

</t>
<t tx="felix.20220222014050.3">/**
 * * Asynchronous clipboards getter
 * Get the system's clipboard contents and returns a promise
 * Also puts it in the global clipboardContents variable
 * @returns a promise of the clipboard string content
 */
public async asyncGetTextFromClipboard(): Promise&lt;string&gt; {
    const s = await vscode.env.clipboard.readText();
    // Set immediate clipboard string for future read
    this._clipboardContent = s;
    // Return from synchronous clipboards getter
    return this.getTextFromClipboard();
}

</t>
<t tx="felix.20220222014050.4">/**
 * * Synchronous clipboards getter
 * @returns the global variable 'clipboardContent' that was set by asyncGetTextFromClipboard
 */
public getTextFromClipboard(): string {
    return this._clipboardContent;
}

</t>
<t tx="felix.20220301224252.1">// @ts-check

// This script will be run within the webview itself
// It cannot access the main VS Code APIs directly.
// Send message to leointeg with vscode.postMessage({ keyNameEx1: someValue, ... });
// Receive messages from leointeg with window.addEventListener('message', event =&gt; { ... });
(function () {
    // @ts-expect-error
    const vscode = acquireVsCodeApi();

    let timer; // for debouncing sending the settings from this webview to leointeg
    let dirty = false; // all but nav input
    let navTextDirty = false;

    let firstTabElId = 'searchOptions'; // The first tabbable element used to be 'findText' before nav inputs
    let lastTabElId = 'searchBody';

    /**
     * * Flag for freezing the nav 'search as you type' headlines (concept from original nav plugin)
     * - Resets when switching to tag, or when clearing the input field.
     * - Sets when pressing Enter with non-empty input field &amp;&amp; not tag mode.
     */
    let frozen = false;
    let w_freezeElement = document.getElementById("freeze");
    if (w_freezeElement) {
        w_freezeElement.style.display = 'none';
    }
    let navSearchTimer; // for debouncing the search-headline while typing if unfrozen

    // * LeoSearchSettings Type
    let searchSettings = {
        // Nav settings
        navText: '',
        showParents: true,
        isTag: false,
        searchOptions: 0,
        // Find/replace
        findText: '',
        replaceText: '',
        wholeWord: false,
        ignoreCase: true,
        regExp: false,
        markFinds: false,
        markChanges: false,
        searchHeadline: true,
        searchBody: true,
        searchScope: 0, // 0 is entire outline (1: sub-outline, 2: node only)
    };

    // * Search related controls (No nav inputs)
    let findReplaceInputIds = ['findText', 'replaceText'];
    let checkboxIds = [
        'wholeWord',
        'ignoreCase',
        'regExp',
        'markFinds',
        'markChanges',
        'searchHeadline',
        'searchBody',
    ];
    let radioIds = ['entireOutline', 'subOutlineOnly', 'nodeOnly', 'fileOnly'];

    function resetTagNav() {
        navSearchTimer = setTimeout(() =&gt; {
            if (navTextDirty) {
                navTextDirty = false;
                if (navSearchTimer) {
                    clearTimeout(navSearchTimer);
                }
                sendSearchConfig();
            }
            vscode.postMessage({ type: 'leoNavTextChange' });
        }, 250); // quarter second
    }

    function navTextChange() {
        // cancel timer, reset 'debounced' timer after checks, if still needed
        if (navSearchTimer) {
            clearTimeout(navSearchTimer);
        }

        // * Needed Checks
        if (searchSettings.navText.length === 0) {
            setFrozen(false);
            // if tagging but empty: SEND SEARCH LIST-ALL-TAGS COMMAND
            if (searchSettings.isTag) {
                resetTagNav();
            }

        }
        if (searchSettings.navText === "m" &amp;&amp; !searchSettings.isTag) {
            // ! Easter Egg: calls 'marked-list', which list all marked nodes !
            navSearchTimer = setTimeout(() =&gt; {
                if (navTextDirty) {
                    navTextDirty = false;
                    if (navSearchTimer) {
                        clearTimeout(navSearchTimer);
                    }
                    sendSearchConfig();
                }
                vscode.postMessage({ type: 'leoNavMarkedList' });

            }, 40); // Shorter delay for this command
            return false;
        }

        // User changed text in nav text input
        if (frozen || searchSettings.navText.length &lt; 3) {
            return; // dont even continue if not long enough or already frozen
        }

        // DEBOUNCE .25 to .5 seconds with navSearchTimer
        navSearchTimer = setTimeout(() =&gt; {
            if (navTextDirty) {
                navTextDirty = false;
                if (navSearchTimer) {
                    clearTimeout(navSearchTimer);
                }
                sendSearchConfig();
            }
            vscode.postMessage({ type: 'leoNavTextChange' });
        }, 400); // almost half second

    }

    function setSearchSetting(p_id) {
        if (checkboxIds.includes(p_id)) {
            toggleCheckbox(p_id);
        } else if (radioIds.includes(p_id)) {
            setRadio(p_id);
        }
    }

    function setFrozen(p_focus) {
        frozen = p_focus;
        w_freezeElement = document.getElementById("freeze");
        if (w_freezeElement) {
            if (frozen) {
                w_freezeElement.style.display = '';
            } else {
                w_freezeElement.style.display = 'none';
            }
        }
    }

    function setSettings(p_settings) {
        if (p_settings["navText"] || p_settings["navText"] === '') {

            // Nav controls
            // @ts-expect-error
            document.getElementById("navText").value = p_settings["navText"];
            searchSettings["navText"] = p_settings["navText"];

            // showParents
            // @ts-expect-error
            document.getElementById("showParents").checked = p_settings["showParents"];
            searchSettings["showParents"] = p_settings["showParents"];

            // isTag
            // @ts-expect-error
            document.getElementById("isTag").checked = p_settings["isTag"];
            searchSettings["isTag"] = p_settings["isTag"];
            handleIsTagSwitch(false);

            // searchOptions
            // @ts-expect-error
            document.getElementById("searchOptions").value = p_settings["searchOptions"];
            searchSettings["searchOptions"] = p_settings["searchOptions"];
        } else {
            // ! Not at least Leo 6.6 final : hide top elements !
            firstTabElId = 'findText';
            var elements = document.getElementsByClassName("nav-element");

            for (var i = 0; i &lt; elements.length; i++) {
                // @ts-expect-error
                elements[i].style.display = "none";
            }
        }

        // When opening a Leo document, set default values of fields
        findReplaceInputIds.forEach((p_inputId) =&gt; {
            // @ts-expect-error
            document.getElementById(p_inputId).value = p_settings[p_inputId];
            searchSettings[p_inputId] = p_settings[p_inputId];
        });
        checkboxIds.forEach((p_inputId) =&gt; {
            // @ts-expect-error
            document.getElementById(p_inputId).checked = p_settings[p_inputId];
            searchSettings[p_inputId] = p_settings[p_inputId];
        });
        // @ts-expect-error
        document.getElementById(radioIds[p_settings['searchScope']]).checked = true;
        searchSettings.searchScope = p_settings['searchScope'];
    }

    function sendSearchConfig() {
        dirty = false; // clear dirty flag
        vscode.postMessage({ type: 'searchConfig', value: searchSettings });
    }

    function processChange() {
        clearTimeout(timer);
        dirty = true;
        timer = setTimeout(() =&gt; {
            sendSearchConfig();
        }, 300);
    }

    function toggleCheckbox(p_inputId) {
        let w_checkbox = document.getElementById(p_inputId);
        let w_setTo = true;
        // @ts-expect-error
        if (w_checkbox.checked) {
            w_setTo = false;
        }
        // @ts-expect-error
        w_checkbox.checked = w_setTo;
        searchSettings[p_inputId] = w_setTo;
        if (timer) {
            clearTimeout(timer);
        }
        sendSearchConfig();
    }

    function setRadio(p_inputId) {
        // @ts-expect-error
        document.getElementById(p_inputId).checked = true;
        searchSettings['searchScope'] = parseInt(
            // @ts-expect-error
            document.querySelector('input[name="searchScope"]:checked').value
        );
        if (timer) {
            clearTimeout(timer);
        }
        sendSearchConfig();
    }

    function checkKeyDown(p_event) {
        if (!p_event) {
            p_event = window.event;
        }
        var keyCode = p_event.code || p_event.key;

        // Detect CTRL+F
        if (p_event.ctrlKey &amp;&amp; !p_event.shiftKey &amp;&amp; p_event.keyCode === 70) {
            p_event.preventDefault();
            p_event.stopPropagation();
            focusOnField('findText');
            return;
        }

        // ? NEEDED ?
        /*
        // Detect F2
        if (!p_event.ctrlKey &amp;&amp; !p_event.shiftKey &amp;&amp; p_event.keyCode === 113) {
            p_event.preventDefault();
            p_event.stopPropagation();
            vscode.postMessage({ type: 'leoFindPrevious' });
            return;
        }
        // Detect F3
        if (!p_event.ctrlKey &amp;&amp; !p_event.shiftKey &amp;&amp; p_event.keyCode === 114) {
            p_event.preventDefault();
            p_event.stopPropagation();
            vscode.postMessage({ type: 'leoFindNext' });
            return;
        }
        // Detect Ctrl + =
        if (p_event.ctrlKey &amp;&amp; !p_event.shiftKey &amp;&amp; p_event.keyCode === 187) {
            p_event.preventDefault();
            p_event.stopPropagation();
            vscode.postMessage({ type: 'replace' });
            return;
        }
        // Detect Ctrl + -
        if (p_event.ctrlKey &amp;&amp; !p_event.shiftKey &amp;&amp; p_event.keyCode === 189) {
            p_event.preventDefault();
            p_event.stopPropagation();
            vscode.postMessage({ type: 'replaceThenFind' });
            return;
        }
        */

        if (keyCode === 'Tab') {
            var actEl = document.activeElement;
            var lastEl = document.getElementById(lastTabElId);
            var firstEl = document.getElementById(firstTabElId);

            if (p_event.shiftKey) {
                // shift + tab so if first got last
                if (lastEl &amp;&amp; actEl === firstEl) {
                    p_event.preventDefault();
                    p_event.stopPropagation();
                    p_event.stopImmediatePropagation();
                    lastEl.focus();
                    return;
                }
            } else {
                // tab, so if last goto first
                if (firstEl &amp;&amp; actEl === lastEl) {
                    p_event.preventDefault();
                    p_event.stopPropagation();
                    p_event.stopImmediatePropagation();
                    firstEl.focus();
                    return;
                }
            }
        }
    }

    function focusOnField(p_id) {
        const inputField = document.querySelector('#' + p_id);
        if (inputField) {
            // @ts-expect-error
            inputField.select();
            // TODO : TEST IF NEEDED TO PREVENT FLICKER ON FIRST TRY?
            setTimeout(() =&gt; {
                // @ts-expect-error
                inputField.select();
            }, 0);
        }
    }

    function getSettings() {
        // clear dirty, clear timer,
        if (dirty) {
            dirty = false;
            clearTimeout(timer);
            sendSearchConfig(); // just trigger send settings
        }
    }

    function handleIsTagSwitch(p_wasSet) {
        let w_input = document.getElementById('navText');
        let w_showParent = document.getElementById('showParents');
        let w_navSelect = document.getElementById('searchOptions');
        if (searchSettings.isTag) {

            if (w_input) {
                // @ts-expect-error
                w_input.placeholder = "&lt;tag pattern here&gt;";
                w_input.title = "Enter a tag name to list tagged nodes in the Goto pane\nClear this field to list all tags used in this file";
            }

            // @ts-expect-error
            w_showParent.disabled = true;
            // @ts-expect-error
            w_navSelect.disabled = true;
            if (p_wasSet) {
                // if nav text is empty: show all tags
                setTimeout(() =&gt; {
                    clearTimeout(timer);
                    sendSearchConfig();
                    navTextChange();
                }, 100);
            }
        } else {
            if (w_input) {
                // @ts-expect-error
                w_input.placeholder = "&lt;nav pattern here&gt;";
                w_input.title = "Typing searches headlines interactively\nEnter freezes input and searches body text";
            }
            // @ts-expect-error
            w_showParent.disabled = false;
            // @ts-expect-error
            w_navSelect.disabled = false;
        }

    }

    // * Nav text input detection
    const w_navTextEl = document.getElementById('navText');
    if (w_navTextEl) {
        w_navTextEl.onkeypress = function (p_event) {
            if (!p_event) {
                // @ts-expect-error
                p_event = window.event;
            }
            var keyCode = p_event.code || p_event.key;
            if (keyCode === 'Enter') {
                if (searchSettings.navText.length === 0 &amp;&amp; searchSettings.isTag) {
                    setFrozen(false);
                    resetTagNav();
                } else {
                    if (searchSettings.navText.length &gt;= 3 || searchSettings.isTag) {
                        setFrozen(true);
                        if (navTextDirty) {
                            navTextDirty = false;
                            if (timer) {
                                clearTimeout(timer);
                            }
                            if (navSearchTimer) {
                                clearTimeout(navSearchTimer);
                            }
                            sendSearchConfig();
                        }
                        vscode.postMessage({ type: 'leoNavEnter' });
                    }
                    if (searchSettings.navText.length === 0) {
                        vscode.postMessage({ type: 'leoNavClear' });
                    }
                }

                return false;
            }
        };

        w_navTextEl.addEventListener('input', function (p_event) {
            // @ts-expect-error
            searchSettings.navText = this.value;
            navTextDirty = true;
            navTextChange(); // DEBOUNCE THIS! Don't process change too fast!
        });
    }

    const w_showParentsEl = document.getElementById('showParents');
    if (w_showParentsEl) {
        w_showParentsEl.addEventListener('change', function (p_event) {
            // @ts-expect-error
            searchSettings.showParents = this.checked;
            processChange();
        });
    }

    const w_isTagEl = document.getElementById('isTag');
    if (w_isTagEl) {
        w_isTagEl.addEventListener('change', function (p_event) {
            // @ts-expect-error
            let w_checked = this.checked;
            let w_wasSet = false;
            if (searchSettings.isTag !== w_checked) {
                setFrozen(false); // Switched tagging so reset freeze
                if (w_checked) {
                    w_wasSet = true;
                }
            }
            searchSettings.isTag = w_checked;
            // Set placeholder text
            processChange();
            handleIsTagSwitch(w_wasSet);
        });
    }

    // * Find &amp; Replace controls change detection
    const w_searchOptionsEl = document.getElementById('searchOptions');
    if (w_searchOptionsEl) {
        w_searchOptionsEl.addEventListener('change', function (p_event) {
            // @ts-expect-error
            searchSettings.searchOptions = Number(this.value);
            processChange();
        });

    }

    findReplaceInputIds.forEach((p_inputId) =&gt; {
        const w_inputEl = document.getElementById(p_inputId);
        if (w_inputEl) {

            w_inputEl.onkeypress = function (p_event) {
                if (!p_event) {
                    // @ts-expect-error
                    p_event = window.event;
                }
                var keyCode = p_event.code || p_event.key;
                if (keyCode === 'Enter') {
                    if (timer) {
                        clearTimeout(timer);
                        sendSearchConfig();
                    }
                    vscode.postMessage({ type: 'leoFindNext' });
                    return false;
                }
            };
            w_inputEl.addEventListener('input', function (p_event) {
                // @ts-expect-error
                searchSettings[p_inputId] = this.value;
                processChange();
            });
        }
    });

    checkboxIds.forEach((p_inputId) =&gt; {
        const w_inputEl = document.getElementById(p_inputId);
        if (w_inputEl) {

            w_inputEl.addEventListener('change', function (p_event) {
                // @ts-expect-error
                searchSettings[p_inputId] = this.checked;
                processChange();
            });
        }
    });

    radioIds.forEach((p_inputId) =&gt; {
        const w_inputEl = document.getElementById(p_inputId);
        if (w_inputEl) {

            w_inputEl.addEventListener('change', function (p_event) {
                searchSettings['searchScope'] = parseInt(
                    // @ts-expect-error
                    document.querySelector('input[name="searchScope"]:checked').value
                );
                processChange();
            });
        }
    });

    const w_findTextsEl = document.getElementById('findText');
    if (w_findTextsEl) {
        w_findTextsEl.addEventListener('click', function () {
            // @ts-expect-error
            if (w_findTextsEl.value === "&lt;find pattern here&gt;") {
                // @ts-expect-error
                w_findTextsEl.select();
            }
        });
    }

    document.onkeydown = checkKeyDown;

    document.addEventListener('focusin', (event) =&gt; {
        vscode.postMessage({ type: 'gotFocus' });
    });
    document.addEventListener('focusout', (event) =&gt; {
        vscode.postMessage({ type: 'lostFocus' });
    });

    // Handle messages sent from the extension to the webview
    window.addEventListener('message', (event) =&gt; {
        const message = event.data; // The json data that the extension sent
        switch (message.type) {
            // * Nav Tab Controls
            // Focus and select all text in 'nav' field
            case 'selectNav': {
                focusOnField('navText');
                if (message.text || message.text === "") {
                    // @ts-expect-error
                    document.getElementById("navText").value = message.text;
                    searchSettings["navText"] = message.text;
                    if (timer) {
                        clearTimeout(timer);
                    }
                    sendSearchConfig();
                }
                break;
            }
            // * Find Tab Controls
            // Focus and select all text in 'find' field
            case 'selectFind': {
                focusOnField('findText');
                break;
            }
            // Focus and select all text in 'replace' field
            case 'selectReplace': {
                focusOnField('replaceText');
                break;
            }
            case 'getSettings': {
                getSettings();
                break;
            }
            case 'setSettings': {
                setSettings(message.value);
                break;
            }
            case 'setSearchSetting': {
                setSearchSetting(message.id);
                break;
            }
        }
    });

    vscode.postMessage({ type: 'refreshSearchConfig' });
})();
</t>
<t tx="felix.20220305225942.1">/**
 * * Handles an enter press in the 'nav pattern' input
 */
public async navEnter(): Promise&lt;LeoBridgePackage&gt; {
    await this._isBusyTriggerSave(false, true);
    const w_package = await this.sendAction(
        Constants.LEOBRIDGE.NAV_SEARCH
    );
    this._leoGotoProvider.refreshTreeRoot();
    this.showGotoPane({ preserveFocus: true }); // show but dont change focus
    return w_package;
}

</t>
<t tx="felix.20220305231404.1">/**
 * * Handles a debounced text change in the nav pattern input box
 */
public async navTextChange(): Promise&lt;LeoBridgePackage&gt; {
    await this._isBusyTriggerSave(false, true);
    const w_package = await this.sendAction(
        Constants.LEOBRIDGE.NAV_HEADLINE_SEARCH
    );
    this._leoGotoProvider.refreshTreeRoot();
    this.showGotoPane({ preserveFocus: true }); // show but dont change focus
    return w_package;
}

</t>
<t tx="felix.20220307233825.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoGoto, LeoGotoNavKey, TGotoTypes } from "./types";
import * as utils from "./utils";

@language typescript
@tabwidth -4
@others


</t>
<t tx="felix.20220307235733.1">{
  "command": "leointeg.findQuick",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Focus on Nav tab"
},
{
  "command": "leointeg.goAnywhere",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Go Anywhere"
},
{
  "command": "leointeg.gotoNavPrev",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Select Previous Goto Result"
},
{
  "command": "leointeg.gotoNavNext",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Select Next Goto Result"
},
{
  "command": "leointeg.gotoNavFirst",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Select First Goto Result"
},
{
  "command": "leointeg.gotoNavLast",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Select Last Goto Result"
},
{
  "command": "leointeg.findQuickSelected",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Nav search with current selection",
  "icon": "$(leo-find-quick-selected)"
},
{
  "command": "leointeg.findQuickTimeline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "List nodes in reverse gnx order",
  "icon": "$(leo-find-quick-timeline)"
},
{
  "command": "leointeg.findQuickChanged",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "List all changed/dirty nodes",
  "icon": "$(leo-find-quick-changed)"
},
{
  "command": "leointeg.history",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "List visited nodes from history",
  "icon": "$(leo-find-quick-history)"
},
{
  "command": "leointeg.markedList",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "List all marked nodes",
  "icon": "$(leo-find-quick-marked)"
},
</t>
<t tx="felix.20220308203528.1">export interface LeoGoto {
    key: number; // id from python
    h: string;
    t: TGotoTypes;
}

</t>
<t tx="felix.20220308213523.1"></t>
<t tx="felix.20220308213538.1">/**
 * * Opens the Nav tab and focus on nav text input
 * @param p_string an optional string to be placed in the nav text input
 */
public async findQuick(p_string?: string): Promise&lt;unknown&gt; {

    let w_panelID = '';
    let w_panel: vscode.WebviewView | undefined;

    if (this._lastTreeView === this._leoTreeExView) {
        w_panelID = Constants.FIND_EXPLORER_ID;
        w_panel = this._findPanelWebviewExplorerView;
    } else {
        w_panelID = Constants.FIND_ID;
        w_panel = this._findPanelWebviewView;
    }

    await vscode.commands.executeCommand(w_panelID + '.focus');

    if (w_panel &amp;&amp; w_panel.show &amp;&amp; !w_panel.visible) {
        w_panel.show(false);
    }
    const w_message: { [key: string]: string } = { type: 'selectNav' };
    if (p_string &amp;&amp; p_string?.trim()) {
        w_message["text"] = p_string.trim();
    }
    if (w_panel) {
        return w_panel.webview.postMessage(w_message);
    }

    return Promise.resolve();

}

</t>
<t tx="felix.20220308213547.1">/**
 * * Opens the Nav tab with the selected text as the search string.
 */
public findQuickSelected(): Thenable&lt;unknown&gt; {
    if (vscode.window.activeTextEditor) {
        const editor = vscode.window.activeTextEditor;
        const selection = editor.selection;
        if (!selection.isEmpty) {
            const text = editor.document.getText(selection).replace(/\r\n/g, "\n");
            return this.findQuick(text);
        }
    }
    return this.findQuick();
}

</t>
<t tx="felix.20220308213552.1">/**
 * * Lists all nodes in reversed gnx order, newest to oldest.
 */
public async findQuickTimeline(): Promise&lt;unknown&gt; {
    await this.sendAction(Constants.LEOBRIDGE.FIND_QUICK_TIMELINE);
    this._leoGotoProvider.refreshTreeRoot();
    return this.showGotoPane();
}

</t>
<t tx="felix.20220308213557.1">
/**
 * * Lists all nodes that are changed (aka "dirty") since last save.
 */
public async findQuickChanged(): Promise&lt;unknown&gt; {
    await this.sendAction(Constants.LEOBRIDGE.FIND_QUICK_CHANGED);
    this._leoGotoProvider.refreshTreeRoot();
    return this.showGotoPane();
}

</t>
<t tx="felix.20220308213600.1">/**
 * * Lists nodes from c.nodeHistory.
 */
public async findQuickHistory(): Promise&lt;unknown&gt; {
    await this.sendAction(Constants.LEOBRIDGE.FIND_QUICK_HISTORY);
    this._leoGotoProvider.refreshTreeRoot();
    return this.showGotoPane();
}

</t>
<t tx="felix.20220308213605.1">/**
 * * List all marked nodes.
 */
public async findQuickMarked(p_preserveFocus?: boolean): Promise&lt;unknown&gt; {
    await this.sendAction(Constants.LEOBRIDGE.FIND_QUICK_MARKED);
    this._leoGotoProvider.refreshTreeRoot();
    if (p_preserveFocus &amp;&amp; (this._leoGoto.visible || this._leoGotoExplorer.visible)) {
        return Promise.resolve();
    }
    return this.showGotoPane();
}

</t>
<t tx="felix.20220308213619.1">/**
 * * Opens goto and focus in depending on passed options
 */
public showGotoPane(p_options?: { preserveFocus?: boolean }): Thenable&lt;unknown&gt; {
    let w_panel = "";
    if (this._lastTreeView === this._leoTreeExView) {
        w_panel = Constants.GOTO_EXPLORER_ID;
    } else {
        w_panel = Constants.GOTO_ID;
    }
    return vscode.commands.executeCommand(w_panel + '.focus', p_options);
}

</t>
<t tx="felix.20220309215616.1">/**
 * * Handles a click (selection) of a nav panel node: Sends 'goto' command to server.
 */
public async gotoNavEntry(p_node: LeoGotoNode): Promise&lt;unknown&gt; {

    await this._isBusyTriggerSave(false, true);
    this._leoGotoProvider.resetSelectedNode(p_node); // Inform controller of last index chosen

    if (p_node.entryType === 'tag') {
        // * For when the nav input IS CLEARED : GOTO PANE LISTS ALL TAGS!
        // The node clicked was one of the tags, pre-fill the nac search with this tag and open find pane
        let w_string: string = p_node.label as string;
        let w_panelID = '';
        let w_panel: vscode.WebviewView | undefined;
        if (this._lastTreeView === this._leoTreeExView) {
            w_panelID = Constants.FIND_EXPLORER_ID;
            w_panel = this._findPanelWebviewExplorerView;
        } else {
            w_panelID = Constants.FIND_ID;
            w_panel = this._findPanelWebviewView;
        }
        await vscode.commands.executeCommand(w_panelID + '.focus');

        if (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) {
            w_panel = this._findPanelWebviewView;
        } else if (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible) {
            w_panel = this._findPanelWebviewExplorerView;
        }

        if (w_panel &amp;&amp; w_panel.show &amp;&amp; !w_panel.visible) {
            w_panel.show(false);
        }
        const w_message: { [key: string]: string; } = { type: 'selectNav' };
        if (w_string &amp;&amp; w_string.trim()) {
            w_message["text"] = w_string.trim();
        }
        await w_panel!.webview.postMessage(w_message);
        // Do search

        setTimeout(async () =&gt; {
            await this.sendAction(Constants.LEOBRIDGE.NAV_SEARCH);
            this._leoGotoProvider.refreshTreeRoot();
            await this.showGotoPane({ preserveFocus: true }); // show but dont change focus
        }, 10);

    } else if (p_node.entryType !== 'generic' &amp;&amp; p_node.entryType !== 'parent') {
        // Other and not a tag so just locate the entry in either body or outline
        const p_navEntryResult = await this.sendAction(
            Constants.LEOBRIDGE.GOTO_NAV_ENTRY,
            { key: p_node.key }
        );

        if (!p_navEntryResult.focus) {
            return vscode.window.showInformationMessage(Constants.USER_MESSAGES.SEARCH_NOT_FOUND);
        } else {
            let w_revealTarget = Focus.Body;
            const w_focus = p_navEntryResult.focus.toLowerCase();

            if (w_focus.includes('tree') || w_focus.includes('head')) {
                // tree
                w_revealTarget = Focus.Outline;
                this.showOutlineIfClosed = true;
            } else {
                this.showBodyIfClosed = true;
            }

            this.setupRefresh(
                // ! KEEP FOCUS ON GOTO PANE !
                Focus.Goto,
                {
                    tree: true,
                    body: true,
                    scroll: w_revealTarget === Focus.Body,
                    // documents: false,
                    // buttons: false,
                    states: true,
                },
                p_navEntryResult.node
            );

            return this.launchRefresh();
        }
    }
}

</t>
<t tx="felix.20220310224330.1">/**
 * * Handle the change of visibility of either goto treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onGotoTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {
    if (p_event.visible) {
        this._leoGotoProvider.setLastGotoView(p_explorerView ? this._leoGotoExplorer : this._leoGoto);
        // this.refreshGotoPane();  // No need to refresh because no selection needs to be set
    }
}

</t>
<t tx="felix.20220313211902.1">/**
 * * Tag Node
 */
public tagNode(p_node?: ArchivedPosition): void {
    this.triggerBodySave(false)
        .then(() =&gt; {
            return vscode.window.showInputBox({
                title: Constants.USER_MESSAGES.TITLE_TAG_NODE,
                placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_TAG,
                prompt: Constants.USER_MESSAGES.PROMPT_TAG,
            });
        })
        .then((p_inputResult?: string) =&gt; {

            if (p_inputResult &amp;&amp; p_inputResult.trim()) {
                p_inputResult = p_inputResult.trim();
                // check for special chars first
                if (p_inputResult.split(/(&amp;|\||-|\^)/).length &gt; 1) {
                    vscode.window.showInformationMessage(Constants.USER_MESSAGES.TAGS_CHARACTERS_ERROR);
                    return;
                }
                let w_param: { [key: string]: any; } = {};
                if (p_node) {
                    w_param = utils.buildNodeCommand(p_node);
                }
                w_param.tag = p_inputResult;
                this.sendAction(
                    Constants.LEOBRIDGE.TAG_NODE,
                    w_param
                ).then((p_resultTag: LeoBridgePackage) =&gt; {

                    this.setupRefresh(
                        Focus.NoChange,
                        {
                            tree: true,
                            // body: false,
                            // documents: false,
                            // buttons: false,
                            states: true,
                        }
                    );
                    this.launchRefresh();
                });
            }
        });
}

</t>
<t tx="felix.20220313211907.1">/**
 * * Remove single Tag on selected node
 */
public removeTag(p_node?: ArchivedPosition): void {

    if ((p_node &amp;&amp; p_node.nodeTags) || (this.lastSelectedNode &amp;&amp; this.lastSelectedNode.nodeTags)) {
        this.triggerBodySave(false)
            .then(() =&gt; {
                return this.sendAction(
                    Constants.LEOBRIDGE.GET_UA,
                    p_node ? utils.buildNodeCommand(p_node) : undefined
                );

            })
            .then((p_package: LeoBridgePackage) =&gt; {
                if (p_package.ua &amp;&amp; p_package.ua !== null) {

                    let uaQty = Object.keys(p_package.ua).length;
                    let tagQty = 0;
                    if (uaQty) {
                        tagQty = p_package.ua.__node_tags ? p_package.ua.__node_tags.length : 0;
                    }
                    if (tagQty) {
                        return p_package.ua.__node_tags;
                    }

                } else {
                    return [];
                }
            })
            .then((p_nodeTags: string[]) =&gt; {
                if (!p_nodeTags.length) {
                    return "";
                }
                return vscode.window.showQuickPick(p_nodeTags, {
                    title: Constants.USER_MESSAGES.TITLE_REMOVE_TAG,
                    placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_TAG,
                    canPickMany: false
                    // prompt: Constants.USER_MESSAGES.PROMPT_TAG,
                });
            })
            .then((p_inputResult?: string) =&gt; {
                if (p_inputResult &amp;&amp; p_inputResult.trim()) {
                    let w_param: { [key: string]: any; } = {};
                    if (p_node) {
                        w_param = utils.buildNodeCommand(p_node);
                    }
                    w_param.tag = p_inputResult.trim();
                    this.sendAction(
                        Constants.LEOBRIDGE.REMOVE_TAG,
                        w_param
                    ).then((p_resultTag: LeoBridgePackage) =&gt; {
                        this.setupRefresh(
                            Focus.NoChange,
                            {
                                tree: true,
                                // body: false,
                                // documents: false,
                                // buttons: false,
                                states: true,
                            }
                        );
                        this.launchRefresh();
                    });
                }
            });
    } else if (this.lastSelectedNode) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.NO_TAGS_ON_NODE + this.lastSelectedNode.headline);
    } else {
        return;
    }

}

</t>
<t tx="felix.20220313221212.1">/**
 * * Remove all tags on selected node
 */
public removeTags(p_node?: ArchivedPosition): void {
    if ((p_node &amp;&amp; p_node.nodeTags) || (this.lastSelectedNode &amp;&amp; this.lastSelectedNode.nodeTags)) {
        this.triggerBodySave(false)
            .then(() =&gt; {
                this.sendAction(
                    Constants.LEOBRIDGE.REMOVE_TAGS,
                    p_node ? utils.buildNodeCommand(p_node) : undefined
                ).then((p_resultTag: LeoBridgePackage) =&gt; {
                    this.setupRefresh(
                        Focus.NoChange,
                        {
                            tree: true,
                            // body: false,
                            // documents: false,
                            // buttons: false,
                            states: true,
                        }
                    );
                    this.launchRefresh();
                });
            });
    } else if (this.lastSelectedNode) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.NO_TAGS_ON_NODE + this.lastSelectedNode.headline);
    } else {
        return;
    }
}

</t>
<t tx="felix.20220319202027.1">export type TGotoTypes = "tag" | "headline" | "body" | "parent" | "generic";

</t>
<t tx="felix.20220320172705.1">/**
 * * Build all possible strings for the goto panel
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the goto anywhere tree view
 */
export function buildGotoIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_PARENT),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_PARENT)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_NODE),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_NODE)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_BODY),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_BODY)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_TAG),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_TAG)
        }
    ];
}

</t>
<t tx="felix.20220321001559.1">## 1.0.7

- Added 'Nav-tab' and 'Tags-tab' functionality to the 'Find panel'. (Requires Leo minimal version of at least 6.6-final)
- Outline now shows distinct icons and labels to distinguish generic user-attributes from 'tags'.
- Added 'Goto Anywhere' panel, with buttons for showing lists from common node attributes searches:
  - 'Timeline' nodes by creation date
  - Changed/Dirty nodes
  - History of visited nodes
  - Marked nodes
  - Nav search with currently selected body text
- Made those same commands available through vscode command palettes and user keybindings.
- Added leoID check upon connection, and implemented a dialog to capture and set the leoID on the server, equivalent to &lt;https://leo-editor.github.io/leo-editor/running.html?highlight=leoid#running-leo-the-first-time&gt;

</t>
<t tx="felix.20220321211021.1">public static addMinibufferCommands: { label: string, detail: string }[] = [
    { "label": "find-quick", "detail": "Opens the Nav tab." },
    { "label": "find-quick-selected", "detail": "Opens the Nav tab with the selected text as the search string." },

    { "label": "focus-to-body", "detail": "Put the keyboard focus in Leo's body pane." },
    { "label": "focus-to-find", "detail": "Put the keyboard focus in Leo's find input." },
    { "label": "focus-to-log", "detail": "Reveals Leo's log pane." },
    { "label": "focus-to-nav", "detail": "Put the keyboard focus in Leo's nav search input." },
    { "label": "focus-to-tree", "detail": "Put the keyboard focus in Leo's body pane." },

    { "label": "find-quick-timeline", "detail": "Lists all nodes in reversed gnx order, newest to oldest." },
    { "label": "find-quick-changed", "detail": "Lists all nodes that are changed (aka \"dirty\") since last save." },
    { "label": "history", "detail": "Lists nodes from c.nodeHistory." },
    { "label": "marked-list", "detail": "List all marked nodes." },

    { "label": "remove-tag", "detail": "Prompt for a tag to remove on selected node" },
    { "label": "remove-all-tags", "detail": "Remove all tags on selected node" },

    { "label": "export-headlines", "detail": "Export all headlines to an external file." },

    { "label": "flatten-outline", "detail": "Export the selected outline to an external file. The outline is represented in MORE format." },

    { "label": "outline-to-cweb", "detail": "Export the selected outline to an external file. The outline is represented in CWEB format." },
    { "label": "outline-to-noweb", "detail": "Export the selected outline to an external file. The outline is represented in noweb format." },
    { "label": "remove-sentinels", "detail": "Import one or more files, removing any sentinels." },
    { "label": "weave", "detail": "Simulate a literate-programming weave operation by writing the outline to a text file." },

    { "label": "read-file-into-node", "detail": "Read a file into a single node." },
    { "label": "write-file-from-node", "detail": "If node starts with @read-file-into-node, use the full path name in the headline. Otherwise, prompt for a file name." },

];

</t>
<t tx="felix.20220327193813.1">private _leoIDMissing: boolean = false;
get leoIDMissing(): boolean {
    return this._leoIDMissing;
}
set leoIDMissing(p_value: boolean) {
    this._leoIDMissing = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEOID_MISSING, p_value);
}

</t>
<t tx="felix.20220327211552.1">/**
 * * Inputs user for ID, then sets on server. If install path is known, also asks to save.
 * @returns a promise that resolves when the id is sent to the server or input is canceled
 */
public async setLeoID(): Promise&lt;unknown&gt; {

    // showInputBox
    const w_idInputOption: vscode.InputBoxOptions = {
        title: 'Enter Leo id', // Over input
        prompt: "leoID.txt not found: " +
            "Enter an id that identifies you uniquely. \n" +
            "Leo uses this id to uniquely identify nodes.",
        validateInput: (value) =&gt; {
            if (!utils.cleanLeoID(value)) {
                return "Your id should contain only letters and numbers\n" +
                    "and must be at least 3 characters in length.";
            } else {
                return "";
            }
        },
        ignoreFocusOut: true
    };

    let w_idResult = await vscode.window.showInputBox(w_idInputOption);
    // p_idResult is string | undefined
    if (w_idResult) {
        w_idResult = utils.cleanLeoID(w_idResult);
    }
    if (w_idResult) {
        // OK: id valid!
        this.sendAction(
            Constants.LEOBRIDGE.SET_LEOID,
            { leoID: w_idResult }
        );
        this.leoStates.leoIDMissing = false; // At least set for this session


        // Ask to save to .leoID.txt in Leo's dir.
        return vscode.window.showInformationMessage(
            "Save Leo ID?",
            {
                modal: true,
                detail: "Write id '" + w_idResult + "' in " + Constants.LEO_ID_NAME + "?"
            },
            "Save ID"
        ).then(answer =&gt; {
            if (answer === "Save ID") {
                const w_leoDir = this.config.leoEditorPath;
                const w_userHome: undefined | string = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;

                const w_folders = [];
                if (w_userHome) {
                    w_folders.push([
                        path.join(w_userHome, ".leo"),
                        path.join(w_userHome, ".leo", Constants.LEO_ID_NAME)
                    ]);
                }
                w_folders.push([
                    path.join(w_leoDir, Constants.CONFIG_PATH),
                    path.join(w_leoDir, Constants.CONFIG_PATH, Constants.LEO_ID_NAME)
                ]);
                w_folders.push([
                    path.join(w_leoDir, Constants.SERVER_PATH),
                    path.join(w_leoDir, Constants.SERVER_PATH, Constants.LEO_ID_NAME)
                ]);

                let w_wroteFile = false;
                w_folders.forEach(p_dir_file =&gt; {
                    if (!w_wroteFile &amp;&amp; fs.existsSync(p_dir_file[0])) {
                        // .leo in user home exists
                        try {
                            fs.writeFileSync(p_dir_file[1], w_idResult!, { encoding: 'utf8', flag: 'w' });
                            if (fs.existsSync(p_dir_file[1])) {
                                vscode.window.showInformationMessage(Constants.LEO_ID_NAME + " created in " + p_dir_file[0]);
                                w_wroteFile = true;
                                return true;
                            }
                        } catch (p_err) {
                            console.log('Could not write ' + p_dir_file[1]);
                        }
                    }
                });
                if (w_wroteFile) {
                    return true;
                } else {
                    vscode.window.showWarningMessage("can not create " + Constants.LEO_ID_NAME);
                }

            } else {
                vscode.window.showInformationMessage("Using ID " + w_idResult + " for this Leo session only.");
            }
            return false;
        });

    } else {
        // invalid or canceled
        // Show a message with button to call this command again
        vscode.window.showWarningMessage("Leo ID not set", "Set Leo ID")
            .then(p_chosenButton =&gt; {
                if (p_chosenButton === "Set Leo ID") {
                    vscode.commands.executeCommand(Constants.COMMANDS.SET_LEOID);
                }
            });
    }
    return true;

}

</t>
<t tx="felix.20220327223745.1">/**
 * * Make sure that the given Leo ID will not corrupt a .leo file.
 * @Returns the valid id string, or empty "" string for cancellation or invalid string
 */
export function cleanLeoID(id_: string): string {
    const old_id: string = id_.toString();
    if (!id_) {
        return "";
    }
    try {
        id_ = id_.replace(/\./g, "").replace(/\,/g, "").replace(/\"/g, "").replace(/\'/g, "");
        //  Remove *all* whitespace: https://stackoverflow.com/questions/3739909
        id_ = id_.split(' ').join('');
    }
    catch (exception) {
        // g.es_exception(exception);
        id_ = '';
    }
    // Last, check if not alphanum or less than 3 in length
    if (!isAlphaNum(id_) || id_.length &lt; 3) {
        id_ = "";
    }
    return id_;
}

</t>
<t tx="felix.20220327230102.1">export function isAlphaNum(str: string): boolean {
    let code;
    let i;
    let len;

    for (i = 0, len = str.length; i &lt; len; i++) {
        code = str.charCodeAt(i);
        if (!(code &gt; 47 &amp;&amp; code &lt; 58) &amp;&amp; // numeric (0-9)
            !(code &gt; 64 &amp;&amp; code &lt; 91) &amp;&amp; // upper alpha (A-Z)
            !(code &gt; 96 &amp;&amp; code &lt; 123)) { // lower alpha (a-z)
            return false;
        }
    }
    return true;
}

</t>
<t tx="felix.20220702153409.1">## 1.0.8

- Added an 'undo panel' that shows actions history and supports right-clicking to go to any undo point.
- Added and improved icons sets for disabled icon-buttons and common actions.
- Tooltips and description do not contain the whole u.a. when listing positions.
  (Hovering the mouse triggers the retrieval of this info for a single node.)
- Initial node selection when opening Leo Documents: Fixed in leoserver 1.0.3 to come out in Leo 6.6.4.
- Zoom-in/Zoom-out vscode commands now called instead of replace next/previous (on Ctrl+/-) if no text range selected.
- Re-wrote the main tree outline view integration: Revised and refactored internal tree model.
- Disabled commands created with enablement clauses instead of extraneous commands.
- Replaced the page-up/page-down Outline keyboard shortcut commands with goto-first-sibling and goto-last-sibling
- 'new leo document' CTRL+N and 'open leo file' CTRL+O keybindings can now also be used with focus in the body pane
- Start position selected upon opening is now fixed, and not forced as the first one
- Many minibuffer-only commands are now fixed and available through the minibuffer itself, and for some, the vscode command palette.
- Removed 'close on delete' setting requirement because of the new vscode API to control individual tabs as needed.
- DB file extensions support: Load / Save-as now supports .db file extension.
- Added 'minibuffer history' as top choice of minibuffer entries.
- Fixed config settings that were not working in tandem with leoserver. (Ask for refreshing, invert node colors, etc.)
- New requirement Leo version 6.7 is now the minimal version required.
- Fixed mouse expand/collapse behavior in outline when 'leo tree browsing' is off.
- changing 'invert node dirty' color scheme now changes / refreshes after saving the setting.
- Goto Panel can now be browsed with the keyboard arrow keys. The focus will stay on the goto pane while displaying results.
- Goto panel can be cleared by pressing 'enter' in a cleared/empty nav input box (in the find panel).

</t>
<t tx="felix.20220704004247.1">private _leoCanGoBack: boolean = false;
get leoCanGoBack(): boolean {
    return this._leoCanGoBack;
}
set leoCanGoBack(p_value: boolean) {
    this._leoCanGoBack = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_BACK, p_value);
}

</t>
<t tx="felix.20220704004253.1">private _leoCanGoNext: boolean = false;
get leoCanGoNext(): boolean {
    return this._leoCanGoNext;
}
set leoCanGoNext(p_value: boolean) {
    this._leoCanGoNext = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_NEXT, p_value);
}

</t>
<t tx="felix.20220704004530.1">private _leoCanHoist: boolean = false;
get leoCanHoist(): boolean {
    return this._leoCanHoist;
}
set leoCanHoist(p_value: boolean) {
    this._leoCanHoist = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_HOIST, p_value);
}

</t>
<t tx="felix.20220705000805.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { Constants } from "./constants";
import { Icon } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20220705001810.1">// leo undo provider class
export class LeoUndosProvider implements vscode.TreeDataProvider&lt;LeoUndoNode&gt; {

    private _beadId = 0;

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoUndoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoUndoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoUndoNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(
        private _leoIntegration: LeoIntegration
    ) { }

    /**
     * * Refresh the whole outline
     */
    public refreshTreeRoot(): void {
        this._onDidChangeTreeData.fire(undefined);
    }

    public getTreeItem(element: LeoUndoNode): Thenable&lt;LeoUndoNode&gt; | LeoUndoNode {
        return element;
    }

    public getChildren(element?: LeoUndoNode): Thenable&lt;LeoUndoNode[]&gt; {
        const w_children: LeoUndoNode[] = [];

        if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

            // call action to get get list, and convert to LeoButtonNode(s) array
            return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_UNDOS).then(p_package =&gt; {
                if (p_package &amp;&amp; p_package.undos) {

                    // response = {"bead": undoer.bead, "undos": undos}
                    const beads = p_package.undos;
                    const bead = p_package.bead || 0;

                    if (beads.length) {
                        let w_foundNode: LeoUndoNode | undefined;
                        let i: number = 0;
                        let w_defaultIcon = 1;

                        beads.forEach(p_bead =&gt; {
                            let w_description: string = "";
                            let w_undoFlag: boolean = false;
                            let w_icon = w_defaultIcon;

                            if (i === bead) {
                                w_description = "Undo";
                                w_undoFlag = true;
                                w_icon = 0;
                                w_defaultIcon = 2;
                            }
                            if (i === bead + 1) {
                                w_description = "Redo";
                                w_icon = 2;
                                w_defaultIcon = 3;
                                if (!w_foundNode) {
                                    w_undoFlag = true; // Passed all nodes until 'redo', no undo found.
                                }
                            }
                            const w_node = new LeoUndoNode(
                                p_bead || "unknown",
                                w_description,
                                (this._beadId++).toString(),
                                Constants.CONTEXT_FLAGS.UNDO_BEAD,
                                i - bead, // 0 is same (no undo) +/- undo redo.
                                this._leoIntegration.undoIcons[w_icon]
                            );
                            w_children.push(w_node);
                            if (w_undoFlag) {
                                w_foundNode = w_node;
                            }
                            i++;
                        });
                        if (w_foundNode) {
                            this._leoIntegration.setUndoSelection(w_foundNode);
                        }
                    } else {
                        const w_node = new LeoUndoNode(
                            "Unchanged",
                            "",
                            (this._beadId++).toString(),
                            Constants.CONTEXT_FLAGS.NOT_UNDO_BEAD,
                            0
                        );
                        w_children.push(w_node);
                    }

                    return w_children;
                } else {
                    return [];
                }
            });
        } else {
            return Promise.resolve([]); // Defaults to an empty list of children
        }

    }

    public getParent(element: LeoUndoNode): vscode.ProviderResult&lt;LeoUndoNode&gt; {
        // Leo documents are just a list, as such, entries are always child of root, so return null
        return undefined;
    }

    public resolveTreeItem(item: LeoUndoNode, element: LeoUndoNode, token: vscode.CancellationToken): vscode.ProviderResult&lt;LeoUndoNode&gt; {
        // item.tooltip = "TODO Undo Tooltip";
        if (item.contextValue === Constants.CONTEXT_FLAGS.UNDO_BEAD) {
            item.tooltip = "Undo Bead #" + item.beadIndex;
        }
        return item;
    }
}

</t>
<t tx="felix.20220705001820.1">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoUndoNode extends vscode.TreeItem {

    constructor(
        public label: string,
        public description: string,
        public id: string,
        public contextValue: string,
        public beadIndex: number,
        public iconPath?: Icon

    ) {
        super(label);
    }

}
</t>
<t tx="felix.20220705220032.1">/**
 * * Checks the server version and pops up a message to the user if an update is possible
 */
public checkVersion(): void {
    this.sendAction(Constants.LEOBRIDGE.GET_VERSION).then((p_rv: LeoBridgePackage) =&gt; {
        let w_ok = false;
        if (p_rv &amp;&amp; p_rv.major !== undefined &amp;&amp; p_rv.minor !== undefined &amp;&amp; p_rv.patch !== undefined) {
            this.serverVersion = { major: p_rv.major, minor: p_rv.minor, patch: p_rv.patch };
            if (utils.compareVersions(this.serverVersion, Constants.MIN_SERVER_VERSION_NUMBER)) {
                w_ok = true;
            }
        }
        if (!w_ok) {
            vscode.window.showErrorMessage(
                Constants.USER_MESSAGES.MINIMUM_LEO_VERSION_STRING
            );
        }
    });
}

</t>
<t tx="felix.20220706000811.1">/**
 * * Handle the change of visibility of either undo treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onUndosTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_explorerView) { } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        if (p_explorerView) {
            this._lastLeoUndos = this._leoUndosExplorer;
            if (this._leoUndosExplorerShown) {
                this._leoUndosProvider.refreshTreeRoot(); // Already shown, will redraw but not re-select
            }
            this._leoUndosExplorerShown = true; // either way set it
        } else {
            this._lastLeoUndos = this._leoUndos;
            if (this._leoUndosShown) {
                this._leoUndosProvider.refreshTreeRoot(); // Already shown, will redraw but not re-select
            }
            this._leoUndosShown = true; // either way set it
        }
    }
}

</t>
<t tx="felix.20220706220024.1"></t>
<t tx="felix.20220706220120.1">{
  "view": "leoUndos",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoUndosExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="felix.20220706220128.1">{
  "view": "leoUndos",
  "contents": "Can't undo",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "view": "leoUndosExplorer",
  "contents": "Can't undo",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
}
</t>
<t tx="felix.20220706223903.1"></t>
<t tx="felix.20220706223907.1">/**
 * * highlights the current undo state without disturbing focus
 */
private _setUndoSelection(p_node: LeoUndoNode): void {
    if (this._lastLeoUndos &amp;&amp; this._lastLeoUndos.visible &amp;&amp; !this._undoPaneReveal) {
        this._undoPaneReveal = this._lastLeoUndos.reveal(p_node, { select: true, focus: false }).then(
            () =&gt; {
                this._undoPaneReveal = undefined;
            },
            (p_error) =&gt; {
                console.log('setUndoSelection could not reveal');
            }
        );
    }
}

</t>
<t tx="felix.20220706233403.1">/**
 * * Reverts to a particular undo bead state
 */
public async revertToUndo(p_undo: LeoUndoNode): Promise&lt;any&gt; {
    if (p_undo.contextValue !== Constants.CONTEXT_FLAGS.UNDO_BEAD) {
        return Promise.resolve();
    }
    let action = Constants.LEOBRIDGE.REDO;
    let repeat = p_undo.beadIndex;
    if (p_undo.beadIndex &lt;= 0) {
        action = Constants.LEOBRIDGE.UNDO;
        repeat = (-p_undo.beadIndex) + 1;
    }
    const w_package = await this.sendAction(
        action,
        { repeat: repeat }
    );
    this.setupRefresh(
        Focus.Outline,
        {
            tree: true,
            body: true,
            documents: true,
            states: true,
            buttons: true,
        }
    );
    this.launchRefresh();
    return w_package;

}

</t>
<t tx="felix.20220709005340.1">public static unsupportedMinibufferCommands: string[] = [
    'read-outline-only', // Seems buggy in Leo. Not present until fixed or deprecated in Leo. (removed in Leo 6.7.5)
    'restart-leo' // added to bad list for leoserver 1.0.6. (Can be removed in next leointeg version)
];

</t>
<t tx="felix.20220714002222.1">/**
 * * Opens user interface to choose chapter
 * Offers choices of chapters below the input dialog to choose from,
 * and selects the chosen - or typed - chapter
 */
public async chapterSelect(): Promise&lt;unknown&gt; {

    await this._isBusyTriggerSave(false);

    const q_chaptersList: Thenable&lt;vscode.QuickPickItem[]&gt; = this.sendAction(
        Constants.LEOBRIDGE.GET_CHAPTERS
    ).then((p_result: LeoBridgePackage) =&gt; {
        if (p_result.chapters &amp;&amp; p_result.chapters.length) {
            const chapters: vscode.QuickPickItem[] = [];

            p_result.chapters.forEach(p_chapter =&gt; {
                chapters.push({
                    label: p_chapter
                });
            });

            return chapters;
        } else {
            return [];
        }
    });

    // Add Nav tab special commands
    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.SELECT_CHAPTER_PROMPT
    };

    const p_picked = await vscode.window.showQuickPick(q_chaptersList, w_options);

    if (p_picked &amp;&amp; p_picked.label) {
        return this.sendAction(
            Constants.LEOBRIDGE.CHAPTER_SELECT,
            { name: p_picked.label }
        ).then((p_resultTag: LeoBridgePackage) =&gt; {
            this.setupRefresh(
                Focus.NoChange,
                {
                    tree: true,
                    body: true,
                    // documents: false,
                    // buttons: false,
                    states: true,
                },
                p_resultTag.node
            );
            this.launchRefresh();
        });
    }

    return Promise.resolve(undefined); // Canceled

}

</t>
<t tx="felix.20220714224733.1">/**
 * * Asks for uA name, and value, then sets is on the server
 */
public async setUa(): Promise&lt;unknown&gt; {
    let w_name = "";

    await this._isBusyTriggerSave(false);

    let w_uaName = await vscode.window.showInputBox({
        title: Constants.USER_MESSAGES.SET_UA_NAME_TITLE,
        prompt: Constants.USER_MESSAGES.SET_UA_NAME_PROMPT,
        placeHolder: Constants.USER_MESSAGES.SET_UA_NAME_PLACEHOLDER
    });
    // trim string and re-check if valid string
    if (w_uaName &amp;&amp; w_uaName.trim()) {
        w_uaName = w_uaName.trim();
        w_name = w_uaName;

        const w_uaVal = await vscode.window.showInputBox({
            title: Constants.USER_MESSAGES.SET_UA_VAL_TITLE,
            prompt: Constants.USER_MESSAGES.SET_UA_VAL_PROMPT,
            placeHolder: Constants.USER_MESSAGES.SET_UA_VAL_PLACEHOLDER
        });

        if (w_name &amp;&amp; !(typeof w_uaVal === 'undefined' || w_uaVal === null)) {
            // ok got both name and val
            return this.sendAction(
                Constants.LEOBRIDGE.SET_UA_MEMBER,
                { name: w_name, value: w_uaVal }
            ).then((p_resultTag: LeoBridgePackage) =&gt; {
                this.setupRefresh(
                    Focus.NoChange,
                    {
                        tree: true,
                        // body: false,
                        // documents: false,
                        // buttons: false,
                        // states: false,
                    }
                );
                this.launchRefresh();
            });
        }

    }

    return Promise.resolve(); // canceled

}

</t>
<t tx="felix.20220716153757.1">private _leoInChapter: boolean = false;
get leoInChapter(): boolean {
    return this._leoInChapter;
}
set leoInChapter(p_value: boolean) {
    this._leoInChapter = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_IN_CHAPTER, p_value);
}

</t>
<t tx="felix.20220716153803.1">private _leoTopHoistChapter: boolean = false;
get leoTopHoistChapter(): boolean {
    return this._leoTopHoistChapter;
}
set leoTopHoistChapter(p_value: boolean) {
    this._leoTopHoistChapter = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_TOP_HOIST_CHAPTER, p_value);
}

</t>
<t tx="felix.20220721204822.1">import * as vscode from 'vscode';
import * as utils from './utils';
import { Constants } from "./constants";
import { LeoIntegration } from './leoIntegration';
import { ArchivedPosition, Icon, LeoBridgePackage } from './types';

@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20220721204822.10">public resolveTreeItem(item: LeoApOutlineNode, element: ArchivedPosition, token: vscode.CancellationToken): vscode.ProviderResult&lt;LeoApOutlineNode&gt; {

    if (!item.description) {
        // No ua's nor node tags.
        item.tooltip = item.label.label;
        return item;
    }

    // Has description, so get uA's from server.
    return this._leoIntegration.sendAction(
        Constants.LEOBRIDGE.GET_UA,
        utils.buildNodeCommand(element)
    ).then((p_package: LeoBridgePackage) =&gt; {
        if (p_package.ua &amp;&amp; p_package.ua !== null) {

            const tagQty = (Object.keys(p_package.ua).length &amp;&amp; p_package.ua.__node_tags) ? p_package.ua.__node_tags.length : 0;

            if (tagQty) {
                // list tags instead
                item.tooltip = item.label.label + "\n\u{1F3F7} " + p_package.ua.__node_tags.join('\n\u{1F3F7} ') + "\n";
                delete p_package.ua.__node_tags;
            } else {
                item.tooltip = item.label.label + "\n";
            }

            // Recalculate
            if (Object.keys(p_package.ua).length) {
                item.tooltip += JSON.stringify(p_package.ua, undefined, 2);
            }

        } else {
            item.tooltip = item.label.label;
        }
        return item;

    });

}

</t>
<t tx="felix.20220721204822.11">export class LeoApOutlineNode extends vscode.TreeItem {

    constructor(
        public label: vscode.TreeItemLabel, // Node headline
        public collapsibleState: vscode.TreeItemCollapsibleState,
        public position: ArchivedPosition, // Pointer/reference for leo's node ArchivedPosition
        public description: string,
        public iconPath: Icon,
        public id: string,
        public contextValue: string // For contextual menu on each node (not the global 'selected node' flag!)
    ) {
        super(label, collapsibleState);
        this.command = {
            command: Constants.COMMANDS.SELECT_NODE,
            title: '',
            // using 'this' as LeoApOutlineNode instead of position, to match 'openToTheSide' parameter
            arguments: [this]
        };
    }

}
</t>
<t tx="felix.20220721204822.2">export class LeoApOutlineProvider implements vscode.TreeDataProvider&lt;ArchivedPosition&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;ArchivedPosition | undefined&gt; = new vscode.EventEmitter&lt;ArchivedPosition | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;ArchivedPosition | undefined&gt; = this._onDidChangeTreeData.event;

    public treeId: number = 0; // Starting salt for generated tree node Ids

    private _rootNode: ArchivedPosition | undefined;

    @others
}

</t>
<t tx="felix.20220721204822.3">constructor(
    private _icons: Icon[],
    private _invertDirty: boolean,
    private _leoIntegration: LeoIntegration
) {
}

</t>
<t tx="felix.20220721204822.4">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20220721204822.5">/**
 * * Builds a unique Id from gnx and stack, plus collapsed state,
 * for vscode to distinguish the collapsed state.
 */
private _buildId(p: ArchivedPosition, p_collapsed: number): string {
    // (vscode uses id for collapsible state)
    return this.treeId + utils.buildApId(p);
    // NOT NEEDED -&gt; expanded.toString(); // Added Uniqueness: VSCode's collapsible state in id
}

</t>
<t tx="felix.20220721204822.6">/**
 * * Force uniqueness of ids generated for nodes in the  next tree refresh
 */
public incTreeId(): void {
    this.treeId++;
}

</t>
<t tx="felix.20220721204822.7">public getTreeItem(element: ArchivedPosition): Thenable&lt;LeoApOutlineNode&gt; | LeoApOutlineNode {

    let w_collapse: vscode.TreeItemCollapsibleState = vscode.TreeItemCollapsibleState.None;
    if (element.hasChildren) {
        w_collapse = element.expanded ? vscode.TreeItemCollapsibleState.Expanded : vscode.TreeItemCollapsibleState.Collapsed;
    }
    let w_contextValue = Constants.CONTEXT_FLAGS.NODE_UNMARKED;
    if (element.marked) {
        w_contextValue = Constants.CONTEXT_FLAGS.NODE_MARKED;
    }
    // then append 'leoNodeAtFile' to existing if needed
    if (element.atFile) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ATFILE;
    }
    // then append 'leoNodeCloned' to existing if needed
    if (element.cloned) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_CLONED;
    }
    // and finally, check for 'root' too
    if (element._isRoot) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ROOT;
    } else {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_NOT_ROOT;
    }

    const w_icon: number =
        (+(this._invertDirty !== !!element.dirty) &lt;&lt; 3) |
        (+element.cloned &lt;&lt; 2) |
        (+element.marked &lt;&lt; 1) |
        +element.hasBody;

    let desc: string = "";
    let tagsQty = 0;
    if (element.u || element.nodeTags) {
        tagsQty = element.nodeTags ? element.nodeTags : 0;
        if (element.u) {
            desc = "\u{1F4CE} (" + element.u + ")";
        }
        if (tagsQty) {
            w_contextValue += Constants.CONTEXT_FLAGS.NODE_TAGS;
            if (desc) {
                desc = desc + " "; // add space
            }
            desc = desc + "\u{1F3F7} (" + tagsQty + ")";
        }
    }

    let w_hl: [number, number] = [0, 0];
    if (element.selected &amp;&amp; this._leoIntegration.findFocusTree) {
        if (this._leoIntegration.findHeadlinePosition &amp;&amp; utils.isApEqual(this._leoIntegration.findHeadlinePosition, element)) {
            w_hl = this._leoIntegration.findHeadlineRange;
        }
    }

    const w_leoNode = new LeoApOutlineNode(
        { label: element.headline, highlights: [w_hl] },
        w_collapse,
        element, // ArchivedPosition
        desc,
        this._icons[w_icon],
        this._buildId(element, w_collapse),
        w_contextValue
    );
    // Check if its the selected node and call signal it to the UI
    if (element.selected) {
        this._leoIntegration.gotSelectedNode(element);
    }
    // Build a LeoNode (a vscode tree node) from the ArchivedPosition
    return w_leoNode;
}

</t>
<t tx="felix.20220721204822.8">public getChildren(element?: ArchivedPosition): Thenable&lt;ArchivedPosition[]&gt; {

    if (!this._leoIntegration.leoStates.fileOpenedReady) {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
    if (element) {
        return this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.GET_CHILDREN,
            utils.buildNodeCommand(element)
        ).then((p_package: LeoBridgePackage) =&gt; {
            return p_package.children!;
        });
    } else {
        return this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.GET_CHILDREN, {}
        ).then((p_package: LeoBridgePackage) =&gt; {
            const w_nodes = p_package.children!;
            if (w_nodes &amp;&amp; w_nodes.length === 1) {
                this._rootNode = w_nodes[0];
                this._rootNode._isRoot = true;
            }
            return w_nodes;
        });
    }
}

</t>
<t tx="felix.20220721204822.9">public getParent(element: ArchivedPosition): vscode.ProviderResult&lt;ArchivedPosition&gt; {
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        // Check if hoisted and is already up to root node
        if (this._rootNode &amp;&amp; element.gnx === this._rootNode.gnx &amp;&amp; element.childIndex === this._rootNode.childIndex) {
            if (
                JSON.stringify(this._rootNode.stack) ===
                JSON.stringify(element.stack)
            ) {
                return null; // Default gives no parent
            }
        }

        return this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.GET_PARENT,
            element ? utils.buildNodeCommand(element) : {}
        ).then((p_package: LeoBridgePackage) =&gt; {
            if (p_package.node === null) {
                return null;
            } else {
                return p_package.node;
            }
        });
    } else {
        return null; // Default gives no parent
    }
}

</t>
<t tx="felix.20220721225622.1">/**
 * * Handle the selected node that was reached while converting received ap_nodes.
 * @param p_element The "selected" ArchivedPosition element reached.
 */
public gotSelectedNode(p_element: ArchivedPosition): void {

    const w_focusTree = (this._revealType.valueOf() &gt;= RevealType.RevealSelectFocus.valueOf());
    const w_last = this.lastSelectedNode;

    if (
        !w_focusTree &amp;&amp;
        this._refreshType.scroll &amp;&amp;
        w_last &amp;&amp;
        utils.isApEqual(w_last, p_element) &amp;&amp;
        this._lastTreeView &amp;&amp;
        this._lastTreeView.visible

    ) {
        void this._lastTreeView.reveal(p_element, {
            select: true,
            focus: false
        }).then(
            () =&gt; {
                //ok
            },
            () =&gt; {
                // 
                console.log('gotSelectedNode scroll mode reveal error catched');
            }
        );
        // ! MINIMAL TIMEOUT REQUIRED ! WHY ?? (works so leave)
        if (this._gotSelectedNodeBodyTimer) {
            clearTimeout(this._gotSelectedNodeBodyTimer);
        }
        this._gotSelectedNodeBodyTimer = setTimeout(() =&gt; {
            this.showBody(false, this.finalFocus.valueOf() !== Focus.Body); // SAME with scroll information specified
        }, 25);
    } else {

        if (this._revealType) {
            if (this._gotSelectedNodeRevealTimer) {
                clearTimeout(this._gotSelectedNodeRevealTimer);
            }
            this._gotSelectedNodeRevealTimer = setTimeout(() =&gt; {
                this._lastTreeView.reveal(p_element, {
                    select: true,
                    focus: w_focusTree
                }).then(() =&gt; {
                    // ok
                }, (p_reason) =&gt; {
                    // Reveal failed. Retry refreshOutline once
                    this._refreshOutline(true, RevealType.RevealSelect);
                });
                // Done, so reset reveal type 'flag'
                this._revealType = RevealType.NoReveal;
            }, 0);
        }

        // Apply node to body pane
        let w_showBodyNoFocus: boolean = this.finalFocus.valueOf() !== Focus.Body; // Will preserve focus where it is without forcing into the body pane if true
        if (this._focusInterrupt) {
            this._focusInterrupt = false;
            w_showBodyNoFocus = true;
        }
        if (!w_last || this._needLastSelectedRefresh) {
            // lastSelectedNode will be set in _tryApplyNodeToBody !
            this._needLastSelectedRefresh = false;
        }

        if (this._bodyTextDocument &amp;&amp;
            !this._bodyTextDocument.isClosed &amp;&amp; // IS OPENED
            !this._refreshType.body &amp;&amp; // NO NEED TO REFRESH BODY !
            this._locateOpenedBody(p_element.gnx) // DID LOCATE NEW GNX =&gt; ALREADY SHOWN!
        ) {
            // * Just make sure body selection is considered done.
            this.lastSelectedNode = p_element; // Set the 'lastSelectedNode' this will also set the 'marked' node context
            this._commandStack.newSelection(); // Signal that a new selected node was reached and to stop using the received selection as target for next command
            this._preventShowBody = false; // in case it was a config-changed-refresh
        } else {
            // * Actually run the normal 'APPLY NODE TO BODY' to show or switch
            this._tryApplyNodeToBody(p_element, false, w_showBodyNoFocus);
        }

        // Set context flags
        this.leoStates.setSelectedNodeFlags(p_element);
    }

}

</t>
<t tx="felix.20220724215921.1">/**
 * * Places selection on the required node with a 'timeout'. Used after refreshing the opened Leo documents view.
 * @param p_documentNode Document node instance in the Leo document view to be the 'selected' one.
 */
public setDocumentSelection(p_documentNode: LeoDocumentNode): void {
    this.leoStates.leoChanged = p_documentNode.documentEntry.changed; // also set here since slightly newer.
    this.leoStates.leoOpenedFileName = p_documentNode.documentEntry.name;
    if (this._leoDocumentsRevealTimer) {
        clearTimeout(this._leoDocumentsRevealTimer);
    }
    this._leoDocumentsRevealTimer = setTimeout(() =&gt; {
        if (!this._leoDocuments.visible &amp;&amp; !this._leoDocumentsExplorer.visible) {
            return;
        }
        let w_trigger = false;
        let w_docView: vscode.TreeView&lt;LeoDocumentNode&gt;;
        if (this._leoDocuments.visible) {
            w_docView = this._leoDocuments;
        } else {
            w_docView = this._leoDocumentsExplorer;
        }
        if (w_docView.selection.length &amp;&amp; w_docView.selection[0] === p_documentNode) {
            // console.log('already selected!');
        } else {
            w_trigger = true;
        }
        if (w_trigger &amp;&amp; !this._documentPaneReveal) {
            this._documentPaneReveal = w_docView.reveal(p_documentNode, { select: true, focus: false })
                .then(
                    (p_result) =&gt; {
                        // Shown document node
                        this._documentPaneReveal = undefined;
                    },
                    (p_reason) =&gt; {
                        console.log('shown doc error on reveal: ', p_reason);
                    }
                );
        }
    }, 150);
}

</t>
<t tx="felix.20220724224959.1">/**
 * * Setup global refresh options
 * @param p_finalFocus final focus placement
 * @param p_refreshType Refresh flags for each UI part
 * @param p_node The AP node to be refreshed if refresh type 'node' only is set
 */
public setupRefresh(p_finalFocus: Focus, p_refreshType: ReqRefresh, p_node?: ArchivedPosition, p_preserveRange?: boolean): void {
    if (p_preserveRange) {
        this.refreshPreserveRange = true; // Will be cleared after a refresh cycle.
    }
    // Set final "focus-placement" EITHER true or false
    this.finalFocus = p_finalFocus;
    // Set all properties WITHOUT clearing others.
    Object.assign(this._refreshType, p_refreshType);
    if (p_node) {
        this._refreshNode = p_node;
    } else {
        this._refreshNode = undefined;
    }
}

</t>
<t tx="felix.20220726144945.1">/**
 * * Public method exposed as 'refreshDocumentsPane' setter/getter to refresh the documents pane
 * Document Panel May be refreshed by other services (states service, ...)
 */
private _refreshDocumentsPane(): void {
    this._leoDocumentsProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20220726145019.1">/**
 * * Refreshes the undo pane
 * Goto Panel May be refreshed by other services (states service, ...)
 */
private _refreshUndoPane(): void {
    this._leoUndosProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20220726145121.1">/**
 * * Public method exposed as 'refreshButtonsPane' setter/getter to refresh the buttons pane
 * Buttons Panel May be refreshed by other services (states service, ...)
 */
private _refreshButtonsPane(): void {
    this._leoButtonsProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20220726145220.1">/**
 * * Public method exposed as 'refreshGotoPane' setter/getter to refresh the Goto pane
 * Goto Panel May be refreshed by other services (states service, ...)
 */
private _refreshGotoPane(): void {
    this._leoGotoProvider.refreshTreeRoot();
}

</t>
<t tx="felix.20220730152836.1">/**
 * * unique string from AP's gnx, childIndex, and its stack's gnx and childIndex pairs.
 */
export function buildApId(p: ArchivedPosition): string {
    return p.gnx + p.childIndex + p.stack.map(s =&gt; s.gnx + s.childIndex).join("");
}

</t>
<t tx="felix.20220804203041.1">/**
 * * Adds 'do nothing' to the frontend stack and refreshes all parts.
 * @returns Promise back from command's execution, if added on stack, undefined otherwise.
 */
public fullRefresh(): Promise&lt;LeoBridgePackage&gt; | undefined {
    const w_command: UserCommand = {
        action: Constants.LEOBRIDGE.DO_NOTHING,
        finalFocus: this.finalFocus,
        refreshType: {
            tree: true,
            body: true,
            documents: true,
            buttons: true,
            states: true,
        }
    };
    const q_result = this._commandStack.add(w_command);

    if (q_result) {
        q_result.then((p_doNothingPackage) =&gt; {
            if (p_doNothingPackage.commander) {
                p_doNothingPackage.filename = p_doNothingPackage.commander.fileName;
                this.serverOpenedFileName = p_doNothingPackage.filename;
                this.serverOpenedNode = p_doNothingPackage.node!;
            }
        });
    }

    return q_result;
}

</t>
<t tx="felix.20220804203829.1">/**
 * * Checks if gnx for body is still the latest lastReceivedNode gnx
 * TODO : MAYBE NOT REQUIRED ?
 * @param gnx node identity to check
 * @param ts timestamp of last time that this gnx was set as the body
 */
public isGnxStillValid(gnx: string, ts: number): boolean {

    if (
        this._commandStack.lastReceivedNode &amp;&amp;
        this._commandStack.lastReceivedNode.gnx !== gnx &amp;&amp;
        this._commandStack.lastReceivedNodeTS &gt; ts &amp;&amp;
        (this._commandStack.finalRefreshType.tree || this._commandStack.finalRefreshType.node)
    ) {
        // new commandStack lastReceivedNode, is different and newer and tree/node has to refresh
        return false;
    }
    // also test other sources ,and check if command also not started to go back to original gnx
    // by checking if the test above only failed for gnx being the same
    if (
        this._refreshNode &amp;&amp;
        this._refreshNode.gnx !== gnx &amp;&amp;
        this._lastRefreshNodeTS &gt; ts &amp;&amp;
        this._lastRefreshNodeTS &lt; this._lastSelectedNodeTS
    ) {
        // new _refreshNode is different and newer
        return false;
    }
    if (
        this.lastSelectedNode &amp;&amp;
        this.lastSelectedNode.gnx !== gnx &amp;&amp;
        this._lastSelectedNodeTS &gt; ts &amp;&amp;
        this._lastRefreshNodeTS &lt; this._lastSelectedNodeTS &amp;&amp;
        this._commandStack.lastReceivedNodeTS &lt; this._lastSelectedNodeTS
    ) {
        // new lastSelectedNode is different and newer
        return false;
    }
    return true;
}

</t>
<t tx="felix.20220805212936.1">/**
 * * Checks if gnx is the same but at a later timestamp
 * TODO : MAYBE NOT REQUIRED ?
 * @param gnx node identity to check
 * @param ts timestamp limit
 */
public isGnxReselected(gnx: string, ts: number): boolean {

    if (
        this._commandStack.lastReceivedNode &amp;&amp;
        this._commandStack.lastReceivedNode.gnx === gnx &amp;&amp;
        this._commandStack.lastReceivedNodeTS &gt; ts &amp;&amp;
        (this._commandStack.finalRefreshType.tree || this._commandStack.finalRefreshType.node)
    ) {
        // new commandStack lastReceivedNode, is different and newer and tree/node has to refresh
        return true;
    }
    // also test other sources
    if (
        this._refreshNode &amp;&amp;
        this._refreshNode.gnx === gnx &amp;&amp;
        this._lastRefreshNodeTS &gt; ts
    ) {
        // new _refreshNode is different and newer
        return true;
    }
    if (
        this.lastSelectedNode &amp;&amp;
        this.lastSelectedNode.gnx !== gnx &amp;&amp;
        this._lastSelectedNodeTS &gt; ts
    ) {
        // new lastSelectedNode is different and newer
        return true;
    }
    return false;
}

</t>
<t tx="felix.20220806151009.1">/**
 * * Previous / Next Node Buttons
 * @param p_next Flag to mean 'next' instead of default 'previous'
 * @returns the promise from the command sent to the leo bridge
 */
public async prevNextNode(p_next: boolean, p_fromOutline?: boolean): Promise&lt;any&gt; {

    await this._isBusyTriggerSave(false, true);

    let w_command: string;
    if (p_next) {
        w_command = Constants.LEOBRIDGE.GOTO_NEXT_HISTORY;
    } else {
        w_command = Constants.LEOBRIDGE.GOTO_PREV_HISTORY;
    }
    return this.nodeCommand({
        action: w_command,
        node: undefined,
        refreshType: { tree: true, states: true, body: true },
        finalFocus: p_fromOutline ? Focus.Outline : Focus.Body
    });
}

</t>
<t tx="felix.20220806151117.1">/**
 * * Capture instance for further calls on find panel webview
 * @param p_panel The panel (usually that got the latest onDidReceiveMessage)
 */
public setFindPanel(p_panel: vscode.WebviewView): void {
    if (p_panel.viewType === Constants.FIND_EXPLORER_ID) {
        // Explorer find panel
        this._lastFindView = this._findPanelWebviewExplorerView;
        this._findPanelWebviewExplorerView = p_panel;
        this._context.subscriptions.push(
            p_panel.onDidChangeVisibility(() =&gt;
                this._onFindViewVisibilityChanged(true)
            ));
    } else {
        // Leo Pane find panel
        this._findPanelWebviewView = p_panel;
        this._lastFindView = this._findPanelWebviewView;
        this._context.subscriptions.push(
            p_panel.onDidChangeVisibility(() =&gt;
                this._onFindViewVisibilityChanged(false)
            ));
    }
    this.checkForceFindFocus(true);
}

</t>
<t tx="felix.20220808231327.1">{
  "command": "leointeg.importAnyFile",
  "title": "Import File",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "icon": "$(leo-import)"
},
{
  "command": "leointeg.readFileIntoNode",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Read File Into Node..."
},
{
  "command": "leointeg.exportHeadlines",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Export Outline..."
},
{
  "command": "leointeg.flattenOutline",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Flatten Selected Outline..."
},
{
  "command": "leointeg.outlineToCweb",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Outline to CWEB..."
},
{
  "command": "leointeg.outlineToNoweb",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Outline to Noweb..."
},
{
  "command": "leointeg.removeSentinels",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Remove Sentinels..."
},
{
  "command": "leointeg.weave",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Weave..."
},
{
  "command": "leointeg.writeFileFromNode",
  "category": "Leo",
  "enablement": "leoTreeOpened",
  "title": "Write File From Node..."
},
</t>
<t tx="felix.20220808233838.1"></t>
<t tx="felix.20220808233838.2">/**
 * * Export Outline
 * Export all headlines to an external file.
 */
public exportHeadlines(p_exportFileUri?: vscode.Uri): Thenable&lt;unknown&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
                return this._leoFilesBrowser.getExportFileUrl(
                    "Export Headlines",
                    {
                        'Text files': ['txt'],
                        'All files': ['*'],
                    },
                );
            } else {
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            }
        })
        .then((p_chosenLeoFile) =&gt; {
            if (p_chosenLeoFile.trim()) {

                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.EXPORT_HEADLINES,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    finalFocus: Focus.NoChange, // use last
                    name: p_chosenLeoFile,
                });
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject('Export Headlines not added on command stack');
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20220808233838.4">/**
 * * Flatten Selected Outline
 * Export the selected outline to an external file.
 * The outline is represented in MORE format.
 */
public flattenOutline(): Thenable&lt;unknown&gt; {

    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
                return this._leoFilesBrowser.getExportFileUrl(
                    "Flatten Selected Outline",
                    {
                        'Text files': ['txt'],
                        'All files': ['*'],
                    },
                );
            } else {
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            }
        })
        .then((p_chosenLeoFile) =&gt; {
            if (p_chosenLeoFile.trim()) {

                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.FLATTEN_OUTLINE,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    finalFocus: Focus.NoChange, // use last
                    name: p_chosenLeoFile,
                });
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject('Flatten Selected Outline not added on command stack');
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20220808233838.5">/**
 * * Outline To CWEB
 */
public outlineToCweb(): Thenable&lt;unknown&gt; {

    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
                return this._leoFilesBrowser.getExportFileUrl(
                    "Outline To CWEB",
                    {
                        'CWEB files': ['w'],
                        'Text files': ['txt'],
                        'All files': ['*'],
                    },
                );
            } else {
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            }
        })
        .then((p_chosenLeoFile) =&gt; {
            if (p_chosenLeoFile.trim()) {

                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.OUTLINE_TO_CWEB,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    finalFocus: Focus.NoChange, // use last
                    name: p_chosenLeoFile,
                });
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject('Outline To CWEB not added on command stack');
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20220808233838.6">/**
 * * Outline To Noweb
 */
public outlineToNoweb(): Thenable&lt;unknown&gt; {

    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
                return this._leoFilesBrowser.getExportFileUrl(
                    "Outline To Noweb",
                    {
                        'Noweb files': ['nw'],
                        'Text files': ['txt'],
                        'All files': ['*'],
                    },
                );
            } else {
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            }
        })
        .then((p_chosenLeoFile) =&gt; {
            if (p_chosenLeoFile.trim()) {

                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.OUTLINE_TO_NOWEB,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    finalFocus: Focus.NoChange, // use last
                    name: p_chosenLeoFile,
                });
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject('Outline To Noweb not added on command stack');
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20220808233838.7">/**
 * * Remove Sentinels
 */
public removeSentinels(p_leoFileUri?: vscode.Uri): Thenable&lt;unknown&gt; {
    // Convert one or more files, replacing the original files while removing any sentinels they contain.

    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            let q_importFiles: Promise&lt;LeoBridgePackage | undefined&gt;; // Promise for opening a file
            if (p_leoFileUri &amp;&amp; p_leoFileUri.fsPath.trim()) {
                const w_fixedFilePath: string = p_leoFileUri.fsPath.replace(/\\/g, '/');
                q_importFiles = this.sendAction(
                    Constants.LEOBRIDGE.REMOVE_SENTINELS,
                    { names: [w_fixedFilePath] }
                );
            } else {
                q_importFiles = this._leoFilesBrowser.getImportFileUrls(
                    {
                        'Python files': ['py'],
                        'All files': ['*'],
                        'C/C++ files': ['c', 'cpp', 'h', 'hpp'],
                        'Java files': ['java'],
                        'Lua files': ['lua'],
                        'Pascal files': ['pas'],
                    },
                    false,
                    "Remove Sentinels"
                ).then(
                    (p_chosenLeoFiles) =&gt; {
                        if (p_chosenLeoFiles.length) {
                            return this.sendAction(
                                Constants.LEOBRIDGE.REMOVE_SENTINELS,
                                { names: p_chosenLeoFiles }
                            );
                        } else {
                            return Promise.resolve(undefined);
                        }
                    },
                    (p_errorGetFile) =&gt; {
                        return Promise.reject(p_errorGetFile);
                    }
                );
            }
            return q_importFiles;
        })
        .then(
            (p_importFileResult: LeoBridgePackage | undefined) =&gt; {
                if (p_importFileResult) {
                    this.setupRefresh(
                        Focus.NoChange,
                        {
                            tree: true,
                            body: true,
                            goto: true,
                            states: true,
                            documents: true,
                            buttons: true
                        }
                    );
                    return this.launchRefresh();
                } else {
                    return Promise.resolve(undefined);
                }
            },
            (p_errorImport) =&gt; {
                console.log('Rejection for Read a file into a single node file');
                return Promise.reject(p_errorImport);
            }
        );

}

</t>
<t tx="felix.20220808233838.8">/**
 * * Weave
 * Simulate a literate-programming weave operation by writing the outline to a text file.
 */
public weave(): Thenable&lt;unknown&gt; {

    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
                return this._leoFilesBrowser.getExportFileUrl(
                    "Weave",
                    {
                        'Text files': ['txt'],
                        'All files': ['*'],
                    },
                );
            } else {
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            }
        })
        .then((p_chosenLeoFile) =&gt; {
            if (p_chosenLeoFile.trim()) {

                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.WEAVE,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    finalFocus: Focus.NoChange, // use last
                    name: p_chosenLeoFile,
                });
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject('Weave not added on command stack');
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20220808233838.9">/**
 * * Write file from node
 */
public writeFileFromNode(): Thenable&lt;unknown&gt; {

    // * If node starts with @read-file-into-node, use the full path name in the headline.
    // * Otherwise, prompt for a file name.

    if (!this.leoStates.fileOpenedReady || !this.lastSelectedNode) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
        return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    }

    const h = this.lastSelectedNode.headline.trimEnd();
    const tag = '@read-file-into-node';

    let fileName = '';
    if (h.startsWith(tag)) {
        fileName = h.substring(tag.length).trim();
    }

    let q_fileName: Thenable&lt;string&gt;;
    if (fileName) {
        q_fileName = Promise.resolve(fileName);
    } else {
        q_fileName = this._isBusyTriggerSave(true, true)
            .then((p_saveResult) =&gt; {
                if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
                    return this._leoFilesBrowser.getExportFileUrl(
                        "Write file from node",
                        {
                            'All files': ['*'],
                            'Python files': ['py'],
                            'Leo files': ['leo'],
                        },
                    );
                } else {
                    vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                    return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                }
            });
    }

    return q_fileName.then((p_chosenLeoFile) =&gt; {
        if (p_chosenLeoFile.trim()) {

            const q_commandResult = this.nodeCommand({
                action: Constants.LEOBRIDGE.WRITE_FILE_FROM_NODE,
                node: undefined,
                refreshType: { tree: true, states: true, documents: true },
                finalFocus: Focus.NoChange, // use last
                name: p_chosenLeoFile,
            });
            this.leoStates.leoOpenedFileName = p_chosenLeoFile.trim();
            // this._leoStatusBar.update(true, 0, true); // removed until proper API for knowing focus placement
            this._addRecentAndLastFile(p_chosenLeoFile.trim());
            if (q_commandResult) {
                return q_commandResult;
            } else {
                return Promise.reject('Write File From Node not added on command stack');
            }
        } else {
            // Canceled
            return Promise.resolve(undefined);
        }
    });
}

</t>
<t tx="felix.20220809232939.1">/**
 * * Read file from node
 */
public readFileIntoNode(p_leoFileUri?: vscode.Uri): Thenable&lt;unknown&gt; {

    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            let q_importFile: Promise&lt;LeoBridgePackage | undefined&gt;; // Promise for opening a file
            if (p_leoFileUri &amp;&amp; p_leoFileUri.fsPath.trim()) {
                const w_fixedFilePath: string = p_leoFileUri.fsPath.replace(/\\/g, '/');
                q_importFile = this.sendAction(
                    Constants.LEOBRIDGE.READ_FILE_INTO_NODE,
                    { name: w_fixedFilePath }
                );
            } else {
                q_importFile = this._leoFilesBrowser.getImportFileUrls(
                    {
                        'All files': ['*'],
                        'Python files': ['py'],
                        'Leo files': ['leo'],
                    },
                    true,
                    "Read File Into Node"
                ).then(
                    (p_chosenLeoFiles) =&gt; {
                        if (p_chosenLeoFiles.length) {
                            return this.sendAction(
                                Constants.LEOBRIDGE.READ_FILE_INTO_NODE,
                                { name: p_chosenLeoFiles[0] }
                            );
                        } else {
                            return Promise.resolve(undefined);
                        }
                    },
                    (p_errorGetFile) =&gt; {
                        return Promise.reject(p_errorGetFile);
                    }
                );
            }
            return q_importFile;
        })
        .then(
            (p_importFileResult: LeoBridgePackage | undefined) =&gt; {
                if (p_importFileResult) {
                    this.setupRefresh(
                        Focus.NoChange,
                        {
                            tree: true,
                            body: true,
                            goto: true,
                            states: true,
                            documents: true,
                            buttons: true
                        }
                    );
                    return this.launchRefresh();
                } else {
                    return Promise.resolve(undefined);
                }
            },
            (p_errorImport) =&gt; {
                console.log('Rejection for Read a file into a single node file');
                return Promise.reject(p_errorImport);
            }
        );

}

</t>
<t tx="felix.20220810231122.1">/**
 * * getExportFileUrl
 */
public getExportFileUrl(p_title: string, p_fileTypes: { [name: string]: string[]; }): Promise&lt;string&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve("");
    }
    this._fileBrowserActive = true;
    return new Promise((p_resolve, p_reject) =&gt; {
        // Choose file
        vscode.window.showSaveDialog({
            saveLabel: "Export File",
            defaultUri: this._getBestOpenFolderUri(),
            filters: p_fileTypes,
            title: p_title
        })
            .then(p_chosenLeoFile =&gt; {
                this._fileBrowserActive = false;
                if (p_chosenLeoFile) {
                    // single string
                    p_resolve(utils.fixSlashesDriveLetter(p_chosenLeoFile.fsPath));
                } else {
                    p_resolve(""); // not rejection - resolve empty string
                }
            });

    });
}

</t>
<t tx="felix.20220815210705.1">/**
 * * Place the XML or JSON Leo outline tree on the clipboard for the given node.
 */
public async copyNodeAsJson(): Promise&lt;LeoBridgePackage | undefined&gt; {

    await this._isBusyTriggerSave(false, true);

    const w_commandResult = this.nodeCommand({
        action: Constants.LEOBRIDGE.COPY_PNODE_AS_JSON,
        node: undefined,
        refreshType: {},
        finalFocus: Focus.NoChange,
    });
    return w_commandResult.then(p_package =&gt; {
        if (p_package &amp;&amp; p_package.string) {
            this.replaceClipboardWith(p_package.string);
        } else {
        }
        return p_package;
    });

}

</t>
<t tx="felix.20220815210715.1">/**
 * * Place the XML or JSON Leo outline tree on the clipboard for the given node.
 */
public async copyGnx(): Promise&lt;unknown&gt; {

    await this._isBusyTriggerSave(false, true);

    const w_commandResult = this.nodeCommand({
        action: Constants.LEOBRIDGE.DO_NOTHING,
        node: undefined,
        refreshType: {},
        finalFocus: Focus.NoChange,
    });

    return w_commandResult.then(p_package =&gt; {
        if (p_package &amp;&amp; p_package.node) {
            this.replaceClipboardWith(p_package.node.gnx);
        }
        return p_package;
    });
}

</t>
<t tx="felix.20220815221536.1">/**
 * * Creates, while preserving the top gnx of a section of tree outline, from the clipboard content.
 */
public async pasteAsTemplate(
    p_node?: ArchivedPosition,
    p_fromOutline?: boolean
): Promise&lt;LeoBridgePackage | undefined&gt; {

    await this._isBusyTriggerSave(false, true);

    const text = await this.asyncGetTextFromClipboard();

    const w_commandResult = this.nodeCommand({
        action: Constants.LEOBRIDGE.PASTE_AS_TEMPLATE,
        node: p_node,
        refreshType: { tree: true, body: true, states: true },
        name: text,
        finalFocus: p_fromOutline ? Focus.Outline : Focus.Body,
    });
    return w_commandResult;
}

</t>
<t tx="felix.20220824014747.1">/**
 * * Checks timestamp only, if is still the latest lastReceivedNode
  * @param ts timestamp of last time
 */
public isTsStillValid(ts: number): boolean {

    if (
        this._commandStack.lastReceivedNode &amp;&amp;
        this._commandStack.lastReceivedNodeTS &gt; ts &amp;&amp;
        (this._commandStack.finalRefreshType.tree || this._commandStack.finalRefreshType.node)
    ) {
        // new commandStack lastReceivedNode, is different and newer and tree/node has to refresh
        return false;
    }
    // also test other sources ,and check if command also not started to go back to original gnx
    // by checking if the test above only failed for gnx being the same
    if (
        this._refreshNode &amp;&amp;
        this._lastRefreshNodeTS &gt; ts &amp;&amp;
        this._lastRefreshNodeTS &lt; this._lastSelectedNodeTS
    ) {
        // new _refreshNode is different and newer
        return false;
    }
    if (
        this.lastSelectedNode &amp;&amp;
        this._lastSelectedNodeTS &gt; ts &amp;&amp;
        this._lastRefreshNodeTS &lt; this._lastSelectedNodeTS &amp;&amp;
        this._commandStack.lastReceivedNodeTS &lt; this._lastSelectedNodeTS
    ) {
        // new lastSelectedNode is different and newer
        return false;
    }
    return true;
}

</t>
<t tx="felix.20220824144905.1">/**
 * * Opens quickPick of minibuffer's commands history
 * @returns Promise that resolves when the chosen command is placed on the front-end command stack
 */
private async _showMinibufferHistory(p_choices: vscode.QuickPickItem[], p_history: string[]): Promise&lt;LeoBridgePackage | undefined&gt; {

    if (!p_history || !p_history.length) {
        return Promise.resolve(undefined);
    }

    // Build from list of strings (labels).
    let w_commandList: vscode.QuickPickItem[] = [];
    for (const w_command of p_history) {
        let w_found = false;
        for (const w_pick of p_choices) {
            if (w_pick.label === w_command) {
                w_commandList.push(w_pick);
                w_found = true;
                break;
            }
        }
        if (!w_found) {
            w_commandList.push({
                label: w_command,
                description: Constants.USER_MESSAGES.MINIBUFFER_BAD_COMMAND,
                detail: `No command function for ${w_command}`
            });
        }
    }
    if (!w_commandList.length) {
        return;
    }

    // Add Nav tab special commands
    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.MINIBUFFER_PROMPT,
        matchOnDetail: true,
    };
    const w_picked = await vscode.window.showQuickPick(w_commandList.reverse(), w_options);
    return this._doMinibufferCommand(w_picked);
}

</t>
<t tx="felix.20220825004838.1">/**
 * * Perform chosen minibuffer command
 */
private async _doMinibufferCommand(p_picked?: vscode.QuickPickItem): Promise&lt;LeoBridgePackage | undefined&gt; {
    // First, add to minibuffer history for that commander.
    if (p_picked &amp;&amp; utils.compareVersions(this.serverVersion, { major: 1, minor: 0, patch: 8 })) {
        await this.sendAction("!add_history", { command: p_picked.label });
    }
    // Second, check for overridden command: Exit by doing the overridden command.
    if (p_picked &amp;&amp;
        p_picked.label &amp;&amp;
        Constants.MINIBUFFER_OVERRIDDEN_COMMANDS[p_picked.label]) {
        return vscode.commands.executeCommand(
            Constants.MINIBUFFER_OVERRIDDEN_COMMANDS[p_picked.label]
        );
    }
    // Ok, it was really a minibuffer command
    if (p_picked &amp;&amp; p_picked.label) {
        const w_commandResult = this.nodeCommand({
            action: "-" + p_picked.label,
            node: undefined,
            refreshType: {
                tree: true,
                body: true,
                documents: true,
                buttons: true,
                states: true,
            },
            finalFocus: Focus.NoChange, // TODO: Fetch focus location from Leo?
        });
        return w_commandResult;
    }
}

</t>
<t tx="felix.20220825224916.1">/**
 * Check if search input should be forced-focused again
 */
public checkForceFindFocus(p_fromInit: boolean): void {
    if (this._findNeedsFocus) {
        setTimeout(() =&gt; {
            let w_panel: vscode.WebviewView | undefined;
            if (this._findPanelWebviewView &amp;&amp; this._findPanelWebviewView.visible) {
                w_panel = this._findPanelWebviewView;
            } else if (this._findPanelWebviewExplorerView &amp;&amp; this._findPanelWebviewExplorerView.visible) {
                w_panel = this._findPanelWebviewExplorerView;
            }
            if (w_panel) {
                this._findNeedsFocus = false;
                w_panel.webview.postMessage({ type: 'selectFind' });
                return;
            }
        }, 60);

    }
}

</t>
<t tx="felix.20220826004334.1">/**
 * * Handle the change of visibility of either find panel
 * @param p_event The visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onFindViewVisibilityChanged(p_explorerView: boolean): void {
    if (p_explorerView) {
        if (this._findPanelWebviewExplorerView?.visible) {
            this._lastFindView = this._findPanelWebviewExplorerView;
            this.checkForceFindFocus(false);
        }
    } else {
        if (this._findPanelWebviewView?.visible) {
            this._lastFindView = this._findPanelWebviewView;
            this.checkForceFindFocus(false);
        }
    }
}

</t>
<t tx="felix.20220826200039.1">/**
 * * Checks if an archived position is equivalent to another
 * @param p_a
 * @param p_b
 * @returns True if equivalent, false otherwise
 */
export function isApEqual(p_a: ArchivedPosition, p_b: ArchivedPosition): boolean {

    if (p_a === p_b) {
        return true; // well duh...
    }

    if (p_a.gnx !== p_b.gnx) {
        return false; // Same v node?
    }
    if (p_a.childIndex !== p_b.childIndex) {
        return false; // At same child-rank to it's parent?
    }
    if (JSON.stringify(p_a.stack) !== JSON.stringify(p_b.stack)) {
        return false; // and same parent positions chain up to the root?
    }
    // Well up to here it should be the same position!
    return true;
}

</t>
<t tx="felix.20220901003642.1">/**
 * * Location of focus to be set when current/last command is resolved
 */
export const enum Focus {
    NoChange = 0, // Stays on goto pane, or other current panel.
    Body, // Forces body to appear, refresh leaves focus on body.
    Outline, // Forces outline to appear, refresh leaves focus on Outline.
    Goto
}

</t>
<t tx="felix.20220903004804.1">/**
 * * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
export class LeoGotoProvider implements vscode.TreeDataProvider&lt;LeoGotoNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoGotoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoGotoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoGotoNode | undefined&gt; = this._onDidChangeTreeData.event;

    private _lastGotoView: vscode.TreeView&lt;LeoGotoNode&gt; | undefined;

    private _nodeList: LeoGotoNode[] = []; // Node list kept here.
    private _viewSwitch: boolean = false;

    private _selectedNodeIndex: number = 0;

    constructor(private _leoIntegration: LeoIntegration) { }

    public setLastGotoView(p_view: vscode.TreeView&lt;LeoGotoNode&gt;): void {
        this._lastGotoView = p_view;
        if (this._nodeList &amp;&amp; this._nodeList.length) {
            this._viewSwitch = true;
            this._onDidChangeTreeData.fire(undefined);
        }
    }

    public getLastGotoView(): vscode.TreeView&lt;LeoGotoNode&gt; | undefined {
        return this._lastGotoView;
    }

    public resetSelectedNode(p_node?: LeoGotoNode): void {
        this._selectedNodeIndex = 0;
        if (p_node) {
            const w_found = this._nodeList.indexOf(p_node);
            if (w_found &gt;= 0) {
                this._selectedNodeIndex = w_found;
                return;
            }
        }
    }

    public navigateNavEntry(p_nav: LeoGotoNavKey): void {
        if (!this._nodeList.length) {
            return;
        }
        switch (p_nav.valueOf()) {
            case LeoGotoNavKey.first:
                this._selectedNodeIndex = 0;
                break;

            case LeoGotoNavKey.last:
                this._selectedNodeIndex = this._nodeList.length - 1;
                break;

            case LeoGotoNavKey.next:
                if (this._selectedNodeIndex &lt; this._nodeList.length - 1) {
                    this._selectedNodeIndex += 1;
                }
                break;

            case LeoGotoNavKey.prev:
                if (this._selectedNodeIndex &gt; 0) {
                    this._selectedNodeIndex -= 1;
                }
                break;

        }
        const node = this._nodeList[this._selectedNodeIndex];
        this._lastGotoView?.reveal(node, { select: true, focus: true });
        this._leoIntegration.gotoNavEntry(node);
    }

    /**
     * * Refresh the whole outline
     */
    public refreshTreeRoot(): void {
        this._nodeList = [];
        this._selectedNodeIndex = 0;
        this._onDidChangeTreeData.fire(undefined);
    }

    public getTreeItem(element: LeoGotoNode): LeoGotoNode {
        return element;
    }

    public getChildren(element?: LeoGotoNode): Thenable&lt;LeoGotoNode[]&gt; | LeoGotoNode[] {

        // if called with element, or not ready, give back empty array as there won't be any children
        if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

            // WAS JUST A VIEW SWITCH:
            if (this._viewSwitch) {
                this._viewSwitch = false;
                setTimeout(() =&gt; {
                    if (this._nodeList.length &amp;&amp; (this._selectedNodeIndex + 1) &lt;= this._nodeList.length) {
                        void this._lastGotoView?.reveal(this._nodeList[this._selectedNodeIndex], {
                            select: true,
                            focus: false
                        }).then(() =&gt; { }, () =&gt; {
                            console.log('Reveal failed for goto panel switching detected.');
                        });
                    }
                }, 0);
                return this._nodeList; // Make sure the nodes are valid (give back)
            }

            // call action to get get list, and convert to LeoButtonNode(s) array
            return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_GOTO_PANEL).then(p_package =&gt; {
                this._nodeList = [];
                if (p_package &amp;&amp; p_package.navList) {

                    const w_navList: LeoGoto[] = p_package.navList;
                    if (w_navList &amp;&amp; w_navList.length) {
                        w_navList.forEach((p_goto: LeoGoto) =&gt; {
                            const w_newNode = new LeoGotoNode(this._leoIntegration, p_goto, p_package.navOptions!);
                            this._nodeList.push(w_newNode);
                        });
                    }
                    return this._nodeList;
                } else {
                    return [];
                }
            });


        } else {
            return []; // Defaults to an empty list of children
        }
    }

    public getParent(element: LeoGotoNode): ProviderResult&lt;LeoGotoNode&gt; | null {
        // Leo documents are just a list, as such, entries are always child of root, so return null
        return null;
    }

}
</t>
<t tx="felix.20220903004914.1">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoGotoNode extends vscode.TreeItem {

    // Context string is checked in package.json with 'when' clauses
    public entryType: TGotoTypes;
    private _id: string;
    private _description: string | boolean;
    private _headline: string;
    private _iconIndex: number; // default to tag
    private _leoIntegration: LeoIntegration;
    public key: number; // id from python

    constructor(
        p_leoIntegration: LeoIntegration,
        p_gotoEntry: LeoGoto,
        p_navOptions: { isTag: boolean, showParents: boolean },

    ) {
        let w_spacing = "";
        if (p_navOptions.showParents &amp;&amp; !p_navOptions.isTag) {
            w_spacing = "    ";
        }
        let w_label = "";
        if (["tag", "headline"].includes(p_gotoEntry.t)) {
            w_label = w_spacing + p_gotoEntry.h;
        }
        super(w_label);

        // Setup this instance
        this._leoIntegration = p_leoIntegration;
        this._id = utils.getUniqueId();
        this.entryType = p_gotoEntry.t;
        this.key = p_gotoEntry.key;
        this._headline = p_gotoEntry.h.trim();

        this._description = false;
        if (this.entryType === 'body') {
            this._iconIndex = 2;
            if (p_navOptions.showParents) {
                this._description = "    " + this._headline;
            } else {
                this._description = "  " + this._headline;
            }
        } else if (this.entryType === 'parent') {
            this._iconIndex = 0;
            this._description = this._headline.trim();
        } else if (this.entryType === 'generic') {
            this._iconIndex = 4;
            this._description = this._headline;
        } else if (this.entryType === 'headline') {
            this._iconIndex = 1;
        } else {
            this._iconIndex = 3; // tag
        }

        this.command = {
            command: Constants.COMMANDS.GOTO_NAV_ENTRY,
            title: '',
            arguments: [this]
        };

    }

    // @ts-ignore
    public get tooltip(): string {
        if (this.entryType !== "generic") {
            return this.entryType.charAt(0).toUpperCase() + this.entryType.slice(1);
        }
        return this._headline;
    }

    // @ts-ignore
    public get description(): string | boolean {
        return this._description;
    }

    // @ts-ignore
    public get iconPath(): Icon | vscode.ThemeIcon | string {
        if (this._iconIndex &lt; 4) {
            return this._leoIntegration.gotoIcons[this._iconIndex];
        }
        // else return undefined for generic text without icon
        return undefined;
    }

    // @ts-ignore
    public get id(): string {
        // Add prefix and suffix salt to numeric index to prevent accidental duplicates
        // Should be unique when refreshed
        return "g" + this._id + "o";
    }

}
</t>
<t tx="felix.20220903192048.1">/**
 * * Goto the next, previous, first or last nav entry via arrow keys in
 */
public navigateNavEntry(p_nav: LeoGotoNavKey): void {
    this._leoGotoProvider.navigateNavEntry(p_nav);
}

</t>
<t tx="felix.20220903201408.1">export const enum LeoGotoNavKey {
    prev = 0,
    next,
    first,
    last
}

</t>
<t tx="felix.20220904222510.1">/**
 * * Builds and returns object with 'node' and 'name' members
 * @param p_node Targeted tree node
 * @param p_command from which to extract possible name and 'keep selection' flag
 * @returns object suitable for being a parameter of a leoBridge action
 */
export function buildNodeCommand(p_node: ArchivedPosition, p_command?: UserCommand): { [key: string]: any } {
    const w_result: any = {
        ap: {
            childIndex: p_node.childIndex,
            gnx: p_node.gnx,
            stack: p_node.stack,
        }
    };
    if (p_command &amp;&amp; p_command.name) {
        w_result.name = p_command.name;
    }
    if (p_command &amp;&amp; p_command.keepSelection) {
        w_result.keep = true;
    }
    return w_result;
}

</t>
<t tx="felix.20220905181421.1">/**
 * * Checks for all tabs if any are 'leoBody' scheme
 * @returns total found
 */
private _isBodyVisible(): number {
    let w_total = 0;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME
            ) {
                w_total++;
            }
        });
    });
    return w_total;
}

</t>
<t tx="felix.20220905194121.1">/**
 * * Checks if outline is visible
 * @returns true if either outline is visible
 */
public isOutlineVisible(): boolean {
    return this._leoTreeExView.visible || this._leoTreeView.visible;
}

</t>
<t tx="felix.20220907223335.1">/**
 * * Checks for all tabs if any are 'leoBody' scheme
 * @returns total found
 */
private _isBodyPreview(): boolean {
    let w_isPreview: boolean = true;
    let w_found: boolean = false;
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME
            ) {
                w_found = true;
                if (!p_tab.isPreview) {
                    w_isPreview = false;
                }
            }
        });
    });
    if (w_found) {
        return w_isPreview;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20220924172739.1">/**
 * (Re)set the set of icons
 * @param p_icons New set of icons
 */
public setInvertFlag(p_invertFLag: boolean): void {
    this._invertDirty = p_invertFLag;
}

</t>
<t tx="felix.20220925181748.1">/**
 * * CLears the nav search results of the goto pane
 */
public async navTextClear(): Promise&lt;LeoBridgePackage&gt; {
    await this._isBusyTriggerSave(false, true);
    const w_package = await this.sendAction(
        Constants.LEOBRIDGE.NAV_CLEAR
    );
    this._leoGotoProvider.refreshTreeRoot();
    return w_package;
}

</t>
<t tx="felix.20221002170017.1">## 1.0.9

- Fixed minibuffer history order.
- Fixed keyboard navigation in the goto pane: focus no more flashes.
- Fixed navigation commands, including alt+arrow keys, to show outline if hidden.
- Fixed body edit undo bead creation frequency (when documents pane is not visible.)
- Fixed expand-collapse node selection prior to an 'insert' command.

</t>
<t tx="felix.20221009171323.1">## 1.0.10

- Added 'navigation' flag to 'goto_next_clone' and 'goto_next_marked' commands to force open body and outline if not visible.
- fixed icon path string generation.
- Added icons to the undo pane.
- Added asterisk to outline title to flag 'changed' document.
- Added branch info, and opened-file description to outline title: requires Leo 6.7.1
- Improved page-up/page-down behavior when already on first/last sibling.
- Added the Ctrl+Shift+L keyboard shortcut to reveal the 'LeoInteg' view in the activity bar. (Can be toggled via config setting)
- The Alt+'-' keyboard shortcut that also applies by default to vscode's explorer view when focus is outside LeoInteg's panels, can now be toggled via config setting.
- Changed the behavior of the 'Go Anywhere' command to offer a quick-input search control to search headlines.
- The 'Go Anywhere' command is also now exposed as the Ctrl+P keyboard shortcut, replacing vscode's 'Go to File' command when focus is in any LeoInteg's panel. (Can be toggled via config setting)
- Fixed colorization of section references, along with support for @color and @nocolor directives.

</t>
<t tx="felix.20221027232254.1">/**
 * * Build all possible strings for undo icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the undo tree view
 */
export function buildUndoIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_UNDO_ACTIVE),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_UNDO_ACTIVE)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_UNDO),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_UNDO)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_REDO_ACTIVE),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_REDO_ACTIVE)
        },
        {
            light: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_LIGHT_REDO),
            dark: vscode.Uri.joinPath(p_context.extensionUri, Constants.GUI.ICON_DARK_REDO)
        }
    ];
}

</t>
<t tx="felix.20221030151905.1">/**
 * Saves the selected Leo file for selecting on the next startup
 * Note: Must be a real file on disk, not untitled document(s)!
 */
export function setGlobalLastActiveFile(p_context: vscode.ExtensionContext, p_file: string): Thenable&lt;void&gt; {
    return p_context.workspaceState.update(Constants.LAST_ACTIVE_FILE_KEY, p_file);
}

</t>
<t tx="felix.20221030152024.1">/**
 * Gets the last Leo file (or empty string) that was active. (Used to select it at startup.)
 * Note: Must be a real file on disk, not untitled document(s)!
 */
export function getGlobalLastActiveFile(p_context: vscode.ExtensionContext): string {
    return p_context.workspaceState.get(Constants.LAST_ACTIVE_FILE_KEY) || "";
}

</t>
<t tx="felix.20221031200229.1">/**
 * * Refresh the outline's description (debounced):
 * &lt;branch&gt;: &lt;filename&gt; in &lt;path&gt;
 */
private _refreshDesc(): void {
    if (this.leoStates.fileOpenedReady) {

        if (this.config.showBranchInOutlineTitle) {
            this.sendAction(
                Constants.LEOBRIDGE.GET_BRANCH
            ).then(
                (p_result: LeoBridgePackage) =&gt; {
                    let w_branch = "";
                    if (p_result &amp;&amp; p_result.branch) {
                        w_branch = p_result.branch + ": ";
                    }

                    if (this._leoTreeView) {
                        this._leoTreeView.description = w_branch + this._titleDesc;
                    }
                    if (this._leoTreeExView) {
                        this._leoTreeExView.description = w_branch + this._titleDesc;
                    }
                }
            );
        } else {
            if (this._leoTreeView) {
                this._leoTreeView.description = this._titleDesc;
            }
            if (this._leoTreeExView) {
                this._leoTreeExView.description = this._titleDesc;
            }
        }

    } else {
        if (this._leoTreeView) {
            this._leoTreeView.description = "";
        }
        if (this._leoTreeExView) {
            this._leoTreeExView.description = "";
        }
    }
}

</t>
<t tx="felix.20221127172926.1">/**
 * * Minimal Leo Editor and Leo server versions
 */
public static MIN_SERVER_VERSION_NUMBER = {
    major: 1,
    minor: 0,
    patch: 11,
};

</t>
<t tx="felix.20221202003550.1">/**
 * * Mimic vscode's CTRL+P to find any position by it's headline
 */
public async gotoAnywhere(): Promise&lt;unknown&gt; {
    await this._isBusyTriggerSave(false);

    const q_positions: Thenable&lt;vscode.QuickPickItem[]&gt; = this.sendAction(
        Constants.LEOBRIDGE.GET_POSITION_DATA
    ).then((p_result: LeoBridgePackage) =&gt; {
        if (p_result["position-data-dict"]) {

            const allPositions: ChosePositionItem[] = [];
            // Options for date to look like : Saturday, September 17, 2016
            const w_dateOptions: Intl.DateTimeFormatOptions = { weekday: "long", year: 'numeric', month: "long", day: 'numeric' };

            Object.values(p_result["position-data-dict"]).forEach(p_position =&gt; {
                let w_description = p_position.gnx; // Defaults as gnx.
                const w_gnxParts = w_description.split('.');
                const dateString = w_gnxParts[1] ? w_gnxParts[1] : "";

                if (w_gnxParts.length === 3 &amp;&amp; dateString.length === 14 &amp;&amp; /^\d+$/.test(dateString)) {
                    // legit 3 part numeric gnx, so build a string date
                    const dateString = w_gnxParts[1];
                    const w_year = +dateString.substring(0, 4); // unary + operator to convert the strings to numbers.
                    const w_month = +dateString.substring(4, 6);
                    const w_day = +dateString.substring(6, 8);
                    const w_date = new Date(w_year, w_month - 1, w_day);
                    w_description = `by ${w_gnxParts[0]} on ${w_date.toLocaleDateString("en-US", w_dateOptions)}`;
                }
                allPositions.push({
                    label: p_position.headline,
                    position: p_position,
                    description: w_description
                });
            });

            return allPositions;
        } else {
            return [];
        }
    });

    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.SEARCH_POSITION_BY_HEADLINE
    };

    const p_picked = await vscode.window.showQuickPick(q_positions, w_options);

    if (p_picked &amp;&amp; p_picked.label) {
        return this.sendAction(
            Constants.LEOBRIDGE.SET_SELECTED_NODE,
            utils.buildNodeCommand((p_picked as ChosePositionItem).position)
        ).then((p_resultTag: LeoBridgePackage) =&gt; {
            this.setupRefresh(
                Focus.Body, // Finish in body pane given explicitly because last focus was in input box.
                {
                    tree: true,
                    body: true,
                    // documents: false,
                    // buttons: false,
                    states: true,
                },
                p_resultTag.node
            );
            this.launchRefresh();
        });
    }

    return Promise.resolve(undefined); // Canceled

}

</t>
<t tx="felix.20221204000406.1">export interface ChosePositionItem extends vscode.QuickPickItem {
    position: ArchivedPosition;
}

</t>
<t tx="felix.20221208001059.1">## 1.0.12

- Fixed undo pane's context menu for unchanged document.
- Fixed minibuffer history item order that had unordered entries in some cases. Also keeps unique entries as per Leo's original behavior.
- Fixed keyboard navigation in the 'Goto Panel'. Arrow navigation is now possible.
- Added support for @killcolor and @nocolor-node color suppression directives: requires Leo 6.7.2
- Fixed 'when' condition for keybindings of 'replace' &amp; 'replace-then-find'.
- Completed set of search commands: re-search, word-search and their backward variants.
- Fixed defaults set as placeholders in search commands that use an input box.
- Added support for search commands to leave selection range in tree headlines: requires Leo 6.7.2
- Removed status-bar indicator and related settings until vscode's API allows for focus detection.
- Clicking on the \&lt;find pattern here\&gt; text of the find panel selects all the text to replace easily.
- Fixed auto-closing/restoring body panes at vscode's startup which would cause the 'Cannot save / newer file' error.
- Fixed 'on document changed' logic which would leave the node icon in the wrong 'has-body-content' visual state.
- Trying to open an already opened Leo document now properly selects that document instead of the last one in the list.

</t>
<t tx="felix.20221212232224.1">## 1.0.11

- Fixed 'openAside' context menu entry in explorer.
- Fixed context variables used for views-welcome in package.json.

</t>
<t tx="felix.20230130154800.1">/**
 * * Sets selected node body's modified time for this gnx virtual file
 * @param p_uri URI of file for which to set made-up modified time
 */
public setNewBodyUriTime(p_uri: vscode.Uri): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    this._lastBodyTimeGnx = w_gnx;
    this._setOpenedBodyTime(w_gnx);
}

</t>
<t tx="felix.20230130154806.1">/**
 * * Adds entries in openedBodiesGnx and _openedBodiesInfo if needed
 * * and sets the modified time of an opened body.
 */
private _setOpenedBodyTime(p_gnx: string): void {
    const w_now = new Date().getTime();
    let w_created = w_now;
    if (this._openedBodiesInfo[p_gnx]) {
        w_created = this._openedBodiesInfo[p_gnx].ctime; // Already created?
    }
    this._openedBodiesInfo[p_gnx] = {
        ctime: w_created,
        mtime: w_now // new 'modified' time for sure.
    };
}

</t>
<t tx="felix.20230204150552.1">/**
 * Interactive Search to implement search-backward, re-search, word-search. etc.
 * HAS SPECIAL SYSTEM WITH _lastCommandFindEndOutline TO FAKE FOCUS ZONE PROVENANCE DETECTION
 */
public async interactiveSearch(p_backward: boolean, p_regex: boolean, p_word: boolean): Promise&lt;unknown&gt; {

    this._isBusyTriggerSave(false, true);

    if (p_regex &amp;&amp; p_word) {
        console.error('interactiveSearch called with both "WORD" and "REGEX"');
        return;
    }

    let w_searchTitle = Constants.USER_MESSAGES.INT_SEARCH_TITLE;
    let w_searchPrompt = Constants.USER_MESSAGES.INT_SEARCH_PROMPT;
    let w_searchPlaceholder = Constants.USER_MESSAGES.SEARCH_PLACEHOLDER;

    if (p_backward) {
        w_searchTitle += Constants.USER_MESSAGES.INT_SEARCH_BACKWARD;
    }
    if (p_regex) {
        w_searchTitle = Constants.USER_MESSAGES.INT_SEARCH_REGEXP + w_searchTitle;
    }
    if (p_word) {
        w_searchTitle = Constants.USER_MESSAGES.INT_SEARCH_WORD + w_searchTitle;
    }

    const disposables: vscode.Disposable[] = [];

    // Get value from find panel input
    const w_startValue = this._lastSettingsUsed!.findText === Constants.USER_MESSAGES.FIND_PATTERN_HERE ? '' : this._lastSettingsUsed!.findText;

    try {
        return await new Promise&lt;unknown&gt;((resolve, reject) =&gt; {
            const input = vscode.window.createInputBox();
            input.title = w_searchTitle;
            input.value = w_startValue;
            input.prompt = w_searchPrompt;
            input.placeholder = w_searchPlaceholder;

            disposables.push(
                input.onDidAccept(async () =&gt; {
                    if (!input.value) {
                        input.hide();
                        return resolve(true); // Cancelled with escape or empty string.
                    }
                    const value = input.value; // maybe this was replace.

                    const w_action: string = Constants.LEOBRIDGE.INTERACTIVE_SEARCH;

                    const w_options: { [key: string]: any } = {
                        findText: value,
                        word: p_word,
                        regex: p_regex,
                        backward: p_backward,
                    };

                    // KEEP undefined to re-use last starting focus zone (outline in this case)
                    if (!this._lastCommandFindEndOutline) {
                        // TODO : Send real parameter when possible (vscode prevents focus detection)
                        w_options.fromOutline = "false"; // Not from a find ending on outline, so set to false.
                    }
                    const p_findResult = await this.sendAction(
                        w_action,
                        w_options
                    );

                    this.findFocusTree = false; // Reset flag for headline range

                    if (!p_findResult.found || !p_findResult.focus) {
                        vscode.window.showInformationMessage(Constants.USER_MESSAGES.SEARCH_NOT_FOUND);
                        input.hide();
                    } else {
                        let w_finalFocus = Focus.Body;
                        const w_focus = p_findResult.focus.toLowerCase();
                        if (w_focus.includes('tree') || w_focus.includes('head')) {
                            // tree
                            this._lastCommandFindEndOutline = 2;
                            w_finalFocus = Focus.Outline;
                            this.showOutlineIfClosed = true;
                            // * SETUP HEADLINE RANGE
                            this.findFocusTree = true;
                            // Default to 0,0 if range not available
                            const range = p_findResult.range ? p_findResult.range : [0, 0];
                            this.findHeadlineRange = [range[0], range[1]];
                            this.findHeadlinePosition = p_findResult.node;
                        } else {
                            this.showBodyIfClosed = true;
                        }
                        this.loadSearchSettings();
                        this.setupRefresh(
                            w_finalFocus, // ! Unlike gotoNavEntry, this sets focus in outline -or- body.
                            {
                                tree: true, // HAVE to refresh tree because find folds/unfolds only result outline paths
                                body: true,
                                scroll: p_findResult.found &amp;&amp; w_finalFocus === Focus.Body,
                                // documents: false,
                                // buttons: false,
                                states: true,
                            },
                            p_findResult.node!,
                            this.findFocusTree
                        );
                        this.launchRefresh();
                        input.hide();
                    }

                }),
                input.onDidHide(() =&gt; {
                    return resolve(true);
                })
            );
            if (this._interactiveSearchInputBox) {
                this._interactiveSearchInputBox.dispose(); // just in case.
            }
            this._interactiveSearchInputBox = input;
            this._interactiveSearchInputBox.show();
        });
    } finally {
        disposables.forEach(d =&gt; d.dispose());
        this._interactiveSearchInputBox?.hide();
    }

}

</t>
<t tx="felix.20230226173728.1">{
  "view": "leoIntegration",
  "contents": "Starting Server...",
  "when": "leoStartingServer || !leoBridgeReady &amp;&amp; config.leoIntegration.startServerAutomatically &amp;&amp; !leoStartingServer &amp;&amp; !leoConnecting &amp;&amp; !leoStartupFinished"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Starting Server...",
  "when": "leoStartingServer || !leoBridgeReady &amp;&amp; config.leoIntegration.startServerAutomatically &amp;&amp; !leoStartingServer &amp;&amp; !leoConnecting &amp;&amp; !leoStartupFinished"
},
</t>
<t tx="felix.20230227002122.1">/**
 * Setup flags for end of opening last-files.
 */
private _finishOpenLastFiles(): void {
    // set connecting false and other flags to finish 'open last files'
    this.leoStates.leoBridgeReady = true;
    this.leoStates.leoStartupFinished = true;
    setTimeout(() =&gt; {
        this.leoStates.leoConnecting = false;
    }, 100);

}
</t>
<t tx="felix.20230304182815.1">## Undo Panel

&gt; In LeoInteg, the undo functionality is a multi-tiered system that segregates structural outline changes from text changes within the body pane. The Undo Panel captures outline alterations as individual 'Undo Beads', independent from VS Code's native text undo states. When focus resides in the body pane, the Undo keybinding triggers VS Code's text-specific undo action. However, once the focus shifts or a new node is selected, all concurrent text changes coalesce into a single 'Undo Bead' within the Undo Panel. These 'Undo Beads' can then be manipulated either through the Undo Panel or by keybindings, provided the focus is explicitly set on the outline pane. This dual-layer undo architecture enables precise control over both code and structural modifications.

Use the undo / redo icons above the outline or above the undo pane itself. You can also right-click on an undo step to directly switch to that specific state!

![Undo pane](https://raw.githubusercontent.com/boltex/leointeg/master/resources/undo-pane.gif)

</t>
<t tx="felix.20230304202815.1">## Navigating a Leo Document

Arrow keys, home/end, page up/down are used for basic navigation. But in order to **find and goto specific nodes directly**, use the methods described below.

### Goto Anywhere Command

Normally in vscode, the the **`Ctrl+P`** shortcut allows you to switch to any project file, but when the focus is in one of Leo's panels, the **`Ctrl+P`** keybinding allows you to switch to a node directly by typing (part of) it's headline.

![Goto Anywhere](https://raw.githubusercontent.com/boltex/leointeg/master/resources/goto-anywhere.gif)

### Find Commands

With focus in Leo's outline or body pane, Hit **`Ctrl+F`** to open the _find panel_.

Enter your search pattern directly in the **\&lt;find pattern here\&gt;** field. Press **`Enter`** to find the first match starting from your current position.

Hitting **`F3`** repeatedly will find the subsequent matches. (**`F2`** for previous matches)

![Find results](https://raw.githubusercontent.com/boltex/leointeg/master/resources/find-in-headlines.gif)

### Nav and the Goto Panel

Type your search pattern in the **Nav** field instead to see all results show up below in leo's **Goto Pane**. This will show the headlines as you type.

Press **`Enter`** to freeze the results and show results also found in **body text of any node**. This will add a snowflake icon  to the **Nav** field.

From the **Goto Pane**, you can use the arrow keys, home/end, page up/down to cycle directly to any of those matches.

![Goto pane](https://raw.githubusercontent.com/boltex/leointeg/master/resources/nav-goto-pane.gif)

### Using Tags

If you check the **Tag** option, the **Nav** field and **Goto Pane** are then used to find nodes by their tag  _ua_ (user attribute).

![Node tags](https://raw.githubusercontent.com/boltex/leointeg/master/resources/nav-tags.gif)

</t>
<t tx="felix.20230304215145.1">@language md
@tabwidth -4
# Sponsors and Backers 

[Support Me via GitHub Sponsors](https://github.com/sponsors/boltex)

## Many thanks to these awesome sponsors and backers

&lt;table&gt;
    &lt;tr&gt;
        &lt;td align="center"&gt;
            &lt;a href="https://github.com/edreamleo"&gt;
                &lt;img src="https://avatars.githubusercontent.com/u/592928?v=4"
                     alt="Edward K. Ream"
                     width="48"
                     height="48"
                &gt;
            &lt;/a&gt;
            &lt;br&gt;
            Edward K. Ream
        &lt;/td&gt;
        &lt;td align="center"&gt;
            &lt;a href="https://github.com/tbpassin"&gt;
                &lt;img src="https://avatars.githubusercontent.com/u/36974235?v=4"
                     alt="Thomas Passin"
                     width="48"
                     height="48"
                &gt;
            &lt;/a&gt;
            &lt;br&gt;
            Thomas Passin
        &lt;/td&gt;        
        &lt;td align="center"&gt;
            &lt;a href="https://github.com/kghenderson"&gt;
                &lt;img src="https://avatars.githubusercontent.com/u/3522168?v=4"
                     alt="Kevin Henderson"
                     width="48"
                     height="48"
                &gt;
            &lt;/a&gt;
            &lt;br&gt;
            Kevin Henderson
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</t>
<t tx="felix.20230310210120.1">## 1.0.13

- Added missing find panel settings toggle commands to the minibuffer override.
- Fixed setting synchronization that was lagging by one change when going from vscode to leoInteg's welcome/setting panel.

</t>
<t tx="felix.20230808224051.1">export function getNonce(): string {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i &lt; 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}

</t>
<t tx="felix.20230811224332.1">/**
 * * Revert the contents of a Leo outline to last saved contents.
 * If unnamed file, calls anyways to let the real command print out message
 */
public async revert(): Promise&lt;unknown&gt; {
    if (this.leoStates.leoOpenedFileName) {
        await this._isBusyTriggerSave(true, true);

        const w_result = await vscode.window.showInformationMessage(
            Constants.USER_MESSAGES.REVERT_PREVIOUS_VERSION +
            this.leoStates.leoOpenedFileName +
            '?',
            { modal: true },
            {
                title: Constants.USER_MESSAGES.YES,
                isCloseAffordance: false
            },
            {
                title: Constants.USER_MESSAGES.NO,
                isCloseAffordance: true
            },
        );
        if (!w_result || w_result.title === Constants.USER_MESSAGES.NO) {
            return;
        }

        const q_commandResult = this.nodeCommand({
            action: Constants.LEOBRIDGE.REVERT,
            node: undefined,
            refreshType: {
                tree: true,
                body: true,
                documents: true,
                buttons: true,
                goto: true,
                states: true,
            },
            finalFocus: Focus.NoChange, // use last

        });
        if (q_commandResult) {
            return q_commandResult;
        } else {
            return Promise.reject('Revert to saved version failed');
        }
    } else {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.CANNOT_REVERT);
    }

}
</t>
<t tx="felix.20230815233005.1">/**
 * * Cycle opened documents
 */
public async tabCycle(): Promise&lt;unknown&gt; {
    await this._isBusyTriggerSave(true, true);
    const w_package = await this.sendAction(Constants.LEOBRIDGE.GET_OPENED_FILES);
    const w_files: LeoDocument[] = w_package.files!;
    let w_index: number = 0;
    let w_chosenIndex = 0;
    if (w_files &amp;&amp; w_files.length &amp;&amp; w_files.length &gt; 1) {
        w_files.forEach(function (p_filePath: LeoDocument) {
            if (p_filePath.selected) {
                if (w_index === w_files.length - 1) {
                    w_chosenIndex = 0;
                } else {
                    w_chosenIndex = w_index + 1;
                }
            }
            w_index++;
        });
    } else {
        // "Only one, or no opened documents"
        return undefined;
    }
    this.finalFocus = Focus.Outline;
    return this.selectOpenedLeoDocument(w_chosenIndex);
}

</t>
<t tx="felix.20230821005233.1">## 1.0.15

- Added description under command label in minibuffer-history's user input box.
- Fixed default keybindings for alt+home and alt+end. (goto first/last visible node)
- Fixed critical bug with the 'python command' user setting.
- Fixed 'new' command to force-show Leo's body and outline panes.
- Server manager now offers better error handling and status messages when starting a server and/or connecting to it.
- Improved 'when' conditions for keybindings to have command trigger at appropriate times. (Having focus on the right panels for commands to trigger)
- Commands that toggle search settings in the 'find' panel will make sure the panel is visible before toggling the setting.
- Custom @button, @rclick and @command entries of the minibuffer are now shown with proper ordering, description and icon.
- Branch for opened Leo document now hidden by default in outline's title.
- Added new option setting "showBranchInOutlineTitle" to show the branch with the filename in the outline's title bar.
- Settings panel now shows the resulting command used to spawn the server process (built from the various server startup settings).
- Added a 100ms delay when selecting opened document node in document panel to fix a bug where activity bar would flash when switching from leo view to explorer view when document pane was opened.

</t>
<t tx="felix.20231001151916.1">## Leo Commands

![Menus](https://raw.githubusercontent.com/boltex/leointeg/master/resources/context-hover-menus.png)

LeoInteg offers an extensive set of integrated commands, accessible through a variety of interfaces  toolbar buttons, dedicated menus, and intuitive keybindings. Those commands are also discoverable via the Visual Studio Code Command Palette. (accessible through F1 or Ctrl+Shift+P)

### Context-Aware Keybindings

The keybinding architecture is designed to be context-aware. When your focus is within the LeoInteg Body or Outline pane, LeoInteg-specific keybindings take precedence. Shift your focus outside these panes, and Visual Studio Code's native keybindings resume control.

### The Minibuffer

For those familiar with Leo, the 'minibuffer' serves as the nerve center for command execution. Access it through Alt+X and use the complete set of Leo's commands!
</t>
<t tx="felix.20231007200850.1">public static MINIBUFFER_QUICK_PICK: vscode.QuickPickItem = {
    label: Constants.USER_MESSAGES.MINIBUFFER_HISTORY_LABEL,
    description: Constants.USER_MESSAGES.MINIBUFFER_HISTORY_DESC,
    iconPath: new vscode.ThemeIcon("history")
};
</t>
<t tx="felix.20231009003516.1">## 1.0.16

- Editing a headline, when inserting or renaming a node, can now be interrupted by most other keyboard shortcuts and commands.
- Fixed minibuffer history so that each opened Leo document has its own minibuffer command history: Requires Leo 6.7.5.
- Implemented more of the original Leo's easter eggs: Pressing 'm' in the nav input launches the 'marked-list' command.
- Added automatic Leo installation path finding.

</t>
<t tx="felix.20231101200432.1">private _leoEditHeadline: boolean = false;
get leoEditHeadline(): boolean {
    return this._leoEditHeadline;
}
set leoEditHeadline(p_value: boolean) {
    this._leoEditHeadline = p_value;
    this.qLastContextChange = utils.setContext(Constants.CONTEXT_FLAGS.LEO_EDIT_HEADLINE, p_value);
}

</t>
<t tx="felix.20231101204323.1">/**
 * Show a headline input box that resolves to undefined only with escape.
 * Other Leo commands interrupt by accepting the value entered so far.
 */
private _showHeadlineInputBox(p_options: vscode.InputBoxOptions): Promise&lt;string | undefined&gt; {

    const hib = vscode.window.createInputBox();
    this._hibLastValue = undefined; // Prepare for 'cancel' as default.
    const q_headlineInputBox = new Promise&lt;string | undefined&gt;((p_resolve, p_reject) =&gt; {

        hib.ignoreFocusOut = !!p_options.ignoreFocusOut;
        hib.value = p_options.value!;
        hib.valueSelection = p_options.valueSelection;
        hib.prompt = p_options.prompt;
        this._hibDisposables.push(hib.onDidAccept(() =&gt; {
            if (this._hib) {
                this._hib.enabled = false;
                this._hibLastValue = this._hib.value;
                this._hib.hide();
            }
        }, this));
        if (this._hibResolve) {
            console.error('IN _showHeadlineInputBox AND THE _hibResolve PROMISE ALREADY EXISTS!');
        }
        this._hibResolve = p_resolve;
        // onDidHide handles CANCEL AND ACCEPT AND INTERCEPT !
        this._hibDisposables.push(hib.onDidHide(() =&gt; {
            if (this._hib) {
                this._hibLastValue = this._hib.value; // * FORCE VALUE EVEN WHEN CANCELLING LIKE IN ORIGINAL LEO !
            }
            this.leoStates.leoEditHeadline = false;
            if (this._hibResolve) {
                // RESOLVE whatever value was set otherwise undefined will mean 'canceled'.
                this._hibResolve(this._hibLastValue);
                // Dispose of everything disposable with the edit headline process.
                for (const disp of this._hibDisposables) {
                    disp.dispose();
                }
                // Empty related global variables.
                this._hibDisposables = [];
                this._hibResolve = undefined;
                this._hib = undefined;
            } else {
                console.log('ERROR ON onDidHide NO _hibResolve !');
            }
        }, this));
        this._hibDisposables.push(hib);
        // setup finished, set command context and show it! 
        this._hib = hib;
        this.leoStates.leoEditHeadline = true;
        this._hib.show();
    });
    return q_headlineInputBox;
}
</t>
<t tx="felix.20231102005126.1">/**
 * * Compares major, minor and patch members of versions
 * @param p_version given version 
 * @param p_min minimal version
 * @returns true if at least minimal version
 */
export function compareVersions(p_version: Version, p_min: Version): boolean {
    if (
        p_version.major &gt; p_min.major ||
        p_version.major === p_min.major &amp;&amp; p_version.minor &gt; p_min.minor ||
        p_version.major === p_min.major &amp;&amp; p_version.minor === p_min.minor &amp;&amp; p_version.patch &gt;= p_min.patch
    ) {
        return true;
    }
    return false;
}

</t>
<t tx="felix.20231102005402.1">export interface Version {
    major: number;
    minor: number;
    patch: number;
}

</t>
<t tx="felix.20231102230431.1">public async findInstallPath(): Promise&lt;string&gt; {

    return new Promise((p_resolve, p_reject) =&gt; {
        // Find Leo's installation folder with command line tricks from Matt Wilkie 
        const options = { encoding: 'utf-8' as BufferEncoding };
        const isWindows = process.platform === 'win32';
        let hasCreated = false;
        let python = this.config.leoPythonCommand;
        if (!python) {
            python = Constants.DEFAULT_PYTHON;
            if (isWindows) {
                python = Constants.WIN32_PYTHON;
            }
        }

        // Your command
        let output = "";
        try {
            output = execSync(python + ' -c "import leo; import os; print(os.path.dirname(leo.__file__))"', options);
        } catch (error) {
            output = ""; // Clear to make sure
        }

        if (!output) {
            try {
                if (isWindows) {
                    execSync('echo g.es_print(g.app.loadManager.computeLeoDir()) &gt; tmp_locate_leo_dir.leox', options);
                } else {
                    execSync('echo "g.es_print(g.app.loadManager.computeLeoDir())" &gt; tmp_locate_leo_dir.leox', options);
                }
                hasCreated = true;

            } catch (e) {
                // pass
            }
            try {

                output = execSync('leo-messages --silent --script=tmp_locate_leo_dir.leox', options);

            } catch (error) {
                output = ""; // Clear to make sure
            } finally {
                if (isWindows) {
                    execSync('del tmp_locate_leo_dir.leox', options);
                } else {
                    execSync('rm tmp_locate_leo_dir.leox', options);
                }
            }
        }

        if (output &amp;&amp; output.trim()) {

            output = output.trim();

            if (output.endsWith('/leo') || output.endsWith('\\leo')) {
                output = output.slice(0, -4);
            }

            // Set config option to the proper leo path.
            this.config.setLeoIntegSettings(
                [{
                    code: Constants.CONFIG_NAMES.LEO_EDITOR_PATH,
                    value: output
                }]
            ).then(() =&gt; {
                this.leoSettingsWebview.changedConfiguration();
                vscode.window.showInformationMessage('Leo-Editor installation folder found automatically as ' + output);
                p_resolve(output);
            });
        } else {
            p_resolve(""); // Empty string when not found.
        }
    });

}

</t>
<t tx="felix.20231130222754.1">export function fixSlashesDriveLetter(p_path: string): string {
    if (!p_path) {
        return '';
    }
    p_path = p_path.split('\\').join('/');
    return p_path.replace(/^([a-z]):/, (match, driveLetter) =&gt; driveLetter.toUpperCase() + ':');

}

</t>
<t tx="felix.20231130225803.1">## 1.0.17

- Global settings now save data with proper drive letter capitalization (For windows OS)
- Added icon for 'Open Recent-files list' command on the documents panel.
- Fixed conflict with leojs for body with same gnx.

</t>
<t tx="felix.20231210150154.1">## 1.0.18

- Fixed body pane tab label identifier.
- Fixed goto-next-clone and goto-next-marked commands refresh cycles.
- Added 'Show Recent Files' button to panel if no files are opened.

</t>
<t tx="felix.20231216214036.1">## 1.0.19

- Fixed tooltips in find panel.
- Added UNL support: Requires Leo 6.7.7.
- Fixed 'goto-script' refresh cycle.
- @button panel entries now run with 'play' icon press instead of by selecting the entry.
- Leo panel now shows a 'Opening...' message when opening a Leo file if no file were already opened.
- Added support for the 'wrap' state of the body pane. (Along with @wrap and @nowrap directives)

</t>
<t tx="felix.20240107202609.1">public async handleUnl(p_arg: { unl: string, scheme: string }): Promise&lt;void&gt; {

    if (!this.leoStates.leoBridgeReady || !this.leoStates.fileOpenedReady) {
        this.addLogPaneEntry('Handle UNL: No Commander started');
        return;
    }

    const leoJsExtension = vscode.extensions.getExtension('boltex.leojs');
    if (leoJsExtension !== undefined &amp;&amp; leoJsExtension.isActive) {
        // If leojs is active only honor UNLS clicked in LeoInteg Panels only.
        if (p_arg.scheme !== Constants.URI_LEO_SCHEME) {
            console.log('LeoJS active: UNL ignored by LeoInteg');
            return;
        }
    }
    await this.triggerBodySave(true);
    try {

        if (p_arg.unl) {

            return this.sendAction(
                Constants.LEOBRIDGE.HANDLE_UNL,
                { unl: p_arg.unl }
            ).then((p_result: LeoBridgePackage) =&gt; {
                this.setupRefresh(
                    Focus.NoChange,
                    {
                        tree: true,
                        body: true,
                        goto: true,
                        states: true,
                        documents: true,
                        buttons: true
                    }
                );
                this.launchRefresh();
                this.loadSearchSettings();

            });

        } else {
            console.log('NO ARGUMENT FOR HANDLE URL! ', p_arg);
        }
    }
    catch (e) {
        console.log('FAILED HANDLE URL! ', p_arg);
    }
}

</t>
<t tx="felix.20240107210250.1">import * as vscode from 'vscode';
import { Constants } from "./constants";

export class UnlProvider implements vscode.DocumentLinkProvider {

    /*
        * GNX-based UNL Samples
        unl:gnx://leoPy.leo#ekr.20230626064652.1
        unl:gnx://myProject.leo#node12345678.1
        unl:gnx://codeRepo.leo#function.20231231.1
    
        * Headline-based UNL Samples
        unl://C:/leo.repo/leo-editor/leo/doc/LeoDocs.leo#Getting Started--&gt;Introduction
        unl://D:/work/notes.leo#Meeting Notes--&gt;2023--&gt;March--&gt;Project X Discussion
        unl://myDocuments/notes.leo#Ideas--&gt;New Concepts--&gt;brainstorming-session
        unl://relativePath/myFile.leo#Chapter 1--&gt;Section 2--&gt;Paragraph 3
        unl://C:/projects/leoProject.leo#Code Review--&gt;Module 1--&gt;Function XYZ--&gt;Improvements
    
        * Mixed Characters and Edge Cases
        unl://path/to/file.leo#Headline-with-Dashes--&gt;Sub-section--&gt;Item 1
        unl://anotherPath/docs.leo#Special Characters!--&gt;@$%^&amp;*
        unl://leoFile.leo#Testing--&gt;Edge--&gt;Cases--&gt;with--&gt;Multiple Separators

        REFERENCE IN leoGlobals.py
         2. New in Leo 6.7.4: UNLs based on gnx's (global node indices):
        
            Links of the form `unl:gnx:` + `//{outline}#{gnx}` open the given
            outline and select the first outline node with the given gnx. These UNLs
            will work as long as the node exists anywhere in the outline.
        
            For example, the link: `unl:gnx://#ekr.20031218072017.2406` refers to this
            outline's "Code" node. Try it. The link works in this outline.

    */

    // private gnxUnlRegex = /\bunl:gnx:[^\r\n#]*#\S*/g; // This allows spaces and content after the UNL.
    // private headlineUnlRegex = /\bunl:(?!gnx:)[^\r\n#]*#[^\r\n]*\S/g; // This goes on until end of line.

    // *It seems that the double slash is required for valid UNLs (as per this comment in p.get_UNL and related methods in leoNodes.py)

    // All unls must contain a file part: f"//{file-name}#"
    // The file-name may be empty.

    private gnxUnlRegex = /\bunl:gnx:\/\/[^\r\n#]*#\S*/g; // This allows spaces and content after the UNL.
    private headlineUnlRegex = /\bunl:\/\/[^\r\n#]*#[^\r\n]*\S/g; // This goes on until end of line.

    public provideDocumentLinks(document: vscode.TextDocument, token: vscode.CancellationToken): vscode.ProviderResult&lt;vscode.DocumentLink[]&gt; {
        const text = document.getText();
        const links: vscode.DocumentLink[] = [];
        const scheme = document.uri.scheme;
        let match;

        // GNX-based UNLs
        while ((match = this.gnxUnlRegex.exec(text)) !== null) {
            const range = new vscode.Range(document.positionAt(match.index), document.positionAt(match.index + match[0].length));
            const args = encodeURIComponent(JSON.stringify({ unl: match[0], scheme: scheme }));
            links.push(new vscode.DocumentLink(range, vscode.Uri.parse(`command:${Constants.COMMANDS.HANDLE_UNL}?${args}`)));
        }

        //  Headline - based UNLs
        while ((match = this.headlineUnlRegex.exec(text)) !== null) {
            const range = new vscode.Range(document.positionAt(match.index), document.positionAt(match.index + match[0].length));
            const args = encodeURIComponent(JSON.stringify({ unl: match[0], scheme: scheme }));
            links.push(new vscode.DocumentLink(range, vscode.Uri.parse(`command:${Constants.COMMANDS.HANDLE_UNL}?${args}`)));
        }

        return links;
    }
}
</t>
<t tx="felix.20240121194014.1">/**
 * Supported Languages
 */
public static LANGUAGES = [
    "plain",
    "python",
    "javascript",
    "typescript",
    "c",
    "cpp",
    "css",
    "fortran",
    "fortran90",
    "html",
    "java",
    "json",
    "markdown",
    "php",
    "restructuredtext",
    "rust",
    "xml",
];

</t>
<t tx="felix.20240121200443.1">/**
 * * Sets all 'bodywrap' vscode settings
 */
public setBodyWrap(): Thenable&lt;void&gt; {
    let w_totalConfigName = "";
    for (const w_lang of Constants.LANGUAGES) {
        let langWrap = '[' + Constants.LEO_LANGUAGE_PREFIX + w_lang + Constants.LEO_WRAP_SUFFIX + ']';
        w_totalConfigName += langWrap;
    }
    return vscode.workspace.getConfiguration().update(w_totalConfigName, { 'editor.wordWrap': 'on' }, vscode.ConfigurationTarget.Global);
}

</t>
<t tx="felix.20240121200637.1">public checkBodyWrap(p_forced?: boolean): void {
    let w_missing = false;

    let w_languageSettings: Record&lt;string, string&gt; | undefined;
    let w_totalConfigName = "";

    for (const w_lang of Constants.LANGUAGES) {
        let langWrap = '[' + Constants.LEO_LANGUAGE_PREFIX + w_lang + Constants.LEO_WRAP_SUFFIX + ']';
        w_totalConfigName += langWrap;
        // w_languageSettings = vscode.workspace.getConfiguration(langWrap);
    }
    w_languageSettings = vscode.workspace.getConfiguration(w_totalConfigName, null);

    if (!w_languageSettings || !w_languageSettings['editor.wordWrap'] || w_languageSettings['editor.wordWrap'] !== 'on') {
        w_missing = true;
    }

    if (w_missing &amp;&amp; p_forced) {
        void this.setBodyWrap();
        // ! NOT warning the user for this forced setting at startup because its internal to LeoInteg only !
    } else if (w_missing &amp;&amp; !p_forced) {
        void vscode.window.showWarningMessage(
            Constants.USER_MESSAGES.BODY_WRAP_RECOMMEND,
            Constants.USER_MESSAGES.FIX_IT
        ).then(p_chosenButton =&gt; {
            if (p_chosenButton === Constants.USER_MESSAGES.FIX_IT) {
                void vscode.commands.executeCommand(Constants.COMMANDS.SET_BODY_WRAP_SETTINGS);
                void vscode.window.showInformationMessage(Constants.USER_MESSAGES.BODY_WRAP_SET);
            }
        });
    }
}

</t>
<t tx="felix.20240122213243.1">## 1.0.20

- Fixed 'Goto' panel's navigation's stability issues after switching panels.
- Added support for XML language colorization.
- Added hover menu to the UNL status bar item to choose from any UNL formats to be copied to the clipboard.
- Removed 'font-size &amp; zoom' related config settings following VSCode's new ZOOM settings API.
- Fixed Find-Panel's behavior and styling.

</t>
<t tx="felix.20240214000508.1">/**
 * 'getUnl' action for use in status bar
 */
private _getUNL(): void {

    if (!utils.compareVersions(this.serverVersion, { major: 1, minor: 0, patch: 10 })) {
        return;
    }
    // IF SERVER VERSION &gt;= 10 get unl action !
    this.sendAction(Constants.LEOBRIDGE.GET_UNL)
        .then((p_package: LeoBridgePackage) =&gt; {
            if (p_package.unl) {
                this._leoStatusBar.setString(p_package.unl);
            }
        });

}

</t>
<t tx="felix.20240221215337.1">/**
 * Remove body wrap setting from older LeoInteg versions
 * that suported less languages
 */
public removeOldBodyWrap(): void {
    // Last version did not have XML
    let w_totalOldVersionConfigName = "";

    // Looping from the first element up to the second-to-last element
    for (let i = 0; i &lt; Constants.LANGUAGES.length - 1; i++) {
        const w_lang = Constants.LANGUAGES[i];
        const langWrap = '[' + Constants.LEO_LANGUAGE_PREFIX + w_lang + Constants.LEO_WRAP_SUFFIX + ']';
        w_totalOldVersionConfigName += langWrap;
    }

    if (vscode.workspace.getConfiguration().has(w_totalOldVersionConfigName)) {
        void vscode.workspace.getConfiguration().update(w_totalOldVersionConfigName, undefined, vscode.ConfigurationTarget.Global);
    }

}

</t>
<t tx="felix.20240223230449.1">/**
 * Put UNL of current node on the clipboard. 
 * @para optional unlType to specify type.
 */
public unlToClipboard(unlType?: UnlType): Thenable&lt;void&gt; {

    if (!utils.compareVersions(this.serverVersion, { major: 1, minor: 0, patch: 10 })) {
        return Promise.resolve();
    }
    // "shortGnx" | "fullGnx" | "shortLegacy" | "fullLegacy"
    let short = unlType &amp;&amp; unlType.includes('short');
    let legacy = unlType &amp;&amp; unlType.includes('Legacy');
    // IF SERVER VERSION &gt;= 10 get unl action !
    return this.sendAction(Constants.LEOBRIDGE.GET_UNL, { short: short, legacy: legacy })
        .then((p_package: LeoBridgePackage) =&gt; {
            if (p_package.unl) {
                return this.replaceClipboardWith(p_package.unl);
            }
        });
}

</t>
<t tx="felix.20240223230656.1">export type UnlType = 'shortGnx' | 'fullGnx' | 'shortLegacy' | 'fullLegacy';

</t>
<t tx="felix.20240330232425.1">## 1.0.21

- Fixed icons disabled appearance by changing the graphic format from SVG to a weoff2 font.
- Changed behavior of the 'Open Aside' command: it now  opens 'detached' body panes, which allows text editing for a fixed gnx.

</t>
<t tx="felix.20240430200658.1">"icons": {
  "leo-arrow-down": {
    "description": "Arrow Down",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f101"
    }
  },
  "leo-arrow-left": {
    "description": "Arrow Left",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f102"
    }
  },
  "leo-arrow-right": {
    "description": "Arrow Right",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f103"
    }
  },
  "leo-arrow-small-down": {
    "description": "Small Arrow Down",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f104"
    }
  },
  "leo-arrow-small-left": {
    "description": "Small Arrow Left",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f105"
    }
  },
  "leo-arrow-small-right": {
    "description": "Small Arrow Right",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f106"
    }
  },
  "leo-arrow-small-up": {
    "description": "Small Arrow Up",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f107"
    }
  },
  "leo-arrow-up": {
    "description": "Arrow Up",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f108"
    }
  },
  "leo-chapter-back": {
    "description": "Chapter Back",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f109"
    }
  },
  "leo-chapter-main": {
    "description": "Chapter Main",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f10a"
    }
  },
  "leo-chapter-next": {
    "description": "Chapter Next",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f10b"
    }
  },
  "leo-chapter-select": {
    "description": "Chapter Select",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f10c"
    }
  },
  "leo-clear-files": {
    "description": "Clear Files",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f10d"
    }
  },
  "leo-clipboard": {
    "description": "Clipboard",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f10e"
    }
  },
  "leo-close": {
    "description": "Close",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f10f"
    }
  },
  "leo-close-server": {
    "description": "Close Server",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f110"
    }
  },
  "leo-collapse": {
    "description": "Collapse",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f111"
    }
  },
  "leo-connect": {
    "description": "Connect",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f112"
    }
  },
  "leo-cut": {
    "description": "Cut",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f113"
    }
  },
  "leo-dehoist": {
    "description": "Dehoist",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f114"
    }
  },
  "leo-delete": {
    "description": "Delete",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f115"
    }
  },
  "leo-demote": {
    "description": "Demote",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f116"
    }
  },
  "leo-edit": {
    "description": "Edit",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f117"
    }
  },
  "leo-extract": {
    "description": "Extract",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f118"
    }
  },
  "leo-extract-name": {
    "description": "Extract Name",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f119"
    }
  },
  "leo-find-next": {
    "description": "Find Next",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f11a"
    }
  },
  "leo-find-previous": {
    "description": "Find Previous",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f11b"
    }
  },
  "leo-find-quick": {
    "description": "Find Quick",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f11c"
    }
  },
  "leo-find-quick-changed": {
    "description": "Find Quick Changed",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f11d"
    }
  },
  "leo-find-quick-history": {
    "description": "Find Quick History",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f11e"
    }
  },
  "leo-find-quick-marked": {
    "description": "Find Quick Marked",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f11f"
    }
  },
  "leo-find-quick-selected": {
    "description": "Find Quick Selected",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f120"
    }
  },
  "leo-find-quick-timeline": {
    "description": "Find Quick Timeline",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f121"
    }
  },
  "leo-folder": {
    "description": "Folder",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f122"
    }
  },
  "leo-gear": {
    "description": "Gear",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f123"
    }
  },
  "leo-hoist": {
    "description": "Hoist",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f124"
    }
  },
  "leo-icon-leo-fill": {
    "description": "Leo icon filled",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f125"
    }
  },
  "leo-icon-leo-outline": {
    "description": "Leo icon outlined",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f126"
    }
  },
  "leo-import": {
    "description": "Import",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f127"
    }
  },
  "leo-insert": {
    "description": "Insert",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f128"
    }
  },
  "leo-insert-child": {
    "description": "Insert Child",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f129"
    }
  },
  "leo-link": {
    "description": "Link",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f12a"
    }
  },
  "leo-mark": {
    "description": "Mark",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f12b"
    }
  },
  "leo-new-file": {
    "description": "New File",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f12c"
    }
  },
  "leo-next": {
    "description": "Next",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f12d"
    }
  },
  "leo-node": {
    "description": "Node",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f12e"
    }
  },
  "leo-open-recent": {
    "description": "Open Recent",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f12f"
    }
  },
  "leo-parent": {
    "description": "Parent",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f130"
    }
  },
  "leo-paste": {
    "description": "Paste",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f131"
    }
  },
  "leo-paste-clone": {
    "description": "Paste Clone",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f132"
    }
  },
  "leo-plus": {
    "description": "Plus",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f133"
    }
  },
  "leo-plus-small": {
    "description": "Small Plus",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f134"
    }
  },
  "leo-prev": {
    "description": "Prev",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f135"
    }
  },
  "leo-promote": {
    "description": "Promote",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f136"
    }
  },
  "leo-redo": {
    "description": "Redo",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f137"
    }
  },
  "leo-refresh": {
    "description": "Refresh",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f138"
    }
  },
  "leo-save": {
    "description": "Save",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f139"
    }
  },
  "leo-save-as": {
    "description": "Save As",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f13a"
    }
  },
  "leo-save-as-leo": {
    "description": "Save As .leo",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f13b"
    }
  },
  "leo-show-log": {
    "description": "Show Log",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f13c"
    }
  },
  "leo-sort-children": {
    "description": "Sort Children",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f13d"
    }
  },
  "leo-sort-siblings": {
    "description": "Sort Siblings",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f13e"
    }
  },
  "leo-start-server": {
    "description": "Start Server",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f13f"
    }
  },
  "leo-switch": {
    "description": "Switch",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f140"
    }
  },
  "leo-tag": {
    "description": "Tag",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f141"
    }
  },
  "leo-undo": {
    "description": "Undo",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f142"
    }
  },
  "leo-unmark": {
    "description": "Unmark",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f143"
    }
  },
  "leo-write-at-file-nodes": {
    "description": "Write at-file Nodes",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f144"
    }
  },
  "leo-write-dirty-at-file-nodes": {
    "description": "Write Dirty at-file Nodes",
    "default": {
      "fontPath": "resources/leoicons.woff2",
      "fontCharacter": "\\f145"
    }
  }
},
</t>
<t tx="felix.20240501232955.1">public cleanupBodies(): void {
    const w_foundGnx: string[] = [];
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME
            ) {
                w_foundGnx.push(utils.leoUriToStr((p_tab.input as vscode.TabInputText).uri));
            }
        });
    });
    if (!w_foundGnx.length) {
        return;
    }
    for (const openBody of Object.keys(this._openedBodiesInfo)) {
        if (!w_foundGnx.includes(openBody)) {
            // Not an opened tab! remove it!

            delete this._openedBodiesInfo[openBody];
        }
    }
}
</t>
<t tx="felix.20240502002356.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import * as path from 'path';
import { LeoIntegration } from "./leoIntegration";
import { ArchivedPosition, BodyTimeInfo } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20240502002356.10">public readDirectory(p_uri: vscode.Uri): [string, vscode.FileType][] {
    const w_commanders: Set&lt;string&gt; = new Set();
    const w_detached: Set&lt;string&gt; = new Set();
    if (this._leoIntegration.leoStates.fileOpenedReady) {

        for (const p_tabGroup of vscode.window.tabGroups.all) {
            for (const p_tab of p_tabGroup.tabs) {
                if (p_tab.input &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_DETACHED_SCHEME
                ) {
                    // Found detached. 
                    const [unused, id, gnx] = (p_tab.input as vscode.TabInputText).uri.path.split("/");
                    w_commanders.add(id);
                    w_detached.add((p_tab.input as vscode.TabInputText).uri.path);
                }
            }
        }
    }

    if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'

        const w_directory: [string, vscode.FileType][] = [];

        for (const w_commander of [...w_commanders]) {
            w_directory.push([w_commander, vscode.FileType.Directory]);
        }
        return w_directory;

    } else if (
        p_uri.path.split('/').length
    ) {

        const w_directory: [string, vscode.FileType][] = [];
        for (const w_file of [...w_detached]) {
            if (w_file.split('/')[1] === p_uri.path.split('/')[1]) {
                w_directory.push([w_file.split('/')[2], vscode.FileType.File]);
            }
        }
        return w_directory;

    } else {
        throw vscode.FileSystemError.FileNotFound(p_uri);
    }
}

</t>
<t tx="felix.20240502002356.11">public createDirectory(p_uri: vscode.Uri): void {
    console.warn('DETACHED Called createDirectory with ', p_uri.path); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20240502002356.12">public writeFile(p_uri: vscode.Uri, p_content: Uint8Array, p_options: { create: boolean, overwrite: boolean }): void {
    if (this.preventSaveToLeo) {
        this.preventSaveToLeo = false;
    } else {
        void this._leoIntegration.triggerBodySave(true); // Might have been a vscode 'save' via the menu
    }
    const w_gnx = utils.leoUriToStr(p_uri);

    if (!this._openedBodiesInfo[w_gnx]) {
        console.error("LeoJS: Tried to save DETACHED but not in _openedBodiesGnx. gnx :", w_gnx);
    }
    this._setOpenedBodyTime(w_gnx);
    this._openedBodiesInfo[w_gnx].lastBodyLength = p_content.byteLength;
    this._fireSoon({ type: vscode.FileChangeType.Changed, uri: p_uri });
}

</t>
<t tx="felix.20240502002356.13">public rename(p_oldUri: vscode.Uri, p_newUri: vscode.Uri, p_options: { overwrite: boolean }): void {
    console.warn('DETACHED Called rename on ', p_oldUri.path, p_newUri.path); // should not happen
    this._fireSoon(
        { type: vscode.FileChangeType.Deleted, uri: p_oldUri },
        { type: vscode.FileChangeType.Created, uri: p_newUri }
    );
}

</t>
<t tx="felix.20240502002356.14">public delete(p_uri: vscode.Uri): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    if (this._openedBodiesInfo[w_gnx]) {
        delete this._openedBodiesInfo[w_gnx];
        delete this.openedBodiesVNodes[w_gnx];
    } else {
        // console.log("not deleted");
    }

    // dirname is just a slash "/"
    let w_dirname = p_uri.with({ path: path.posix.dirname(p_uri.path) });

    this._fireSoon(
        { type: vscode.FileChangeType.Changed, uri: w_dirname },
        { uri: p_uri, type: vscode.FileChangeType.Deleted }
    );
}

</t>
<t tx="felix.20240502002356.15">public copy(p_uri: vscode.Uri): void {
    console.warn('DETACHED Called copy on ', p_uri.path); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20240502002356.16">private _fireSoon(...p_events: vscode.FileChangeEvent[]): void {
    this._bufferedEvents.push(...p_events);
    if (this._fireSoonHandle) {
        clearTimeout(this._fireSoonHandle);
    }
    this._fireSoonHandle = setTimeout(() =&gt; {
        this._onDidChangeFileEmitter.fire(this._bufferedEvents);
        this._bufferedEvents.length = 0; // clearing events array
    }, 5);
}

</t>
<t tx="felix.20240502002356.2">/**
 * * Body panes implementation as a file system using "leointegDetached" as a scheme identifier
 */
export class LeoBodyDetachedProvider implements vscode.FileSystemProvider {

    // * Flag normally false
    public preventSaveToLeo: boolean = false;

    // * Last file read data with the readFile method
    private _lastGnx: string = ""; // gnx of last file read
    private _lastBodyData: string = ""; // body content of last file read

    // * List of currently VISIBLE opened body panes gnx (from 'watch' &amp; 'dispose' methods)
    public watchedBodiesGnx: string[] = [];

    // * List of gnx open in tab(s) (from tryApplyNodeToBody / switchBody and fs.delete)
    public openedBodiesVNodes: { [key: string]: ArchivedPosition } = {};
    private _openedBodiesInfo: { [key: string]: BodyTimeInfo } = {};

    // * An event to signal that a resource has been changed
    // * It should fire for resources that are being watched by clients of this provider
    private _onDidChangeFileEmitter = new vscode.EventEmitter&lt;vscode.FileChangeEvent[]&gt;();
    readonly onDidChangeFile: vscode.Event&lt;vscode.FileChangeEvent[]&gt; = this._onDidChangeFileEmitter.event;
    private _bufferedEvents: vscode.FileChangeEvent[] = [];
    private _fireSoonHandle?: NodeJS.Timer;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20240502002356.3">/**
 * * Sets selected node body's modified time for this gnx virtual file
 * @param p_uri URI of file for which to set made-up modified time
 */
public setNewBodyUriTime(p_uri: vscode.Uri, v: ArchivedPosition): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    this._setOpenedBodyTime(w_gnx);
    this.openedBodiesVNodes[w_gnx] = v;
}

</t>
<t tx="felix.20240502002356.4">/**
 * * Adds entries in _openedBodiesGnx and _openedBodiesInfo if needed
 * * and sets the modified time of an opened body.
 */
private _setOpenedBodyTime(p_gnx: string): void {
    const w_now = new Date().getTime();
    let w_created = w_now;
    if (this._openedBodiesInfo[p_gnx]) {
        w_created = this._openedBodiesInfo[p_gnx].ctime; // Already created?
    }

    this._openedBodiesInfo[p_gnx] = {
        ctime: w_created,
        mtime: w_now // new 'modified' time.
    };
}

</t>
<t tx="felix.20240502002356.5">/**
 * Remove entries of openedBodies if not in any tabGroups
 * * This matches _hideBodiesUnknownToFileSys from leoUI !
*/
public cleanupDetachedBodies(): void {
    const w_openedBodiesKeys = Object.keys(this._openedBodiesInfo);
    if (!w_openedBodiesKeys.length) {
        return; // Return if not even one to remove.
    }
    const w_foundTabsGnx: string[] = [];
    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_DETACHED_SCHEME
            ) {
                w_foundTabsGnx.push(utils.leoUriToStr((p_tab.input as vscode.TabInputText).uri));
            }
        });
    });

    for (const openBody of Object.keys(this._openedBodiesInfo)) {
        if (!w_foundTabsGnx.includes(openBody)) {
            // Not an opened tab! remove it!
            delete this._openedBodiesInfo[openBody];
            delete this.openedBodiesVNodes[openBody];
        }
    }
}

</t>
<t tx="felix.20240502002356.6">/**
 * * Refresh the body pane for a particular gnx by telling vscode that the file from the Leo file provider has changed
 * @param p_gnx Gnx of body associated with this virtual file, mostly Leo's selected node
 */
public fireRefreshFile(p_gnx: string): void {

    this._setOpenedBodyTime(p_gnx);

    if (!this.watchedBodiesGnx.includes(p_gnx)) {
        // * Should only be called if vscode.window.tabGroups contained an opened detached body.
        console.log('called fireRefreshFile on an unwatched DETACHED !', p_gnx);
        return; // Document is not being watched (closed tab or non-visible non-dirty tab)
    }

    this._onDidChangeFileEmitter.fire([{
        type: vscode.FileChangeType.Changed,
        uri: utils.strToLeoDetachedUri(p_gnx)
    }]);
}

</t>
<t tx="felix.20240502002356.7">public watch(p_resource: vscode.Uri, p_options: { readonly recursive: boolean; readonly excludes: readonly string[] }): vscode.Disposable {
    const w_gnx = utils.leoUriToStr(p_resource);
    if (!this.watchedBodiesGnx.includes(w_gnx)) {
        this.watchedBodiesGnx.push(w_gnx); // add gnx
    }
    // else already in list
    return new vscode.Disposable(() =&gt; {
        const w_position = this.watchedBodiesGnx.indexOf(w_gnx); // find and remove it
        if (w_position &gt; -1) {
            this.watchedBodiesGnx.splice(w_position, 1);
            this.cleanupDetachedBodies(); // IF NOT EVEN AN EXISTING TAB (not just hidden)
        }
    });
}

</t>
<t tx="felix.20240502002356.8">public stat(p_uri: vscode.Uri): vscode.FileStat | Thenable&lt;vscode.FileStat&gt; {
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        const w_gnx = utils.leoUriToStr(p_uri);

        const w_commanders: Set&lt;string&gt; = new Set();
        const w_detached: Set&lt;string&gt; = new Set(); // same whole gnx string as with setNewBodyUriTime

        for (const p_tabGroup of vscode.window.tabGroups.all) {
            for (const p_tab of p_tabGroup.tabs) {
                if (p_tab.input &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                    (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_DETACHED_SCHEME
                ) {
                    // Found detached. 
                    const [unused, id, gnx] = (p_tab.input as vscode.TabInputText).uri.path.split("/");
                    w_commanders.add(id);
                    w_detached.add(utils.leoUriToStr((p_tab.input as vscode.TabInputText).uri));
                }
            }
        }

        // w_commanders and w_detached are filled up!
        if (p_uri.fsPath.length === 1) {
            return { type: vscode.FileType.Directory, ctime: 0, mtime: 0, size: 0 };
        }

        const [unused, id, gnx] = p_uri.path.split("/");

        if (id &amp;&amp; !gnx) {
            return { type: vscode.FileType.Directory, ctime: 0, mtime: 0, size: 0 };
            // SPECIAL CASE -----------------------------------------------
        } else if (w_gnx === this._lastGnx &amp;&amp; this._openedBodiesInfo[this._lastGnx]) {
            return {
                type: vscode.FileType.File,
                ctime: this._openedBodiesInfo[this._lastGnx].ctime,
                mtime: this._openedBodiesInfo[this._lastGnx].mtime,
                size: this._openedBodiesInfo[this._lastGnx].lastBodyLength!
            };
            // ------------------------------------------------------------
        } else if (this._openedBodiesInfo[w_gnx]) {
            const id = p_uri.path.split("/")[1];
            const bodyGnx = p_uri.path.split("/")[2];

            return this._leoIntegration.sendAction(
                Constants.LEOBRIDGE.GET_BODY_LENGTH,
                { "gnx": bodyGnx, "commanderId": id }
            ).then((p_result) =&gt; {
                return Promise.resolve(
                    {
                        type: vscode.FileType.File,
                        ctime: this._openedBodiesInfo[w_gnx].ctime,
                        mtime: this._openedBodiesInfo[w_gnx].mtime,
                        size: p_result.len ? p_result.len : 0
                    }
                );
            });

            // let c: Commands;
            // let w_v: ArchivedPosition | undefined;
            // const id = p_uri.path.split("/")[1];
            // for (const w_frame of g.app.windowList) {
            //     if (w_frame.c.id.toString() === id) {
            //         c = w_frame.c;
            //         w_v = c.fileCommands.gnxDict[p_uri.path.split("/")[2]];
            //         break;
            //     }
            // }
            // if (w_v) {
            //     return {
            //         type: vscode.FileType.File,
            //         ctime: this._openedBodiesInfo[w_gnx].ctime,
            //         mtime: this._openedBodiesInfo[w_gnx].mtime,
            //         size: Buffer.byteLength(w_v.b, 'utf8') // w_v.b.length
            //     };
            // } else {
            //     console.warn('DETACHED BODY stat: not found!');
            // }
        } else {
            //  should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
            // console.error('DETACHED asked for STAT about file NOT IN _openedBodiesGnx ');
        }
    }
    // throw vscode.FileSystemError.FileNotFound();
    // (Instead of FileNotFound) should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
    return { type: vscode.FileType.File, ctime: 0, mtime: 0, size: 0 };
}

</t>
<t tx="felix.20240502002356.9">public async readFile(p_uri: vscode.Uri): Promise&lt;Uint8Array&gt; {
    if (this._leoIntegration.leoStates.fileOpenedReady) {

        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            throw vscode.FileSystemError.FileIsADirectory();
        } else {
            const w_gnx = utils.leoUriToStr(p_uri);

            // * should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
            // if (!this._openedBodiesInfo[w_gnx]) {
            //     console.warn('DETACHED readFile: ERROR File not in _openedBodiesGnx! gnx: ', w_gnx);
            // }
            const id = p_uri.path.split("/")[1];
            const bodyGnx = p_uri.path.split("/")[2];

            // console.log('detached read id: ', id, ' bodyGNX', bodyGnx);
            let w_buffer: Uint8Array;

            // * GET FROM SERVER
            const p_result = await this._leoIntegration.sendAction(
                Constants.LEOBRIDGE.GET_BODY,
                { "gnx": bodyGnx, "commanderId": id }
            );

            if (p_result.body) {
                // console.log('back from read gnx: ', w_gnx, '   - read ok has body');

                this._lastGnx = w_gnx;
                this._lastBodyData = p_result.body;
                if (this.openedBodiesVNodes[w_gnx]) {
                    this.openedBodiesVNodes[w_gnx]._lastBodyData = p_result.body;
                }
                w_buffer = Buffer.from(p_result.body);
                this._openedBodiesInfo[this._lastGnx].lastBodyLength = w_buffer.byteLength;

            } else if (p_result.body === "") {
                // console.log('back from read gnx: ', w_gnx, '  - read ok has empty body');

                this._lastGnx = w_gnx;
                this._lastBodyData = "";
                if (this.openedBodiesVNodes[w_gnx]) {
                    this.openedBodiesVNodes[w_gnx]._lastBodyData = '';
                }
                w_buffer = Buffer.from("");
                this._openedBodiesInfo[this._lastGnx].lastBodyLength = w_buffer.byteLength;

            } else {
                this._leoIntegration.fullRefresh();

                if (this._lastGnx === w_gnx) {
                    // was last gnx of closed file about to be switched to new document selected
                    w_buffer = Buffer.from(this._lastBodyData || "");
                } else {
                    // * should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
                    //console.error("DETACHED ERROR =&gt; readFile of unknown GNX"); // is possibleGnxList updated correctly?

                    //  throw vscode.FileSystemError.FileNotFound();
                    // (Instead of FileNotFound) should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
                    w_buffer = Buffer.from("");
                }
            }

            return w_buffer;

            // let c: Commands;
            // let w_v: ArchivedPosition | undefined;

            // const id = p_uri.path.split("/")[1];
            // for (const w_frame of g.app.windowList) {
            //     if (w_frame.c.id.toString() === id) {
            //         c = w_frame.c;
            //         w_v = c.fileCommands.gnxDict[p_uri.path.split("/")[2]];
            //         break;
            //     }
            // }

            // if (w_v) {
            //     this._errorRefreshFlag = false; // got body so reset possible flag!
            //     this._lastGnx = w_gnx;
            //     this._lastBodyData = w_v.b;
            //     const w_buffer: Uint8Array = Buffer.from(this._lastBodyData);
            //     return w_buffer;
            // } else {
            //     if (!this._errorRefreshFlag) {
            //         this._leoIntegration.fullRefresh();
            //     }
            //     if (this._lastGnx === w_gnx) {
            //         // was last gnx of closed file about to be switched to new document selected
            //         return Buffer.from(this._lastBodyData);
            //     }
            //     console.error("DETACHED ERROR =&gt; readFile of unknown GNX"); // is possibleGnxList updated correctly?
            //     return Buffer.from("");
            // }
        }





    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20240502210859.1">/**
* Builds a 'Leo Detached Scheme' vscode.Uri from a gnx 
* @param p_str leo node gnx strings are used to build Uri
* @returns A vscode 'Uri' object
*/
export function strToLeoDetachedUri(p_str: string): vscode.Uri {
    return vscode.Uri.parse(Constants.URI_SCHEME_DETACHED_HEADER + p_str);
}

</t>
<t tx="felix.20240502214807.1">/**
 * * Opens a detached body aside, and set focus in a body pane locked to its commander/gnx. 
 * - Does not select the node in the outline.
 * - If already opened aside in the same targeted column, just reveal.
 * @param p is the position node to be opened aside
 */
public async openAside(p?: ArchivedPosition): Promise&lt;unknown&gt; {
    // Those 'body panes' opened aside, (other than the main body pane), 
    // stay opened until the node's gnx becomes invalid/deleted, or it's commander is closed.
    await this.triggerBodySave(true);

    let c_id = this.leoStates.leoCommanderId;
    if (!p) {
        p = this.lastSelectedNode!;
    }
    const detachedUri = utils.strToLeoDetachedUri(`${c_id}/${p.gnx}`);

    // * Step 1 : Open the document
    this._leoDetachedFileSystem.setNewBodyUriTime(detachedUri, p);
    const w_openedDocument = await vscode.workspace.openTextDocument(detachedUri);
    this.bodyDetachedTextDocument = w_openedDocument;

    let q_bodyStates = this.sendAction(
        Constants.LEOBRIDGE.GET_BODY_STATES,
        utils.buildNodeCommand(p!)
    );

    const w_showOptions: vscode.TextDocumentShowOptions =
    {
        viewColumn: vscode.ViewColumn.Beside,
        preserveFocus: this.config.treeKeepFocusWhenAside,
        preview: false,
    };
    // * Actually Show the body pane document in a text editor
    const q_showTextDocument = vscode.window.showTextDocument(
        this.bodyDetachedTextDocument,
        w_showOptions
    );

    q_bodyStates.then((p_bodyStates: LeoBridgePackage) =&gt; {
        let w_language: string = p_bodyStates.language!;
        let w_wrap: boolean = !!p_bodyStates.wrap;
        let w_tabWidth: number | boolean = p_bodyStates.tabWidth || !!p_bodyStates.tabWidth;
        let w_gnx: string | undefined = p_bodyStates.selection?.gnx; // ? To verify if better than w_openedDocumentGnx ?

        // Replace language string if in 'exceptions' array
        w_language = Constants.LEO_LANGUAGE_PREFIX +
            (Constants.LANGUAGE_CODES[w_language] || w_language) +
            (w_wrap ? Constants.LEO_WRAP_SUFFIX : "");

        // Apply language if the selected node is still the same after all those events
        if (!w_openedDocument.isClosed) {
            // w_openedDocument still OPEN
            this._setBodyLanguage(w_openedDocument, w_language);

        }
        return p_bodyStates;
    });


    Promise.all([q_bodyStates, q_showTextDocument]).then(
        (p_values: [LeoBridgePackage, vscode.TextEditor]) =&gt; {

            // * Set text selection range
            const w_resultBodyStates = p_values[0];
            const w_bodyTextEditor = p_values[1];
            if (!w_resultBodyStates.selection) {
                console.log("no selection in returned package from get_body_states");
            }

            const w_leoBodySel: BodySelectionInfo = w_resultBodyStates.selection!;

            // Cursor position and selection range
            const w_activeRow: number = w_leoBodySel.insert.line;
            const w_activeCol: number = w_leoBodySel.insert.col;
            let w_anchorLine: number = w_leoBodySel.start.line;
            let w_anchorCharacter: number = w_leoBodySel.start.col;

            if (w_activeRow === w_anchorLine &amp;&amp; w_activeCol === w_anchorCharacter) {
                // Active insertion same as start selection, so use the other ones
                w_anchorLine = w_leoBodySel.end.line;
                w_anchorCharacter = w_leoBodySel.end.col;
            }

            const w_selection = new vscode.Selection(
                w_anchorLine,
                w_anchorCharacter,
                w_activeRow,
                w_activeCol
            );

            let w_scrollRange: vscode.Range | undefined;

            // Build scroll position from selection range.
            w_scrollRange = new vscode.Range(
                w_activeRow,
                w_activeCol,
                w_activeRow,
                w_activeCol
            );

            if (w_bodyTextEditor) {
                // this._revealType = RevealType.NoReveal; // ! IN CASE THIS WAS STILL UP FROM SHOW_OUTLINE

                w_bodyTextEditor.selection = w_selection; // set cursor insertion point &amp; selection range
                if (!w_scrollRange) {
                    w_scrollRange = w_bodyTextEditor.document.lineAt(0).range;
                }

                if (this._refreshType.scroll) {
                    this._refreshType.scroll = false;
                    // Set scroll approximation
                    w_bodyTextEditor.revealRange(w_scrollRange, vscode.TextEditorRevealType.InCenterIfOutsideViewport);
                }

            } else {
                console.log("no selection in returned package from showTextDocument");
            }

        }
    );
    return q_showTextDocument;
}

</t>
<t tx="felix.20240502215719.1">/**
 * * Closes all visible text editors that have Leo filesystem scheme (that are not dirty)
 */
export async function closeLeoTextEditors(): Promise&lt;unknown&gt; {

    const w_foundTabs: vscode.Tab[] = [];

    vscode.window.tabGroups.all.forEach((p_tabGroup) =&gt; {
        p_tabGroup.tabs.forEach((p_tab) =&gt; {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                ((p_tab.input as vscode.TabInputText).uri.scheme).startsWith(Constants.URI_LEO_SCHEME) &amp;&amp;
                !p_tab.isDirty
            ) {
                w_foundTabs.push(p_tab);
            }
        });
    });

    let q_closedTabs;
    if (w_foundTabs.length) {
        q_closedTabs = vscode.window.tabGroups.close(w_foundTabs, true);
        w_foundTabs.forEach((p_tab) =&gt; {
            if (p_tab.input) {
                vscode.commands.executeCommand(
                    'vscode.removeFromRecentlyOpened',
                    (p_tab.input as vscode.TabInputText).uri
                );
                // Delete to close all other body tabs.
                // (w_oldUri will be deleted last below)
                const w_edit = new vscode.WorkspaceEdit();
                w_edit.deleteFile((p_tab.input as vscode.TabInputText).uri, { ignoreIfNotExists: true });
                vscode.workspace.applyEdit(w_edit);
            }
        });
    } else {
        q_closedTabs = Promise.resolve(true);
    }
    return q_closedTabs;
}

</t>
<t tx="felix.20240502230536.1">/**
 * React to the closing of 'tabs' via
 * events from vscode.window.tabGroups
 */
public _onTabGroupsChanged(p_event: vscode.TabGroupChangeEvent): void {
    this.checkClosedTabs(); // debounced
}

</t>
<t tx="felix.20240502230541.1">/**
 * React to the closing of 'tabgroups' via
 * events from vscode.window.tabGroups
 */
public _onTabsChanged(p_event: vscode.TabChangeEvent): void {
    this.checkClosedTabs(); // debounced
}

</t>
<t tx="felix.20240502230658.1">private _refreshDetachedBodies() {
    //  Refresh detached bodies as needed IF SAME COMMANDER, AND CLOSE : 
    if (!this.leoStates.fileOpenedReady) {
        this._refreshType.excludeDetached = false;
        return;
    }

    const c_id = this.leoStates.leoCommanderId;
    const q_foundResults: Array&lt;Promise&lt;LeoBridgePackage&gt;&gt; = [];
    const w_sentFoundTabs: Array&lt;vscode.Tab&gt; = [];
    const w_sentFoundUri: Array&lt;vscode.Uri&gt; = [];
    let w_hasDetached = false;

    for (const p_tabGroup of vscode.window.tabGroups.all) {
        for (const p_tab of p_tabGroup.tabs) {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_DETACHED_SCHEME
            ) {
                const w_uri = (p_tab.input as vscode.TabInputText).uri;
                const [unused, id, gnx] = w_uri.path.split("/");

                if (id === c_id) {
                    w_hasDetached = true;
                }

                // Refresh detached bodies if same commander  // ! ALSO FIRE REFRESH !
                if (!this._refreshType.excludeDetached &amp;&amp; this._refreshType.body &amp;&amp; id === c_id) {
                    // console.log('fire refresh DETACHED in _refreshDetachedBodies');
                    this._leoDetachedFileSystem.fireRefreshFile(`${id}/${gnx}`);
                }

                // if refresh tree is true, validate that opened detached of same commander still valid and close as needed.
                if (this._refreshType.tree &amp;&amp; id === c_id &amp;&amp; !this._refreshType.documents) {
                    const w_foundVnode = this._leoDetachedFileSystem.openedBodiesVNodes[utils.leoUriToStr(w_uri)];
                    if (w_foundVnode) {
                        w_sentFoundTabs.push(p_tab);
                        w_sentFoundUri.push(w_uri);
                        q_foundResults.push(
                            this.sendAction(
                                Constants.LEOBRIDGE.GET_IS_VALID,
                                utils.buildNodeCommand(w_foundVnode) // No need to specify commander
                            )
                        );
                    }
                } else if (this._refreshType.documents) {
                    const w_foundVnode = this._leoDetachedFileSystem.openedBodiesVNodes[utils.leoUriToStr(w_uri)];
                    if (w_foundVnode) {
                        const param = utils.buildNodeCommand(w_foundVnode);
                        param["commanderId"] = id;
                        w_sentFoundTabs.push(p_tab);
                        w_sentFoundUri.push(w_uri);
                        q_foundResults.push(
                            this.sendAction(
                                Constants.LEOBRIDGE.GET_IS_VALID,
                                param
                            )
                        );
                    }

                }

            }

        }
    }
    if (w_hasDetached &amp;&amp; this._refreshType.tree) {
        this.refreshCommanderDetachedLanguage(); // May have moved outside of language specific outline
    }
    this._refreshType.excludeDetached = false;

    if (q_foundResults.length) {

        return Promise.all(q_foundResults).then((p_results) =&gt; {
            const w_foundTabs: Set&lt;vscode.Tab&gt; = new Set();
            const w_foundUri: Set&lt;vscode.Uri&gt; = new Set();

            let w_resultIndex = 0;
            for (const w_res of p_results) {
                if (!w_res.valid) {
                    w_foundTabs.add(w_sentFoundTabs[w_resultIndex]);
                    w_foundUri.add(w_sentFoundUri[w_resultIndex]);
                }
                w_resultIndex = w_resultIndex + 1;
            }

            if (w_foundTabs.size) {
                void vscode.window.tabGroups.close([...w_foundTabs], true);
                for (const w_uri of w_foundUri) {
                    void vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_uri);
                }
            }
        });
    }

}

</t>
<t tx="felix.20240502230809.1">private _checkClosedTabs(): void {
    // check if selected body still has opened textEditors
    let bodyCount = 0;
    for (const p_tabGroup of vscode.window.tabGroups.all) {
        for (const p_tab of p_tabGroup.tabs) {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                ((p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_SCHEME)
            ) {
                // a normal body (non detached found)
                bodyCount++;
                break;
            }
        }
        if (bodyCount) {
            break;
        }
    }
    if (!bodyCount) {
        // Make sure no more saving over possible detached with same gnx
        this._bodyLastChangedDocument = undefined;
        this._bodyLastChangedDocumentSaved = false;
    }
    this._leoFileSystem.cleanupBodies();
    this._leoDetachedFileSystem.cleanupDetachedBodies();
}

</t>
<t tx="felix.20240502230852.1">/**
 * Debounced refresh language for all detached bodies of active commander
 */
private _refreshCommanderDetachedLanguage(): void {

    const c_id = this.leoStates.leoCommanderId;
    const w_documents: vscode.TextDocument[] = [];
    const w_uris: string[] = [];

    for (const p_tabGroup of vscode.window.tabGroups.all) {
        for (const p_tab of p_tabGroup.tabs) {
            if (p_tab.input &amp;&amp;
                (p_tab.input as vscode.TabInputText).uri &amp;&amp;
                ((p_tab.input as vscode.TabInputText).uri.scheme === Constants.URI_LEO_DETACHED_SCHEME)
            ) {
                const [unused, id, gnx] = (p_tab.input as vscode.TabInputText).uri.path.split("/");
                if (id === c_id) {
                    // From same commander
                    if (!w_uris.includes((p_tab.input as vscode.TabInputText).uri.toString())) {
                        w_uris.push((p_tab.input as vscode.TabInputText).uri.toString());
                    }

                }
            }
        }
    }

    for (const w_doc of vscode.workspace.textDocuments) {
        if (!w_doc.isClosed &amp;&amp; w_uris.includes(w_doc.uri.toString())) {
            w_documents.push(w_doc);
        }
    }

    for (const w_doc of w_documents) {
        const w_foundVnode = this._leoDetachedFileSystem.openedBodiesVNodes[utils.leoUriToStr(w_doc.uri)];
        const id = w_doc.uri.path.split("/")[1];
        if (w_foundVnode) {
            void this.sendAction(
                Constants.LEOBRIDGE.GET_BODY_STATES,
                { gnx: w_foundVnode.gnx, commanderId: id }
            ).then((p_bodyStates: LeoBridgePackage) =&gt; {
                let w_language: string = p_bodyStates.language!;
                let w_wrap: boolean = !!p_bodyStates.wrap;
                let w_tabWidth: number | boolean = p_bodyStates.tabWidth || !!p_bodyStates.tabWidth;

                // Replace language string if in 'exceptions' array
                w_language = Constants.LEO_LANGUAGE_PREFIX +
                    (Constants.LANGUAGE_CODES[w_language] || w_language) +
                    (w_wrap ? Constants.LEO_WRAP_SUFFIX : "");

                // Apply language if the selected node is still the same after all those events
                if (!w_doc.isClosed) {
                    // w_doc still OPEN
                    this._setBodyLanguage(w_doc, w_language);

                }

            });
        } else {
            console.log('DETACHED VNODE not found when resetting language');
        }
    }

}

</t>
<t tx="felix.20240505142143.1">/**
 * * Looks for given position's coloring language, taking account of '@killcolor', etc.
 */
private async _getBodyLanguage(p: ArchivedPosition, c_id?: string): Promise&lt;string&gt; {
    if (!p) {
        p = this.lastSelectedNode!;
    }
    const param = utils.buildNodeCommand(p);
    if (c_id) {
        param["commanderId"] = c_id;
    }
    return this.sendAction(
        Constants.LEOBRIDGE.GET_BODY_STATES,
        param
    ).then((p_bodyStates: LeoBridgePackage) =&gt; {
        let w_language = p_bodyStates.language;
        let w_wrap: boolean = !!p_bodyStates.wrap;

        if (w_language) {
            // Replace language string if in 'exceptions' array
            w_language = Constants.LEO_LANGUAGE_PREFIX +
                (Constants.LANGUAGE_CODES[w_language] || w_language) +
                (w_wrap ? Constants.LEO_WRAP_SUFFIX : "");

            return w_language;
        } else {
            return "";
        }
    });
}

</t>
<t tx="felix.20240523231957.1">/**
 * Close all tabs that are not part of their filesystems
 * * This matches cleanupDetachedBodies from leoBodyDetached !
 */
private _hideBodiesUnknownToFileSys(p_editors: readonly vscode.TextEditor[]): void {
    p_editors.forEach((p_editor) =&gt; {
        if (p_editor) {
            switch (p_editor.document.uri.scheme) {
                case Constants.URI_LEO_SCHEME:
                    if (this.bodyUri.fsPath !== p_editor.document.uri.fsPath) {
                        void this._hideDeleteBody(p_editor);
                    }
                    this._checkPreviewMode(p_editor);
                    break;

                case Constants.URI_LEO_DETACHED_SCHEME:
                    const w_gnx = utils.leoUriToStr(p_editor.document.uri);
                    //if (!this._leoDetachedFileSystem.watchedBodiesGnx.includes(w_gnx)) {
                    if (!this._leoDetachedFileSystem.openedBodiesVNodes[w_gnx]) {
                        // unknown to the detached filesystem
                        void this._hideDeleteBody(p_editor);
                    }
                    break;

                default:
                    break;
            }

        }

    });
}

</t>
<t tx="fil.20210603195218.1">import * as vscode from "vscode";
import * as path from 'path';
import * as os from 'os';
import { LeoIntegration } from "./leoIntegration";
import * as utils from "./utils";

@language typescript
@tabwidth -4
@others
</t>
<t tx="fil.20210603195319.1">export class LeoSettingsProvider {

    private _panel: vscode.WebviewPanel | undefined;
    private readonly _extensionUri: vscode.Uri;
    private _html: string | undefined;
    private _waitingForUpdate: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._extensionUri = _context.extensionUri;
    }

    @others
}
</t>
<t tx="fil.20210603195319.2">public async changedConfiguration(p_event?: vscode.ConfigurationChangeEvent): Promise&lt;void&gt; {
    if (this._panel &amp;&amp; !this._waitingForUpdate) {
        await this._panel.webview.postMessage({ command: 'newConfig', config: this._leoIntegration.config.getConfig() });
    }
}

</t>
<t tx="fil.20210603195319.3">public openWebview(): Promise&lt;unknown&gt; {
    if (this._panel) {
        return Promise.resolve(this._panel.reveal());
    } else {
        this._panel = vscode.window.createWebviewPanel(
            'leoSettings', // Identifies the type of the webview. Used internally
            'Leo Integration Settings', // Title of the panel displayed to the user
            { viewColumn: vscode.ViewColumn.Beside, preserveFocus: false }, // Editor column to show the new webview panel in.
            {
                retainContextWhenHidden: false,
                enableFindWidget: true,
                enableCommandUris: true,
                enableScripts: true
            }
        );

        return this._getBaseHtml(this._panel.webview).then(p_baseHtml =&gt; {
            if (this._panel) {

                this._context.subscriptions.push(this._panel);

                // Get the local path to main script run in the webview, then convert it to a uri we can use in the webview.
                const scriptUri = this._panel.webview.asWebviewUri(
                    vscode.Uri.joinPath(this._extensionUri, 'settings-panel', 'main.js')
                );
                // Do the same for the stylesheet.
                const style = this._panel.webview.asWebviewUri(
                    vscode.Uri.joinPath(this._extensionUri, 'settings-panel', 'style.css')
                );

                const w_baseUri = this._panel.webview.asWebviewUri(this._extensionUri);

                this._panel.iconPath = vscode.Uri.joinPath(this._extensionUri, 'resources', 'leoapp128px.png');

                const w_nonce = utils.getNonce();

                this._context.subscriptions.push(
                    this._panel.webview.onDidReceiveMessage(
                        message =&gt; {
                            switch (message.command) {
                                case 'alert':
                                    void vscode.window.showErrorMessage(message.text);
                                    break;
                                case 'chooseLeoEditorPath':
                                    utils.chooseLeoFolderDialog().then(p_chosenPath =&gt; {
                                        if (this._panel &amp;&amp; p_chosenPath &amp;&amp; p_chosenPath.length) {
                                            this._panel.webview.postMessage(
                                                {
                                                    command: 'newEditorPath',
                                                    editorPath: p_chosenPath[0].fsPath
                                                }
                                            );
                                        }
                                    });
                                    break;
                                case 'getNewConfig':
                                    if (this._panel &amp;&amp; !this._waitingForUpdate) {
                                        void this._panel.webview.postMessage(
                                            {
                                                command: 'newConfig',
                                                config: this._leoIntegration.config.getConfig()
                                            }
                                        );
                                    }
                                    break;
                                case 'config':
                                    this._waitingForUpdate = true;
                                    void this._leoIntegration.config.setLeoIntegSettings(message.changes).then(() =&gt; {
                                        void this._panel!.webview.postMessage(
                                            {
                                                command: 'vscodeConfig',
                                                config: this._leoIntegration.config.getConfig()
                                            }
                                        );
                                        this._waitingForUpdate = false;
                                    });
                                    break;
                            }
                        },
                        null,
                        this._context.subscriptions
                    )
                );

                this._panel.webview.html = p_baseHtml
                    .replace(
                        /#{nonce}/g,
                        w_nonce
                    )
                    .replace(
                        /#{style}/g,
                        `${style}`
                    )
                    .replace(
                        /#{webview.cspSource}/g,
                        this._panel.webview.cspSource
                    )
                    .replace(
                        /#{root}/g,
                        `${w_baseUri}`
                    ).replace(
                        /#{endOfBody}/g,
                        `&lt;script type="text/javascript" nonce="${w_nonce}"&gt;window.leoConfig = ${JSON.stringify(
                            this._leoIntegration.config.getConfig()
                        )};window.platform = ${JSON.stringify(
                            os.platform()
                        )};&lt;/script&gt;
                    &lt;script nonce="${w_nonce}" src="${scriptUri}"&gt;&lt;/script&gt;
                    `
                    );

                this._panel.onDidDispose(
                    () =&gt; { this._panel = undefined; },
                    null,
                    this._context.subscriptions
                );
            }
        });
    }
}

</t>
<t tx="fil.20210603195319.4">private async _getBaseHtml(webview: vscode.Webview): Promise&lt;string&gt; {
    if (this._html !== undefined) {
        return this._html;
    } else {
        // 'Normal' uri, not a 'webview.asWebviewUri(...)' !
        const w_fileUri = vscode.Uri.joinPath(this._extensionUri, 'settings-panel', 'index.html');
        const w_doc = await vscode.workspace.openTextDocument(w_fileUri);
        this._html = w_doc.getText();
        return this._html;
    }
}
</t>
<t tx="fil.20210603195851.1">public resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken
) {
    this._view = webviewView;

    webviewView.webview.options = {
        // Allow scripts in the webview
        enableScripts: true,

        localResourceRoots: [this._extensionUri],
    };

    this._context.subscriptions.push(
        webviewView.webview.onDidReceiveMessage((data) =&gt; {
            switch (data.type) {
                case 'leoNavEnter': {
                    this._leoIntegration.navEnter();
                    break;
                }
                case 'leoNavTextChange': {
                    this._leoIntegration.navTextChange();
                    break;
                }
                case 'leoNavClear': {
                    this._leoIntegration.navTextClear();
                    break;
                }
                case 'leoNavMarkedList': {
                    this._leoIntegration.findQuickMarked(true);
                    break;
                }
                case 'gotFocus': {
                    utils.setContext(Constants.CONTEXT_FLAGS.FOCUS_FIND, true);
                    break;
                }
                case 'lostFocus': {
                    utils.setContext(Constants.CONTEXT_FLAGS.FOCUS_FIND, false);
                    break;
                }
                case 'leoFindNext': {
                    vscode.commands.executeCommand(Constants.COMMANDS.FIND_NEXT);
                    break;
                }
                case 'leoFindPrevious': {
                    vscode.commands.executeCommand(Constants.COMMANDS.FIND_PREVIOUS);
                    break;
                }
                case 'searchConfig': {
                    this._leoIntegration.saveSearchSettings(data.value);
                    break;
                }
                case 'replace': {
                    this._leoIntegration.replace(true, false);
                    break;
                }
                case 'replaceThenFind': {
                    this._leoIntegration.replace(true, true);
                    break;
                }
                case 'refreshSearchConfig': {
                    // Leave a cycle before getting settings
                    setTimeout(() =&gt; {
                        this._leoIntegration.loadSearchSettings();
                    }, 0);
                    break;
                }
            }
        })
    );
    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);
    this._leoIntegration.setFindPanel(this._view);
}

</t>
<t tx="fil.20210603195902.1">private _getHtmlForWebview(webview: vscode.Webview) {
    // Get the local path to main script run in the webview, then convert it to a uri we can use in the webview.
    const scriptUri = webview.asWebviewUri(
        vscode.Uri.joinPath(this._extensionUri, 'find-panel', 'main.js')
    );
    // Do the same for the stylesheet.
    const style = webview.asWebviewUri(
        vscode.Uri.joinPath(this._extensionUri, 'find-panel', 'style.css')
    );
    // Use a nonce to only allow a specific script to be run.
    const nonce = utils.getNonce();

    return `&lt;!DOCTYPE html&gt;
        &lt;html lang="en" tabindex="-1"&gt;
        &lt;head&gt;
            &lt;meta charset="UTF-8"&gt;
            &lt;meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource}; script-src 'nonce-${nonce}';"&gt;
            &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
            &lt;link href="${style}" rel="stylesheet"&gt;
            &lt;title&gt;Leo Find Panel&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;div class="row mb-0 nav-element"&gt;
                &lt;div class="col no-overflow"&gt;
                    &lt;label for="navText"&gt;Nav:&lt;/label&gt;
                    &lt;select
                        name="searchOptions"
                        id="searchOptions"
                        title="Confine search to:&amp;#013; - All: regular search for all nodes&amp;#013; - Subtree: current node and it's children&amp;#013; - File: only search under a node with an @&lt;file&gt; directive&amp;#013; - Chapter: only search under a node with an @chapter directer&amp;#013; - Node: only search currently selected node"
                    &gt;
                        &lt;option value="0"&gt;All&lt;/option&gt;
                        &lt;option value="1"&gt;Subtree&lt;/option&gt;
                        &lt;option value="2"&gt;File&lt;/option&gt;
                        &lt;option value="3"&gt;Chapter&lt;/option&gt;
                        &lt;option value="4"&gt;Node&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
                &lt;div class="col-nav"&gt;
                    &lt;input type="checkbox" id="isTag" name="isTag" &gt;
                    &lt;label class="label-fix" for="isTag" title="Search Tag attributes, set algebra is supported:&amp;#013;&amp;amp; both the given tags&amp;#013;&amp;vert; either of the given tags (or both)&amp;#013;&amp;#45; the first tag, but not the second tag&amp;#013;&amp;#94; either of the given tags (but *not* both)"
                    &gt;Tag&lt;/label&gt;

                    &lt;input type="checkbox" id="showParents" name="showParents" &gt;
                    &lt;label class="label-fix" for="showParents" title="List parents of nodes in text searches"&gt;Show parents&lt;/label&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="input-holder mt-0 mb-6 nav-element"&gt;
                &lt;input title="Typing searches headlines interactively&amp;#013;Enter freezes input and searches body text" type="text" id="navText" name="navText" placeholder="&lt;nav pattern here&gt;"&gt;
            &lt;/div&gt;
            &lt;div class="nav-element" id="freeze" title="Clear field to unfreeze"&gt;&amp;#x2744;&lt;/div&gt;

            &lt;label class="mb-0" for="findText"&gt;Find/Replace:&lt;/label&gt;
            &lt;div class="input-holder mt-4 mb-4"&gt;
                &lt;input title="Enter or F3 to find and goto the next match&amp;#013;F2 for the previous match" type="text" id="findText" name="findText" placeholder="&lt;find pattern here&gt;" &gt;
            &lt;/div&gt;
            &lt;div class="input-holder mb-4"&gt;
                &lt;input title="Replace (Ctrl+=)&amp;#013;Replace &amp;amp; Find Next (Ctrl+-)" type="text" id="replaceText" name="replaceText" placeholder="&lt;replace pattern here&gt;" &gt;
            &lt;/div&gt;
            &lt;div class="row"&gt;
                &lt;div class="col"&gt;
                    &lt;input type="checkbox" id="wholeWord" name="wholeWord" &gt;
                    &lt;label title="Match Whole Word (Ctrl+Alt+W)" class="label-fix" for="wholeWord"&gt;Whole &lt;u&gt;w&lt;/u&gt;ord&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="ignoreCase" name="ignoreCase" &gt;
                    &lt;label title="Matches Ignore Case (Ctrl+Alt+I)" class="label-fix" for="ignoreCase"&gt;&lt;u&gt;I&lt;/u&gt;gnore case&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="regExp" name="regExp" &gt;
                    &lt;label title="Use Regular Expression (Ctrl+Alt+X)" class="label-fix" for="regExp"&gt;Rege&lt;u&gt;x&lt;/u&gt;p&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="markFinds" name="markFinds" &gt;
                    &lt;label title="Mark Found nodes (Ctrl+Alt+F)" class="label-fix" for="markFinds"&gt;Mark &lt;u&gt;f&lt;/u&gt;inds&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="markChanges" name="markChanges" &gt;
                    &lt;label title="Mark Changed nodes (Ctrl+Alt+C)" class="label-fix" for="markChanges"&gt;Mark &lt;u&gt;c&lt;/u&gt;hanges&lt;/label&gt;
                &lt;/div&gt;
                &lt;div class="col"&gt;
                    &lt;!-- RADIOS --&gt;
                    &lt;input type="radio" id="entireOutline" name="searchScope" value="0"&gt;
                    &lt;label title="Search in Whole Outline (Ctrl+Alt+E)" class="label-fix" for="entireOutline"&gt;&lt;u&gt;E&lt;/u&gt;ntire outline&lt;/label&gt;&lt;br&gt;
                    &lt;input type="radio" id="subOutlineOnly" name="searchScope" value="1"&gt;
                    &lt;label title="Limit to Selected Outline (Ctrl+Alt+S)" class="label-fix" for="subOutlineOnly"&gt;&lt;u&gt;S&lt;/u&gt;uboutline Only&lt;/label&gt;&lt;br&gt;
                    &lt;input type="radio" id="nodeOnly" name="searchScope" value="2"&gt;
                    &lt;label title="Limit to Selected Node (Ctrl+Alt+N)" class="label-fix" for="nodeOnly"&gt;&lt;u&gt;N&lt;/u&gt;ode only&lt;/label&gt;&lt;br&gt;
                    &lt;input type="radio" id="fileOnly" name="searchScope" value="3"&gt;
                    &lt;label title="Limit to External Files (Ctrl+Alt+L)" class="label-fix" for="fileOnly"&gt;Fi&lt;u&gt;l&lt;/u&gt;e only&lt;/label&gt;&lt;br&gt;
                    &lt;!-- CHECKBOXES --&gt;
                    &lt;input type="checkbox" id="searchHeadline" name="searchHeadline" &gt;
                    &lt;label title="Search in Headlines (Ctrl+Alt+H)" class="label-fix" for="searchHeadline"&gt;Search &lt;u&gt;h&lt;/u&gt;eadline&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="searchBody" name="searchBody" &gt;
                    &lt;label title="Search in Body Text (Ctrl+Alt+B)" class="label-fix" for="searchBody"&gt;Search &lt;u&gt;b&lt;/u&gt;ody&lt;/label&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;script nonce="${nonce}" src="${scriptUri}"&gt;&lt;/script&gt;
        &lt;/body&gt;
        &lt;/html&gt;`;
}

</t>
<t tx="fil.20210603223013.1"></t>
<t tx="fil.20210603223013.2">@language css
html {
  box-sizing: border-box;
  font-size: 13px;
  overflow: hidden;
  --input-padding-vertical: 6px;
  --input-padding-horizontal: 4px;
  --input-margin-vertical: 4px;
  --input-margin-horizontal: 0;
  height: 100%;
}


*,
*:before,
*:after {
  box-sizing: inherit;
}

body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
ol,
ul {
  margin: 0;
  padding: 0;
  font-weight: normal;
}

img {
  max-width: 100%;
  height: auto;
}

html:focus:after {
  content:'';
  position: fixed;
  top:0;
  bottom: 0;
  left: 0;
  right: 0;
  outline: 1px solid;
  outline-width: 1px;
  outline-style: solid;
  outline-offset: -1px;
  outline-color: var(--vscode-focusBorder);
  pointer-events: none;
}

body {
  height: 100%;
  margin-left: 20px;
  background-color: transparent;
  padding: 0 var(--container-padding);
  scrollbar-gutter: stable;
  overflow:hidden;
  padding-right: 4px;
  color: var(--vscode-foreground);
  font-size: var(--vscode-font-size);
  font-weight: var(--vscode-font-weight);
  font-family: var(--vscode-font-family);
}

body:hover {
  overflow-y: auto;
} 

.row .col:nth-child(2) {
  padding-right: 4px;
}

ol,
ul {
  padding-left: var(--container-padding);
}

body&gt;*,
form&gt;* {
  margin-block-start: var(--input-margin-vertical);
  margin-block-end: var(--input-margin-vertical);
}

*:focus {
  outline-color: var(--vscode-focusBorder);
}

a {
  color: var(--vscode-textLink-foreground);
}

a:hover,
a:active {
  color: var(--vscode-textLink-activeForeground);
}

code {
  font-size: var(--vscode-editor-font-size);
  font-family: var(--vscode-editor-font-family);
}

button {
  border: none;
  padding: var(--input-padding-vertical) var(--input-padding-horizontal);
  width: 100%;
  text-align: center;
  outline: 1px solid transparent;
  outline-offset: 2px !important;
  color: var(--vscode-button-foreground);
  background: var(--vscode-button-background);
}

button:hover {
  cursor: pointer;
  background: var(--vscode-button-hoverBackground);
}

button:focus {
  outline-color: var(--vscode-focusBorder);
}

button.secondary {
  color: var(--vscode-button-secondaryForeground);
  background: var(--vscode-button-secondaryBackground);
}

button.secondary:hover {
  background: var(--vscode-button-secondaryHoverBackground);
}

select {
  background: var(--vscode-dropdown-background);
  color: var(--vscode-input-foreground);
  border-color: var(--vscode-dropdown-border);
  cursor: pointer;
  width: 50px;
  left: 15%;
  position: relative;
  border-radius: 2px;
}

select:focus {
  outline-color: var(--vscode-input-border);
}

select:disabled {
  opacity: 0.5;
  cursor: default;
}

select option {
  background-color: var(--vscode-dropdown-listBackground);
}

select option:focus {
  background-color: var(--vscode-input-background);
  outline-color: var(--vscode-input-border);
}

input:not([type="radio"]):not([type="checkbox"]),
textarea {
  display: block;
  margin-right: 20px;
  width: 100%;
  border: none;
  font-family: var(--vscode-font-family);
  padding: var(--input-padding-vertical) var(--input-padding-horizontal);
  padding: 3px var(--input-padding-horizontal);
  border-radius: 2px;
  color: var(--vscode-input-foreground);
  outline-color: var(--vscode-input-border);
  background-color: var(--vscode-input-background);
}

input[type="checkbox"],
input[type="radio"] {
  cursor: pointer;
}

input[type="checkbox"]:focus+label {
  border: 1px solid var(--vscode-button-background);
}

input[type="radio"]:focus+label {
  border: 1px solid var(--vscode-button-background);
}

input:disabled {
  opacity: 0.5;
  cursor: default;
}

input::placeholder,
textarea::placeholder {
  color: var(--vscode-input-placeholderForeground);
}

u {
  color: var(--vscode-editor-foreground);
  text-decoration-color: var(--vscode-foreground);
  text-underline-offset: 0.04em;
}

body&gt;div&gt;div&gt;label:focus,
body&gt;div&gt;div&gt;label:active {
  outline-color: none !important;
  border: none !important;
}

#freeze {
  cursor: default;
  position: absolute;
  right: 0.9em;
  line-height: 1em;
  top: 1.05em;
  font-size: 1.8em;
  color: #5c87ff80;
  padding: 0;
  margin: 0;
}

.comment {
  display: none;
}

div.row {
  overflow-x: hidden;
  white-space: nowrap;
}

div.col {
  vertical-align: top;
  width: 50%;
  max-width: 9.5em;
  display: inline-block;
  text-overflow: ellipsis;
  overflow: hidden;
}

div.col-nav {
  width: 50%;
  display: inline-block;
  text-overflow: ellipsis;
  overflow: hidden;
}

.mt-0 {
  margin-top: 0;
}

.mt-4 {
  margin-top: 4px;
}

.mb-0 {
  margin-bottom: 0;
}

.mb-4 {
  margin-bottom: 4px;
}

.mb-6 {
  margin-bottom: 6px;
}

.input-holder {
  padding: 0;
  margin-right: 6px;
}

.align-right {
  text-align: right;
}

.float-left {
  float: left;
}

.float-right {
  float: right;
}

.no-overflow {
  text-overflow: unset !important;
}

.label-fix {
  vertical-align: top;
  line-height: 18px;
}
</t>
<t tx="fil.20210603223013.4">@others
@language javascript
@tabwidth -4
</t>
<t tx="fil.20210603223933.1"></t>
<t tx="fil.20210603223933.165">@language javascript
// @ts-check

// This script will be run within the webview itself
// It cannot access the main VS Code APIs directly.
// Send message to LeoInteg with vscode.postMessage({ keyNameEx1: someValue, ... });
// Receive messages from LeoInteg with window.addEventListener('message', event =&gt; { ... });
(function () {
    const cssColorRegex = /^(?:(#?)([0-9a-f]{3}|[0-9a-f]{6})|((?:rgb|hsl)a?)\((-?\d+%?)[,\s]+(-?\d+%?)[,\s]+(-?\d+%?)[,\s]*(-?[\d.]+%?)?\))$/i;

    // @ts-expect-error
    const vscode = acquireVsCodeApi();

    initializeAndWatchThemeColors();

    const toast = document.getElementById("saved-config-toast");
    const dirty = document.getElementById("dirty-config-toast");
    const resultingCommandEl = document.getElementById("resultingCommand");
    const leoPythonCommandEl = document.getElementById("leoPythonCommand");
    const leoEditorPathEl = document.getElementById("leoEditorPath");
    const connectionPortEl = document.getElementById("connectionPort");
    const limitUsersEl = document.getElementById("limitUsers");

    const oldState = vscode.getState();
    let currentCount = (oldState &amp;&amp; oldState.count) || 0;
    if (currentCount) {
        vscode.postMessage({
            command: "getNewConfig"
        });
    }
    currentCount = currentCount + 1;
    vscode.setState({ count: currentCount });

    // Global variable config
    let frontConfig = {};
    let vscodeConfig = {};

    // @ts-expect-error
    vscodeConfig = window.leoConfig; // PRE SET BY leoSettingsWebview
    frontConfig = JSON.parse(JSON.stringify(vscodeConfig));

    // @ts-expect-error
    let vscodePlatform = window.platform; // PRE SET BY leoSettingsWebview
    let _platform = JSON.parse(JSON.stringify(vscodePlatform));
    console.log("_platform", _platform);
    let _isWin32 = _platform === "win32";

    // Handle messages sent from the extension to the webview
    window.addEventListener("message", event =&gt; {
        const message = event.data; // The json data that the extension sent
        if (message.command &amp;&amp; dirty &amp;&amp; toast) {
            switch (message.command) {
                case "test":
                    break;
                case "newConfig":
                    vscodeConfig = message.config;
                    frontConfig = JSON.parse(JSON.stringify(message.config));
                    setControls();
                    applyResultingCommand();
                    break;
                case "vscodeConfig":
                    dirty.className = dirty.className.replace("show", "");
                    toast.className = "show";
                    setTimeout(function () {
                        toast.className = toast.className.replace("show", "");
                    }, 1500);
                    vscodeConfig = message.config; // next changes will be confronted to those settings
                    break;
                case "newEditorPath":
                    const w_element = document.getElementById("leoEditorPath");
                    if (w_element) {
                        // @ts-expect-error
                        w_element.value = message.editorPath;
                        onInputChanged(w_element);
                    }
                    break;
                default:
                    break;
            }
        } else {
            console.log('got object without command:', message);
        }
    });

    function adjustLight(color, amount) {
        const cc = color + amount;
        const c = amount &lt; 0 ? (cc &lt; 0 ? 0 : cc) : cc &gt; 255 ? 255 : cc;

        return Math.round(c);
    }

    function darken(color, percentage) {
        return lighten(color, -percentage);
    }

    function lighten(color, percentage) {
        const rgba = toRgba(color);
        if (rgba == null) { return color; }

        const [r, g, b, a] = rgba;
        const amount = (255 * percentage) / 100;
        return `rgba(${adjustLight(r, amount)}, ${adjustLight(g, amount)}, ${adjustLight(b, amount)}, ${a})`;
    }

    function opacity(color, percentage) {
        const rgba = toRgba(color);
        if (rgba == null) { return color; }

        const [r, g, b, a] = rgba;
        return `rgba(${r}, ${g}, ${b}, ${a * (percentage / 100)})`;
    }

    function toRgba(color) {
        color = color.trim();

        const result = cssColorRegex.exec(color);
        if (result == null) { return null; }

        if (result[1] === '#') {
            const hex = result[2];
            switch (hex.length) {
                case 3:
                    return [parseInt(hex[0] + hex[0], 16), parseInt(hex[1] + hex[1], 16), parseInt(hex[2] + hex[2], 16), 1];
                case 6:
                    return [
                        parseInt(hex.substring(0, 2), 16),
                        parseInt(hex.substring(2, 4), 16),
                        parseInt(hex.substring(4, 6), 16),
                        1
                    ];
            }

            return null;
        }

        switch (result[3]) {
            case 'rgb':
                return [parseInt(result[4], 10), parseInt(result[5], 10), parseInt(result[6], 10), 1];
            case 'rgba':
                return [parseInt(result[4], 10), parseInt(result[5], 10), parseInt(result[6], 10), parseFloat(result[7])];
            default:
                return null;
        }
    }

    function initializeAndWatchThemeColors() {
        const onColorThemeChanged = () =&gt; {
            const body = document.body;
            const computedStyle = window.getComputedStyle(body);

            const bodyStyle = body.style;

            const font = computedStyle.getPropertyValue('--vscode-font-family').trim();
            if (font) {
                bodyStyle.setProperty('--font-family', font);
                bodyStyle.setProperty('--font-size', computedStyle.getPropertyValue('--vscode-font-size').trim());
                bodyStyle.setProperty('--font-weight', computedStyle.getPropertyValue('--vscode-font-weight').trim());
            } else {
                bodyStyle.setProperty(
                    '--font-family',
                    computedStyle.getPropertyValue('--vscode-editor-font-family').trim()
                );
                bodyStyle.setProperty('--font-size', computedStyle.getPropertyValue('--vscode-editor-font-size').trim());
                bodyStyle.setProperty(
                    '--font-weight',
                    computedStyle.getPropertyValue('--vscode-editor-font-weight').trim()
                );
            }

            let color = computedStyle.getPropertyValue('--vscode-editor-background').trim();
            bodyStyle.setProperty('--color-background', color);
            bodyStyle.setProperty('--color-background--lighten-05', lighten(color, 5));
            bodyStyle.setProperty('--color-background--darken-05', darken(color, 5));
            bodyStyle.setProperty('--color-background--lighten-075', lighten(color, 7.5));
            bodyStyle.setProperty('--color-background--darken-075', darken(color, 7.5));
            bodyStyle.setProperty('--color-background--lighten-15', lighten(color, 15));
            bodyStyle.setProperty('--color-background--darken-15', darken(color, 15));
            bodyStyle.setProperty('--color-background--lighten-30', lighten(color, 30));
            bodyStyle.setProperty('--color-background--darken-30', darken(color, 30));
            bodyStyle.setProperty('--color-background--lighten-50', lighten(color, 50));
            bodyStyle.setProperty('--color-background--darken-50', darken(color, 50));

            color = computedStyle.getPropertyValue('--vscode-button-background').trim();
            bodyStyle.setProperty('--color-button-background', color);
            bodyStyle.setProperty('--color-button-background--darken-30', darken(color, 30));

            color = computedStyle.getPropertyValue('--vscode-button-foreground').trim();
            bodyStyle.setProperty('--color-button-foreground', color);

            color = computedStyle.getPropertyValue('--vscode-editor-foreground').trim();
            if (!color) {
                color = computedStyle.getPropertyValue('--vscode-foreground').trim();
            }
            bodyStyle.setProperty('--color-foreground', color);
            bodyStyle.setProperty('--color-foreground--85', opacity(color, 85));
            bodyStyle.setProperty('--color-foreground--75', opacity(color, 75));
            bodyStyle.setProperty('--color-foreground--65', opacity(color, 65));
            bodyStyle.setProperty('--color-foreground--50', opacity(color, 50));

            color = computedStyle.getPropertyValue('--vscode-focusBorder').trim();
            bodyStyle.setProperty('--color-focus-border', color);

            color = computedStyle.getPropertyValue('--vscode-textLink-foreground').trim();
            bodyStyle.setProperty('--color-link-foreground', color);
            bodyStyle.setProperty('--color-link-foreground--darken-20', darken(color, 20));
            bodyStyle.setProperty('--color-link-foreground--lighten-20', lighten(color, 20));
        };

        const observer = new MutationObserver(onColorThemeChanged);
        observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });

        onColorThemeChanged();
        return observer;
    }

    function listenAll(selector, name, listener) {
        const els = document.querySelectorAll(selector);
        for (const el of els) {
            el.addEventListener(name, listener, false);
        }
    }

    function chooseLeoEditorPath() {
        vscode.postMessage({
            command: "chooseLeoEditorPath"
        });
    }

    function onBind() {
        listenAll('input[type=checkbox][data-setting]', 'change', function (p_this) {
            return onInputChecked(p_this.target);
        });
        listenAll('input[type=text][data-setting], input:not([type])[data-setting]', 'blur', function (
            p_this
        ) {
            return onInputBlurred(p_this.target);
        });
        listenAll('input[type=text][data-setting], input:not([type])[data-setting]', 'focus', function (
            p_this
        ) {
            return onInputFocused(p_this.target);
        });
        listenAll('input[type=text][data-setting], input[type=number][data-setting]', 'input', function (
            p_this
        ) {
            return onInputChanged(p_this.target);
        });
        listenAll('select[data-setting]', 'change', function (p_this) {
            return onDropdownChanged(p_this.target);
        });
    }
    function showDirtyAndApplyChange() {
        if (dirty) {
            dirty.className = "show";
        }
        applyChanges();
    }

    function onDropdownChanged(element) {
        if (element) {
            const w_value = element.options[element.selectedIndex].value;
            frontConfig[element.id] = w_value;
        }
        showDirtyAndApplyChange();
    }

    function onInputChecked(element) {
        frontConfig[element.id] = element.checked;
        setVisibility(frontConfig);
        showDirtyAndApplyChange();
    }
    function onInputBlurred(element) {
        // console.log('onInputBlurred', element);
    }
    function onInputFocused(element) {
        // console.log('onInputFocused', element);
    }

    function onInputChanged(element) {
        if (element.type === 'number' &amp;&amp; Number(element.value) &lt; Number(element.max) &amp;&amp; Number(element.value) &gt; Number(element.min)) {
            frontConfig[element.id] = Number(element.value);
            element.classList.remove("is-invalid");
            showDirtyAndApplyChange();
        } else if (element.type === 'number' &amp;&amp; (Number(element.value) &gt; Number(element.max) || Number(element.value) &lt; Number(element.min))) {
            // make red
            element.classList.add("is-invalid");
        } else if (element.type === 'text' &amp;&amp; (element.value.length &gt; element.maxLength || (element.value.length &lt; element.minLength &amp;&amp; element.value.length !== 0))) {
            element.classList.add("is-invalid");
        } else if (element.type === 'text' &amp;&amp; element.value.length &lt;= element.maxLength) {
            element.classList.remove("is-invalid");
            frontConfig[element.id] = element.value;
            showDirtyAndApplyChange();
        }
        if (element.type === 'text' || element.type === 'number') {
            applyResultingCommand();
        }
    }

    function setControls() {
        // 1- Set leointeg's own configuration settings
        for (const key in frontConfig) {
            if (frontConfig.hasOwnProperty(key)) {
                const w_element = document.getElementById(key);
                if (w_element &amp;&amp; w_element.getAttribute('type') === 'checkbox') {
                    // @ts-expect-error
                    w_element.checked = frontConfig[key];
                } else if (w_element) {
                    // @ts-expect-error
                    w_element.value = frontConfig[key];
                } else {
                    console.log('ERROR : w_element', key, ' is ', w_element);
                }
            }
        }
    }

    function setVisibility(state) {
        for (const el of document.querySelectorAll('[data-visibility]')) {
            // @ts-expect-error
            el.classList.toggle('hidden', !evaluateStateExpression(el.dataset.visibility, state));
        }
    }
    function parseStateExpression(expression) {
        const [lhs, op, rhs] = expression.trim().split(/([=+!])/);
        return [lhs.trim(), op !== undefined ? op.trim() : '=', rhs !== undefined ? rhs.trim() : rhs];
    }

    function evaluateStateExpression(expression, changes) {
        let state = false;

        for (const expr of expression.trim().split('&amp;')) {
            const [lhs, op, rhs] = parseStateExpression(expr);

            switch (op) {
                case '=': {
                    // Equals
                    let value = changes[lhs];
                    if (value === undefined) {
                        value = getSettingValue(lhs) || false;
                    }
                    state = rhs !== undefined ? rhs === String(value) : Boolean(value);
                    break;
                }
                case '!': {
                    // Not equals
                    let value = changes[lhs];
                    if (value === undefined) {
                        value = getSettingValue(lhs) || false;
                    }
                    state = rhs !== undefined ? rhs !== String(value) : !value;
                    break;
                }
                case '+': {
                    // Contains
                    if (rhs !== undefined) {
                        const setting = getSettingValue(lhs);
                        state = setting !== undefined ? setting.includes(rhs.toString()) : false;
                    }
                    break;
                }
            }

            if (!state) { break; }
        }
        return state;
    }

    function getSettingValue(p_setting) {
        return frontConfig[p_setting];
    }

    function escapeHtml(unsafe) {
        return unsafe
            .replace(/&amp;/g, "&amp;amp;")
            .replace(/&lt;/g, "&amp;lt;")
            .replace(/&gt;/g, "&amp;gt;")
            .replace(/"/g, "&amp;quot;")
            .replace(/'/g, "&amp;#039;");
    }

    function resultingCommand() {

        if (resultingCommandEl &amp;&amp; leoPythonCommandEl) {
            // @ts-expect-errorts
            let w_serverScriptPath = (leoEditorPathEl.value &amp;&amp; leoEditorPathEl.value.trim()) ? leoEditorPathEl.value.trim() + "/leo/core" : "";
            if (!w_serverScriptPath.trim()) {
                resultingCommandEl.innerHTML = "Please set your Leo-Editor installation path";
                resultingCommandEl.style.opacity = "0.3";
                return;
            }

            let w_pythonPath = ""; // Command of child.spawn call
            let w_args = []; //  "\"" + w_serverScriptPath + "\"" // For on windows ??
            // @ts-expect-errorts
            let w_leoPythonCommand = leoPythonCommandEl.value ? leoPythonCommandEl.value : "";

            // @ts-expect-errorts
            let w_usingPort = connectionPortEl.value ? connectionPortEl.value : 32125;
            // @ts-expect-errorts
            let w_limitUsers = limitUsersEl.value ? limitUsersEl.value : 0;

            if (w_leoPythonCommand &amp;&amp; w_leoPythonCommand.length) {
                // Start by running command (see executeCommand for multiple useful snippets)
                w_pythonPath = w_leoPythonCommand; // Set path
            } else {
                w_pythonPath = "python3";
                if (_isWin32) {
                    w_pythonPath = "py";
                }
            }

            if (_isWin32 &amp;&amp; w_pythonPath === "py") {
                w_args.push("-3");
            }
            w_args.push(w_serverScriptPath.trim());


            if (w_limitUsers &gt; 1 &amp;&amp;
                w_limitUsers &lt; 256) {
                w_args.push("--limit");
                w_args.push(w_limitUsers.toString());
            }

            // Add port
            w_args.push("--port");
            w_args.push(w_usingPort.toString());

            resultingCommandEl.innerHTML = escapeHtml(w_pythonPath + " " + w_args.join(" ")).trim();
            resultingCommandEl.style.opacity = "1.0";

        }

    }

    function debounce(func, timeout = 300) {
        let timer;
        return (...args) =&gt; {
            clearTimeout(timer);
            timer = setTimeout(() =&gt; { func.apply(this, args); }, timeout);
        };
    }

    var applyResultingCommand = debounce(
        function () {
            resultingCommand();
        },
        300
    );

    var applyChanges = debounce(
        function () {
            var w_changes = [];
            if (frontConfig) {
                for (var prop in frontConfig) {
                    if (Object.prototype.hasOwnProperty.call(frontConfig, prop)) {
                        if (frontConfig[prop] !== vscodeConfig[prop]) {
                            w_changes.push({ code: prop, value: frontConfig[prop] });
                        }
                    }
                }
            }
            if (w_changes.length) {
                // ok replace!
                vscodeConfig = frontConfig;
                frontConfig = JSON.parse(JSON.stringify(frontConfig));
                vscode.postMessage({
                    command: "config",
                    changes: w_changes
                });
            } else if (dirty) {
                // Still have to remove 'modified' popup
                dirty.className = dirty.className.replace("show", "");
            }
        },
        1500
    );

    // START
    const w_button = document.getElementById('chooseLeoEditorPath');
    if (w_button) {
        w_button.onclick = chooseLeoEditorPath;
    }
    setControls();
    setVisibility(frontConfig);
    onBind();
    setTimeout(applyResultingCommand, 100);

})();

</t>
<t tx="fil.20210603223933.9">@language html
@tabwidth -2
&lt;!DOCTYPE html&gt;
&lt;html lang="en" tabindex="-1"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;meta http-equiv="Content-Security-Policy"
    content="default-src 'none'; style-src #{webview.cspSource}; img-src #{webview.cspSource} https:; script-src 'nonce-#{nonce}';" /&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
  &lt;link href="#{style}" rel="stylesheet" /&gt;
  &lt;title&gt;Leo Integration&lt;/title&gt;
&lt;/head&gt;

&lt;body class="preload"&gt;
  &lt;div class="container"&gt;
    &lt;header&gt;
      &lt;a class="header__link" title="Learn more about Leo Integration"
        href="https://github.com/boltex/leointeg#-leo-for-vs-code"&gt;
        &lt;div class="header__logo"&gt;
          &lt;img class="image__logo" src="#{root}/resources/leoapp128px.png" /&gt;
          &lt;div&gt;
            &lt;h1&gt;
              Leo&lt;span class="header__logo--highlight"&gt;Integ&lt;/span&gt;
            &lt;/h1&gt;
            &lt;p class="header__subtitle"&gt;Leo for VS Code&lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/a&gt;
      &lt;p class="header__blurb"&gt;
        Use &lt;b&gt;Leo&lt;/b&gt;, the &lt;b&gt;Literate Editor with Outlines&lt;/b&gt;, to
        program with &lt;b&gt;directed acyclic graphs&lt;/b&gt;, along with
        &lt;b&gt;section-references&lt;/b&gt;, &lt;b&gt;@others&lt;/b&gt;, and
        &lt;b&gt;clones&lt;/b&gt;.
      &lt;/p&gt;
    &lt;/header&gt;

    &lt;div class="content__area"&gt;
      &lt;section id="welcome" class="section--full mb-0"&gt;
        &lt;h2 class="section__title section__title--primary"&gt;
          Welcome to &lt;span class="highlight"&gt;LeoInteg 1.0.21&lt;/span&gt;
        &lt;/h2&gt;
        &lt;div class="center mt-1"&gt;
          &lt;a class="button button--flat is-sidebar-hidden"
            title="LeoInteg is built by the support of generous users like you!"
            href="https://boltex.github.io/"&gt;Sponsor LeoInteg
            &lt;span class="heart"&gt;&amp;#x2764;&lt;/span&gt;
          &lt;/a&gt;
          &lt;a class="button button--flat" title="LeoInteg's Features"
            href="https://github.com/boltex/leointeg#features-"&gt;
            See What's New in LeoInteg 1.0.21
          &lt;/a&gt;
        &lt;/div&gt;
        &lt;p class="blurb center ml-0 mr-0"&gt;
          &lt;strong&gt;LeoInteg&lt;/strong&gt;
          is an open-source extension created by
          &lt;a class="bold" title="My github user page" href="https://boltex.github.io/"&gt;Flix&lt;/a&gt;
          that integrates
          &lt;a class="bold" title="Learn more about Leo" href="https://leo-editor.github.io/leo-editor/"&gt;Leo&lt;/a&gt;
          into VS Code.
        &lt;/p&gt;
        &lt;h2 class="section__title section__title--break"&gt;&lt;/h2&gt;
        &lt;p class="section__hint mt-0 center"&gt;
          Automate the &lt;a href="#leobridge-options" title="Setup server options"&gt;server startup&lt;/a&gt;,
          auto-refresh for &lt;a href="#external-files" title="Setup file-change detection"&gt;external files changes&lt;/a&gt;,
          or choose which &lt;a href="#node-commands" title="Fine-tune interface"&gt;icons&lt;/a&gt;
          are shown, and more!
        &lt;/p&gt;
      &lt;/section&gt;

      &lt;section id="leobridge-options" class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;Leo Server Options&lt;/h2&gt;
          &lt;/div&gt;
          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="startServerAutomatically" name="startServerAutomatically" type="checkbox" data-setting /&gt;
                &lt;label for="startServerAutomatically"&gt;Auto-Start&amp;nbsp;Server&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Run the leoserver.py server script at startup&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="connectToServerAutomatically" name="connectToServerAutomatically" type="checkbox"
                  data-setting /&gt;
                &lt;label for="connectToServerAutomatically"&gt;Auto-Connect&amp;nbsp;to&amp;nbsp;Server&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Connects automatically to a Leo server&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="leoEditorPath"&gt;Leo&amp;#8209;Editor&amp;nbsp;Path&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/label&gt;
                &lt;input id="leoEditorPath" name="leoEditorPath" type="text" maxlength="256" placeholder="C:/leo-editor"
                  data-setting /&gt;
                &lt;button type="button" id="chooseLeoEditorPath" name="chooseLeoEditorPath"
                  class="button btn button--flat button--flat-primary button--choose-path"&gt;
                  Browse For Folder...
                &lt;/button&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Location of your Leo-Editor installation&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="leoPythonCommand"&gt;Python&amp;nbsp;Command&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/label&gt;
                &lt;input id="leoPythonCommand" name="leoPythonCommand" type="text" maxlength="256"
                  placeholder="Empty for default" data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Command for starting python (Defaults to 'py' on windows, or
                'python3' otherwise)&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="connectionAddress"&gt;Connection&amp;nbsp;Address&lt;/label&gt;
                &lt;input id="connectionAddress" name="connectionAddress" type="text" maxlength="256"
                  placeholder="Host Name, IP Address or localhost" data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Connection host&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="connectionPort"&gt;Connection&amp;nbsp;Port&lt;/label&gt;
                &lt;input id="connectionPort" name="connectionPort" type="number" min="0" max="65535" max-length="5"
                  placeholder="Port Number" data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Connection host port number&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="break"&gt;&lt;/div&gt;
            &lt;fieldset class="info"&gt;
              &lt;legend title="The resulting server process spawn command"&gt;Server Process Launch Command&lt;/legend&gt;
              &lt;div class="setting"&gt;
                &lt;div class="setting__input"&gt;
                  &lt;p id="resultingCommand" name="resultingCommand" title="The resulting server process spawn command"
                    class="cursor-default text-italic"&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/fieldset&gt;
            &lt;fieldset class="alert"&gt;
              &lt;legend&gt;Experimental Features&lt;/legend&gt;
              &lt;div class="setting"&gt;
                &lt;div class="setting__input"&gt;
                  &lt;input id="setDetached" name="setDetached" type="checkbox" data-setting /&gt;
                  &lt;label for="setDetached"&gt;Spawn&amp;nbsp;Detached&lt;/label&gt;
                &lt;/div&gt;
                &lt;span class="setting__hint"&gt;Server spawned with 'detached' option&lt;br&gt;
                  (Shows dialog when quitting with unsaved files)&lt;/span&gt;
              &lt;/div&gt;
              &lt;div class="setting"&gt;
                &lt;div class="setting__input"&gt;
                  &lt;label for="limitUsers"&gt;User&amp;nbsp;Limit&lt;/label&gt;
                  &lt;input id="limitUsers" name="limitUsers" type="number" min="0" max="255" max-length="3"
                    placeholder="1 to 255" data-setting /&gt;
                &lt;/div&gt;
                &lt;span class="setting__hint"&gt;Server's max simultaneous connections&lt;/span&gt;
              &lt;/div&gt;
              &lt;br&gt;
              &lt;p&gt;For a standalone, persistent, or multi-user server
                see &lt;a href="https://leo-editor.github.io/leo-editor/leoserver.html"
                  title="Leo server documentation"&gt;Using leoserver.py&lt;/a&gt;
                from Leo's documentation.
              &lt;/p&gt;
            &lt;/fieldset&gt;

          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="external-files" class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;External Files Change Detection&lt;/h2&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="checkForChangeExternalFiles"&gt;Check changes to external files&lt;/label&gt;
                &lt;select id="checkForChangeExternalFiles" name="checkForChangeExternalFiles" data-setting&gt;
                  &lt;option value="none"&gt;Default from Leo's config&lt;/option&gt;
                  &lt;option value="force-check"&gt;Check for changes&lt;/option&gt;
                  &lt;option value="force-ignore"&gt;Ignore all changes&lt;/option&gt;
                &lt;/select&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Use Leo's defaults, or force either to check changes or not&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="defaultReloadIgnore"&gt;Force reload or ignore changes&lt;/label&gt;
                &lt;select id="defaultReloadIgnore" name="defaultReloadIgnore" data-setting&gt;
                  &lt;option value="none"&gt;
                    Choose each time
                  &lt;/option&gt;
                  &lt;option value="yes-all"&gt;
                    Reload All
                  &lt;/option&gt;
                  &lt;option value="no-all"&gt;
                    Ignore All
                  &lt;/option&gt;
                &lt;/select&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Choose yourself, or set default to reload
                or ignore changes&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="interface-behavior" class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;Interface Behavior&lt;/h2&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="leoTreeBrowse" name="leoTreeBrowse" type="checkbox" data-setting /&gt;
                &lt;label for="leoTreeBrowse"&gt;Use Leo Tree Browsing&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Navigate Leo's outline with Leo's shortcuts
                and behavior instead of the default vscode
                method&lt;br /&gt;(Arrow keys move selection
                instead of moving a cursor when focus is on
                Leo's outline)&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="treeKeepFocus" name="treeKeepFocus" type="checkbox" data-setting /&gt;
                &lt;label for="treeKeepFocus"&gt;Keep focus on Outline&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Keep focus in the outline when selecting a
                node - overridden by "&lt;strong&gt;Leo Tree Browsing&lt;/strong&gt;"&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="treeKeepFocusWhenAside" name="treeKeepFocusWhenAside" type="checkbox" data-setting /&gt;
                &lt;label for="treeKeepFocusWhenAside"&gt;Keep focus when opening on the side&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Keep focus in the outline when opening a detached body pane on the side&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="break"&gt;&lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="goAnywhereShortcut" name="goAnywhereShortcut" type="checkbox" data-setting /&gt;
                &lt;label for="goAnywhereShortcut"&gt;Replace 'Go to File' shortcut with 'Go Anywhere'&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;
                Make &lt;strong&gt;[Ctrl+P]&lt;/strong&gt; call Leo's &lt;strong&gt;Go Anywhere&lt;/strong&gt;
                instead of VSCode's &lt;strong&gt;Go to File&lt;/strong&gt; when focus in the body or outline&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="collapseAllShortcut" name="collapseAllShortcut" type="checkbox" data-setting /&gt;
                &lt;label for="collapseAllShortcut"&gt;Enable collapse-all shortcut for
                  explorer&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Allows the
                &lt;strong&gt;[Alt+'-'] keyboard shortcut&lt;/strong&gt;
                to collapse folders in the file
                explorer&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="activityViewShortcut" name="activityViewShortcut" type="checkbox" data-setting /&gt;
                &lt;label for="activityViewShortcut"&gt;Enable 'Show LeoInteg view' shortcut&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Allows the &lt;strong&gt;[Ctrl+Shift+L] keyboard shortcut&lt;/strong&gt;
                to reveal the Leointeg Activity View&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="tree-in-explorer" class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;div class="setting__input setting__input--big"&gt;
              &lt;input id="treeInExplorer" name="treeInExplorer" type="checkbox" data-setting /&gt;
              &lt;label for="treeInExplorer"&gt;Show&amp;nbsp;Leo&amp;nbsp;Outline&amp;nbsp;in&amp;nbsp;Explorer&lt;/label&gt;
            &lt;/div&gt;
            &lt;p class="section__header-hint"&gt;
              Adds an instance of the outline pane in the explorer view
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="section__preview"&gt;
          &lt;img class="image__preview" src="#{root}/resources/treeInExplorerDisabled.png" /&gt;
          &lt;img class="image__preview--overlay hidden" src="#{root}/resources/treeInExplorerEnabled.png"
            data-visibility="treeInExplorer" /&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="show-branch-in-title" class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;div class="setting__input setting__input--big"&gt;
              &lt;input id="showBranchInOutlineTitle" name="showBranchInOutlineTitle" type="checkbox" data-setting /&gt;
              &lt;label for="showBranchInOutlineTitle"&gt;Show&amp;nbsp;branch&amp;nbsp;in&amp;nbsp;outline&amp;nbsp;title&lt;/label&gt;
            &lt;/div&gt;
            &lt;p class="section__header-hint"&gt;
              Adds the current git branch along the filename
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="section__preview"&gt;
          &lt;img class="image__preview" src="#{root}/resources/withoutbranch.png" /&gt;
          &lt;img class="image__preview--overlay hidden" src="#{root}/resources/withbranch.png"
            data-visibility="showBranchInOutlineTitle" /&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="invert-contrast" class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;div class="setting__input setting__input--big"&gt;
              &lt;input id="invertNodeContrast" name="invertNodeContrast" type="checkbox" data-setting /&gt;
              &lt;label for="invertNodeContrast"&gt;Invert Node Contrast&lt;/label&gt;
            &lt;/div&gt;
            &lt;p class="section__header-hint"&gt;
              Inverts the dirty/clean border appearance of tree nodes
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="section__preview"&gt;
          &lt;img class="image__preview" src="#{root}/resources/invertedDisabled.png" /&gt;
          &lt;img class="image__preview--overlay hidden" src="#{root}/resources/invertedEnabled.png"
            data-visibility="invertNodeContrast" /&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="node-commands" class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;Node Commands&lt;/h2&gt;
            &lt;p class="section__header-hint"&gt;
              Hovering tree nodes displays an edit icon -
              Choose more commands to display when hovering
            &lt;/p&gt;
          &lt;/div&gt;
          &lt;div class="section__preview"&gt;
            &lt;img class="image__preview" src="#{root}/resources/allIconsDisabled.png" /&gt;

            &lt;div class="image__preview--float-container"&gt;
              &lt;img class="image__preview--float" src="#{root}/resources/bookmark.png"
                data-visibility="showMarkOnNodes" /&gt;
              &lt;img class="image__preview--float" src="#{root}/resources/copy.png" data-visibility="showCopyOnNodes" /&gt;
              &lt;img class="image__preview--float" src="#{root}/resources/clone.png" data-visibility="showCloneOnNodes" /&gt;
              &lt;img class="image__preview--float" src="#{root}/resources/add.png" data-visibility="showAddOnNodes" /&gt;
              &lt;img class="image__preview--float" src="#{root}/resources/editHeadline.png"
                data-visibility="showEditOnNodes" /&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showEditOnNodes" name="showEditOnNodes" type="checkbox" data-setting /&gt;
                &lt;label for="showEditOnNodes"&gt;Edit&amp;nbsp;Headline&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Edit Headline' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showMarkOnNodes" name="showMarkOnNodes" type="checkbox" data-setting /&gt;
                &lt;label for="showMarkOnNodes"&gt;Mark&amp;nbsp;/&amp;nbsp;Unmark&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Mark/Unmark' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showCopyOnNodes" name="showCopyOnNodes" type="checkbox" data-setting /&gt;
                &lt;label for="showCopyOnNodes"&gt;Copy&amp;nbsp;Node&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Copy' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showCloneOnNodes" name="showCloneOnNodes" type="checkbox" data-setting /&gt;
                &lt;label for="showCloneOnNodes"&gt;Clone&amp;nbsp;Node&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Clone' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showAddOnNodes" name="showAddOnNodes" type="checkbox" data-setting /&gt;
                &lt;label for="showAddOnNodes"&gt;Add&amp;nbsp;Node&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Insert' on hover&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;
      &lt;section id="status-bar" class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;Status Bar Indicator&lt;/h2&gt;
            &lt;p class="section__header-hint"&gt;
              UNL is shown at the bottom in the status bar
            &lt;/p&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showUnlOnStatusBar" name="showUnlOnStatusBar" type="checkbox" data-setting /&gt;
                &lt;label for="showUnlOnStatusBar"&gt;Enable UNL in status bar&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Click the indicator to copy the UNL to the clipboard&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="section__preview"&gt;
          &lt;img class="image__preview" src="#{root}/resources/unl-off.png" /&gt;
          &lt;img class="image__preview--overlay hidden" src="#{root}/resources/unl-on.png"
            data-visibility="showUnlOnStatusBar" /&gt;
        &lt;/div&gt;
      &lt;/section&gt;
    &lt;/div&gt;

    &lt;div class="sidebar"&gt;
      &lt;div class="sidebar__group"&gt;
        &lt;a class="button button--flat-primary" title="Support LeoInteg Development"
          href="https://boltex.github.io/"&gt;Sponsor
          LeoInteg &amp;#x2764;&lt;/a&gt;
        &lt;p&gt;
          LeoInteg is built by the support of generous users like &lt;b&gt;you&lt;/b&gt;!
        &lt;/p&gt;
      &lt;/div&gt;

      &lt;div class="sidebar__group"&gt;
        &lt;h2&gt;Configuration&lt;/h2&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href="#leobridge-options" title="Server settings"&gt;Leo server Options&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#external-files" title="File change detection settings"&gt;External Files&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#interface-behavior" title="Outline behavior settings"&gt;Interface Behavior&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#tree-in-explorer" title="Outline visibility settings"&gt;Outline in Explorer&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#show-open-aside" title="Outline context menu settings"&gt;Open to the Side&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#show-branch-in-title" title="Outline git branch visibility settings"&gt;Show branch in title&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#invert-contrast" title="UI contrast settings"&gt;Invert Contrast&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#node-commands" title="Outline nodes settings"&gt;Node Hover Commands&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#status-bar" title="Status bar indicator"&gt;Status Bar Indicator&lt;/a&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;

      &lt;div class="sidebar__group"&gt;
        &lt;h2&gt;About Leo&lt;/h2&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href="https://leo-editor.github.io/leo-editor/" title="Leo's Home Page"&gt;Home Page&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://leo-editor.github.io/leo-editor/leo_toc.html"
              title="Leo's Documentation Page"&gt;Documentation&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://groups.google.com/forum/#!forum/leo-editor" title="Leo Editor Forum"&gt;Forum&lt;/a&gt;
            &lt;small&gt; &amp;nbsp;&amp;nbsp;&amp;mdash;&amp;nbsp; #Google Group&lt;/small&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://github.com/leo-editor/leo-editor" title="Leo Editor on GitHub"&gt;Source&lt;/a&gt;
            &lt;small&gt; &amp;nbsp;&amp;nbsp;&amp;mdash;&amp;nbsp; #GitHub&lt;/small&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div id="dirty-config-toast"&gt;Saving...&lt;/div&gt;
  &lt;div id="saved-config-toast"&gt;Settings Saved&lt;/div&gt;
  #{endOfBody}
&lt;/body&gt;

&lt;/html&gt;
</t>
<t tx="fil.20210603223956.2">@language css
html {
  height: 100%;
  font-size: 62.5%;
  box-sizing: border-box;
  scroll-behavior: smooth
}

body {
  background-color: var(--color-background);
  color: var(--color-foreground);
  font-family: var(--font-family);
  height: 100%;
  line-height: 1.4;
  font-size: 100% !important
}

body.vscode-light {
  background-color: var(--color-background--darken-075)
}

a {
  border: 0;
  color: var(--color-link-foreground);
  font-weight: 400;
  outline: none;
  text-decoration: none
}

a:not([href]):not([tabindex]):focus,
a:not([href]):not([tabindex]):hover {
  color: inherit;
  text-decoration: none
}

a:focus {
  outline-color: var(--color-focus-border)
}

a:hover {
  color: var(--color-link-foreground--lighten-20)
}

a,
a:active,
a:focus {
  outline: none
}

b {
  font-weight: 600
}

span.heart {
  color: #8b3177
}

code,
.shortcut-key {
  border-radius: 4px;
  color: var(--color-foreground);
  padding: 2px 6px 0 6px;
  vertical-align: baseline
}

.vscode-dark code,
.vscode-dark .shortcut-key {
  background-color: var(--color-background--lighten-15);
  border-bottom: 2px solid var(--color-background--lighten-15)
}

.vscode-light code,
.vscode-light .shortcut-key {
  background-color: var(--color-background--darken-15);
  border-bottom: 2px solid var(--color-background--darken-15)
}

h1 {
  border: none;
  font-size: 4rem;
  font-weight: 400;
  margin: 0;
  padding: 0;
  white-space: nowrap
}

h2 {
  font-size: 2.2rem;
  font-weight: 200;
  line-height: normal;
  margin: 1em 0 0.3em 0;
  white-space: nowrap
}

h3 {
  font-size: 1.8rem;
  font-weight: 200;
  line-height: normal;
  margin: 1em 0 0.3em 0;
  white-space: nowrap
}

h4 {
  font-size: 1rem;
  font-weight: 200;
  line-height: normal;
  margin: 1em 0 0.3em 0;
  white-space: nowrap
}

header {
  grid-area: header;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(265px, 1fr));
  grid-gap: 1em 3em;
  align-items: center;
  justify-items: center;
  margin: 0 3em
}

input,
select,
button {
  font-family: var(--font-family);
  font-size: inherit;
  margin: 0
}

input[type="checkbox"] {
  background: none;
  border: none;
  cursor: pointer;
  margin: 0;
  padding: 0 10px
}

input[type="checkbox"]:focus {
  background: rgba(0, 0, 0, 0.1);
  border-radius: 5px;
  outline: none
}

input[type="checkbox"][disabled] {
  color: var(--color-foreground--75);
  cursor: default
}

input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  margin: 0
}

input[type="number"],
input[type="text"],
input:not([type]) {
  background: none;
  color: var(--color-foreground);
  margin: 0 10px;
  max-width: 300px;
  padding: 4px
}

.vscode-dark input[type="number"],
.vscode-dark input[type="text"],
.vscode-dark input:not([type]) {
  border: 1px solid rgba(255, 255, 255, 0.3)
}

.vscode-light input[type="number"],
.vscode-light input[type="text"],
.vscode-light input:not([type]) {
  border: 1px solid rgba(0, 0, 0, 0.3)
}

input[type="number"]:focus,
input[type="text"]:focus,
input:not([type]):focus {
  outline-color: var(--color-focus-border)
}

.vscode-light input[type="number"]:focus,
.vscode-light input[type="text"]:focus,
.vscode-light input:not([type]):focus {
  background-color: rgba(255, 255, 255, 0.4)
}

.vscode-dark input[type="number"]:focus,
.vscode-dark input[type="text"]:focus,
.vscode-dark input:not([type]):focus {
  background-color: rgba(0, 0, 0, 0.2)
}

input[type="number"].is-invalid,
input[type="text"].is-invalid,
input:not([type]).is-invalid {
  outline-color: red !important;
  border-color: red !important
}

input[type="number"][disabled],
input[type="text"][disabled],
input:not([type])[disabled] {
  color: var(--color-foreground--75);
  cursor: default
}

input[type="number"]::placeholder,
input[type="text"]::placeholder,
input:not([type])::placeholder {
  color: var(--vscode-input-placeholderForeground)
}

label {
  cursor: pointer
}

select {
  background: none;
  color: var(--color-foreground);
  cursor: pointer;
  margin: 0 0.75em;
  padding: 2px;
  min-width: 14em
}

.vscode-light select {
  border: 1px solid rgba(0, 0, 0, 0.3)
}

.vscode-dark select {
  border: 1px solid rgba(255, 255, 255, 0.3)
}

select:focus {
  outline-color: var(--color-focus-border)
}

.vscode-light select:focus {
  background-color: rgba(255, 255, 255, 0.4)
}

.vscode-dark select:focus {
  background-color: rgba(0, 0, 0, 0.2)
}

select[disabled] {
  color: var(--color-foreground--75);
  cursor: default
}

.vscode-light select option {
  background-color: var(--color-background--darken-05)
}

.vscode-dark select option {
  background-color: var(--color-background--lighten-05)
}

select option:focus {
  outline-color: var(--color-focus-border)
}

.vscode-light select option:focus {
  background-color: rgba(255, 255, 255, 0.4)
}

.vscode-dark select option:focus {
  background-color: rgba(0, 0, 0, 0.2)
}

ul {
  list-style: none;
  margin: 0;
  padding: 0
}

.button {
  background: none;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  display: inline-block;
  font-size: 1.1rem;
  letter-spacing: 0.25em;
  margin: 1em 0.5em;
  padding: 1em 1.75em;
  text-decoration: none;
  text-transform: uppercase;
  user-select: none;
  white-space: nowrap
}

.button:focus {
  outline: none
}

.button--big {
  font-size: 1.5rem
}

.button--flat {
  transition: background-color 250ms, border-color 250ms, color 250ms
}

.vscode-light .button--flat {
  border: 1px solid rgba(0, 0, 0, 0.6);
  color: black
}

.vscode-dark .button--flat {
  border: 1px solid rgba(255, 255, 255, 0.6);
  color: white !important
}

.vscode-light .button--flat:hover {
  background-color: var(--color-button-background--darken-30);
  border-color: var(--color-button-background--darken-30);
  color: white !important
}

.vscode-dark .button--flat:hover {
  background-color: white;
  border-color: white;
  color: black !important
}

.preload .button--flat {
  transition-duration: 0s !important
}

.button--flat-inverse {
  background-color: white;
  border: 1px solid white;
  color: black !important;
  font-weight: 600;
  transition: background-color 250ms, border-color 250ms, color 250ms
}

.button--flat-inverse:hover {
  background: rgba(0, 0, 0, 0.2);
  border-color: rgba(255, 255, 255, 0.6);
  color: white !important
}

.preload .button--flat-inverse {
  transition-duration: 0s !important
}

.button--flat-primary {
  background-color: var(--color-button-background);
  border: 1px solid var(--color-button-background);
  color: var(--color-button-foreground) !important;
  font-weight: 600;
  transition: background-color 250ms, border-color 250ms, color 250ms
}

.vscode-dark .button--flat-primary:hover {
  background-color: white;
  border-color: white;
  color: black !important
}

.vscode-light .button--flat-primary:hover {
  background-color: var(--color-button-background--darken-30);
  border-color: var(--color-button-background--darken-30);
  color: white !important
}

.preload .button--flat-primary {
  transition-duration: 0s !important
}

.button--choose-path {
  padding: 0.6em 0.7em;
  margin-left: 0.2rem;
  margin-bottom: 0
}

.blurb {
  font-size: 1.5rem;
  font-weight: 200;
  color: var(--color-foreground--65);
  margin: 1em
}

.blurb b {
  color: var(--color-foreground--85)
}

.vscode-light .blurb {
  color: var(--color-foreground--75)
}

.command {
  font-weight: 600;
  padding: 1px 3px
}

.container {
  display: grid;
  grid-template-areas: "header header" "hero hero" "content sidebar";
  grid-template-columns: repeat(1, 1fr min-content);
  margin: 1em auto;
  grid-gap: 1em 3em;
  max-width: 1200px;
  min-width: 450px
}

@media all and (max-width: 768px) {
  .container {
    grid-gap: 1em 0
  }
}

.content__area {
  grid-area: content;
  font-size: 1.4rem
}

.vscode-dark .content__area {
  background-color: var(--color-background--lighten-05)
}

.vscode-light .content__area {
  background-color: var(--color-background)
}

@media all and (max-width: 768px) {
  .content__area {
    grid-column: span 1
  }
}

.content__area--full-scroll {
  background-color: unset !important;
  margin-bottom: 90vh
}

.content__area--full-scroll .section--settings {
  margin: 0 0 1em 0
}

.cta {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  font-size: 1.3rem;
  margin: 0
}

.cta p {
  margin-left: 10%;
  margin-right: 10%;
  margin-top: -0.5em;
  opacity: 0.6
}

.cta--primary {
  margin: 0 1em
}

.cta--secondary {
  margin: 0 1em
}

.header__blurb {
  color: var(--color-foreground--75);
  flex: 2 1 55%;
  font-size: 1.5rem;
  font-weight: 200;
  margin: 0;
  min-width: 345px
}

@media all and (max-width: 880px) {
  .header__blurb {
    margin: 0 2em
  }
}

.header__link {
  color: var(--color-foreground);
  outline: none
}

.header__link:hover,
.header__link:active,
.header__link:focus {
  color: var(--color-foreground);
  outline: none
}

.header__logo {
  display: flex;
  flex-wrap: nowrap
}

.header__logo--highlight {
  color: #8d3d17
}

.header__subtitle {
  color: var(--color-foreground--65);
  font-size: 2rem;
  font-weight: 100;
  margin: -0.2em 0 0 0;
  white-space: nowrap
}

.hero__area {
  grid-area: hero;
  color: var(--color-foreground--75);
  font-size: 1.5rem;
  font-weight: 200;
  margin: 0 1em
}

.hero__area b {
  color: var(--color-foreground--85)
}

.hero__area--sticky {
  background: var(--color-background);
  margin: 0;
  padding: 1em 0;
  position: sticky;
  top: -1px;
  z-index: 1;
  grid-column: span 1
}

.vscode-light .hero__area--sticky {
  background: var(--color-background--darken-075)
}

.hero__row {
  display: flex;
  flex-wrap: nowrap;
  align-items: baseline;
  justify-content: space-between
}

.hero__subtitle {
  color: var(--color-foreground--75);
  font-size: 1.4rem;
  margin: 0.25em 0 0 0
}

.hero__title {
  font-size: 4rem;
  margin: 0
}

.hero__title-actions {
  margin: 0 1em
}

.hero__toolbar {
  flex: 1 1 auto;
  display: flex;
  justify-content: flex-end;
  white-space: nowrap
}

.hero__toolbar select,
.hero__toolbar option {
  background-color: var(--color-background) !important;
  margin-right: 0
}

@media all and (max-width: 768px) {

  .hero__toolbar select,
  .hero__toolbar option {
    margin-right: unset
  }
}

.hero__toolbar-scope {
  flex: 0 0 auto
}

.icon {
  background-color: var(--color-foreground);
  display: inline-block;
  height: 24px;
  margin-right: 3px;
  position: relative;
  width: 19px;
  top: 9px
}

h2 .icon {
  top: 7px
}

.icon--md {
  height: 30px;
  width: 24px;
  top: 12px
}

.icon--lg {
  height: 36px;
  width: 30px;
  top: 15px
}

.image__logo {
  margin: 9px 1em 0 0;
  max-height: 64px;
  max-width: 64px
}

.image__preview {
  display: block;
  border-radius: 8px;
  box-shadow: 0px 0px 1px 0px rgba(0, 0, 0, 0.8), 0px 0px 12px 1px rgba(0, 0, 0, 0.5);
  width: 600px
}

.image__preview__body {
  display: block;
  border-radius: 8px;
  box-shadow: 0px 0px 1px 0px rgba(0, 0, 0, 0.8), 0px 0px 12px 1px rgba(0, 0, 0, 0.5);
  width: 680px
}

.image__preview--overlay {
  left: 0;
  position: absolute;
  top: 0
}

.image__preview--float-container {
  left: 0;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  padding-right: 17%
}

.image__preview__body--float-container {
  left: 0;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  padding-right: 7px;
  padding-left: 7px;
  overflow: hidden
}

.image__preview--float {
  float: right
}

.link__configure,
.link__learn-more {
  margin-left: 10px
}

.presets {
  align-items: baseline;
  justify-content: center;
  display: flex;
  width: 100%;
  flex-wrap: wrap
}

section {
  display: flex;
  flex-wrap: wrap;
  margin-bottom: 1em;
  padding: 1em
}

section h2 {
  flex: 1 0 auto;
  display: flex;
  margin-top: 0;
  margin-bottom: 1em
}

.section--full {
  flex-flow: column
}

.section--settings {
  flex: 0 1 auto;
  display: flex;
  flex-wrap: wrap;
  border-radius: 8px;
  margin: 1em;
  padding: 1em 0 0.5em 1em
}

.vscode-dark .section--settings {
  background: var(--color-background--lighten-075)
}

.vscode-light .section--settings {
  background: var(--color-background--darken-05)
}

.vscode-light .section--collapsible {
  background: var(--color-background)
}

.section--collapsible .section__header {
  cursor: pointer;
  flex: 1 0 100%;
  margin-right: 0
}

.section--collapsible .section__header:after {
  background-color: var(--color-foreground--75);
  content: "";
  height: 40px;
  -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125"&gt;&lt;path d="M50 62a3 3 0 0 1-2-1L26 44a3 3 0 0 1 3-5l21 16 21-16a3 3 0 1 1 3 5L52 61a3 3 0 0 1-2 1z"/&gt;&lt;/svg&gt;');
  mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125"&gt;&lt;path d="M50 62a3 3 0 0 1-2-1L26 44a3 3 0 0 1 3-5l21 16 21-16a3 3 0 1 1 3 5L52 61a3 3 0 0 1-2 1z"/&gt;&lt;/svg&gt;');
  -webkit-mask-repeat: no-repeat;
  mask-repeat: no-repeat;
  -webkit-mask-size: 32px 40px;
  mask-size: 32px 40px;
  position: absolute;
  right: 0;
  top: 0;
  transition: transform 250ms ease-in-out;
  width: 32px
}

.section--collapsible.collapsed .section__header {
  margin-bottom: 0
}

.section--collapsible.collapsed .section__header:after {
  transform: translateY(-9px) rotate(-180deg)
}

.section--collapsible.collapsed .section__header h2 {
  margin-bottom: 0
}

.section--collapsible.collapsed .section__collapsible {
  display: none
}

.section__collapsible {
  display: flex;
  flex-wrap: wrap
}

.section__content {
  flex: 1 1 100%;
  display: flex;
  flex-flow: column wrap
}

.section__group {
  flex: 1 0 100%;
  display: flex;
  flex-flow: wrap-reverse
}

.section__group+.section__group {
  margin-top: 1em
}

.section__header {
  display: flex;
  align-items: baseline;
  flex: 0 1 auto;
  flex-flow: column;
  margin-bottom: 1em;
  margin-right: 1em;
  position: relative
}

.section__header h2 {
  margin-bottom: 0
}

.section__header .link__configure,
.section__header .link__learn-more {
  visibility: hidden
}

.section__header:hover .link__configure,
.section__header:hover .link__learn-more {
  visibility: visible
}

.section__header-hint {
  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0.25em 0
}

.section__header-info {
  display: grid;
  grid-template-columns: auto auto;
  grid-gap: 1em;
  align-items: center;
  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0.25em 0.5em
}

.section__header-info p {
  margin: 0;
  line-height: 2rem
}

.section__header-info .icon {
  top: 3px
}

.section__hint {
  flex: 0 0 auto;
  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0
}

.section__preview {
  flex: 0 1 auto;
  position: relative;
  margin-left: auto;
  margin-right: auto;
  margin-bottom: 0.65rem
}

.section__collapsible .section__preview {
  margin-bottom: 1em
}

.section__preview-hint {
  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0.5em 0.5em 0 0.5em;
  text-align: center
}

.section__title {
  flex: 1 0 auto;
  margin: 0
}

.section__title--primary {
  font-size: 3rem;
  margin: 0.3em 0;
  justify-content: center
}

.section__title--break {
  margin: 0.3em 15% 0 15%;
  padding-top: 1em;
  justify-content: center
}

.vscode-dark .section__title--break {
  border-top: 1px solid var(--color-background--lighten-30)
}

.vscode-light .section__title--break {
  border-top: 1px solid var(--color-background--darken-30)
}

.setting {
  flex: 0 1 auto;
  position: relative;
  margin-right: 1em;
  min-width: 15.5em
}

.setting input[type="checkbox"] {
  flex: 0 0 16px;
  height: 16px;
  margin: 0 10px 0 0;
  position: relative;
  top: 3px;
  width: 16px
}

.setting[disabled] label {
  color: var(--color-foreground--75);
  cursor: default
}

#interface-behavior .setting {
  min-width: 29em
}

fieldset {
  display: flex;
  flex-wrap: wrap;
  margin-right: 1em;
  padding-right: 0;
  border-style: solid;
  border-width: 1px;
  flex-basis: 100%;
}

fieldset.info {
  background-color: #00378010;
  border-color: #3e6092
}

fieldset.alert {
  background-color: #80000010;
  border-color: #92473e
}

fieldset p {
  margin: 0;
  padding-right: 1em;
  width: 100%;
  color: var(--color-foreground--65)
}

fieldset p span {
  color: var(--color-foreground)
}

.setting__input {
  display: inline-flex;
  flex-wrap: nowrap;
  align-items: baseline;
  line-height: normal;
  margin: 0.5em 0
}

.setting__input input,
.setting__input select {
  flex-grow: 1
}

.setting__input input+.link__configure,
.setting__input input+.link__learn-more,
.setting__input select+.link__configure,
.setting__input select+.link__learn-more {
  margin-left: 0
}

.setting__input input[type="text"],
.setting__input input:not([type]) {
  min-width: 150px
}

.setting__input label {
  flex-grow: 0
}

.setting__input label&gt;select {
  margin-top: 0.25em
}

.setting__input .link__learn-more,
.setting__input .link__configure {
  visibility: hidden;
  max-height: 15px
}

.setting__input .link__learn-more .icon,
.setting__input .link__configure .icon {
  display: block;
  top: unset
}

.setting__input:hover .link__learn-more,
.setting__input:hover .link__configure {
  visibility: visible
}

.setting__input--big {
  font-size: 2.2rem;
  font-weight: 200;
  margin: 0
}

.setting__input--big input[type="checkbox"] {
  flex: 0 0 1.5em;
  height: 1em;
  margin: 0;
  position: relative;
  top: 3px;
  left: -5px;
  width: 1em
}

.setting__input--big label {
  white-space: nowrap
}

.setting__input--big .link__learn-more,
.setting__input--big .link__configure {
  max-height: 17px
}

.setting__input--format {
  display: flex
}

.setting__input--format input[type="text"],
.setting__input--format input:not([type]) {
  max-width: unset
}

.setting__hint {
  color: var(--color-foreground--75);
  display: block;
  font-weight: 200;
  font-size: 1.3rem;
  margin: 0 1em 0.5em 1em
}

.settings {
  flex: 1 0 auto;
  display: flex;
  flex-wrap: wrap
}

.break {
  flex-basis: 100%;
  height: 0
}

.settings--fixed {
  display: block
}

.sidebar {
  grid-area: sidebar;
  align-self: flex-start;
  font-size: 1.3rem;
  position: sticky;
  top: 0;
  z-index: 2
}

@media all and (max-width: 768px) {
  .sidebar {
    display: none
  }
}

.sidebar li {
  white-space: nowrap
}

.sidebar .button {
  margin: 0
}

.sidebar__group {
  margin-top: 1em
}

.sidebar__group h2 {
  font-size: 2rem
}

.sidebar__group p {
  font-weight: 400;
  opacity: 0.5;
  text-align: center
}

.sidebar__jump-link.active {
  font-weight: 700
}

.sidebar__jump-link.active:before {
  content: " ";
  border-left: 4px solid var(--color-link-foreground--darken-20);
  position: absolute;
  left: -1em;
  height: 1em;
  padding-bottom: 4px
}

.vscode-light .sidebar__jump-link.active:before {
  border-left-color: var(--color-link-foreground--lighten-20)
}

.sponsor__image {
  opacity: 0.8;
  transition: opacity 250ms;
  transform: scale(0.6);
  margin: -2.5em 0
}

.sponsor__image:hover {
  opacity: 1
}

.sponsor__tag {
  font-size: 1.1rem;
  margin: -1em 0.5em 0 0.5em;
  opacity: 0.5;
  text-align: center
}

.bold {
  font-weight: 600
}

.center {
  text-align: center
}

.hidden {
  display: none !important
}

.highlight {
  background-color: #cc5d1a;
  border-bottom: 2px solid #cc5d1a;
  border-radius: 3px;
  color: #f2f2f2;
  margin: 0 0.25em;
  padding: 2px 10px;
  text-align: center;
  vertical-align: bottom
}

.is-sidebar-hidden {
  display: none
}

@media all and (max-width: 768px) {
  .is-sidebar-hidden {
    display: initial
  }
}

.mb-0 {
  margin-bottom: 0 !important
}

.mb-05 {
  margin-bottom: 0.5em !important
}

.mb-1 {
  margin-bottom: 1em !important
}

.mb-2 {
  margin-bottom: 2em !important
}

.ml-0 {
  margin-left: 0 !important
}

.ml-1 {
  margin-left: 1em !important
}

.ml-2 {
  margin-left: 2em !important
}

.ml-3 {
  margin-left: 3em !important
}

.ml-4 {
  margin-left: 4em !important
}

.mr-0 {
  margin-right: 0 !important
}

.mr-1 {
  margin-right: 1em !important
}

.mr-2 {
  margin-right: 2em !important
}

.mt-n1 {
  margin-top: -1em !important
}

.mt-0 {
  margin-top: 0 !important
}

.mt-05 {
  margin-top: 0.5em !important
}

.mt-1 {
  margin-top: 1em !important
}

.mt-2 {
  margin-top: 2em !important
}

.non-interactive {
  cursor: default !important
}

.nowrap {
  white-space: nowrap !important
}

.vscode-dark .light {
  display: none
}

.vscode-light .dark {
  display: none
}

::-webkit-scrollbar-corner {
  background-color: transparent !important
}

#saved-config-toast {
  box-shadow: 0px 0px 28px 0 rgba(0, 0, 0, 0.5);
  cursor: default;
  display: block;
  padding: 1em 0.5rem;
  position: fixed;
  text-align: center;
  width: 60%;
  top: 50px;
  left: 50%;
  border-radius: 12px;
  margin-left: -30%;
  visibility: hidden;
  font-size: 2rem;
  z-index: 100
}

#saved-config-toast.show {
  visibility: visible;
  animation: fadein 0.5s, fadeout 0.5s 1s
}

#resultingCommand {
  margin: 0 10px;
  padding: 4px;
  font-family: 'Courier New', monospace;
  background-color: #12121240;
}

.cursor-default {
  cursor: default
}

.text-italic{
  font-style: italic;
}

.vscode-light #saved-config-toast:before {
  border-bottom-color: var(--color-background--darken-075)
}

.vscode-dark #saved-config-toast:before {
  border-bottom-color: var(--color-background--lighten-075)
}

.vscode-light #saved-config-toast {
  background: var(--color-background--darken-075)
}

.vscode-dark #saved-config-toast {
  background: var(--color-background--lighten-075)
}

#dirty-config-toast {
  box-shadow: 0px 0px 28px 0 rgba(0, 0, 0, 0.5);
  cursor: default;
  display: block;
  padding: 1em 0.5rem;
  position: fixed;
  text-align: center;
  width: 60%;
  top: 50px;
  left: 50%;
  border-radius: 12px;
  margin-left: -30%;
  visibility: hidden;
  font-size: 2rem;
  z-index: 100
}

#dirty-config-toast.show {
  visibility: visible
}

.vscode-light #dirty-config-toast:before {
  border-bottom-color: var(--color-background--darken-075)
}

.vscode-dark #dirty-config-toast:before {
  border-bottom-color: var(--color-background--lighten-075)
}

.vscode-light #dirty-config-toast {
  background-color: #cc5d1a;
  color: #f2f2f2
}

.vscode-dark #dirty-config-toast {
  background-color: #cc5d1a;
  color: #f2f2f2
}

@keyframes fadein {
  from {
    opacity: 0.8
  }

  to {
    opacity: 1
  }
}

@keyframes fadeout {
  from {
    opacity: 1
  }

  to {
    opacity: 0
  }
}

.token-popup__scroller {
  margin-right: -0.4em;
  max-height: 35vh;
  overflow-y: scroll;
  padding-right: 0.4em
}

.token-popup__hint {
  color: var(--color-foreground--75);
  display: inline-block;
  font-weight: 200;
  margin: 1.25em 0.5em 0 0.25em
}

.token-popup__title {
  color: var(--color-foreground);
  font-weight: 400;
  margin: 0.25em 0 1em 0;
  text-align: center
}

.token-popup__table {
  border-collapse: collapse;
  color: var(--color-foreground--75);
  table-layout: fixed
}

.vscode-light .token-popup__table tr:nth-child(even) {
  background-color: rgba(0, 0, 0, 0.05)
}

.vscode-dark .token-popup__table tr:nth-child(even) {
  background-color: rgba(255, 255, 255, 0.04)
}

.token-popup__table td {
  padding: 6px
}

.token-popup__table td i {
  opacity: 0.6
}

.token-popup__table td:first-child {
  padding: 6px 12px
}

.token-popup__table td:last-child {
  padding-right: 12px;
  text-align: end
}

.token {
  background: var(--color-link-foreground--darken-20);
  border-bottom: 2px solid var(--color-link-foreground--darken-20);
  border-radius: 3px;
  color: white;
  cursor: pointer;
  display: inline-block;
  padding: 1px 8px !important
}

.token:before {
  content:"${"
}

.token:after {
  content: "}"
}

.vscode-light .token {
  background: var(--color-link-foreground--lighten-20);
  border-bottom-color: var(--color-link-foreground--lighten-20)
}
</t>
<t tx="fil.20210609233100.1">/**
 * * Clear leointeg's last-opened &amp; recently opened Leo files list
 */
public clearRecentLeoFiles(): void {
    this._context.workspaceState.update(Constants.LAST_FILES_KEY, undefined);
    this._context.workspaceState.update(Constants.RECENT_FILES_KEY, undefined);
    vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLEARED_RECENT);
}

</t>
<t tx="fil.20230405000235.1">## 1.0.14

- Made package much smaller by fixing webpack compilation. (from 5.6mb to 760kb)
- Added 'new', 'Open' and 'Save' icons to the outline pane's title bar.
- Fixed links in welcome page.
- Made package smaller by excluding image files for readme and other .md files in resources folder.
- Fixed 'minibuffer' preserving of the body pane before opening input.
- Added 'revert' command used to 'Revert to Saved' the currently opened Leo document.
- Added 'tag' related commands to outline nodes context menu, and to the minibuffer.
- Added goto-global-line functionality to the minibuffer with direct access via direct 'number' entry.
- Fixed input box entry UI for various commands. (insert-child, insert-node, clone-find-tag, etc.)
- Added 'tab-cycle-next' command and the Ctrl+Tab keybinding shortcut to cycle opened Leo documents.
- Fixed the 'focus-on-tree' command, along with the Alt+T shortcut, to work from Leo panes other than the body pane.
- Fixed 'opening' a Leo file (normally or via right-click) to force-show the main Leo panes (outline and body).

</t>
</tnodes>
</leo_file>
