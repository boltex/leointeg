<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="felix.20190922171916.2"><vh>Introduction</vh></v>
<v t="felix.20200718165721.1"><vh>Code</vh>
<v t="felix.20200717222352.1"><vh>@clean package.json</vh>
<v t="felix.20200717222716.1"><vh>configuration</vh>
<v t="felix.20200717223431.1"><vh>External Files Change Detection</vh></v>
<v t="felix.20200717223454.1"><vh>Interface Behavior</vh></v>
<v t="felix.20200717223513.1"><vh>Statusbar Indicator</vh></v>
<v t="felix.20200717223828.1"><vh>Interface Appearance</vh></v>
<v t="felix.20200717223852.1"><vh>Leo Bridge Options</vh></v>
</v>
<v t="felix.20200717222850.1"><vh>viewsContainers</vh></v>
<v t="felix.20200717222918.1"><vh>views</vh></v>
<v t="felix.20200717222938.1"><vh>languages</vh></v>
<v t="felix.20200717222946.1"><vh>grammars</vh></v>
<v t="felix.20200717223012.1"><vh>commands</vh>
<v t="felix.20200717224224.1"><vh>Tests</vh></v>
<v t="felix.20200717224216.1"><vh>Show Webviews</vh></v>
<v t="felix.20200717224258.1"><vh>Server</vh></v>
<v t="felix.20200717231121.1"><vh>Scripting &amp; @buttons</vh></v>
<v t="felix.20200717224519.1"><vh>Show UI Panes</vh></v>
<v t="felix.20200717224549.1"><vh>Leo File Documents</vh></v>
<v t="felix.20200717230237.1"><vh>Tree View</vh></v>
<v t="felix.20200717230331.1"><vh>Node Editing</vh></v>
<v t="felix.20200717230350.1"><vh>Move Nodes</vh></v>
<v t="felix.20200717230620.1"><vh>Outline Editing</vh></v>
<v t="felix.20200717230807.1"><vh>Goto Nodes</vh></v>
<v t="felix.20200717230820.1"><vh>Hoist/Dehoist</vh></v>
<v t="felix.20200717230830.1"><vh>Undo/Redo</vh></v>
<v t="felix.20200717231448.1"><vh>TODO</vh></v>
</v>
<v t="felix.20200717223038.1"><vh>viewsWelcome</vh>
<v t="felix.20200717232644.1"><vh>Leo Integration Panel</vh>
<v t="felix.20200717231719.1"><vh>Not Ready: [start], [connect] and settings</vh></v>
<v t="felix.20200717231753.1"><vh>Not Ready Auto Start: [connect] and settings</vh></v>
<v t="felix.20200717231742.1"><vh>Not Ready Server Started: [connect] and settings</vh></v>
<v t="felix.20200717231803.1"><vh>Not Ready: Connecting</vh></v>
<v t="felix.20200717231844.1"><vh>Ready: [open] and settings</vh></v>
</v>
<v t="felix.20200717232009.1"><vh>Leo Documents</vh>
<v t="felix.20200717233055.1"><vh>Not Ready</vh></v>
<v t="felix.20200717233118.1"><vh>Ready: Empty</vh></v>
</v>
<v t="felix.20200717232019.1"><vh>leoButtons</vh>
<v t="felix.20200717233230.1"><vh>Not Ready</vh></v>
<v t="felix.20200717233257.1"><vh>Ready: No Opened Files</vh></v>
<v t="felix.20200717233318.1"><vh>Ready: No Buttons</vh></v>
</v>
</v>
<v t="felix.20200717223100.1"><vh>menus</vh>
<v t="felix.20200718001246.1"><vh>commandPalette</vh>
<v t="felix.20200718001643.1"><vh>Server</vh></v>
<v t="felix.20200718001834.1"><vh>Scripting &amp; @buttons</vh></v>
<v t="felix.20200718001744.1"><vh>Show UI Panes</vh></v>
<v t="felix.20200718001726.1"><vh>Leo File Documents</vh></v>
<v t="felix.20200718001920.1"><vh>Tree View</vh></v>
<v t="felix.20200718001925.1"><vh>Node Editing</vh></v>
<v t="felix.20200718001929.1"><vh>Move Nodes</vh></v>
<v t="felix.20200718001935.1"><vh>Outline Editing</vh></v>
<v t="felix.20200718001940.1"><vh>Goto Nodes</vh></v>
<v t="felix.20200718001958.1"><vh>Hoist/Dehoist</vh></v>
<v t="felix.20200718002007.1"><vh>Undo/Redo</vh></v>
<v t="felix.20200718002528.1"><vh>TODO</vh></v>
<v t="felix.20200718002013.1"><vh>Hidden Commands</vh>
<v t="felix.20200718003128.1"><vh>Tests</vh></v>
<v t="felix.20200718003207.1"><vh>Show UI Panes</vh></v>
<v t="felix.20200718003215.1"><vh>Leo File Documents</vh></v>
<v t="felix.20200718003223.1"><vh>Tree View</vh></v>
<v t="felix.20200718003227.1"><vh>Node Editing</vh></v>
<v t="felix.20200718003236.1"><vh>Move Nodes</vh></v>
<v t="felix.20200718003239.1"><vh>Outline Editing</vh></v>
<v t="felix.20200718003243.1"><vh>Goto Nodes</vh></v>
<v t="felix.20200718003251.1"><vh>Hoist/Dehoist</vh></v>
<v t="felix.20200718003259.1"><vh>Undo/Redo</vh></v>
</v>
</v>
<v t="felix.20200718001311.1"><vh>explorer/context</vh></v>
<v t="felix.20200718001319.1"><vh>view/title</vh></v>
<v t="felix.20200718001334.1"><vh>view/item/context</vh></v>
</v>
<v t="felix.20200717223116.1"><vh>keybindings</vh>
<v t="felix.20200718005357.1"><vh>Scripting</vh></v>
<v t="felix.20200718005412.1"><vh>Show UI Panes</vh></v>
<v t="felix.20200718005425.1"><vh>Leo File Documents</vh></v>
<v t="felix.20200718005440.1"><vh>Tree View</vh></v>
<v t="felix.20200718005444.1"><vh>Node Editing</vh></v>
<v t="felix.20200718005448.1"><vh>Move Nodes</vh></v>
<v t="felix.20200718005453.1"><vh>Outline Editing</vh></v>
<v t="felix.20200718005458.1"><vh>Goto Nodes</vh></v>
</v>
<v t="felix.20200717223127.1"><vh>resourceLabelFormatters</vh></v>
</v>
<v t="felix.20191126232434.2"><vh>@clean leobridgeserver.py</vh>
<v t="felix.20191128002414.1"><vh>Imports</vh></v>
<v t="felix.20191128002417.1"><vh>Constants</vh></v>
<v t="felix.20200302204251.1"><vh>class IdleTimeManager</vh>
<v t="felix.20200302204251.2"><vh>itm.add_callback</vh></v>
<v t="felix.20200302204251.3"><vh>itm.on_idle</vh></v>
<v t="felix.20200302204251.4"><vh>itm.start</vh></v>
</v>
<v t="felix.20200302205810.1"><vh>class ExternalFilesController</vh>
<v t="felix.20200302205810.2"><vh>efc.ctor</vh></v>
<v t="felix.20200302205810.7"><vh>efc.on_idle</vh></v>
<v t="felix.20200302205810.8"><vh>efc.idle_check_commander</vh></v>
<v t="felix.20200302205810.9"><vh>efc.idle_check_at_file_node</vh></v>
<v t="felix.20200304221925.1"><vh>efc.integResult</vh></v>
<v t="felix.20200302205810.21"><vh>efc.utilities</vh>
<v t="felix.20200302205810.22"><vh>efc.ask</vh></v>
<v t="felix.20200302205810.23"><vh>efc.checksum</vh></v>
<v t="felix.20200302205810.25"><vh>efc.get_mtime</vh></v>
<v t="felix.20200302205810.26"><vh>efc.get_time</vh></v>
<v t="felix.20200302205810.27"><vh>efc.has_changed</vh></v>
<v t="felix.20200302205810.28"><vh>efc.is_enabled</vh></v>
<v t="felix.20200302205810.29"><vh>efc.join</vh></v>
<v t="felix.20200302205810.30"><vh>efc.set_time</vh></v>
<v t="felix.20200302205810.31"><vh>efc.warn</vh></v>
</v>
<v t="felix.20200308145948.1"><vh>other called methods</vh>
<v t="felix.20200308150856.1"><vh>open_with</vh></v>
<v t="felix.20200308150848.1"><vh>check_overwrite</vh></v>
<v t="felix.20200308150821.1"><vh>shut_down</vh></v>
<v t="felix.20200308150842.1"><vh>destroy_frame</vh></v>
</v>
</v>
<v t="felix.20191126232434.4"><vh>class LeoBridgeIntegController</vh>
<v t="felix.20191126232434.5"><vh>__init__</vh></v>
<v t="felix.20200303214235.1"><vh>_asyncIdleLoop</vh></v>
<v t="felix.20200626012709.1"><vh>_returnNo</vh></v>
<v t="felix.20200626030820.1"><vh>_returnYes</vh></v>
<v t="felix.20200303214255.1"><vh>_idleTime</vh></v>
<v t="felix.20200623201853.1"><vh>_getTotalOpened</vh></v>
<v t="felix.20200623215904.1"><vh>_getFirstOpenedCommander</vh></v>
<v t="felix.20200304224909.1"><vh>sendAsyncOutput</vh></v>
<v t="felix.20200304220844.1"><vh>askResult</vh></v>
<v t="felix.20200312231358.1"><vh>applyConfig</vh></v>
<v t="felix.20200219224515.1"><vh>logSignon</vh></v>
<v t="felix.20200219222712.1"><vh>es</vh></v>
<v t="felix.20200211202929.1"><vh>initConnection</vh></v>
<v t="felix.20200622230608.1"><vh>getOpenedFiles</vh></v>
<v t="felix.20200624172552.1"><vh>setOpenedFile</vh></v>
<v t="felix.20191126232434.13"><vh>openFile</vh></v>
<v t="felix.20191126232434.14"><vh>closeFile</vh></v>
<v t="felix.20200216160305.1"><vh>saveFile</vh></v>
<v t="felix.20200619165641.1"><vh>getStates</vh></v>
<v t="felix.20200710014747.1"><vh>getButtons</vh></v>
<v t="felix.20200718122313.1"><vh>removeButton</vh></v>
<v t="felix.20200710030614.1"><vh>clickButton</vh></v>
<v t="felix.20200711182907.1"><vh>getCommands</vh></v>
<v t="felix.20200718122351.1"><vh>runByName</vh></v>
<v t="felix.20191128003151.1"><vh>JSON Output Functions</vh>
<v t="felix.20191128004456.1"><vh>setActionId</vh></v>
<v t="felix.20200213195413.1"><vh>asyncOutput</vh></v>
<v t="felix.20191126232434.7"><vh>sendLeoBridgePackage</vh></v>
<v t="felix.20191126232434.8"><vh>outputError</vh></v>
<v t="felix.20191126232434.9"><vh>outputBodyData</vh></v>
<v t="felix.20191126232434.10"><vh>outputPNode</vh></v>
<v t="felix.20191126232434.11"><vh>outputPNodes</vh></v>
</v>
<v t="felix.20200705193918.1"><vh>Outline Goto Commands</vh>
<v t="felix.20200705193927.1"><vh>pageUp</vh></v>
<v t="felix.20200711210205.1"><vh>pageDown</vh></v>
<v t="felix.20200711210205.2"><vh>gotoFirstVisible</vh></v>
<v t="felix.20200705233325.1"><vh>gotoLastVisible</vh></v>
<v t="felix.20200705201100.1"><vh>gotoLastSibling</vh></v>
<v t="felix.20200705223536.1"><vh>gotoNextVisible</vh></v>
<v t="felix.20200705223541.1"><vh>gotoPrevVisible</vh></v>
<v t="felix.20200706030410.1"><vh>gotoNextMarked</vh></v>
<v t="felix.20200706202247.1"><vh>gotoNextClone</vh></v>
<v t="felix.20200705223430.1"><vh>contractOrGoLeft</vh></v>
<v t="felix.20200705223521.1"><vh>expandAndGoRight</vh></v>
</v>
<v t="felix.20191128000818.1"><vh>Outline Editing Commands</vh>
<v t="felix.20191127004621.1"><vh>markPNode</vh></v>
<v t="felix.20191127235913.1"><vh>unmarkPNode</vh></v>
<v t="felix.20191231203545.1"><vh>clonePNode</vh></v>
<v t="felix.20191127004619.1"><vh>copyPNode</vh></v>
<v t="felix.20191127004620.1"><vh>cutPNode</vh></v>
<v t="felix.20191130211048.1"><vh>pastePNode</vh></v>
<v t="felix.20191130211048.2"><vh>pasteAsClonePNode</vh></v>
<v t="felix.20191127002548.1"><vh>deletePNode</vh></v>
<v t="felix.20191127000344.1"><vh>movePNodeDown</vh></v>
<v t="felix.20191127000419.1"><vh>movePNodeLeft</vh></v>
<v t="felix.20191127000420.1"><vh>movePNodeRight</vh></v>
<v t="felix.20191127000420.2"><vh>movePNodeUp</vh></v>
<v t="felix.20191127001506.1"><vh>insertPNode</vh></v>
<v t="felix.20200120224033.1"><vh>insertNamedPNode</vh></v>
<v t="felix.20191127001506.2"><vh>promotePNode</vh></v>
<v t="felix.20191127001506.3"><vh>demotePNode</vh></v>
<v t="felix.20191231184412.1"><vh>sortChildrenPNode</vh></v>
<v t="felix.20191231184412.2"><vh>sortSiblingsPNode</vh></v>
<v t="felix.20191231201748.1"><vh>hoistPNode</vh></v>
<v t="felix.20191231201749.1"><vh>deHoist</vh></v>
</v>
<v t="felix.20191128001054.1"><vh>Outline and Body Interaction</vh>
<v t="felix.20200105173826.1"><vh>outlineCommand</vh></v>
<v t="felix.20191231203711.1"><vh>undo</vh></v>
<v t="felix.20200103204811.1"><vh>redo</vh></v>
<v t="felix.20200301235235.1"><vh>refreshFromDiskPNode</vh></v>
<v t="felix.20191231214801.1"><vh>executeScript</vh></v>
<v t="felix.20191126232434.15"><vh>getPNode</vh></v>
<v t="felix.20191126232434.16"><vh>getChildren</vh></v>
<v t="felix.20191126232434.17"><vh>getParent</vh></v>
<v t="felix.20191126232434.18"><vh>getSelectedNode</vh></v>
<v t="felix.20191201194046.1"><vh>getAllGnx</vh></v>
<v t="felix.20191126232434.19"><vh>getBody</vh></v>
<v t="felix.20191126232434.20"><vh>getBodyLength</vh></v>
<v t="felix.20191126232434.21"><vh>setNewBody</vh></v>
<v t="felix.20191126232434.22"><vh>setBody</vh></v>
<v t="felix.20191126232434.23"><vh>setNewHeadline</vh></v>
<v t="felix.20191126232434.24"><vh>setSelectedNode</vh></v>
<v t="felix.20191126232434.25"><vh>expandNode</vh></v>
<v t="felix.20191126232434.26"><vh>collapseNode</vh></v>
<v t="felix.20200329000454.1"><vh>contractAll</vh></v>
<v t="felix.20191126232434.29"><vh>yieldAllRootChildren</vh></v>
<v t="felix.20191216195906.1"><vh>findPNodeFromGnx</vh></v>
</v>
<v t="felix.20191128003648.1"><vh>leoFlexx Conversion Functions</vh>
<v t="felix.20191126232434.27"><vh>create_gnx_to_vnode</vh></v>
<v t="felix.20191126232434.28"><vh>test_round_trip_positions</vh></v>
<v t="felix.20191126232434.30"><vh>ap_to_p</vh></v>
<v t="felix.20191126232434.31"><vh>p_to_ap</vh></v>
</v>
</v>
<v t="felix.20191126232435.1"><vh>main</vh></v>
</v>
<v t="felix.20200718024635.1"><vh>@clean src/commandStack.ts</vh>
<v t="felix.20200718024635.2"><vh>class CommandStack</vh>
<v t="felix.20200718024635.3"><vh>size</vh></v>
<v t="felix.20200718024635.4"><vh>newSelection</vh></v>
<v t="felix.20200718024635.5"><vh>add</vh></v>
<v t="felix.20200718024635.6"><vh>_tryStart</vh></v>
<v t="felix.20200718024635.7"><vh>_runStackCommand</vh></v>
<v t="felix.20200718024635.8"><vh>_resolveResult</vh></v>
</v>
</v>
<v t="felix.20200718030926.1"><vh>@clean src/config.ts</vh>
<v t="felix.20200718030926.2"><vh>class Config</vh>
<v t="felix.20200718030926.3"><vh>getConfig</vh></v>
<v t="felix.20200718030926.4"><vh>setLeoIntegSettings</vh></v>
<v t="felix.20200718030926.5"><vh>buildFromSavedSettings</vh></v>
</v>
</v>
<v t="felix.20200718020912.1"><vh>@clean src/constants.ts</vh>
<v t="felix.20200718020912.2"><vh>class Constants</vh>
<v t="felix.20200718020912.3"><vh>general constants</vh></v>
<v t="felix.20200718020912.4"><vh>language id's</vh></v>
<v t="felix.20200718020912.5"><vh>workbench interface panels</vh></v>
<v t="felix.20200718020912.6"><vh>user messages</vh></v>
<v t="felix.20200718020912.7"><vh>ask/save buttons</vh></v>
<v t="felix.20200718020912.8"><vh>configuration keys</vh></v>
<v t="felix.20200718020912.9"><vh>context flags</vh></v>
<v t="felix.20200718020912.14"><vh>vscode executeCommand strings</vh></v>
<v t="felix.20200718020912.10"><vh>async actions</vh></v>
<v t="felix.20200718020912.11"><vh>async info messages codes</vh></v>
<v t="felix.20200718020912.12"><vh>async ask return codes</vh></v>
<v t="felix.20200718020912.13"><vh>leoBridge action strings</vh></v>
<v t="felix.20200718020912.15"><vh>commands strings</vh></v>
</v>
</v>
<v t="felix.20200718031424.1"><vh>@clean src/extension.ts</vh>
<v t="felix.20200718031424.2"><vh>activate</vh>
<v t="felix.20200718031424.4"><vh>TODO commands</vh></v>
<v t="felix.20200718031424.5"><vh>button commands</vh></v>
<v t="felix.20200718031424.6"><vh>file commands</vh></v>
<v t="felix.20200718031424.7"><vh>edit headline commands</vh></v>
<v t="felix.20200718031424.8"><vh>node commands...</vh>
<v t="felix.20200718031424.9"><vh>cut/copy/paste</vh></v>
<v t="felix.20200718031424.10"><vh>expand/contract</vh></v>
<v t="felix.20200718031424.11"><vh>git-diff</vh></v>
<v t="felix.20200718031424.12"><vh>goto</vh></v>
<v t="felix.20200718031424.13"><vh>hoist/dehoist</vh></v>
<v t="felix.20200718031424.14"><vh>insert/clone</vh></v>
<v t="felix.20200718031424.15"><vh>mark/unmark</vh></v>
<v t="felix.20200718031424.16"><vh>move nodes</vh></v>
<v t="felix.20200718031424.17"><vh>pgUp/pgDown</vh></v>
<v t="felix.20200718031424.18"><vh>promote/demote</vh></v>
<v t="felix.20200718031424.19"><vh>sorting</vh></v>
<v t="felix.20200718031424.20"><vh>undo/redo</vh></v>
</v>
<v t="felix.20200718031424.21"><vh>server commands</vh></v>
<v t="felix.20200718031424.22"><vh>select/show commands</vh></v>
</v>
<v t="felix.20200718031424.24"><vh>deactivate</vh></v>
<v t="felix.20200718031424.25"><vh>showWelcomeIfNewer</vh></v>
<v t="felix.20200718031424.26"><vh>getDurationMilliseconds</vh></v>
</v>
<v t="felix.20200718035737.1"><vh>@clean src/leoAsync.ts</vh>
<v t="felix.20200718035737.2"><vh>class LeoAsync</vh>
<v t="felix.20200718035737.3"><vh>log</vh></v>
<v t="felix.20200718035737.4"><vh>showSaveAsDialog</vh></v>
<v t="felix.20200718035737.5"><vh>showAskModalDialog</vh></v>
<v t="felix.20200718035737.6"><vh>showWarnModalMessage</vh></v>
<v t="felix.20200718035737.7"><vh>showChangesDetectedInfoMessage</vh></v>
</v>
</v>
<v t="felix.20200718040540.1"><vh>@clean src/leoBody.ts</vh>
<v t="felix.20200718040540.2"><vh>class LeoBodyProvider</vh>
<v t="felix.20200718040540.3"><vh>setBodyTime</vh></v>
<v t="felix.20200718040540.4"><vh>setRenameTime</vh></v>
<v t="felix.20200718040540.5"><vh>fireRefreshFile</vh></v>
<v t="felix.20200718040540.6"><vh>refreshPossibleGnxList</vh></v>
<v t="felix.20200718040540.7"><vh>getExpiredGnxList</vh></v>
<v t="felix.20200718040540.8"><vh>watch</vh></v>
<v t="felix.20200718040540.9"><vh>fireDeleteExpiredGnx</vh></v>
<v t="felix.20200718040540.10"><vh>stat</vh></v>
<v t="felix.20200718040540.11"><vh>readFile</vh></v>
<v t="felix.20200718040540.12"><vh>readDirectory</vh></v>
<v t="felix.20200718040540.13"><vh>createDirectory</vh></v>
<v t="felix.20200718040540.14"><vh>writeFile</vh></v>
<v t="felix.20200718040540.15"><vh>rename</vh></v>
<v t="felix.20200718040540.16"><vh>delete</vh></v>
<v t="felix.20200718040540.17"><vh>copy</vh></v>
<v t="felix.20200718040540.18"><vh>_fireSoon</vh></v>
</v>
</v>
<v t="felix.20200718153505.1"><vh>@clean src/leoBridge.ts</vh>
<v t="felix.20200718153505.2"><vh>class LeoBridge</vh>
<v t="felix.20200718153505.3"><vh>action</vh></v>
<v t="felix.20200718155251.1"><vh>isBusy</vh></v>
<v t="felix.20200718153505.4"><vh>_asyncAction</vh></v>
<v t="felix.20200718153505.5"><vh>_buildActionParameter</vh></v>
<v t="felix.20200718153505.6"><vh>_resolveBridgeReady</vh></v>
<v t="felix.20200718153505.7"><vh>_rejectAction</vh></v>
<v t="felix.20200718153505.8"><vh>_callAction</vh></v>
<v t="felix.20200718153505.9"><vh>_tryParseJSON</vh></v>
<v t="felix.20200718153505.11"><vh>_processAnswer</vh></v>
<v t="felix.20200718153505.12"><vh>initLeoProcess</vh></v>
<v t="felix.20200718153505.13"><vh>_send</vh></v>
</v>
</v>
<v t="felix.20200718162303.1"><vh>@clean src/leoButtonNode.ts</vh>
<v t="felix.20200718162303.2"><vh>class LeoButtonNode</vh>
<v t="felix.20200718162435.1"><vh>iconPath</vh></v>
<v t="felix.20200718162442.1"><vh>id</vh></v>
<v t="felix.20200718162452.1"><vh>tooltip</vh></v>
<v t="felix.20200718162459.1"><vh>description</vh></v>
</v>
</v>
<v t="felix.20200718164130.1"><vh>@clean src/leoButtons.ts</vh>
<v t="felix.20200718164130.2"><vh>class LeoButtonsProvider</vh>
<v t="felix.20200718164130.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718164130.4"><vh>getTreeItem</vh></v>
<v t="felix.20200718164130.5"><vh>getChildren</vh></v>
<v t="felix.20200718164130.6"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718164509.1"><vh>@clean src/leoDocumentNode.ts</vh>
<v t="felix.20200718164509.2"><vh>class LeoDocumentNode</vh>
<v t="felix.20200718164635.1"><vh>iconPath</vh></v>
<v t="felix.20200718164638.1"><vh>id</vh></v>
</v>
</v>
<v t="felix.20200718165108.1"><vh>@clean src/leoDocuments.ts</vh>
<v t="felix.20200718165108.2"><vh>class LeoDocumentsProvider</vh>
<v t="felix.20200718165108.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718165108.4"><vh>getTreeItem</vh></v>
<v t="felix.20200718165108.5"><vh>getChildren</vh></v>
<v t="felix.20200718165108.6"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718170429.1"><vh>@clean src/leoFileBrowser.ts</vh>
<v t="felix.20200718170429.2"><vh>class LeoFilesBrowser</vh>
<v t="felix.20200718170429.3"><vh>_getBestOpenFolderUri</vh></v>
<v t="felix.20200718170429.4"><vh>getLeoFileUrl</vh></v>
</v>
</v>
<v t="felix.20200718170712.1"><vh>@clean src/leoNode.ts</vh>
<v t="felix.20200718170712.2"><vh>class LeoNode</vh>
<v t="felix.20200718170712.3"><vh>copyProperties</vh></v>
<v t="felix.20200718170712.4"><vh>setRoot</vh></v>
<v t="felix.20200718170712.5"><vh>_getNodeContextValue</vh></v>
<v t="felix.20200718170712.6"><vh>getCursorSelection</vh></v>
<v t="felix.20200718170712.7"><vh>setCursorSelection</vh></v>
<v t="felix.20200718171904.1"><vh>iconPath</vh></v>
<v t="felix.20200718171854.1"><vh>id</vh></v>
<v t="felix.20200718171837.1"><vh>description</vh></v>
<v t="felix.20200718171849.1"><vh>tooltip</vh></v>
</v>
</v>
<v t="felix.20200718180428.1"><vh>@clean src/leoOutline.ts</vh>
<v t="felix.20200718180428.2"><vh>class LeoOutlineProvider</vh>
<v t="felix.20200718180428.3"><vh>refreshTreeNode</vh></v>
<v t="felix.20200718180428.4"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718180428.5"><vh>getTreeItem</vh></v>
<v t="felix.20200718180428.6"><vh>getChildren</vh></v>
<v t="felix.20200718180428.7"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718192351.1"><vh>@clean src/leoStates.ts</vh>
<v t="felix.20200718192411.1"><vh>class LeoStates</vh>
<v t="felix.20200718193719.1"><vh>General State Flags</vh>
<v t="felix.20200718193219.1"><vh>leoBridgeReady</vh></v>
<v t="felix.20200718193222.1"><vh>fileOpenedReady</vh></v>
<v t="felix.20200718193226.1"><vh>leoOpenedFileName</vh></v>
<v t="felix.20200718193230.1"><vh>leoChanged</vh></v>
<v t="felix.20200718193233.1"><vh>leoCanUndo</vh></v>
<v t="felix.20200718193235.1"><vh>leoCanRedo</vh></v>
<v t="felix.20200718193238.1"><vh>leoCanDemote</vh></v>
<v t="felix.20200718193241.1"><vh>leoCanPromote</vh></v>
<v t="felix.20200718193244.1"><vh>leoCanDehoist</vh></v>
</v>
<v t="felix.20200718193731.1"><vh>Selected Node Flags</vh>
<v t="felix.20200718193338.1"><vh>leoMarked</vh></v>
<v t="felix.20200718193341.1"><vh>leoCloned</vh></v>
<v t="felix.20200718193343.1"><vh>leoDirty</vh></v>
<v t="felix.20200718193348.1"><vh>leoEmpty</vh></v>
<v t="felix.20200718193350.1"><vh>leoChild</vh></v>
<v t="felix.20200718193353.1"><vh>leoAtFile</vh></v>
<v t="felix.20200718193403.1"><vh>leoRoot</vh></v>
</v>
<v t="felix.20200718193500.1"><vh>constructor</vh></v>
<v t="felix.20200718192411.2"><vh>selectedNodeFlags</vh></v>
<v t="felix.20200718192411.3"><vh>leoStateFlags</vh></v>
</v>
</v>
<v t="felix.20200718185403.1"><vh>@clean src/leoStatusBar.ts</vh>
<v t="felix.20200718185403.2"><vh>class LeoStatusBar</vh>
<v t="felix.20200718185403.3"><vh>show</vh></v>
<v t="felix.20200718185403.4"><vh>hide</vh></v>
<v t="felix.20200718185403.5"><vh>setString</vh></v>
<v t="felix.20200718185403.6"><vh>update</vh></v>
<v t="felix.20200718185403.7"><vh>_updateLeoObjectIndicatorDebounced</vh></v>
<v t="felix.20200718185403.8"><vh>_updateLeoObjectIndicator</vh></v>
</v>
</v>
<v t="felix.20200718191946.1"><vh>@clean src/serverManager.ts</vh>
<v t="felix.20200718191946.2"><vh>class ServerService</vh>
<v t="felix.20200718191946.3"><vh>_gotTerminalData</vh></v>
<v t="felix.20200718191946.4"><vh>startServer</vh></v>
</v>
</v>
<v t="felix.20200718194857.1"><vh>@clean src/types.d.ts</vh>
<v t="felix.20200718194857.2"><vh>ConfigMembers</vh></v>
<v t="felix.20200718194857.3"><vh>RevealType</vh></v>
<v t="felix.20200718194857.4"><vh>RefreshType</vh></v>
<v t="felix.20200718194857.5"><vh>UserCommand</vh></v>
<v t="felix.20200718194857.6"><vh>LeoAction</vh></v>
<v t="felix.20200718194857.7"><vh>LeoLogEntry</vh></v>
<v t="felix.20200718194857.8"><vh>ArchivedPosition</vh></v>
<v t="felix.20200718194857.9"><vh>LeoPackageStates</vh></v>
<v t="felix.20200718194857.10"><vh>LeoBridgePackage</vh></v>
<v t="felix.20200718194857.11"><vh>LeoDocument</vh></v>
<v t="felix.20200718194857.12"><vh>LeoButton</vh></v>
<v t="felix.20200718194857.13"><vh>Icon</vh></v>
<v t="felix.20200718194857.14"><vh>BodyTimeInfo</vh></v>
<v t="felix.20200718194857.15"><vh>showSaveAsDialogParameters</vh></v>
<v t="felix.20200718194857.16"><vh>runAskYesNoDialogParameters</vh></v>
<v t="felix.20200718194857.17"><vh>runWarnMessageDialogParameters</vh></v>
<v t="felix.20200718194857.18"><vh>runInfoMessageDialogParameters</vh></v>
<v t="felix.20200718194857.19"><vh>AskMessageItem</vh></v>
<v t="felix.20200718194857.20"><vh>ChooseDocumentItem</vh></v>
</v>
<v t="felix.20200718195558.1"><vh>@clean src/utils.ts</vh>
<v t="felix.20200718195558.2"><vh>padNumber2</vh></v>
<v t="felix.20200718195558.3"><vh>buildNodeIconPaths</vh></v>
<v t="felix.20200718195558.4"><vh>buildDocumentIconPaths</vh></v>
<v t="felix.20200718195558.5"><vh>buildButtonsIconPaths</vh></v>
<v t="felix.20200718195558.6"><vh>buildNodeAndTextJson</vh></v>
<v t="felix.20200718195558.7"><vh>getFileFromPath</vh></v>
<v t="felix.20200718195558.8"><vh>isIconChangedByEdit</vh></v>
<v t="felix.20200718195558.9"><vh>isHexColor</vh></v>
<v t="felix.20200718195558.10"><vh>strToLeoUri</vh></v>
<v t="felix.20200718195558.11"><vh>leoUriToStr</vh></v>
<v t="felix.20200718195558.12"><vh>setContext</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="felix.20190922171916.2">@doc

This Leo file contains all of the source for the Visual Studio Code 'Leo Integration' Extension

To contribute, see the official issues page for current list of 'TODO's at https://github.com/boltex/leointeg/issues

Coding Standards
================

All non-trivial structure types should be defined in the types.d.ts file. Any other symbol should have its type properly defined at declaration.

Avoid hardcoded data in code. Immutable constants and objects structures should be in the constants.ts source file.

Generic, re-usable utility functions are kept in the utils.ts source file.



Symbols Decorators prefixes
---------------------------

w_symbol : A 'work' variable, to work with.

p_symbol : This was passed as parameter into the scope you're in.

i_symbol : This in index for a loop or an iteration of some kind.

UPPERCASE : An immutable constant from the constants.ts source file.


</t>
<t tx="felix.20191126232434.10">def outputPNode(self, p_node=False):
    if p_node:
        return self.sendLeoBridgePackage("node", self.p_to_ap(p_node))  # Single node, singular
    else:
        return self.sendLeoBridgePackage("node", None)

</t>
<t tx="felix.20191126232434.11">def outputPNodes(self, p_pList):
    w_apList = []
    for p in p_pList:
        w_apList.append(self.p_to_ap(p))
    return self.sendLeoBridgePackage("nodes", w_apList)  # Multiple nodes, plural

</t>
<t tx="felix.20191126232434.13">def openFile(self, p_file):
    """
    Open a leo file via leoBridge controller, or create a new document if empty string.
    Returns an object that contains a 'opened' member.
    """
    w_found = False

    # If not empty string (asking for New file) then check if already opened
    if p_file:
        for w_commander in self.g.app.commanders():
            if w_commander.fileName() == p_file:
                w_found = True
                self.commander = w_commander

    if not w_found:
        self.commander = self.bridge.openLeoFile(p_file)  # create self.commander

    # Leo at this point has done this too: g.app.windowList.append(c.frame)
    # and so this now app.commanders() yields this: return [f.c for f in g.app.windowList]

    # did this add to existing array of g.app.commanders() ?
    # print(*self.g.app.commanders(), sep='\n')

    if self.commander:
        self.commander.closed = False
        self.create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self.p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage("opened", w_result)
    else:
        return self.outputError('Error in openFile')

</t>
<t tx="felix.20191126232434.14">def closeFile(self, p_package):
    """
    Closes a leo file. A file can then be opened with "openFile"
    Returns an object that contains a 'closed' member
    """
    # TODO : Specify which file to support multiple opened files
    if self.commander:
        if p_package["forced"] and self.commander.changed:
            # return "no" g.app.gui.runAskYesNoDialog  and g.app.gui.runAskYesNoCancelDialog
            self.commander.revert()
        if p_package["forced"] or not self.commander.changed:
            self.commander.closed = True
            self.commander.close()
        else:
            return self.sendLeoBridgePackage('closed', False)  # Cannot close, ask to save, ignore or cancel

    # Switch commanders to first available
    w_total = self._getTotalOpened()
    if w_total:
        self.commander = self._getFirstOpenedCommander()
    else:
        self.commander = None

    if self.commander:
        self.create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self.p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage("closed", w_result)
    else:
        w_result = {"total": 0}
        return self.sendLeoBridgePackage("closed", w_result)

</t>
<t tx="felix.20191126232434.15">def getPNode(self, p_ap):
    '''EMIT OUT a node, don't select it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            return self.outputPNode(w_p)
        else:
            return self.outputError("Error in getPNode no w_p node found")
    else:
        return self.outputError("Error in getPNode no param p_ap")

</t>
<t tx="felix.20191126232434.16">def getChildren(self, p_ap):
    '''EMIT OUT list of children of a node'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p and w_p.hasChildren():
            return self.outputPNodes(w_p.children())
        else:
            return self.outputPNodes([])  # default empty array
    else:
        if self.commander.hoistStack:
            return self.outputPNodes([self.commander.hoistStack[-1].p])
        else:
            return self.outputPNodes(self.yieldAllRootChildren())  # this outputs all Root Children

</t>
<t tx="felix.20191126232434.17">def getParent(self, p_ap):
    '''EMIT OUT the parent of a node, as an array, even if unique or empty'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p and w_p.hasParent():
            return self.outputPNode(w_p.getParent())
        else:
            return self.outputPNode()  # default empty for root
    else:
        return self.outputPNode()

</t>
<t tx="felix.20191126232434.18">def getSelectedNode(self, p_paramUnused):
    '''EMIT OUT Selected Position as an array, even if unique'''
    if self.commander.p:
        return self.outputPNode(self.commander.p)
    else:
        return self.outputPNode()

</t>
<t tx="felix.20191126232434.19">def getBody(self, p_gnx):
    '''EMIT OUT body of a node'''
    if p_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(p_gnx)  # vitalije
        if w_v:
            if w_v.b:
                return self.outputBodyData(w_v.b)
            else:
                return self.outputBodyData()  # default "" empty string
        else:
            return self.sendLeoBridgePackage()  # empty as inexistent
    else:
        return self.sendLeoBridgePackage()  # empty as inexistent

</t>
<t tx="felix.20191126232434.2">#! python3
@language python
@tabwidth -4
@others
if __name__ == '__main__':
    # Startup
    try:
        main()
    except KeyboardInterrupt:
        print("\nKeyboard Interupt: Stopping leobridge server", flush=True)
        sys.exit()
</t>
<t tx="felix.20191126232434.20">def getBodyLength(self, p_gnx):
    '''EMIT OUT body string length of a node'''
    if p_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(p_gnx)  # vitalije
        if w_v and len(w_v.b):
            return self.sendLeoBridgePackage("bodyLength", len(w_v.b))
        else:
            return self.sendLeoBridgePackage("bodyLength", 0)
    else:
        # TODO : May need to signal inexistent by self.sendLeoBridgePackage()  # empty as inexistent
        return self.sendLeoBridgePackage("bodyLength", 0)

</t>
<t tx="felix.20191126232434.21">def setNewBody(self, p_body):
    '''Change Body of selected node'''
    # TODO : This method is unused for now? Remove if unnecessary.
    # TODO : Does this support 'Undo'?
    if self.commander.p:
        self.commander.p.b = p_body['body']
        return self.outputPNode(self.commander.p)
    else:
        return self.outputError("Error in setNewBody")

</t>
<t tx="felix.20191126232434.22">def setBody(self, p_package):
    '''Change Body text of a node'''
    for w_p in self.commander.all_positions():
        if w_p.v.gnx == p_package['gnx']:  # found
            # TODO : Before setting undo and trying to set body, first check if different than existing body
            w_bunch = self.commander.undoer.beforeChangeNodeContents(w_p)  # setup undoable operation
            w_p.v.setBodyString(p_package['body'])
            self.commander.undoer.afterChangeNodeContents(w_p, "Body Text", w_bunch)
            if not self.commander.isChanged():
                self.commander.setChanged()
            if not w_p.v.isDirty():
                w_p.setDirty()
            break
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.23">def setNewHeadline(self, p_package):
    '''Change Headline of a node'''
    w_newHeadline = p_package['text']
    w_ap = p_package['node']
    if w_ap:
        w_p = self.ap_to_p(w_ap)
        if w_p:
            # set this node's new headline
            w_bunch = self.commander.undoer.beforeChangeNodeContents(w_p)
            w_p.h = w_newHeadline
            self.commander.undoer.afterChangeNodeContents(w_p, 'Change Headline', w_bunch)
            return self.outputPNode(w_p)
    else:
        return self.outputError("Error in setNewHeadline")

</t>
<t tx="felix.20191126232434.24">def setSelectedNode(self, p_ap):
    '''Select a node, or the first one found with its GNX'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            if self.commander.positionExists(w_p):
                # set this node as selection
                self.commander.selectPosition(w_p)
            else:
                w_foundPNode = self.findPNodeFromGnx(p_ap['gnx'])
                if w_foundPNode:
                    self.commander.selectPosition(w_foundPNode)
                else:
                    print("Set Selection node does not exist! ap was:" + json.dumps(p_ap))
    # * return the finally selected node
    if self.commander.p:
        return self.outputPNode(self.commander.p)
    else:
        return self.outputPNode()

</t>
<t tx="felix.20191126232434.25">def expandNode(self, p_ap):
    '''Expand a node'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_p.expand()
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.26">def collapseNode(self, p_ap):
    '''Collapse a node'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_p.contract()
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.27">def create_gnx_to_vnode(self):
    '''Make the first gnx_to_vnode array with all unique nodes'''
    t1 = time.process_time()
    self.gnx_to_vnode = {v.gnx: v for v in self.commander.all_unique_nodes()}
    # This is likely the only data that ever will be needed.
    if 0:
        print('app.create_all_data: %5.3f sec. %s entries' % (
            (time.process_time()-t1), len(list(self.gnx_to_vnode.keys()))))
    self.test_round_trip_positions()

</t>
<t tx="felix.20191126232434.28">def test_round_trip_positions(self):
    '''(From Leo plugin leoflexx.py) Test the round tripping of p_to_ap and ap_to_p.'''
    # Bug fix: p_to_ap updates app.gnx_to_vnode. Save and restore it.
    old_d = self.gnx_to_vnode.copy()
    old_len = len(list(self.gnx_to_vnode.keys()))
    t1 = time.process_time()
    qtyAllPositions = 0
    for p in self.commander.all_positions():
        qtyAllPositions += 1
        ap = self.p_to_ap(p)
        p2 = self.ap_to_p(ap)
        assert p == p2, (repr(p), repr(p2), repr(ap))
    gnx_to_vnode = old_d
    new_len = len(list(gnx_to_vnode.keys()))
    assert old_len == new_len, (old_len, new_len)
    print('Leo file opened. Its outline contains ' + str(qtyAllPositions) + " nodes positions.")
    print(('Testing app.test_round_trip_positions for all nodes: Total time: %5.3f sec.' % (time.process_time()-t1)))

</t>
<t tx="felix.20191126232434.29">def yieldAllRootChildren(self):
    '''Return all root children P nodes'''
    p = self.commander.rootPosition()
    while p:
        yield p
        p.moveToNext()

</t>
<t tx="felix.20191126232434.30">def ap_to_p(self, ap):
    '''(From Leo plugin leoflexx.py) Convert an archived position to a true Leo position.'''
    childIndex = ap['childIndex']
    v = self.gnx_to_vnode[ap['gnx']]
    stack = [
        (self.gnx_to_vnode[d['gnx']], d['childIndex'])
        for d in ap['stack']
    ]
    return leoNodes.position(v, childIndex, stack)

</t>
<t tx="felix.20191126232434.31">def p_to_ap(self, p):
    '''(From Leo plugin leoflexx.py) Converts Leo position to a serializable archived position.'''
    if not p.v:
        print('app.p_to_ap: no p.v: %r %s' % (p))
        assert False
    p_gnx = p.v.gnx
    if p_gnx not in self.gnx_to_vnode:
        self.gnx_to_vnode[p_gnx] = p.v
    # * necessary properties for outline
    w_ap = {
        'childIndex': p._childIndex,
        'gnx': p.v.gnx,
        'level': p.level(),
        'headline': p.h,
        'stack': [{
            'gnx': stack_v.gnx,
            'childIndex': stack_childIndex,
            'headline': stack_v.h,
        } for (stack_v, stack_childIndex) in p.stack],
    }
    # TODO : Convert all those booleans into an 8 bit integer 'status' flag
    if p.v.u:
        w_ap['u'] = p.v.u
    if bool(p.b):
        w_ap['hasBody'] = True
    if p.hasChildren():
        w_ap['hasChildren'] = True
    if p.isCloned():
        w_ap['cloned'] = True
    if p.isDirty():
        w_ap['dirty'] = True
    if p.isExpanded():
        w_ap['expanded'] = True
    if p.isMarked():
        w_ap['marked'] = True
    if p.isAnyAtFileNode():
        w_ap['atFile'] = True
    if p == self.commander.p:
        w_ap['selected'] = True
    return w_ap


</t>
<t tx="felix.20191126232434.4">class LeoBridgeIntegController:
    '''Leo Bridge Controller'''

    @others
</t>
<t tx="felix.20191126232434.5">def __init__(self):
    # TODO : @boltex #74 need gnx_to_vnode for each opened file/commander
    self.gnx_to_vnode = []  # utility array - see leoflexx.py in leoPluginsRef.leo
    self.bridge = leoBridge.controller(gui='nullGui',
                                       loadPlugins=True,  # True: attempt to load plugins.
                                       readSettings=True,  # True: read standard settings files.
                                       silent=True,      # True: don't print signon messages.
                                       verbose=False)     # True: prints messages that would be sent to the log pane.
    self.g = self.bridge.globals()

    # * Trace outputs to pythons stdout, also prints the function call stack
    # self.g.trace('test trace')

    # * Intercept Log Pane output: Sends to vsCode's log pane
    self.g.es = self.es  # pointer - not a function call

    # print(dir(self.g))
    self.currentActionId = 1  # Id of action being processed, STARTS AT 1 = Initial 'ready'

    # * Currently Selected Commander (opened from leo.core.leoBridge or chosen via the g.app.windowList frame list)
    self.commander = None

    self.leoIntegConfig = None
    self.webSocket = None
    self.loop = None

    # * Replacement instances to Leo's codebase : IdleTime, idleTimeManager and externalFilesController
    self.g.IdleTime = self._idleTime
    self.g.app.idleTimeManager = IdleTimeManager(self.g)
    # attach instance to g.app for calls to set_time, etc.
    self.g.app.externalFilesController = ExternalFilesController(self)
    # TODO : Maybe use those yes/no replacement right before actual usage instead of in init. (to allow re-use/switching)
    self.g.app.gui.runAskYesNoDialog = self._returnYes  # override for "revert to file" operation

    # * setup leoBackground to get messages from leo
    try:
        self.g.app.idleTimeManager.start()  # To catch derived file changes
    except:
        print('ERROR with idleTimeManager')

</t>
<t tx="felix.20191126232434.7">def sendLeoBridgePackage(self, p_key=False, p_any=None):
    w_package = {"id": self.currentActionId}
    if p_key:
        w_package[p_key] = p_any  # add [key]?:any
    return(json.dumps(w_package, separators=(',', ':')))  # send as json
    # await self.webSocket.send(json.dumps(w_package, separators=(',', ':')))  # send as json

</t>
<t tx="felix.20191126232434.8">def outputError(self, p_message="Unknown Error"):
    print("ERROR: " + p_message)  # Output to this server's running console
    w_package = {"id": self.currentActionId}
    w_package["error"] = p_message
    return p_message

</t>
<t tx="felix.20191126232434.9">def outputBodyData(self, p_bodyText=""):
    return self.sendLeoBridgePackage("bodyData", p_bodyText)

</t>
<t tx="felix.20191126232435.1">def main():
    '''python script for leo integration via leoBridge'''
    global wsHost, wsPort
    print("Starting LeoBridge... (Launch with -h for help)", flush=True)
    # replace default host address and port if provided as arguments

    try:
        opts, args = getopt.getopt(sys.argv[1:], "ha:p:", ["help", "address=", "port="])
    except getopt.GetoptError:
        print('leobridgeserver.py -a &lt;address&gt; -p &lt;port&gt;')
        print('defaults to localhost on port 32125', flush=True)
        if args:
            print("unused args: " + str(args), flush=True)
        sys.exit(2)
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            print('leobridgeserver.py -a &lt;address&gt; -p &lt;port&gt;')
            print('defaults to localhost on port 32125', flush=True)
            sys.exit()
        elif opt in ("-a", "--address"):
            wsHost = arg
        elif opt in ("-p", "--port"):
            wsPort = arg

    # * start Server
    integController = LeoBridgeIntegController()

    # * This is a basic example loop
    # async def asyncInterval(timeout):
    #     dummyCounter = 0
    #     strTimeout = str(timeout) + ' sec interval'
    #     while True:
    #         await asyncio.sleep(timeout)
    #         dummyCounter = dummyCounter+1
    #         await integController.asyncOutput("{\"interval\":" + str(timeout+dummyCounter) + "}")  # as number
    #         print(strTimeout)

    async def leoBridgeServer(websocket, path):
        try:
            integController.initConnection(websocket)
            await websocket.send(integController.sendLeoBridgePackage())  # * Start by sending empty as 'ok'
            integController.logSignon()
            async for w_message in websocket:
                w_param = json.loads(w_message)
                if w_param and w_param['action']:
                    # print("action:" + w_param['action'])
                    # * Storing id of action in global var instead of passing as parameter
                    integController.setActionId(w_param['id'])
                    # ! functions called this way need to accept at least a parameter other than 'self'
                    # ! See : getSelectedNode and getAllGnx
                    # TODO : Block attempts to call functions starting with underscore or reserved
                    answer = getattr(integController, w_param['action'])(w_param['param'])  # Crux
                else:
                    answer = "Error in processCommand"
                    print(answer, flush=True)
                await websocket.send(answer)
        except:
            print("Caught Websocket Disconnect Event", flush=True)
        finally:
            asyncio.get_event_loop().stop()

    localLoop = asyncio.get_event_loop()
    start_server = websockets.serve(leoBridgeServer, wsHost, wsPort)
    # localLoop.create_task(asyncInterval(5)) # Starts a test loop of async communication
    localLoop.run_until_complete(start_server)
    print("LeoBridge started at " + wsHost + " on port: " + str(wsPort) + " [ctrl+c] to break", flush=True)
    localLoop.run_forever()
    print("Stopping leobridge server", flush=True)


</t>
<t tx="felix.20191127000344.1">def movePNodeDown(self, p_ap):
    '''Move a node DOWN, don't select it if possible'''
    return self.outlineCommand("moveOutlineDown", p_ap, True)

</t>
<t tx="felix.20191127000419.1">def movePNodeLeft(self, p_ap):
    '''Move a node LEFT, don't select it if possible'''
    return self.outlineCommand("moveOutlineLeft", p_ap, True)

</t>
<t tx="felix.20191127000420.1">def movePNodeRight(self, p_ap):
    '''Move a node RIGHT, don't select it if possible'''
    return self.outlineCommand("moveOutlineRight", p_ap, True)

</t>
<t tx="felix.20191127000420.2">def movePNodeUp(self, p_ap):
    '''Move a node UP, don't select it if possible'''
    return self.outlineCommand("moveOutlineUp", p_ap, True)

</t>
<t tx="felix.20191127001506.1">def insertPNode(self, p_ap):
    '''Insert a node at given node, then select it once created, and finally return it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_bunch = self.commander.undoer.beforeInsertNode(w_p)
            w_newNode = w_p.insertAfter()
            w_newNode.setDirty()
            self.commander.undoer.afterInsertNode(w_newNode, 'Insert Node', w_bunch)
            self.commander.selectPosition(w_newNode)
            return self.outputPNode(self.commander.p)  # in both cases, return selected node
        else:
            return self.outputError("Error in insertPNode no w_p node found")  # default empty
    else:
        return self.outputError("Error in insertPNode no param p_ap")

</t>
<t tx="felix.20191127001506.2">def promotePNode(self, p_ap):
    '''Promote a node, don't select it if possible'''
    return self.outlineCommand("promote", p_ap, True)

</t>
<t tx="felix.20191127001506.3">def demotePNode(self, p_ap):
    '''Demote a node, don't select it if possible'''
    return self.outlineCommand("demote", p_ap, True)

</t>
<t tx="felix.20191127002548.1">def deletePNode(self, p_ap):
    '''Delete a node, don't select it. Try to keep selection, then return the selected node that remains'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            if w_p == self.commander.p:
                self.commander.deleteOutline()  # already on this node, so delete it
            else:
                oldPosition = self.commander.p  # not same node, save position to possibly return to
                self.commander.selectPosition(w_p)
                self.commander.deleteOutline()
                if self.commander.positionExists(oldPosition):
                    self.commander.selectPosition(oldPosition)  # select if old position still valid
                else:
                    oldPosition._childIndex = oldPosition._childIndex-1
                    # Try again with childIndex
                    if self.commander.positionExists(oldPosition):
                        self.commander.selectPosition(oldPosition)  # additional try with lowered childIndex
            return self.outputPNode(self.commander.p)  # in both cases, return selected node
        else:
            return self.outputError("Error in deletePNode no w_p node found")  # default empty
    else:
        return self.outputError("Error in deletePNode no param p_ap")

</t>
<t tx="felix.20191127004619.1">def copyPNode(self, p_ap):
    '''Copy a node, don't select it'''
    return self.outlineCommand("copyOutline", p_ap, True)

</t>
<t tx="felix.20191127004620.1">def cutPNode(self, p_ap):
    '''Cut a node, don't select it'''
    return self.outlineCommand("cutOutline", p_ap, True)

</t>
<t tx="felix.20191127004621.1">def markPNode(self, p_ap):
    '''Mark a node, don't select it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_p.setMarked()
            return self.outputPNode(self.commander.p)  # return selected node when done (not w_p)
        else:
            return self.outputError("Error in markPNode no w_p node found")
    else:
        return self.outputError("Error in markPNode no param p_ap")

</t>
<t tx="felix.20191127235913.1">def unmarkPNode(self, p_ap):
    '''Unmark a node, don't select it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_p.clearMarked()
            return self.outputPNode(self.commander.p)  # return selected node when done (not w_p)
        else:
            return self.outputError("Error in unmarkPNode no w_p node found")
    else:
        return self.outputError("Error in unmarkPNode no param p_ap")

</t>
<t tx="felix.20191128000818.1"></t>
<t tx="felix.20191128001054.1"></t>
<t tx="felix.20191128002414.1">import leo.core.leoBridge as leoBridge
import leo.core.leoNodes as leoNodes
import asyncio
import websockets
import sys
import getopt
import time
import json

</t>
<t tx="felix.20191128002417.1"># server defaults
wsHost = "localhost"
wsPort = 32125


</t>
<t tx="felix.20191128003151.1"></t>
<t tx="felix.20191128003648.1"></t>
<t tx="felix.20191128004456.1">def setActionId(self, p_id):
    self.currentActionId = p_id

</t>
<t tx="felix.20191130211048.1">def pastePNode(self, p_ap):
    '''Paste a node, don't select it if possible'''
    return self.outlineCommand("pasteOutline", p_ap, True)

</t>
<t tx="felix.20191130211048.2">def pasteAsClonePNode(self, p_ap):
    '''Paste as clone, don't select it if possible'''
    return self.outlineCommand("pasteOutlineRetainingClones", p_ap, True)

</t>
<t tx="felix.20191201194046.1">def getAllGnx(self, p_paramUnused):
    '''Get gnx array from all unique nodes'''
    w_all_gnx = [p.v.gnx for p in self.commander.all_unique_positions(copy=False)]
    return self.sendLeoBridgePackage("allGnx", w_all_gnx)

</t>
<t tx="felix.20191216195906.1">def findPNodeFromGnx(self, p_gnx):
    '''Return first p node with this gnx or false'''
    for p in self.commander.all_unique_positions():
        if p.v.gnx == p_gnx:
            return p
    return False

</t>
<t tx="felix.20191231184412.1">def sortChildrenPNode(self, p_ap):
    '''Sort children of a node, don't select it if possible'''
    return self.outlineCommand("sortChildren", p_ap, True)

</t>
<t tx="felix.20191231184412.2">def sortSiblingsPNode(self, p_ap):
    '''Sort siblings of a node, don't select it if possible'''
    return self.outlineCommand("sortSiblings", p_ap, True)

</t>
<t tx="felix.20191231201748.1">def hoistPNode(self, p_ap):
    '''Select and Hoist a node'''
    return self.outlineCommand("hoist", p_ap)  # Don't try to re-select node

</t>
<t tx="felix.20191231201749.1">def deHoist(self, p_paramUnused):
    '''De-Hoist'''
    self.commander.dehoist()
    return self.outputPNode(self.commander.p)  # in any case, return selected node

</t>
<t tx="felix.20191231203545.1">def clonePNode(self, p_ap):
    '''Clone a node, return it if it was also the current selection, otherwise try not to select it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            if w_p == self.commander.p:
                return self.outlineCommand("clone", p_ap, False)
            else:
                return self.outlineCommand("clone", p_ap, True)
        else:
            return self.outputError("Error in clonePNode function, no w_p node found")  # default empty
    else:
        return self.outputError("Error in clonePNode function, no param p_ap")

</t>
<t tx="felix.20191231203711.1">def undo(self, p_paramUnused):
    '''Undo last un-doable operation'''
    if self.commander.undoer.canUndo():
        self.commander.undoer.undo()
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="felix.20191231214801.1">def executeScript(self, p_package):
    '''Select a node and run its script'''
    if 'node' in p_package:
        w_ap = p_package['node']
        w_p = self.ap_to_p(w_ap)
        if w_p:
            self.commander.selectPosition(w_p)
            w_script = ""
            if 'text' in p_package:
                w_script = str(p_package['text'])
            if w_script and not w_script.isspace():
                # * Mimic getScript !!
                try:
                    # Remove extra leading whitespace so the user may execute indented code.
                    w_script = self.g.removeExtraLws(w_script, self.commander.tab_width)
                    w_script = self.g.extractExecutableString(self.commander, w_p, w_script)
                    w_validScript = self.g.composeScript(self.commander, w_p, w_script,
                                                         forcePythonSentinels=True,
                                                         useSentinels=True)
                    self.commander.executeScript(script=w_validScript)
                except Exception as e:
                    self.g.trace('Error while executing script')
                    print('Error while executing script')
                    print(str(e))
            else:
                self.commander.executeScript()
            return self.outputPNode(self.commander.p)  # in both cases, return selected node
        else:
            return self.outputError("Error in run no w_p node found")  # default empty
    else:
        return self.outputError("Error in run no param p_ap")

</t>
<t tx="felix.20200103204811.1">def redo(self, p_paramUnused):
    '''Undo last un-doable operation'''
    if self.commander.undoer.canRedo():
        self.commander.undoer.redo()
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="felix.20200105173826.1">def outlineCommand(self, p_command, p_ap, p_keepSelection=False):
    '''Generic call to an outline operation (p_command) for specific p-node (p_ap), with possibility of trying to preserve the current selection (p_keepSelection)'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_func = getattr(self.commander, p_command)
            if w_p == self.commander.p:
                w_func()
            else:
                oldPosition = self.commander.p  # not same node, save position to possibly return to
                self.commander.selectPosition(w_p)
                w_func()
                if p_keepSelection and self.commander.positionExists(oldPosition):
                    self.commander.selectPosition(oldPosition)  # select if old position still valid
            return self.outputPNode(self.commander.p)  # in both cases, return selected node
        else:
            return self.outputError("Error in " + p_command + " no w_p node found")  # default empty
    else:
        return self.outputError("Error in " + p_command + " no param p_ap")

</t>
<t tx="felix.20200120224033.1">def insertNamedPNode(self, p_package):
    '''Insert a node at given node, set its headline, select it and finally return it'''
    w_newHeadline = p_package['text']
    w_ap = p_package['node']
    if w_ap:
        w_p = self.ap_to_p(w_ap)
        if w_p:
            w_u = self.commander.undoer.beforeInsertNode(w_p)
            w_newNode = w_p.insertAfter()
            # set this node's new headline
            w_newNode.h = w_newHeadline
            w_newNode.setDirty()
            self.commander.undoer.afterInsertNode(w_newNode, 'Insert Node', w_u)
            self.commander.selectPosition(w_newNode)
            return self.outputPNode(self.commander.p)  # in any case, return selected node
        else:
            return self.outputError("Error in insertNamedPNode no w_p node found")  # default empty
    else:
        return self.outputError("Error in insertNamedPNode no param w_ap")

</t>
<t tx="felix.20200211202929.1">def initConnection(self, p_webSocket):
    self.webSocket = p_webSocket
    self.loop = asyncio.get_event_loop()

</t>
<t tx="felix.20200213195413.1">async def asyncOutput(self, p_json):
    '''Output json string to the websocket'''
    if self.webSocket:
        await self.webSocket.send(p_json)
    else:
        print("websocket not ready yet")

</t>
<t tx="felix.20200216160305.1">def saveFile(self, p_package):
    '''Saves the leo file. New or dirty derived files are rewritten'''
    if self.commander:
        try:
            if "text" in p_package:
                self.commander.save(fileName=p_package['text'])
            else:
                self.commander.save()
        except Exception as e:
            self.g.trace('Error while saving')
            print("Error while saving")
            print(str(e))

    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200219222712.1">def es(self, * args, **keys):
    '''Output to the Log Pane'''
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
        'nodeLink': None,
    }
    d = self.g.doKeywordArgs(keys, d)
    s = self.g.translateArgs(args, d)
    w_package = {"async": "log", "log": s}
    self.sendAsyncOutput(w_package)

</t>
<t tx="felix.20200219224515.1">def logSignon(self):
    '''Simulate the Initial Leo Log Entry'''
    if self.loop:
        self.g.app.computeSignon()
        self.g.es(str(self.g.app.signon))
        self.g.es(str(self.g.app.signon1))
    else:
        print('no loop in logSignon')

</t>
<t tx="felix.20200301235235.1">def refreshFromDiskPNode(self, p_ap):
    '''Refresh from Disk, don't select it if possible'''
    return self.outlineCommand("refreshFromDisk", p_ap, True)

</t>
<t tx="felix.20200302204251.1">class IdleTimeManager:
    """
    A singleton class to manage idle-time handling. This class handles all
    details of running code at idle time, including running 'idle' hooks.

    Any code can call g.app.idleTimeManager.add_callback(callback) to cause
    the callback to be called at idle time forever.
    """
    # TODO : REVISE/REPLACE WITH OWN SYSTEM

    def __init__(self, g):
        """Ctor for IdleTimeManager class."""
        self.g = g
        self.callback_list = []
        self.timer = None
        self.on_idle_count = 0

    @others

</t>
<t tx="felix.20200302204251.2">def add_callback(self, callback):
    """Add a callback to be called at every idle time."""
    self.callback_list.append(callback)

</t>
<t tx="felix.20200302204251.3">def on_idle(self, timer):
    """IdleTimeManager: Run all idle-time callbacks."""
    if not self.g.app:
        return
    if self.g.app.killed:
        return
    if not self.g.app.pluginsController:
        self.g.trace('No g.app.pluginsController', self.g.callers())
        timer.stop()
        return  # For debugger.
    self.on_idle_count += 1
    # Handle the registered callbacks.
    # print("list length : ", len(self.callback_list))
    for callback in self.callback_list:
        try:
            callback()
        except Exception:
            self.g.es_exception()
            self.g.es_print(f"removing callback: {callback}")
            self.callback_list.remove(callback)
    # Handle idle-time hooks.
    self.g.app.pluginsController.on_idle()

</t>
<t tx="felix.20200302204251.4">def start(self):
    """Start the idle-time timer."""
    self.timer = self.g.IdleTime(
        self.on_idle,
        delay=500,  # Milliseconds
        tag='IdleTimeManager.on_idle')
    if self.timer:
        self.timer.start()

</t>
<t tx="felix.20200302205810.1">class ExternalFilesController:
    '''EFC Modified from Leo's sources'''

    @others

</t>
<t tx="felix.20200302205810.2">def __init__(self, integController):
    '''Ctor for ExternalFiles class.'''
    self.on_idle_count = 0
    self.integController = integController
    self.checksum_d = {}
    # Keys are full paths, values are file checksums.
    self.enabled_d = {}
    # For efc.on_idle.
    # Keys are commanders.
    # Values are cached @bool check-for-changed-external-file settings.
    self.has_changed_d = {}
    # Keys are commanders. Values are boolean.
    # Used only to limit traces.
    self.unchecked_commanders = []
    # Copy of g.app.commanders()
    self.unchecked_files = []
    # Copy of self file. Only one files is checked at idle time.
    self._time_d = {}
    # Keys are full paths, values are modification times.
    # DO NOT alter directly, use set_time(path) and
    # get_time(path), see set_time() for notes.
    self.yesno_all_time = 0  # previous yes/no to all answer, time of answer
    self.yesno_all_answer = None  # answer, 'yes-all', or 'no-all'

    self.infoMessage = None  # if yesAll/noAll forced, then just show info message after idle_check_commander
    # False or "detected", "refreshed" or "ignored"

    self.integController.g.app.idleTimeManager.add_callback(self.on_idle)

    self.waitingForAnswer = False
    self.lastPNode = None  # last p node that was asked for if not set to "AllYes\AllNo"
    self.lastCommander = None

</t>
<t tx="felix.20200302205810.21"></t>
<t tx="felix.20200302205810.22">def ask(self, c, path, p=None):
    '''
    Ask user whether to overwrite an @&lt;file&gt; tree.
    Return True if the user agrees.
    '''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["defaultReloadIgnore"].lower()
        if not bool('none' in w_check_config):
            if bool('yes' in w_check_config):
                self.infoMessage = "refreshed"
                return True
            else:
                self.infoMessage = "ignored"
                return False
    # let original function resolve

    if self.yesno_all_time + 3 &gt;= time.time() and self.yesno_all_answer:
        self.yesno_all_time = time.time()  # Still reloading?  Extend time.
        # if yesAll/noAll forced, then just show info message
        w_yesno_all_bool = bool('yes' in self.yesno_all_answer.lower())

        return w_yesno_all_bool
    if not p:
        where = 'the outline node'
    else:
        where = p.h

    _is_leo = path.endswith(('.leo', '.db'))

    if _is_leo:
        s = '\n'.join([
            f'{self.integController.g.splitLongFileName(path)} has changed outside Leo.',
            'Overwrite it?'
        ])
    else:
        s = '\n'.join([
            f'{self.integController.g.splitLongFileName(path)} has changed outside Leo.',
            f"Reload {where} in Leo?",
        ])

    w_package = {"async": "ask", "ask": 'Overwrite the version in Leo?',
                 "message": s, "yes_all": not _is_leo, "no_all": not _is_leo}

    self.integController.sendAsyncOutput(w_package)
    self.waitingForAnswer = True
    return False
    # result = self.integController.g.app.gui.runAskYesNoDialog(c, 'Overwrite the version in Leo?', s,
    # yes_all=not _is_leo, no_all=not _is_leo)

    # if result and "-all" in result.lower():
    # self.yesno_all_time = time.time()
    # self.yesno_all_answer = result.lower()

    # return bool(result and 'yes' in result.lower())

</t>
<t tx="felix.20200302205810.23">def checksum(self, path):
    '''Return the checksum of the file at the given path.'''
    import hashlib
    return hashlib.md5(open(path, 'rb').read()).hexdigest()

</t>
<t tx="felix.20200302205810.25">def get_mtime(self, path):
    '''Return the modification time for the path.'''
    return self.integController.g.os_path_getmtime(self.integController.g.os_path_realpath(path))

</t>
<t tx="felix.20200302205810.26">def get_time(self, path):
    '''
    return timestamp for path

    see set_time() for notes
    '''
    return self._time_d.get(self.integController.g.os_path_realpath(path))

</t>
<t tx="felix.20200302205810.27">def has_changed(self, c, path):
    '''Return True if p's external file has changed outside of Leo.'''
    if not self.integController.g.os_path_exists(path):
        return False
    if self.integController.g.os_path_isdir(path):
        return False
    #
    # First, check the modification times.
    old_time = self.get_time(path)
    new_time = self.get_mtime(path)
    if not old_time:
        # Initialize.
        self.set_time(path, new_time)
        self.checksum_d[path] = self.checksum(path)
        return False
    if old_time == new_time:
        return False
    #
    # Check the checksums *only* if the mod times don't match.
    old_sum = self.checksum_d.get(path)
    new_sum = self.checksum(path)
    if new_sum == old_sum:
        # The modtime changed, but it's contents didn't.
        # Update the time, so we don't keep checking the checksums.
        # Return False so we don't prompt the user for an update.
        self.set_time(path, new_time)
        return False
    # The file has really changed.
    assert old_time, path
    # #208: external change overwrite protection only works once.
    # If the Leo version is changed (dirtied) again,
    # overwrite will occur without warning.
    # self.set_time(path, new_time)
    # self.checksum_d[path] = new_sum
    return True

</t>
<t tx="felix.20200302205810.28">def is_enabled(self, c):
    '''Return the cached @bool check_for_changed_external_file setting.'''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["checkForChangeExternalFiles"].lower()
        if bool('check' in w_check_config):
            return True
        if bool('ignore' in w_check_config):
            return False
    # let original function resolve
    d = self.enabled_d
    val = d.get(c)
    if val is None:
        val = c.config.getBool('check-for-changed-external-files', default=False)
        d[c] = val
    return val

</t>
<t tx="felix.20200302205810.29">def join(self, s1, s2):
    '''Return s1 + ' ' + s2'''
    return f"{s1} {s2}"

</t>
<t tx="felix.20200302205810.30">def set_time(self, path, new_time=None):
    '''
    Implements c.setTimeStamp.

    Update the timestamp for path.

    NOTE: file paths with symbolic links occur with and without those links
    resolved depending on the code call path.  This inconsistency is
    probably not Leo's fault but an underlying Python issue.
    Hence the need to call realpath() here.
    '''

    # print("called set_time for " + str(path))

    t = new_time or self.get_mtime(path)
    self._time_d[self.integController.g.os_path_realpath(path)] = t

</t>
<t tx="felix.20200302205810.31">def warn(self, c, path, p):
    '''
    Warn that an @asis or @nosent node has been changed externally.

    There is *no way* to update the tree automatically.
    '''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["defaultReloadIgnore"].lower()

        if w_check_config != "none":
            # if not 'none' then do not warn, just infoMessage 'warn' at most
            if not self.infoMessage:
                self.infoMessage = "warn"
            return

    # let original function resolve
    if self.integController.g.unitTesting or c not in self.integController.g.app.commanders():
        return
    if not p:
        self.integController.g.trace('NO P')
        return

    s = '\n'.join([
        '%s has changed outside Leo.\n' % self.integController.g.splitLongFileName(path),
        'Leo can not update this file automatically.\n',
        'This file was created from %s.\n' % p.h,
        'Warning: refresh-from-disk will destroy all children.'
    ])

    w_package = {"async": "warn", "warn": 'External file changed', "message": s}

    self.integController.sendAsyncOutput(w_package)
    self.waitingForAnswer = True

</t>
<t tx="felix.20200302205810.7">def on_idle(self):
    '''
    Check for changed open-with files and all external files in commanders
    for which @bool check_for_changed_external_file is True.
    '''
    # Fix for flushing the terminal console to traverse
    # python through node.js when using start server in leoInteg
    sys.stdout.flush()

    if not self.integController.g.app or self.integController.g.app.killed:
        return
    if self.waitingForAnswer:
        return

    self.on_idle_count += 1

    if self.unchecked_commanders:
        # Check the next commander for which
        # @bool check_for_changed_external_file is True.
        c = self.unchecked_commanders.pop()
        self.lastCommander = c
        self.idle_check_commander(c)
    else:
        # Add all commanders for which
        # @bool check_for_changed_external_file is True.
        self.unchecked_commanders = [
            z for z in self.integController.g.app.commanders() if self.is_enabled(z)
        ]

</t>
<t tx="felix.20200302205810.8">def idle_check_commander(self, c):
    '''
    Check all external files corresponding to @&lt;file&gt; nodes in c for
    changes.
    '''
    # #1100: always scan the entire file for @&lt;file&gt; nodes.
    # #1134: Nested @&lt;file&gt; nodes are no longer valid, but this will do no harm.

    self.infoMessage = None  # reset infoMessage
    # False or "detected", "refreshed" or "ignored"

    for p in c.all_unique_positions():
        if self.waitingForAnswer:
            break
        if p.isAnyAtFileNode():
            self.idle_check_at_file_node(c, p)

    # if yesAll/noAll forced, then just show info message
    if self.infoMessage:
        w_package = {"async": "info", "message": self.infoMessage}
        self.integController.sendAsyncOutput(w_package)

</t>
<t tx="felix.20200302205810.9">def idle_check_at_file_node(self, c, p):
    '''Check the @&lt;file&gt; node at p for external changes.'''
    trace = False
    # Matt, set this to True, but only for the file that interests you.\
    # trace = p.h == '@file unregister-leo.leox'
    path = self.integController.g.fullPath(c, p)
    has_changed = self.has_changed(c, path)
    if trace:
        self.integController.g.trace('changed', has_changed, p.h)
    if has_changed:
        self.lastPNode = p  # can be set here because its the same process for ask/warn
        if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
            # Fix #1081: issue a warning.
            self.warn(c, path, p=p)
        elif self.ask(c, path, p=p):
            self.lastCommander.selectPosition(self.lastPNode)
            c.refreshFromDisk()

        # Always update the path &amp; time to prevent future warnings.
        self.set_time(path)
        self.checksum_d[path] = self.checksum(path)

</t>
<t tx="felix.20200303214235.1">async def _asyncIdleLoop(self, p_seconds, p_fn):
    while True:
        await asyncio.sleep(p_seconds)
        p_fn(self)

</t>
<t tx="felix.20200303214255.1">def _idleTime(self, fn, delay, tag):
    # TODO : REVISE/REPLACE WITH OWN SYSTEM
    asyncio.get_event_loop().create_task(self._asyncIdleLoop(delay/1000, fn))

</t>
<t tx="felix.20200304220844.1">def askResult(self, p_result):
    '''Got the result to an asked question/warning from vscode'''
    self.g.app.externalFilesController.integResult(p_result)
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200304221925.1">def integResult(self, p_result):
    '''Received result from vsCode'''
    # Got the result to an asked question/warning from vscode
    if not self.waitingForAnswer:
        print("ERROR: Received Result but no Asked Dialog")
        return
    # check if p_resultwas from a warn (ok) or an ask ('yes','yes-all','no','no-all')
    # act accordingly

    path = self.integController.g.fullPath(self.lastCommander, self.lastPNode)

    # 1- if ok, unblock 'warn'
    # 2- if no, unblock 'ask'
    # ------------------------------------------ Nothing special to do

    # 3- if noAll, set noAll, and unblock 'ask'
    if p_result and "-all" in p_result.lower():
        self.yesno_all_time = time.time()
        self.yesno_all_answer = p_result.lower()
    # ------------------------------------------ Also covers setting yesAll in #5

    # 4- if yes, REFRESH self.lastPNode, and unblock 'ask'
    # 5- if yesAll,REFRESH self.lastPNode, set yesAll, and unblock 'ask'
    if bool(p_result and 'yes' in p_result.lower()):
        self.lastCommander.selectPosition(self.lastPNode)
        self.lastCommander.refreshFromDisk()

    # Always update the path &amp; time to prevent future warnings for this PNode.
    self.set_time(path)
    self.checksum_d[path] = self.checksum(path)

    self.waitingForAnswer = False  # unblock
    self.idle_check_commander(self.lastCommander)  # unblock: run the loop as if timer had hit

</t>
<t tx="felix.20200304224909.1">def sendAsyncOutput(self, p_package):
    if "async" not in p_package:
        print('[sendAsyncOutput] Error async member missing in package parameter' + json.dumps(p_package, separators=(',', ':')))
        return
    if self.loop:
        self.loop.create_task(self.asyncOutput(json.dumps(p_package, separators=(',', ':'))))
    else:
        print('[sendAsyncOutput] Error loop not ready' + json.dumps(p_package, separators=(',', ':')))

</t>
<t tx="felix.20200308145948.1"># Some methods are called in the usual (non-leoBridge without 'efc') save process.
# Those may called by the 'save' function, like check_overwrite,
# or by any other functions from the instance of leo.core.leoBridge that's running.

</t>
<t tx="felix.20200308150821.1">def shut_down(self):
    return

</t>
<t tx="felix.20200308150842.1">def destroy_frame(self, f):
    return

</t>
<t tx="felix.20200308150848.1">def check_overwrite(self, c, fn):
    # print("check_overwrite!! ")
    return True

</t>
<t tx="felix.20200308150856.1">def open_with(self, c, d):
    return

</t>
<t tx="felix.20200312231358.1">def applyConfig(self, p_config):
    '''Got leoInteg's config from vscode'''
    self.leoIntegConfig = p_config
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200329000454.1">def contractAll(self, p_paramUnused):
    '''(Collapse) Contract All'''
    self.commander.contractAllHeadlines()
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="felix.20200619165641.1">def getStates(self, p_package):
    """
    Gets the currently opened file's general states for UI enabled/disabled states
    such as undo available, file changed/unchanged
    """
    w_states = {}
    if self.commander:
        try:
            w_states["changed"] = self.commander.changed   # 'dirty/changed' member
            w_states["canUndo"] = self.commander.canUndo()
            w_states["canRedo"] = self.commander.canRedo()
            w_states["canDemote"] = self.commander.canDemote()
            w_states["canPromote"] = self.commander.canPromote()
            w_states["canDehoist"] = self.commander.canDehoist()

        except Exception as e:
            self.g.trace('Error while getting states')
            print("Error while getting states")
            print(str(e))
    else:
        w_states["changed"] = False
        w_states["canUndo"] = False
        w_states["canRedo"] = False
        w_states["canDemote"] = False
        w_states["canPromote"] = False
        w_states["canDehoist"] = False

    return self.sendLeoBridgePackage("states", w_states)

</t>
<t tx="felix.20200622230608.1">def getOpenedFiles(self, p_package):
    '''Return array of opened file path/names to be used as openFile parameters to switch files'''
    w_files = []
    w_index = 0
    w_indexFound = 0
    for w_commander in self.g.app.commanders():
        if w_commander.closed == False:
            w_isSelected = False
            w_isChanged = w_commander.changed
            if self.commander == w_commander:
                w_indexFound = w_index
                w_isSelected = True
            w_entry = {"name": w_commander.mFileName, "index": w_index,
                       "changed": w_isChanged, "selected": w_isSelected}
            w_files.append(w_entry)
            w_index = w_index + 1

    w_openedFiles = {"files": w_files, "index": w_indexFound}

    return self.sendLeoBridgePackage("openedFiles", w_openedFiles)

</t>
<t tx="felix.20200623201853.1">def _getTotalOpened(self):
    '''Get total of opened commander (who have closed == false)'''
    w_total = 0
    for w_commander in self.g.app.commanders():
        if w_commander.closed == False:
            w_total = w_total + 1
    return w_total

</t>
<t tx="felix.20200623215904.1">def _getFirstOpenedCommander(self):
    '''Get first opened commander, or False if there are none.'''
    for w_commander in self.g.app.commanders():
        if w_commander.closed == False:
            return w_commander
    return False

</t>
<t tx="felix.20200624172552.1">def setOpenedFile(self, p_package):
    '''Choose the new active commander from array of opened file path/names by numeric index'''
    w_openedCommanders = []

    for w_commander in self.g.app.commanders():
        if w_commander.closed == False:
            w_openedCommanders.append(w_commander)

    w_index = p_package['index']

    if w_openedCommanders[w_index]:
        self.commander = w_openedCommanders[w_index]

    if self.commander:
        self.commander.closed = False
        self.create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self.p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage("setOpened", w_result)
    else:
        return self.outputError('Error in setOpenedFile')

</t>
<t tx="felix.20200626012709.1">def _returnNo(self, *arguments):
    '''Used to override g.app.gui.ask[XXX] dialogs answers'''
    return "no"

</t>
<t tx="felix.20200626030820.1">def _returnYes(self, *arguments):
    '''Used to override g.app.gui.ask[XXX] dialogs answers'''
    return "yes"

</t>
<t tx="felix.20200705193918.1"></t>
<t tx="felix.20200705193927.1">def pageUp(self, p_ap):
    """Selects a node a couple of steps up in the tree to simulate page up"""
    self.commander.selectVisBack()
    self.commander.selectVisBack()
    self.commander.selectVisBack()
    return self.outputPNode(self.commander.p)

</t>
<t tx="felix.20200705201100.1">def gotoLastSibling(self, p_ap):
    """Select the last sibling of the selected node."""
    return self.outlineCommand("goToLastSibling", p_ap)

</t>
<t tx="felix.20200705223430.1">def contractOrGoLeft(self, p_ap):
    """Simulate the left Arrow Key in folder of Windows Explorer."""
    return self.outlineCommand("contractNodeOrGoToParent", p_ap)

</t>
<t tx="felix.20200705223521.1">def expandAndGoRight(self, p_ap):
    """If a node has children, expand it if needed and go to the first child."""
    return self.outlineCommand("expandNodeAndGoToFirstChild", p_ap)

</t>
<t tx="felix.20200705223536.1">def gotoNextVisible(self, p_ap):
    """Select the visible node following the presently selected node."""
    return self.outlineCommand("selectVisNext", p_ap)

</t>
<t tx="felix.20200705223541.1">def gotoPrevVisible(self, p_ap):
    """Select the visible node preceding the presently selected node."""
    return self.outlineCommand("selectVisBack", p_ap)

</t>
<t tx="felix.20200705233325.1">def gotoLastVisible(self, p_ap):
    """Select the last visible node of selected chapter or hoist."""
    return self.outlineCommand("goToLastVisibleNode", p_ap)

</t>
<t tx="felix.20200706030410.1">def gotoNextMarked(self, p_ap):
    """Select the next marked node."""
    return self.outlineCommand("goToNextMarkedHeadline", p_ap)

</t>
<t tx="felix.20200706202247.1">def gotoNextClone(self, p_ap):
    """
    Select the next node that is a clone of the selected node.
    If the selected node is not a clone, do find-next-clone.
    """
    return self.outlineCommand("goToNextClone", p_ap)

</t>
<t tx="felix.20200710014747.1">def getButtons(self, p_package):
    '''Gets the currently opened file's @buttons list'''
    w_buttons = []
    if self.commander.theScriptingController and self.commander.theScriptingController.buttonsDict:
        w_dict = self.commander.theScriptingController.buttonsDict
        for w_key in w_dict:
            w_entry = {"name": w_dict[w_key], "index": str(w_key)}
            w_buttons.append(w_entry)
    return self.sendLeoBridgePackage("buttons", w_buttons)

</t>
<t tx="felix.20200710030614.1">def clickButton(self, p_package):
    '''Handles buttons clicked in vscode from the '@button' panel'''
    w_index = p_package['index']
    w_dict = self.commander.theScriptingController.buttonsDict
    w_button = None
    for i_key in w_dict:
        if(str(i_key) == w_index):
            w_button = i_key
    if w_button:
        w_button.command()  # run clicked button command
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="felix.20200711182907.1">def getCommands(self, p_package):
    pass

    print("get command list for string: ")

    if "text" in p_package:
        print(p_package['text'])
    else:
        print("no string given")

    w_commands = []
    w_commands.append("one")
    w_commands.append("two")
    w_commands.append("three")

    return self.sendLeoBridgePackage("commands", w_commands)

</t>
<t tx="felix.20200711210205.1">def pageDown(self, p_ap):
    """Selects a node a couple of steps down in the tree to simulate page down"""
    self.commander.selectVisNext()
    self.commander.selectVisNext()
    self.commander.selectVisNext()
    return self.outputPNode(self.commander.p)

</t>
<t tx="felix.20200711210205.2">def gotoFirstVisible(self, p_ap):
    """Select the first visible node of the selected chapter or hoist."""
    return self.outlineCommand("goToFirstVisibleNode", p_ap)

</t>
<t tx="felix.20200717222352.1">@language json
@tabwidth -2
{
  "name": "leointeg",
  "displayName": "Leo Editor Integration with Visual Studio Code",
  "description": "Use Leo, the literate editor with outline, directly in vscode.",
  "version": "0.1.13",
  "author": {
    "name": "Félix"
  },
  "publisher": "boltex",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/boltex/leointeg"
  },
  "engines": {
    "vscode": "^1.47.0"
  },
  "keywords": [
    "leo",
    "literate",
    "editor",
    "outline",
    "programming"
  ],
  "categories": [
    "Other"
  ],
  "activationEvents": [
    "onView:leoIntegration",
    "workspaceContains:**/*.leo"
  ],
  "main": "./dist/extension",
  "icon": "resources/leoapp128px.png",
  "galleryBanner": {
    "color": "#fffbdc",
    "theme": "light"
  },
  "contributes": {
    @others
  },
  "scripts": {
    "vscode:prepublish": "webpack --mode production",
    "webpack": "webpack --mode development",
    "webpack-dev": "webpack --mode development --watch",
    "test-compile": "tsc -p ./",
    "lint": "tslint -p ./"
  },
  "devDependencies": {
    "@types/glob": "^7.1.1",
    "@types/mocha": "^7.0.2",
    "@types/node": "^14.0.5",
    "@types/vscode": "^1.45.1",
    "@types/ws": "^7.2.4",
    "clean-webpack-plugin": "^3.0.0",
    "csp-html-webpack-plugin": "^4.0.0",
    "css-loader": "^3.5.3",
    "eslint": "^7.1.0",
    "fork-ts-checker-webpack-plugin": "^4.1.6",
    "glob": "^7.1.6",
    "html-loader": "^1.1.0",
    "html-webpack-exclude-assets-plugin": "0.0.7",
    "html-webpack-plugin": "^3.2.0",
    "imagemin-webpack-plugin": "^2.4.2",
    "mini-css-extract-plugin": "^0.9.0",
    "mocha": "^7.2.0",
    "node-sass": "^4.14.1",
    "sass-loader": "^8.0.2",
    "ts-loader": "^7.0.5",
    "tslint": "^6.1.2",
    "typescript": "^3.9.3",
    "vscode-test": "^1.4.0",
    "webpack": "^4.43.0",
    "webpack-cli": "^3.3.11"
  },
  "dependencies": {
    "@types/debounce": "^1.2.0",
    "bufferutil": "^4.0.1",
    "debounce": "^1.2.0",
    "hasbin": "^1.2.3",
    "ws": "^7.3.0"
  }
}
</t>
<t tx="felix.20200717222716.1">"configuration": {
  "title": "Leo Integration",
  "properties": {
    @others
  }
},
</t>
<t tx="felix.20200717222850.1">"viewsContainers": {
  "activitybar": [
    {
      "id": "leoIntegrationView",
      "title": "Leo",
      "icon": "resources/icon.svg"
    }
  ]
},
</t>
<t tx="felix.20200717222918.1">"views": {
  "explorer": [
    {
      "id": "leoIntegrationExplorer",
      "name": "Leo Integration",
      "contextualTitle": "Leo",
      "when": "treeInExplorer"
    },
    {
      "id": "leoDocumentsExplorer",
      "name": "Leo Documents",
      "contextualTitle": "Leo",
      "when": "treeInExplorer"
    },
    {
      "id": "leoButtonsExplorer",
      "name": "Leo Buttons",
      "contextualTitle": "Leo",
      "when": "treeInExplorer"
    }
  ],
  "leoIntegrationView": [
    {
      "id": "leoIntegration",
      "contextualTitle": "Leo",
      "name": "Integration"
    },
    {
      "id": "leoDocuments",
      "contextualTitle": "Leo",
      "name": "Documents"
    },
    {
      "id": "leoButtons",
      "contextualTitle": "Leo",
      "name": "Buttons"
    }
  ]
},
</t>
<t tx="felix.20200717222938.1">"languages": [
  {
    "id": "leobody",
    "aliases": [
      "Leo Body",
      "leobody"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configuration.json"
  }
],
</t>
<t tx="felix.20200717222946.1">"grammars": [
  {
    "language": "leobody",
    "scopeName": "source.leobody",
    "path": "./syntaxes/leobody.tmLanguage.json"
  }
],
</t>
<t tx="felix.20200717223012.1">"commands": [
  @others
],
</t>
<t tx="felix.20200717223038.1">"viewsWelcome": [
  @others
],
</t>
<t tx="felix.20200717223100.1">"menus": {
  @others
},
</t>
<t tx="felix.20200717223116.1">"keybindings": [
  @others
],
</t>
<t tx="felix.20200717223127.1">"resourceLabelFormatters": [
  {
    "scheme": "leo",
    "formatting": {
      "label": "LEO: BODY",
      "separator": "/",
      "workspaceSuffix": ""
    }
  }
]
</t>
<t tx="felix.20200717223431.1">"leoIntegration.checkForChangeExternalFiles": {
  "scope": "application",
  "default": "none",
  "type": "string",
  "description": "Set default for checking changes to external files",
  "enum": [
    "none",
    "force-check",
    "force-ignore"
  ],
  "enumDescriptions": [
    "Default from Leo's config",
    "Check for changes",
    "Ignore all changes"
  ]
},
"leoIntegration.defaultReloadIgnore": {
  "scope": "application",
  "default": "none",
  "type": "string",
  "description": "Set default for derived files to always reload, or always ignore, when changes are detected",
  "enum": [
    "none",
    "yes-all",
    "no-all"
  ],
  "enumDescriptions": [
    "Choose each time",
    "Reload All",
    "Ignore All"
  ]
},
</t>
<t tx="felix.20200717223454.1">"leoIntegration.leoTreeBrowse": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Specifies whether to use Leo's style of tree browsing with the arrow keys"
},
"leoIntegration.treeKeepFocus": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Specifies whether to keep focus in the outline when selecting a node - overridden by \"leoTreeBrowse\""
},
"leoIntegration.treeKeepFocusWhenAside": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Specifies whether to keep focus in the outline when opening a body pane on the side"
},
</t>
<t tx="felix.20200717223513.1">"leoIntegration.statusBarString": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Sets the message string of the Status Bar Indicator"
},
"leoIntegration.statusBarColor": {
  "scope": "application",
  "default": "fb7c47",
  "type": "string",
  "description": "Specifies the hexadecimal color string for the Status Bar Indicator"
},
</t>
<t tx="felix.20200717223828.1">"leoIntegration.treeInExplorer": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Show the outline tree in the explorer view"
},
"leoIntegration.showOpenAside": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Offer 'Open to the Side' in nodes context menu"
},
"leoIntegration.showEditOnNodes": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Edit Headline' button on tree nodes"
},
"leoIntegration.showArrowsOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Move Node' arrow buttons on tree nodes"
},
"leoIntegration.showAddOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Insert' button on tree nodes"
},
"leoIntegration.showMarkOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Mark/Unmark' buttons on tree nodes"
},
"leoIntegration.showCloneOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Clone' button on tree nodes"
},
"leoIntegration.showCopyOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Copy' button on tree nodes"
},
"leoIntegration.invertNodeContrast": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Inverts the contrast of the dirty/clean border aspect of tree nodes"
},
</t>
<t tx="felix.20200717223852.1">"leoIntegration.leoPythonCommand": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Specifies the command to start python (Defaults to 'py' on windows and 'python3' otherwise)"
},
"leoIntegration.startServerAutomatically": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Starts a LeoBridge server automatically, by running the leobridgeserver.py python script"
},
"leoIntegration.connectToServerAutomatically": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Connect automatically to a Leo server on specified 'Connection Port' upon activation of this extension"
},
"leoIntegration.connectionAddress": {
  "default": "localhost",
  "scope": "application",
  "type": "string",
  "description": "Connection host"
},
"leoIntegration.connectionPort": {
  "default": 32125,
  "scope": "application",
  "minimum": 0,
  "maximum": 65535,
  "type": "number",
  "description": "Connection port"
}
</t>
<t tx="felix.20200717224216.1">{
  "command": "leointeg.showSettingsPage",
  "title": "Open Settings",
  "category": "Leo",
  "icon": {
    "light": "resources/light/gear.svg",
    "dark": "resources/dark/gear.svg"
  }
},
{
  "command": "leointeg.showWelcomePage",
  "title": "Welcome",
  "category": "Leo"
},
</t>
<t tx="felix.20200717224224.1">{
  "command": "leointeg.test",
  "category": "Leo",
  "title": "Test Leo Integration"
},
</t>
<t tx="felix.20200717224258.1">{
  "command": "leointeg.startServer",
  "category": "Leo",
  "title": "Start Leo Bridge Server"
},
{
  "command": "leointeg.connectToServer",
  "title": "Connect to Leo Bridge Server",
  "category": "Leo",
  "icon": {
    "light": "resources/light/connect.svg",
    "dark": "resources/dark/connect.svg"
  }
},
</t>
<t tx="felix.20200717224519.1">{
  "command": "leointeg.showBody",
  "category": "Leo",
  "title": "Focus to Body"
},
{
  "command": "leointeg.showOutline",
  "category": "Leo",
  "title": "Focus to Tree"
},
{
  "command": "leointeg.showLogPane",
  "category": "Leo",
  "title": "Show Log Pane"
},
</t>
<t tx="felix.20200717224549.1">{
  "command": "leointeg.openLeoFile",
  "title": "Open Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/folder.svg",
    "dark": "resources/dark/folder.svg"
  }
},
{
  "command": "leointeg.switchLeoFile",
  "title": "Switch Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/switch.svg",
    "dark": "resources/dark/switch.svg"
  }
},
{
  "command": "leointeg.newLeoFile",
  "title": "New Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/new-file.svg",
    "dark": "resources/dark/new-file.svg"
  }
},
{
  "command": "leointeg.closeLeoFile",
  "title": "Close Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leointeg.saveLeoFile",
  "category": "Leo",
  "title": "Save Leo File",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leointeg.saveLeoFileFromOutline",
  "category": "Leo",
  "title": "Save Leo File",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leointeg.saveAsLeoFile",
  "category": "Leo",
  "title": "Save Leo File as...",
  "icon": {
    "light": "resources/light/save-as.svg",
    "dark": "resources/dark/save-as.svg"
  }
},
{
  "command": "leointeg.refreshFromDisk",
  "category": "Leo",
  "title": "Refresh from Disk"
},
{
  "command": "leointeg.refreshFromDiskSelection",
  "category": "Leo",
  "title": "Refresh from Disk"
},
{
  "command": "leointeg.refreshFromDiskSelectionFromOutline",
  "category": "Leo",
  "title": "Refresh from Disk"
},
</t>
<t tx="felix.20200717230237.1">{
  "command": "leointeg.selectTreeNode",
  "category": "Leo",
  "title": "Select Node"
},
{
  "command": "leointeg.openAside",
  "category": "Leo",
  "title": "Open to the Side"
},
{
  "command": "leointeg.contractAll",
  "category": "Leo",
  "title": "Contract All",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
{
  "command": "leointeg.contractAllFromOutline",
  "category": "Leo",
  "title": "Contract All",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
</t>
<t tx="felix.20200717230331.1">{
  "command": "leointeg.editHeadline",
  "category": "Leo",
  "title": "Edit Headline",
  "icon": {
    "light": "resources/light/edit.svg",
    "dark": "resources/dark/edit.svg"
  }
},
{
  "command": "leointeg.editSelectedHeadline",
  "category": "Leo",
  "title": "Edit Headline"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "category": "Leo",
  "title": "Edit Headline"
},
{
  "command": "leointeg.mark",
  "category": "Leo",
  "title": "Mark",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leointeg.markSelection",
  "category": "Leo",
  "title": "Mark"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "category": "Leo",
  "title": "Mark"
},
{
  "command": "leointeg.unmark",
  "category": "Leo",
  "title": "Unmark",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leointeg.unmarkSelection",
  "category": "Leo",
  "title": "Unmark"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "category": "Leo",
  "title": "Unmark"
},
{
  "command": "leointeg.copyNode",
  "category": "Leo",
  "title": "Copy Node",
  "icon": {
    "light": "resources/light/clipboard.svg",
    "dark": "resources/dark/clipboard.svg"
  }
},
{
  "command": "leointeg.copyNodeSelection",
  "category": "Leo",
  "title": "Copy Node"
},
{
  "command": "leointeg.cutNode",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.cutNodeSelection",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.pasteNode",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAsClone",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelection",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.delete",
  "category": "Leo",
  "title": "Delete",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leointeg.deleteSelection",
  "category": "Leo",
  "title": "Delete Node"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "category": "Leo",
  "title": "Delete Node"
},
</t>
<t tx="felix.20200717230350.1">{
  "command": "leointeg.moveOutlineDown",
  "category": "Leo",
  "title": "Move Outline Down",
  "icon": {
    "light": "resources/light/arrow-down.svg",
    "dark": "resources/dark/arrow-down.svg"
  }
},
{
  "command": "leointeg.moveOutlineDownSelection",
  "category": "Leo",
  "title": "Move Outline Down"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Down"
},
{
  "command": "leointeg.moveOutlineLeft",
  "category": "Leo",
  "title": "Move Outline Left",
  "icon": {
    "light": "resources/light/arrow-left.svg",
    "dark": "resources/dark/arrow-left.svg"
  }
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "category": "Leo",
  "title": "Move Outline Left"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Left"
},
{
  "command": "leointeg.moveOutlineRight",
  "category": "Leo",
  "title": "Move Outline Right",
  "icon": {
    "light": "resources/light/arrow-right.svg",
    "dark": "resources/dark/arrow-right.svg"
  }
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "category": "Leo",
  "title": "Move Outline Right"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Right"
},
{
  "command": "leointeg.moveOutlineUp",
  "category": "Leo",
  "title": "Move Outline Up",
  "icon": {
    "light": "resources/light/arrow-up.svg",
    "dark": "resources/dark/arrow-up.svg"
  }
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "category": "Leo",
  "title": "Move Outline Up"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Up"
},
</t>
<t tx="felix.20200717230620.1">{
  "command": "leointeg.insertNode",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.insertNodeSelection",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.cloneNode",
  "category": "Leo",
  "title": "Clone Node",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leointeg.cloneNodeSelection",
  "category": "Leo",
  "title": "Clone Node"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Clone Node"
},
{
  "command": "leointeg.promote",
  "category": "Leo",
  "title": "Promote"
},
{
  "command": "leointeg.promoteSelection",
  "category": "Leo",
  "title": "Promote"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "category": "Leo",
  "title": "Promote"
},
{
  "command": "leointeg.demote",
  "category": "Leo",
  "title": "Demote"
},
{
  "command": "leointeg.demoteSelection",
  "category": "Leo",
  "title": "Demote"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "category": "Leo",
  "title": "Demote"
},
{
  "command": "leointeg.sortChildrenSelection",
  "category": "Leo",
  "title": "Sort Children"
},
{
  "command": "leointeg.sortSiblingsSelection",
  "category": "Leo",
  "title": "Sort Siblings"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "category": "Leo",
  "title": "Sort Siblings"
},
</t>
<t tx="felix.20200717230807.1">{
  "command": "leointeg.gotoFirstVisible",
  "category": "Leo",
  "title": "Goto First Visible"
},
{
  "command": "leointeg.gotoLastVisible",
  "category": "Leo",
  "title": "Goto Last Visible"
},
{
  "command": "leointeg.pageUp",
  "category": "Leo",
  "title": "Page Up"
},
{
  "command": "leointeg.pageDown",
  "category": "Leo",
  "title": "Page Down"
},
{
  "command": "leointeg.gotoLastSibling",
  "category": "Leo",
  "title": "Goto Last Sibling"
},
{
  "command": "leointeg.gotoNextVisible",
  "category": "Leo",
  "title": "Goto Next Visible"
},
{
  "command": "leointeg.gotoPrevVisible",
  "category": "Leo",
  "title": "Goto Prev Visible"
},
{
  "command": "leointeg.contractOrGoLeft",
  "category": "Leo",
  "title": "Contract Or Go Left"
},
{
  "command": "leointeg.expandAndGoRight",
  "category": "Leo",
  "title": "Expand And Go Right"
},
</t>
<t tx="felix.20200717230820.1">{
  "command": "leointeg.hoistNode",
  "category": "Leo",
  "title": "Hoist"
},
{
  "command": "leointeg.hoistSelection",
  "category": "Leo",
  "title": "Hoist"
},
{
  "command": "leointeg.hoistSelectionFromOutline",
  "category": "Leo",
  "title": "Hoist"
},
{
  "command": "leointeg.deHoist",
  "category": "Leo",
  "title": "De-Hoist",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
{
  "command": "leointeg.deHoistFromOutline",
  "category": "Leo",
  "title": "De-Hoist",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
</t>
<t tx="felix.20200717230830.1">{
  "command": "leointeg.undo",
  "category": "Leo",
  "title": "Undo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leointeg.undoFromOutline",
  "category": "Leo",
  "title": "Undo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leointeg.redo",
  "category": "Leo",
  "title": "Redo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
{
  "command": "leointeg.redoFromOutline",
  "category": "Leo",
  "title": "Redo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
</t>
<t tx="felix.20200717231121.1">{
  "command": "leointeg.executeScriptSelection",
  "category": "Leo",
  "title": "Execute Script"
},
{
  "command": "leointeg.minibuffer",
  "category": "Leo",
  "title": "Minibuffer"
},
{
  "command": "leointeg.removeButton",
  "category": "Leo",
  "title": "Remove Button"
},
</t>
<t tx="felix.20200717231448.1">{
  "command": "leointeg.cloneFindAll",
  "category": "Leo",
  "title": "Clone Find All"
},
{
  "command": "leointeg.cloneFindAllFlattened",
  "category": "Leo",
  "title": "Clone Find All Flattened"
},
{
  "command": "leointeg.cloneFindMarked",
  "category": "Leo",
  "title": "Clone Find Marked"
},
{
  "command": "leointeg.cloneFindFlattenedMarked",
  "category": "Leo",
  "title": "cffm - Clone Find Flattened Marked"
},
{
  "command": "leointeg.extract",
  "category": "Leo",
  "title": "Extract"
},
{
  "command": "leointeg.extractNames",
  "category": "Leo",
  "title": "Extract Names"
},
{
  "command": "leointeg.copyMarked",
  "category": "Leo",
  "title": "Copy Marked"
},
{
  "command": "leointeg.diffMarkedNodes",
  "category": "Leo",
  "title": "Diff Marked Nodes"
},
{
  "command": "leointeg.gotoNextMarked",
  "category": "Leo",
  "title": "Goto Next Marked"
},
{
  "command": "leointeg.gotoNextClone",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.markChangedItems",
  "category": "Leo",
  "title": "Mark Changed Items"
},
{
  "command": "leointeg.markSubheads",
  "category": "Leo",
  "title": "Mark Subheads"
},
{
  "command": "leointeg.unmarkAll",
  "category": "Leo",
  "title": "Unmark All"
},
{
  "command": "leointeg.cloneMarkedNodes",
  "category": "Leo",
  "title": "Clone Marked Nodes"
},
{
  "command": "leointeg.deleteMarkedNodes",
  "category": "Leo",
  "title": "Delete Marked Nodes"
},
{
  "command": "leointeg.moveMarkedNodes",
  "category": "Leo",
  "title": "Move Marked Nodes"
}
</t>
<t tx="felix.20200717231719.1">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nStart a local server\n[Start Server](command:leointeg.startServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nStart a local server\n[Start Server](command:leointeg.startServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="felix.20200717231742.1">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="felix.20200717231753.1">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="felix.20200717231803.1">{
  "view": "leoIntegration",
  "contents": "Connecting...",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Connecting...",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; connectToServerAutomatically"
},
</t>
<t tx="felix.20200717231844.1">{
  "view": "leoIntegration",
  "contents": "leoBridge Connected\n[Open Leo File](command:leointeg.openLeoFile)\nView LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "leoBridge Connected\n[Open Leo File](command:leointeg.openLeoFile)\nView LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="felix.20200717232009.1"></t>
<t tx="felix.20200717232019.1"></t>
<t tx="felix.20200717232644.1"></t>
<t tx="felix.20200717233055.1">{
  "view": "leoDocuments",
  "contents": "LeoInteg is not connected",
  "when": "!leoBridgeReady"
},
{
  "view": "leoDocumentsExplorer",
  "contents": "LeoInteg is not connected",
  "when": "!leoBridgeReady"
},
</t>
<t tx="felix.20200717233118.1">{
  "view": "leoDocuments",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoDocumentsExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="felix.20200717233230.1">{
  "view": "leoButtons",
  "contents": "LeoInteg is not connected",
  "when": "!leoBridgeReady"
},
{
  "view": "leoButtonsExplorer",
  "contents": "LeoInteg is not connected",
  "when": "!leoBridgeReady"
},
</t>
<t tx="felix.20200717233257.1">{
  "view": "leoButtons",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoButtonsExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="felix.20200717233318.1">{
  "view": "leoButtons",
  "contents": "There are no @buttons in this outline",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "view": "leoButtonsExplorer",
  "contents": "There are no @buttons in this outline",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
}
</t>
<t tx="felix.20200718001246.1">"commandPalette": [
  @others
],
</t>
<t tx="felix.20200718001311.1">"explorer/context": [
  {
    "command": "leointeg.openLeoFile",
    "when": "resourceScheme == file &amp;&amp; resourceExtname == .leo",
    "group": "navigation@1"
  }
],
</t>
<t tx="felix.20200718001319.1">"view/title": [
  {
    "command": "leointeg.openLeoFile",
    "when": "view =~ /leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "view =~ /leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.showSettingsPage",
    "when": "view =~ /leoIntegration/ &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.connectToServer",
    "when": "view =~ /leoIntegration/ &amp;&amp; !leoBridgeReady &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.openLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoTreeTitled &amp;&amp; leoChanged",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.undoFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanUndo",
    "group": "navigation@3"
  },
  {
    "command": "leointeg.redoFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanRedo",
    "group": "navigation@4"
  },
  {
    "command": "leointeg.deHoistFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanDehoist",
    "group": "navigation@5"
  },
  {
    "command": "leointeg.contractAllFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened",
    "group": "navigation@6"
  }
],
</t>
<t tx="felix.20200718001334.1">"view/item/context": [
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "viewItem =~ /leoDocumentSelectedTitled/ &amp;&amp; leoChanged",
    "group": "inline@1"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "viewItem =~ /leoDocumentSelectedUntitled/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.closeLeoFile",
    "when": "viewItem =~ /leoDocumentSelected/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.editHeadline",
    "when": "showEditOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.insertNode",
    "when": "showAddOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.moveOutlineDown",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineLeft",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineRight",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineUp",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.copyNode",
    "when": "showCopyOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "showCloneOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.mark",
    "when": "showMarkOnNodes &amp;&amp; viewItem =~ /leoNodeUnmarked/",
    "group": "inline@5"
  },
  {
    "command": "leointeg.unmark",
    "when": "showMarkOnNodes &amp;&amp; viewItem =~ /leoNodeMarked/",
    "group": "inline@5"
  },
  {
    "command": "leointeg.openAside",
    "when": "showOpenAside &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext1@1"
  },
  {
    "command": "leointeg.hoistNode",
    "when": "viewItem =~ /leoNodeNotRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.deHoist",
    "when": "leoCanDehoist &amp;&amp; viewItem =~ /leoNodeRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.refreshFromDisk",
    "when": "viewItem =~ /leoNodeAtFile/",
    "group": "leoNodeContext1@3"
  },
  {
    "command": "leointeg.mark",
    "when": "viewItem =~ /leoNodeUnmarked/",
    "group": "leoNodeContext2@1"
  },
  {
    "command": "leointeg.unmark",
    "when": "viewItem =~ /leoNodeMarked/",
    "group": "leoNodeContext2@2"
  },
  {
    "command": "leointeg.copyNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@3"
  },
  {
    "command": "leointeg.cutNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@4"
  },
  {
    "command": "leointeg.pasteNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@5"
  },
  {
    "command": "leointeg.pasteNodeAsClone",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@6"
  },
  {
    "command": "leointeg.delete",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@7"
  },
  {
    "command": "leointeg.insertNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext3@1"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext3@2"
  },
  {
    "command": "leointeg.gotoNextClone",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNodeCloned/",
    "group": "leoNodeContext3@3"
  },
  {
    "command": "leointeg.removeButton",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoButtonNode/",
    "group": "leoButtonContext1@1"
  }
]
</t>
<t tx="felix.20200718001643.1">{
  "command": "leointeg.startServer",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; !leoServerStarted"
},
{
  "command": "leointeg.connectToServer",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="felix.20200718001726.1">{
  "command": "leointeg.openLeoFile",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.switchLeoFile",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "command": "leointeg.newLeoFile",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.closeLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.saveLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.saveAsLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.refreshFromDiskSelection",
  "when": "leoTreeOpened &amp;&amp; leoAtFile"
},
</t>
<t tx="felix.20200718001744.1">{
  "command": "leointeg.showLogPane",
  "when": "leoBridgeReady"
},
</t>
<t tx="felix.20200718001834.1">{
  "command": "leointeg.executeScriptSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.minibuffer",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718001920.1">{
  "command": "leointeg.contractAll",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718001925.1">{
  "command": "leointeg.editSelectedHeadline",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markSelection",
  "when": "leoTreeOpened &amp;&amp; !leoMarked"
},
{
  "command": "leointeg.unmarkSelection",
  "when": "leoTreeOpened &amp;&amp; leoMarked"
},
{
  "command": "leointeg.copyNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cutNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.deleteSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718001929.1">{
  "command": "leointeg.moveOutlineDownSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718001935.1">{
  "command": "leointeg.insertNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.promoteSelection",
  "when": "leoTreeOpened &amp;&amp; leoCanPromote"
},
{
  "command": "leointeg.demoteSelection",
  "when": "leoTreeOpened &amp;&amp; leoCanDemote"
},
{
  "command": "leointeg.sortChildrenSelection",
  "when": "leoTreeOpened &amp;&amp; leoChild"
},
{
  "command": "leointeg.sortSiblingsSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718001940.1">{
  "command": "leointeg.gotoNextMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "when": "leoTreeOpened &amp;&amp; leoCloned"
},
</t>
<t tx="felix.20200718001958.1">{
  "command": "leointeg.hoistSelection",
  "when": "leoTreeOpened &amp;&amp; !leoRoot"
},
{
  "command": "leointeg.deHoist",
  "when": "leoTreeOpened &amp;&amp; leoCanDehoist"
},
</t>
<t tx="felix.20200718002007.1">{
  "command": "leointeg.undo",
  "when": "leoTreeOpened &amp;&amp; leoCanUndo"
},
{
  "command": "leointeg.redo",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718002013.1"></t>
<t tx="felix.20200718002528.1">{
  "command": "leointeg.cloneFindAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindAllFlattened",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindFlattenedMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.extract",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.extractNames",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.copyMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.diffMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markChangedItems",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markSubheads",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.unmarkAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.deleteMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveMarkedNodes",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718003128.1">{
  "command": "leointeg.test",
  "when": "false"
},
</t>
<t tx="felix.20200718003207.1">{
  "command": "leointeg.showBody",
  "when": "false"
},
{
  "command": "leointeg.showOutline",
  "when": "false"
},
</t>
<t tx="felix.20200718003215.1">{
  "command": "leointeg.saveLeoFileFromOutline",
  "when": "false"
},
{
  "command": "leointeg.refreshFromDisk",
  "when": "false"
},
{
  "command": "leointeg.refreshFromDiskSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20200718003223.1">{
  "command": "leointeg.selectTreeNode",
  "when": "false"
},
{
  "command": "leointeg.openAside",
  "when": "false"
},
{
  "command": "leointeg.contractAllFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20200718003227.1">{
  "command": "leointeg.editHeadline",
  "when": "false"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "when": "false"
},
{
  "command": "leointeg.mark",
  "when": "false"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.unmark",
  "when": "false"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.copyNode",
  "when": "false"
},
{
  "command": "leointeg.cutNode",
  "when": "false"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.pasteNode",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAsClone",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.delete",
  "when": "false"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20200718003236.1">{
  "command": "leointeg.moveOutlineDown",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineLeft",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineRight",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineUp",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20200718003239.1">{
  "command": "leointeg.insertNode",
  "when": "false"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "when": "false"
},
{
  "command": "leointeg.cloneNode",
  "when": "false"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.promote",
  "when": "false"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.demote",
  "when": "false"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20200718003243.1">{
  "command": "leointeg.gotoNextClone",
  "when": "false"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.gotoFirstVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoLastVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoLastSibling",
  "when": "false"
},
{
  "command": "leointeg.gotoNextVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoPrevVisible",
  "when": "false"
},
{
  "command": "leointeg.contractOrGoLeft",
  "when": "false"
},
{
  "command": "leointeg.expandAndGoRight",
  "when": "false"
},
</t>
<t tx="felix.20200718003251.1">{
  "command": "leointeg.hoistNode",
  "when": "false"
},
{
  "command": "leointeg.hoistSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.deHoistFromOutline",
  "when": "false"
},
</t>
<t tx="felix.20200718003259.1">{
  "command": "leointeg.undoFromOutline",
  "when": "false"
},
{
  "command": "leointeg.redoFromOutline",
  "when": "false"
}
</t>
<t tx="felix.20200718005357.1">{
  "command": "leointeg.executeScriptSelection",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.executeScriptSelection",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.minibuffer",
  "key": "alt+x",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20200718005412.1">{
  "command": "leointeg.showOutline",
  "key": "alt+t",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.showOutline",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.showBody",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "alt+d",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "tab",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "enter",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="felix.20200718005425.1">{
  "command": "leointeg.saveLeoFileFromOutline",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments/"
},
{
  "command": "leointeg.saveLeoFile",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
</t>
<t tx="felix.20200718005440.1">{
  "command": "leointeg.contractAll",
  "key": "alt+-",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.contractAllFromOutline",
  "key": "alt+-",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
</t>
<t tx="felix.20200718005444.1">{
"command": "leointeg.editSelectedHeadline",
"key": "ctrl+h",
"mac": "cmd+h",
"when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
"command": "leointeg.editSelectedHeadlineFromOutline",
"key": "ctrl+h",
"mac": "cmd+h",
"when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
"command": "leointeg.markSelection",
"key": "ctrl+m",
"mac": "cmd+m",
"when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
"command": "leointeg.markSelectionFromOutline",
"key": "ctrl+m",
"mac": "cmd+m",
"when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
"command": "leointeg.unmarkSelection",
"key": "ctrl+m",
"mac": "cmd+m",
"when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
"command": "leointeg.unmarkSelectionFromOutline",
"key": "ctrl+m",
"mac": "cmd+m",
"when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="felix.20200718005448.1">{
  "command": "leointeg.moveOutlineDownSelection",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineDownSelection",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="felix.20200718005453.1">{
  "command": "leointeg.sortSiblingsSelection",
  "key": "alt+a",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "key": "alt+a",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.promoteSelection",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.demoteSelection",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelection",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; !sideBarFocus &amp;&amp; !editorTextFocus"
},
{
  "command": "leointeg.cloneNodeSelection",
  "key": "ctrl+[Backquote]",
  "win": "ctrl+oem_7",
  "linux": "ctrl+'",
  "mac": "cmd+[Backquote]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "key": "ctrl+[Backquote]",
  "win": "ctrl+oem_7",
  "linux": "ctrl+'",
  "mac": "cmd+[Backquote]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.cutNodeSelection",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.deleteSelection",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="felix.20200718005458.1">{
  "command": "leointeg.gotoFirstVisible",
  "key": "alt+home",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoLastSibling",
  "key": "alt+end",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoFirstVisible",
  "key": "home",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoLastVisible",
  "key": "end",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.pageUp",
  "key": "pageup",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.pageDown",
  "key": "pagedown",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "key": "alt+n",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "key": "alt+n",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "down",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "alt+down",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "up",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "alt+up",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection  &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "left",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "alt+left",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "right",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "alt+right",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
}
</t>
<t tx="felix.20200718020912.1">import * as vscode from "vscode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718020912.10">/**
 * * Actions that can be invoked by Leo through leobridge
 */
public static ASYNC_ACTIONS = {
    ASYNC_LOG: "log",
    ASYNC_ASK: "ask",
    ASYNC_WARN: "warn",
    ASYNC_INFO: "info",
    ASYNC_INTERVAL: "interval"
};

</t>
<t tx="felix.20200718020912.11">/**
 * * When async action was ASYNC_INFO
 */
public static ASYNC_INFO_MESSAGE_CODES = {
    ASYNC_REFRESHED: "refreshed",
    ASYNC_IGNORED: "ignored"
};

</t>
<t tx="felix.20200718020912.12">/**
 * * runAskYesNoDialog or runAskOkDialog result codes, used when async action requires a response
 */
public static ASYNC_ASK_RETURN_CODES = {
    YES: "yes",
    NO: "no",
    YES_ALL: "yes-all",
    NO_ALL: "no-all",
    OK: '"ok"' // Quotes in string as a 'JSON parameter'
};

</t>
<t tx="felix.20200718020912.13">/**
 * * Commands for leobridgeserver.py
 */
public static LEOBRIDGE = {
    APPLY_CONFIG: "applyConfig",
    ASK_RESULT: "askResult",
    GET_ALL_GNX: "getAllGnx",
    GET_BODY_LENGTH: "getBodyLength",
    GET_BODY: "getBody",
    GET_PNODE: "getPNode",
    GET_PARENT: "getParent",
    GET_CHILDREN: "getChildren",
    GET_SELECTED_NODE: "getSelectedNode",
    SET_SELECTED_NODE: "setSelectedNode",
    SET_BODY: "setBody",
    SET_HEADLINE: "setNewHeadline",
    EXPAND_NODE: "expandNode",
    COLLAPSE_NODE: "collapseNode",
    CONTRACT_ALL: "contractAll",
    GET_OPENED_FILES: "getOpenedFiles",
    SET_OPENED_FILE: "setOpenedFile", // Pass index ? name to validate / error check, only index when stable
    OPEN_FILE: "openFile",
    CLOSE_FILE: "closeFile",
    SAVE_FILE: "saveFile",
    SAVE_CLOSE_FILE: "saveCloseFile", // Save and close current document
    GET_BUTTONS: "getButtons",
    REMOVE_BUTTON: "removeButton",
    CLICK_BUTTON: "clickButton",
    GET_COMMANDS: "getCommands", // ask leoBridge for the list of known commands
    RUN_BY_NAME: "runByName", // Run a command by its string name like in minibuffer
    // * Goto operations
    PAGE_UP: "pageUp",
    PAGE_DOWN: "pageDown",
    GOTO_FIRST_VISIBLE: "gotoFirstVisible",
    GOTO_LAST_VISIBLE: "gotoLastVisible",
    GOTO_LAST_SIBLING: "gotoLastSibling",
    GOTO_NEXT_VISIBLE: "gotoNextVisible",
    GOTO_PREV_VISIBLE: "gotoPrevVisible",
    GOTO_NEXT_MARKED: "gotoNextMarked",
    GOTO_NEXT_CLONE: "gotoNextClone",
    CONTRACT_OR_GO_LEFT: "contractOrGoLeft",
    EXPAND_AND_GO_RIGHT: "expandAndGoRight",
    // * Leo Operations
    MARK_PNODE: "markPNode",
    UNMARK_PNODE: "unmarkPNode",
    COPY_PNODE: "copyPNode",
    CUT_PNODE: "cutPNode",
    PASTE_PNODE: "pastePNode",
    PASTE_CLONE_PNODE: "pasteAsClonePNode",
    DELETE_PNODE: "deletePNode",
    MOVE_PNODE_DOWN: "movePNodeDown",
    MOVE_PNODE_LEFT: "movePNodeLeft",
    MOVE_PNODE_RIGHT: "movePNodeRight",
    MOVE_PNODE_UP: "movePNodeUp",
    INSERT_PNODE: "insertPNode",
    INSERT_NAMED_PNODE: "insertNamedPNode",
    CLONE_PNODE: "clonePNode",
    PROMOTE_PNODE: "promotePNode",
    DEMOTE_PNODE: "demotePNode",
    REFRESH_FROM_DISK_PNODE: "refreshFromDiskPNode",
    SORT_CHILDREN: "sortChildrenPNode",
    SORT_SIBLINGS: "sortSiblingsPNode",
    UNDO: "undo",
    REDO: "redo",
    EXECUTE_SCRIPT: "executeScript",
    GET_STATES: "getStates",
    HOIST_PNODE: "hoistPNode",
    DEHOIST: "deHoist",
    // TODO : @boltex More commands to implement #15, #23, #24
    CLONE_FIND_ALL: "cloneFindAll", // #24 @boltex
    CLONE_FIND_ALL_FLATTENED: "cloneFindAllFlattened", // #24 @boltex
    CLONE_FIND_MARKED: "cloneFindMarked", // #24 @boltex
    CLONE_FIND_FLATTENED_MARKED: "cloneFindFlattenedMarked", // #24 @boltex
    EXTRACT: "extract", // #15 @boltex
    EXTRACT_NAMES: "extractNames", // #15 @boltex
    COPY_MARKED: "copyMarked", // #23 @boltex
    DIFF_MARKED_NODES: "diffMarkedNodes", // #23 @boltex
    MARK_CHANGED_ITEMS: "markChangedItems", // #23 @boltex
    MARK_SUBHEADS: "markSubheads", // #23 @boltex
    UNMARK_ALL: "unmarkAll", // #23 @boltex
    CLONE_MARKED_NODES: "cloneMarkedNodes", // #23 @boltex
    DELETE_MARKED_NODES: "deleteMarkedNodes", // #23 @boltex
    MOVE_MARKED_NODES: "moveMarkedNodes" // #23 @boltex
};

</t>
<t tx="felix.20200718020912.14">/**
 * * Command strings to be used with vscode.commands.executeCommand
 * See https://code.visualstudio.com/api/extension-guides/command#programmatically-executing-a-command
 */
public static VSCODE_COMMANDS = {
    SET_CONTEXT: "setContext",
    CLOSE_ACTIVE_EDITOR: "workbench.action.closeActiveEditor",
    QUICK_OPEN: "workbench.action.quickOpen"
};

</t>
<t tx="felix.20200718020912.15">/**
 * * All commands this expansion exposes (in package.json, contributes &gt; commands)
 */
public static COMMANDS = {
    SHOW_WELCOME: Constants.NAME + ".showWelcomePage", // Always available: not in the commandPalette section of package.json
    SHOW_SETTINGS: Constants.NAME + ".showSettingsPage", // Always available: not in the commandPalette section of package.json
    // * LeoBridge
    START_SERVER: Constants.NAME + ".startServer",
    CONNECT: Constants.NAME + ".connectToServer",
    SET_OPENED_FILE: Constants.NAME + ".setOpenedFile",
    OPEN_FILE: Constants.NAME + ".openLeoFile", // sets focus on BODY
    SWITCH_FILE: Constants.NAME + ".switchLeoFile",
    NEW_FILE: Constants.NAME + ".newLeoFile",
    SAVE_FILE: Constants.NAME + ".saveLeoFile", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
    SAVE_FILE_FO: Constants.NAME + ".saveLeoFileFromOutline", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
    SAVE_AS_FILE: Constants.NAME + ".saveAsLeoFile",
    CLOSE_FILE: Constants.NAME + ".closeLeoFile",
    CLICK_BUTTON: Constants.NAME + ".clickButton",
    REMOVE_BUTTON: Constants.NAME + ".removeButton",
    MINIBUFFER: Constants.NAME + ".minibuffer",
    // * Outline selection
    SELECT_NODE: Constants.NAME + ".selectTreeNode",
    OPEN_ASIDE: Constants.NAME + ".openAside",
    // * Goto operations that always finish with focus in outline
    PAGE_UP: Constants.NAME + ".pageUp",
    PAGE_DOWN: Constants.NAME + ".pageDown",
    GOTO_FIRST_VISIBLE: Constants.NAME + ".gotoFirstVisible",
    GOTO_LAST_VISIBLE: Constants.NAME + ".gotoLastVisible",
    GOTO_LAST_SIBLING: Constants.NAME + ".gotoLastSibling",
    GOTO_NEXT_VISIBLE: Constants.NAME + ".gotoNextVisible",
    GOTO_PREV_VISIBLE: Constants.NAME + ".gotoPrevVisible",
    GOTO_NEXT_MARKED: Constants.NAME + ".gotoNextMarked",
    GOTO_NEXT_CLONE: Constants.NAME + ".gotoNextClone",
    GOTO_NEXT_CLONE_SELECTION: Constants.NAME + ".gotoNextCloneSelection",
    GOTO_NEXT_CLONE_SELECTION_FO: Constants.NAME + ".gotoNextCloneSelectionFromOutline",
    CONTRACT_OR_GO_LEFT: Constants.NAME + ".contractOrGoLeft",
    EXPAND_AND_GO_RIGHT: Constants.NAME + ".expandAndGoRight",
    // * Leo Operations
    UNDO: Constants.NAME + ".undo", // From command Palette
    UNDO_FO: Constants.NAME + ".undoFromOutline", // from button, return focus on OUTLINE
    REDO: Constants.NAME + ".redo", // From command Palette
    REDO_FO: Constants.NAME + ".redoFromOutline", // from button, return focus on OUTLINE
    EXECUTE: Constants.NAME + ".executeScriptSelection", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
    SHOW_BODY: Constants.NAME + ".showBody",
    SHOW_OUTLINE: Constants.NAME + ".showOutline",
    SHOW_LOG: Constants.NAME + ".showLogPane",
    SORT_CHILDREN: Constants.NAME + ".sortChildrenSelection", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
    SORT_SIBLING: Constants.NAME + ".sortSiblingsSelection",
    SORT_SIBLING_FO: Constants.NAME + ".sortSiblingsSelectionFromOutline",
    CONTRACT_ALL: Constants.NAME + ".contractAll", // From command Palette
    CONTRACT_ALL_FO: Constants.NAME + ".contractAllFromOutline", // from button, return focus on OUTLINE
    // * Commands from tree panel buttons or context: focus on OUTLINE
    MARK: Constants.NAME + ".mark",
    UNMARK: Constants.NAME + ".unmark",
    COPY: Constants.NAME + ".copyNode",
    CUT: Constants.NAME + ".cutNode",
    PASTE: Constants.NAME + ".pasteNode",
    PASTE_CLONE: Constants.NAME + ".pasteNodeAsClone",
    DELETE: Constants.NAME + ".delete",
    HEADLINE: Constants.NAME + ".editHeadline",
    MOVE_DOWN: Constants.NAME + ".moveOutlineDown",
    MOVE_LEFT: Constants.NAME + ".moveOutlineLeft",
    MOVE_RIGHT: Constants.NAME + ".moveOutlineRight",
    MOVE_UP: Constants.NAME + ".moveOutlineUp",
    INSERT: Constants.NAME + ".insertNode",
    CLONE: Constants.NAME + ".cloneNode",
    PROMOTE: Constants.NAME + ".promote",
    DEMOTE: Constants.NAME + ".demote",
    REFRESH_FROM_DISK: Constants.NAME + ".refreshFromDisk",
    // * Commands from keyboard, while focus on BODY (command-palette returns to BODY for now)
    MARK_SELECTION: Constants.NAME + ".markSelection",
    UNMARK_SELECTION: Constants.NAME + ".unmarkSelection",
    COPY_SELECTION: Constants.NAME + ".copyNodeSelection", // Nothing to refresh/focus so no "FO" version
    CUT_SELECTION: Constants.NAME + ".cutNodeSelection",
    PASTE_SELECTION: Constants.NAME + ".pasteNodeAtSelection",
    PASTE_CLONE_SELECTION: Constants.NAME + ".pasteNodeAsCloneAtSelection",
    DELETE_SELECTION: Constants.NAME + ".deleteSelection",
    HEADLINE_SELECTION: Constants.NAME + ".editSelectedHeadline",
    MOVE_DOWN_SELECTION: Constants.NAME + ".moveOutlineDownSelection",
    MOVE_LEFT_SELECTION: Constants.NAME + ".moveOutlineLeftSelection",
    MOVE_RIGHT_SELECTION: Constants.NAME + ".moveOutlineRightSelection",
    MOVE_UP_SELECTION: Constants.NAME + ".moveOutlineUpSelection",
    INSERT_SELECTION: Constants.NAME + ".insertNodeSelection",
    INSERT_SELECTION_INTERRUPT: Constants.NAME + ".insertNodeSelectionInterrupt", // Headline input box can be interrupted with another insert
    CLONE_SELECTION: Constants.NAME + ".cloneNodeSelection",
    PROMOTE_SELECTION: Constants.NAME + ".promoteSelection",
    DEMOTE_SELECTION: Constants.NAME + ".demoteSelection",
    REFRESH_FROM_DISK_SELECTION: Constants.NAME + ".refreshFromDiskSelection",
    // * Commands from keyboard, while focus on OUTLINE
    MARK_SELECTION_FO: Constants.NAME + ".markSelectionFromOutline",
    UNMARK_SELECTION_FO: Constants.NAME + ".unmarkSelectionFromOutline",
    // COPY_SELECTION Nothing to refresh/focus for "copy a node" so no entry here
    CUT_SELECTION_FO: Constants.NAME + ".cutNodeSelectionFromOutline",
    PASTE_SELECTION_FO: Constants.NAME + ".pasteNodeAtSelectionFromOutline",
    PASTE_CLONE_SELECTION_FO: Constants.NAME + ".pasteNodeAsCloneAtSelectionFromOutline",
    DELETE_SELECTION_FO: Constants.NAME + ".deleteSelectionFromOutline",
    HEADLINE_SELECTION_FO: Constants.NAME + ".editSelectedHeadlineFromOutline",
    MOVE_DOWN_SELECTION_FO: Constants.NAME + ".moveOutlineDownSelectionFromOutline",
    MOVE_LEFT_SELECTION_FO: Constants.NAME + ".moveOutlineLeftSelectionFromOutline",
    MOVE_RIGHT_SELECTION_FO: Constants.NAME + ".moveOutlineRightSelectionFromOutline",
    MOVE_UP_SELECTION_FO: Constants.NAME + ".moveOutlineUpSelectionFromOutline",
    INSERT_SELECTION_FO: Constants.NAME + ".insertNodeSelectionFromOutline",
    CLONE_SELECTION_FO: Constants.NAME + ".cloneNodeSelectionFromOutline",
    PROMOTE_SELECTION_FO: Constants.NAME + ".promoteSelectionFromOutline",
    DEMOTE_SELECTION_FO: Constants.NAME + ".demoteSelectionFromOutline",
    REFRESH_FROM_DISK_SELECTION_FO: Constants.NAME + ".refreshFromDiskSelectionFromOutline",
    HOIST: Constants.NAME + ".hoistNode",
    HOIST_SELECTION: Constants.NAME + ".hoistSelection",
    HOIST_SELECTION_FO: Constants.NAME + ".hoistSelectionFromOutline",
    DEHOIST: Constants.NAME + ".deHoist",
    DEHOIST_FO: Constants.NAME + ".deHoistFromOutline",
    // * - - - - - - - - - - - - - - - not implemented yet
    CLONE_FIND_ALL: Constants.NAME + ".cloneFindAll",
    CLONE_FIND_ALL_FLATTENED: Constants.NAME + ".cloneFindAllFlattened",
    CLONE_FIND_MARKED: Constants.NAME + ".cloneFindMarked",
    CLONE_FIND_FLATTENED_MARKED: Constants.NAME + ".cloneFindFlattenedMarked",
    EXTRACT: Constants.NAME + ".extract",
    EXTRACT_NAMES: Constants.NAME + ".extractNames",
    COPY_MARKED: Constants.NAME + ".copyMarked",
    DIFF_MARKED_NODES: Constants.NAME + ".diffMarkedNodes",
    MARK_CHANGED_ITEMS: Constants.NAME + ".markChangedItems",
    MARK_SUBHEADS: Constants.NAME + ".markSubheads",
    UNMARK_ALL: Constants.NAME + ".unmarkAll",
    CLONE_MARKED_NODES: Constants.NAME + ".cloneMarkedNodes",
    DELETE_MARKED_NODES: Constants.NAME + ".deleteMarkedNodes",
    MOVE_MARKED_NODES: Constants.NAME + ".moveMarkedNodes"
};
</t>
<t tx="felix.20200718020912.2">/**
 * * Text and numeric constants used throughout leoInteg
 */
export class Constants {

    @others
}
</t>
<t tx="felix.20200718020912.3">public static PUBLISHER: string = "boltex";
public static NAME: string = "leointeg";
public static CONFIG_NAME: string = "leoIntegration";
public static CONFIG_REFRESH_MATCH: string = "OnNodes"; // substring to distinguish 'on-hover' icon commands

public static TREEVIEW_ID: string = Constants.CONFIG_NAME;
public static TREEVIEW_EXPLORER_ID: string = Constants.CONFIG_NAME + "Explorer";

public static DOCUMENTS_ID: string = "leoDocuments";
public static DOCUMENTS_EXPLORER_ID: string = "leoDocumentsExplorer";

public static BUTTONS_ID: string = "leoButtons";
public static BUTTONS_EXPLORER_ID: string = "leoButtonsExplorer";

public static VERSION_STATE_KEY: string = "leoIntegVersion";

public static FILE_EXTENSION: string = "leo";
public static URI_LEO_SCHEME: string = "leo";
public static URI_FILE_SCHEME: string = "file";
public static URI_SCHEME_HEADER: string = "leo:/";
public static FILE_OPEN_FILTER_MESSAGE: string = "Leo Files";
public static UNTITLED_FILE_NAME: string = "untitled";
public static RECENT_FILES_KEY: string = "leoFiles";

public static DEFAULT_PYTHON: string = "python3.7";
public static WIN32_PYTHON: string = "py";
public static SERVER_PATH: string = "/leobridgeserver.py";
public static SERVER_STARTED_TOKEN: string = "LeoBridge started";

public static TCPIP_DEFAULT_PORT: number = 32125;
public static TCPIP_DEFAULT_PROTOCOL: string = "ws://";
public static TCPIP_DEFAULT_ADDRESS: string = "localhost";

public static ERROR_PACKAGE_ID: number = 0;
public static STARTING_PACKAGE_ID: number = 1;
public static STATUSBAR_DEBOUNCE_DELAY: number = 50;
public static STATES_DEBOUNCE_DELAY: number = 200; // a fifth of a second after command stack completion

</t>
<t tx="felix.20200718020912.4">/**
 * * Strings used as language id (default is "leobody")
 * TODO : #56 @boltex Add more languages strings for when directives such as @language are used throughout body panes
 */
public static BODY_LANGUAGES = {
    default: "leobody"
};

</t>
<t tx="felix.20200718020912.5">/**
 * * Strings used in the workbench interface panels (not for messages or dialogs)
 */
public static GUI = {
    ICON_LIGHT_DOCUMENT: "resources/light/document.svg",
    ICON_DARK_DOCUMENT: "resources/dark/document.svg",
    ICON_LIGHT_DOCUMENT_DIRTY: "resources/light/document-dirty.svg",
    ICON_DARK_DOCUMENT_DIRTY: "resources/dark/document-dirty.svg",
    ICON_LIGHT_BUTTON: "resources/light/button.svg",
    ICON_DARK_BUTTON: "resources/dark/button.svg",
    ICON_LIGHT_BUTTON_ADD: "resources/light/button-add.svg",
    ICON_DARK_BUTTON_ADD: "resources/dark/button-add.svg",
    ICON_LIGHT_PATH: "resources/light/box",
    ICON_DARK_PATH: "resources/dark/box",
    ICON_FILE_EXT: ".svg",
    STATUSBAR_DEFAULT_COLOR: "fb7c47",
    STATUSBAR_DEFAULT_STRING: "", // Strings like "Literate", "Leo", UTF-8 also supported: \u{1F981}
    STATUSBAR_INDICATOR: "$(keyboard) ",
    QUICK_OPEN_LEO_COMMANDS: "&gt;leo: ",
    EXPLORER_TREEVIEW_PREFIX: "LEO ",
    TREEVIEW_TITLE: "OUTLINE",
    TREEVIEW_TITLE_NOT_CONNECTED: "NOT CONNECTED",
    TREEVIEW_TITLE_CONNECTED: "CONNECTED",
    TREEVIEW_TITLE_INTEGRATION: "INTEGRATION",
    BODY_TITLE: "LEO BODY",
    LOG_PANE_TITLE: "Leo Log Window",
    TERMINAL_PANE_TITLE: "LeoBridge Server",
    THEME_STATUSBAR: "statusBar.foreground"
};

</t>
<t tx="felix.20200718020912.6">/**
 * * Basic user messages strings for messages and dialogs
 */
public static USER_MESSAGES = {
    SCRIPT_BUTTON: "Creates a button from selected node's script",
    SCRIPT_BUTTON_TOOLTIP:
        "The 'Script Button' button creates a new button.\n" +
        "Its name will be the headline of the presently selected node\n" +
        "Hitting this newly created button executes the button's script.\n" +
        "\n" +
        "For example, to run a script on any part of an outline:\n" +
        "\n" +
        "1.  Select the node containing the script.\n" +
        "2.  Press 'Script Button'. This will create a new button.\n" +
        "3.  Select the node on which you want to run the script.\n" +
        "4.  Press the *new* button.",
    SAVE_CHANGES: "Save changes to",
    BEFORE_CLOSING: "before closing?",
    CANCEL: "Cancel",
    OPEN_WITH_LEOINTEG: "Open this Leo file with LeoInteg?",
    FILE_ALREADY_OPENED: "Leo file already opened",
    CHOOSE_OPENED_FILE: "Select an opened Leo File",
    FILE_NOT_OPENED: "No files opened.",
    STATUSBAR_TOOLTIP_ON: "Leo Key Bindings are in effect", // TODO : Add description of what happens if clicked
    STATUSBAR_TOOLTIP_OFF: "Leo Key Bindings off", // TODO : Add description of what happens if clicked
    PROMPT_EDIT_HEADLINE: "Edit Headline",
    PROMPT_INSERT_NODE: "Insert Node",
    DEFAULT_HEADLINE: "New Headline",
    START_SERVER_ERROR: "Error - Cannot start server: ",
    CONNECT_FAILED: "Leo Bridge Connection Failed",
    CONNECT_ERROR: "Leo Bridge Connection Error: Incorrect id",
    CONNECTED: "Connected",
    ALREADY_CONNECTED: "Already connected",
    DISCONNECTED: "Disconnected",
    CLOSE_ERROR: "Cannot close: No files opened.",
    YES: "Yes",
    NO: "No",
    YES_ALL: "Yes to all",
    NO_ALL: "No to all",
    CHANGES_DETECTED: "Changes to external files were detected.",
    REFRESHED: " Nodes were refreshed from file.", // with voluntary leading space
    IGNORED: " They were ignored.", // with voluntary leading space
    TOO_FAST: "leoInteg is busy! " // with voluntary trailing space
};

</t>
<t tx="felix.20200718020912.7">/**
 * * Choices offered when about to lose current changes to a Leo Document
 */
public static ASK_SAVE_CHANGES_BUTTONS: vscode.MessageItem[] = [
    {
        title: Constants.USER_MESSAGES.YES,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.NO,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.CANCEL,
        isCloseAffordance: true
    }
];

</t>
<t tx="felix.20200718020912.8">/**
 * * String for JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public static CONFIG = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "checkForChangeExternalFiles",
    DEFAULT_RELOAD_IGNORE: "defaultReloadIgnore",
    LEO_TREE_BROWSE: "leoTreeBrowse",
    TREE_KEEP_FOCUS: "treeKeepFocus",
    TREE_KEEP_FOCUS_WHEN_ASIDE: "treeKeepFocusWhenAside",
    STATUSBAR_STRING: "statusBarString",
    STATUSBAR_COLOR: "statusBarColor",
    TREE_IN_EXPLORER: "treeInExplorer",
    SHOW_OPEN_ASIDE: "showOpenAside",
    SHOW_EDIT: "showEditOnNodes",
    SHOW_ARROWS: "showArrowsOnNodes",
    SHOW_ADD: "showAddOnNodes",
    SHOW_MARK: "showMarkOnNodes",
    SHOW_CLONE: "showCloneOnNodes",
    SHOW_COPY: "showCopyOnNodes",
    INVERT_NODES: "invertNodeContrast",
    LEO_PYTHON_COMMAND: "leoPythonCommand",
    AUTO_START_SERVER: "startServerAutomatically",
    AUTO_CONNECT: "connectToServerAutomatically",
    IP_ADDRESS: "connectionAddress",
    IP_PORT: "connectionPort",
};

</t>
<t tx="felix.20200718020912.9">/**
 * * Used in 'when' clauses, set with vscode.commands.executeCommand("setContext",...)
 */
public static CONTEXT_FLAGS = {
    // Main flags for connection and opened file
    BRIDGE_READY: "leoBridgeReady", // Connected to leoBridge
    TREE_OPENED: "leoTreeOpened", // At least one Leo file opened
    TREE_TITLED: "leoTreeTitled", // Tree is a Leo file and not a new untitled document
    SERVER_STARTED: "leoServerStarted", // Auto-start or manually started
    // 'states' flags for currently opened tree view
    LEO_CHANGED: "leoChanged",
    LEO_CAN_UNDO: "leoCanUndo",
    LEO_CAN_REDO: "leoCanRedo",
    LEO_CAN_DEMOTE: "leoCanDemote",
    LEO_CAN_PROMOTE: "leoCanPromote",
    LEO_CAN_DEHOIST: "leoCanDehoist",
    // 'states' flags about current selection, for visibility and commands availability
    SELECTED_MARKED: "leoMarked", // no need for unmarked here, use !leoMarked
    SELECTED_CLONE: "leoCloned",
    SELECTED_DIRTY: "leoDirty",
    SELECTED_EMPTY: "leoEmpty",
    SELECTED_CHILD: "leoChild", // Has children
    SELECTED_ATFILE: "LeoAtFile", // Can be refreshed
    SELECTED_ROOT: "leoRoot", // ! Not given by Leo: Computed by leoInteg/vscode instead
    // Statusbar Flag 'keybindings in effect'
    LEO_SELECTED: "leoObjectSelected", // keybindings "On": Outline or body has focus
    // Context Flags for 'when' clauses, used concatenated, for each outline node
    NODE_MARKED: "leoNodeMarked",  // Selected node is marked
    NODE_UNMARKED: "leoNodeUnmarked", // Selected node is unmarked (Needed for regexp)
    NODE_ATFILE: "leoNodeAtFile", // Selected node is an @file or @clean, etc...
    NODE_CLONED: "leoNodeCloned",
    NODE_ROOT: "leoNodeRoot",
    NODE_NOT_ROOT: "leoNodeNotRoot",
    // Flags for Leo documents tree view icons and hover node command buttons
    DOCUMENT_SELECTED_TITLED: "leoDocumentSelectedTitled",
    DOCUMENT_TITLED: "leoDocumentTitled",
    DOCUMENT_SELECTED_UNTITLED: "leoDocumentSelectedUntitled",
    DOCUMENT_UNTITLED: "leoDocumentUntitled",
    // Flags that match specific LeoInteg config settings
    LEO_TREE_BROWSE: Constants.CONFIG.LEO_TREE_BROWSE, // Leo outline also in the explorer view
    TREE_IN_EXPLORER: Constants.CONFIG.TREE_IN_EXPLORER, // Leo outline also in the explorer view
    SHOW_OPEN_ASIDE: Constants.CONFIG.SHOW_OPEN_ASIDE,   // Show 'open aside' in context menu
    SHOW_EDIT: Constants.CONFIG.SHOW_EDIT,              // Hover Icons on outline nodes
    SHOW_ARROWS: Constants.CONFIG.SHOW_ARROWS,           // Hover Icons on outline nodes
    SHOW_ADD: Constants.CONFIG.SHOW_ADD,                 // Hover Icons on outline nodes
    SHOW_MARK: Constants.CONFIG.SHOW_MARK,               // Hover Icons on outline nodes
    SHOW_CLONE: Constants.CONFIG.SHOW_CLONE,             // Hover Icons on outline nodes
    SHOW_COPY: Constants.CONFIG.SHOW_COPY,               // Hover Icons on outline nodes
    AUTO_START_SERVER: Constants.CONFIG.AUTO_START_SERVER,   // Used at startup
    AUTO_CONNECT: Constants.CONFIG.AUTO_CONNECT              // Used at startup
};

</t>
<t tx="felix.20200718024635.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { UserCommand, RefreshType, LeoBridgePackage } from "./types";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20200718024635.2">/**
 * * Front-facing, user command stack of actions. 
 * Actions can also be added once started resolving.
 */
export class CommandStack {

    private _stack: UserCommand[] = [];
    private _busy: boolean = false;

    // Refresh type, for after the last command is done. (From highest so far)
    private _finalRefreshType: RefreshType = RefreshType.NoRefresh; 
    
    // Flag indicating to set focus on outline when all done, instead of body. (From last one pushed)
    private _finalFromOutline: boolean = false; 

    // * Received selection from the last command that finished.
    // * Note: JSON string representation of a node, will be re-sent as node to leo instead of lastSelectedNode
    private _receivedSelection: string = ""; // Selected node that was received from last command from a running stack. Empty string is used as 'false'.

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._busy = false;
    }

    @others
}
</t>
<t tx="felix.20200718024635.3">/**
 * * Get command stack size
 * @returns the number of actions on the command stack
 */
public size(): number {
    return this._stack.length;
}

</t>
<t tx="felix.20200718024635.4">/**
 * * Signal to the command stack that a new selected node was received. 
 * This command stacks needs to know when to clear its own '_receivedSelection'
 */
public newSelection(): void {
    if (!this._busy) {
        this._receivedSelection = "";
    }
}

</t>
<t tx="felix.20200718024635.5">/**
 * * Adds on top and try to execute the bottom command if not already running
 * @param p_command is an object that has the action, node, refresh type and 'fromOutline' flag
 * @returns true if added, false if it could not due to stack 'rules':
 *  - Targeted command (for a specific node) can only be added on an empty stack
 */
public add(p_command: UserCommand): boolean {
    if (this.size() &amp;&amp; p_command.node) {
        // If already started we only if if action requires generic selected node as param
        return false;
    } else {
        this._stack.push(p_command);
        // This flag is set on command entered, not when finally executed because a rapid type in editor can override focus
        this._finalFromOutline = p_command.fromOutline; // use the last _finalFromOutline regardless of previous so change now
        this._tryStart();
        return true;
    }
}

</t>
<t tx="felix.20200718024635.6">/**
 * * Try to launch commands that were added on the stack, if any.
 */
private _tryStart(): void {
    if (this.size() &amp;&amp; !this._busy) {

        // actions have beed added and command stack instance is not busy, so set the busy flag and start from the bottom
        this._busy = true; // Cleared when the last command has returned (and the stack is empty)

        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}

</t>
<t tx="felix.20200718024635.7">/**
 * * Run the command at index 0: The bottom of the stack.
 */
private _runStackCommand(): Promise&lt;LeoBridgePackage&gt; {
    // console.log('Running from a stack of', this._stack.length);

    const w_command = this._stack[0]; // Reference from bottom of stack, don't remove yet

    // Build parameter's json here - use providedHeadline if needed
    let w_nodeJson: string = ""; // ap json used in building w_jsonParam
    let w_jsonParam: string = ""; // Finished parameter that is sent

    // First one uses given node or last selected node, other subsequent on stack will use _receivedSelection
    // (Commands such as 'collapse all' will just ignore passed on node parameter)
    const w_providedHeadline = w_command.providedHeadline; // Can be undefined
    if (w_command.node) {
        // console.log('USING SPECIFIC Node');

        w_nodeJson = w_command.node.apJson; // Was node specific, so we are starting from a new stack of commands
    } else {
        // Use received "selected node" unless first, then use last selected node
        // console.log(`NOT SPECIFIC node, busy is ${this._busy}`);

        if (this._receivedSelection) {
            // console.log('USING LAST _receivedSelection, SHOULD SEE NEXT ABOVE!');

            w_nodeJson = this._receivedSelection;
        } else {
            // console.log('USING LAST lastSelectedNode');

            w_nodeJson = this._leoIntegration.lastSelectedNode!.apJson;
        }
        if (!w_nodeJson) {
            console.log('ERROR NO ARCHIVED POSITION JSON');
        }
    }
    if (w_providedHeadline) {
        w_jsonParam = utils.buildNodeAndTextJson(w_nodeJson, w_providedHeadline); // 'Insert Named Node' or 'Edit Headline'
    } else {
        w_jsonParam = w_nodeJson; // 'Insert Unnamed Node' or regular command
    }

    // Setup _finalRefreshType, if higher than the one setup so far
    this._finalRefreshType = w_command.refreshType &gt; this._finalRefreshType ? w_command.refreshType : this._finalRefreshType;

    // Submit this action to Leo and return a promise of its packaged answer
    return this._leoIntegration.sendAction(w_command.action, w_jsonParam);
}

</t>
<t tx="felix.20200718024635.8">/**
 * * Handle the result from the command that has finished: either launch the next one, or refresh accordingly.
 * @param p_package is the json return 'package' that was just received back from Leo
 */
private _resolveResult(p_package: LeoBridgePackage): void {
    this._stack.shift();
    // If last is done then do refresh outline and focus on outline, or body
    // console.log('p_package :', p_package);

    // TODO : p_package members names should be made into constants

    this._receivedSelection = JSON.stringify(p_package.node); // ! Maybe set this._receivedSelection to the last one anyways ?
    if (!this.size()) {
        // Reset 'received' selected node so that lastSelectedNode is used instead
        // this._receivedSelection = ""; // ! Maybe not clear this here at this point!

        this._busy = false; // We're not busy anymore // ! maybe keep using _receivedSelection instead of clearing it?
        // console.log(`busy NOW FALSE :  ${this._busy}`);

        if (this._finalRefreshType) {
            // At least some type of refresh
            this._leoIntegration.launchRefresh(this._finalRefreshType, this._finalFromOutline);
        }
        // Reset refresh type and focus flag nonetheless
        this._finalRefreshType = RefreshType.NoRefresh;
        this._finalFromOutline = false;

    } else {
        // size &gt; 0, so call _runStackCommand again, keep _busy set to true
        // console.log('Next!');
        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}
</t>
<t tx="felix.20200718030926.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { ConfigMembers, RefreshType } from "./types";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718030926.2">/**
 * * Configuration Settings Service
 */
export class Config implements ConfigMembers {
    // Some config settings are used in leobridgeserver.py such as defaultReloadIgnore and checkForChangeExternalFiles
    // TODO : Should use default values in a centralized way
    public checkForChangeExternalFiles: string = "none";  // Used in leoBridge script
    public defaultReloadIgnore: string = "none"; // Used in leoBridge script
    public leoTreeBrowse: boolean = true;
    public treeKeepFocus: boolean = true;
    public treeKeepFocusWhenAside: boolean = false;
    public treeInExplorer: boolean = true;
    public showOpenAside: boolean = true;
    public statusBarString: string = "";
    public statusBarColor: string = "";
    public showEditOnNodes: boolean = true;
    public showArrowsOnNodes: boolean = false;
    public showAddOnNodes: boolean = false;
    public showMarkOnNodes: boolean = false;
    public showCloneOnNodes: boolean = false;
    public showCopyOnNodes: boolean = false;
    public invertNodeContrast: boolean = false;
    public leoPythonCommand: string = "";
    public startServerAutomatically: boolean = false; // Now set this configuration option default to 'false' to showcase treeViews 'welcome content'
    public connectToServerAutomatically: boolean = false; // Now set this configuration option default to 'false'
    public connectionAddress: string = Constants.TCPIP_DEFAULT_ADDRESS;
    public connectionPort: number = Constants.TCPIP_DEFAULT_PORT;

    private _isSettingConfig: boolean = false;
    private _needsTreeRefresh: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20200718030926.3">/**
 * * Get Leointeg Configuration
 * @returns An object with live config settings members such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public getConfig(): ConfigMembers {
    return {
        checkForChangeExternalFiles: this.checkForChangeExternalFiles,  // Used in leoBridge script
        defaultReloadIgnore: this.defaultReloadIgnore,  // Used in leoBridge script

        leoTreeBrowse: this.leoTreeBrowse,
        treeKeepFocus: this.treeKeepFocus,
        treeKeepFocusWhenAside: this.treeKeepFocusWhenAside,
        treeInExplorer: this.treeInExplorer,
        showOpenAside: this.showOpenAside,
        statusBarString: this.statusBarString,
        statusBarColor: this.statusBarColor,
        showEditOnNodes: this.showEditOnNodes,
        showArrowsOnNodes: this.showArrowsOnNodes,
        showAddOnNodes: this.showAddOnNodes,
        showMarkOnNodes: this.showMarkOnNodes,
        showCloneOnNodes: this.showCloneOnNodes,
        showCopyOnNodes: this.showCopyOnNodes,
        invertNodeContrast: this.invertNodeContrast,
        leoPythonCommand: this.leoPythonCommand,
        startServerAutomatically: this.startServerAutomatically,
        connectToServerAutomatically: this.connectToServerAutomatically,
        connectionAddress: this.connectionAddress,
        connectionPort: this.connectionPort,
    };
}

</t>
<t tx="felix.20200718030926.4">/**
 * * Apply changes to the expansion config settings, those configuration values are persisted
 * @param p_changes is an array of key/values to change in the expansion settings
 * @returns a promise, in case additional procedures need to be run upon completion
 */
public setLeoIntegSettings(p_changes: { code: string, value: any }[]): Promise&lt;void&gt; {
    this._isSettingConfig = true;
    const w_promises: Thenable&lt;void&gt;[] = [];
    const w_vscodeConfig = vscode.workspace.getConfiguration(Constants.CONFIG_NAME);
    p_changes.forEach(i_change =&gt; {
        if (i_change &amp;&amp; i_change.code.includes(Constants.CONFIG_REFRESH_MATCH)) {
            // Check if tree refresh is required for hover-icons to be displayed or hidden accordingly
            this._needsTreeRefresh = true;
        }
        if (w_vscodeConfig.inspect(i_change.code)!.defaultValue === i_change.value) {
            // set as undefined - same as default
            w_promises.push(w_vscodeConfig.update(i_change.code, undefined, true));
            // console.log("clearing ", change.code, "to undefined");
        } else {
            // set as value which is not default
            w_promises.push(w_vscodeConfig.update(i_change.code, i_change.value, true));
            // console.log("setting ", change.code, "to ", change.value);
        }
    });
    return Promise.all(w_promises).then(() =&gt; {
        if (this._needsTreeRefresh) {
            this._needsTreeRefresh = false;
            setTimeout(() =&gt; {
                this._leoIntegration.configTreeRefresh();
            }, 200);
        }
        this._isSettingConfig = false;
        this.buildFromSavedSettings();
    });
}

</t>
<t tx="felix.20200718030926.5">/**
 * * Build config from settings from vscode's saved config settings
 */
public buildFromSavedSettings(): void {
    if (this._isSettingConfig) {
        // * Currently setting config, wait until its done all, and this will be called automatically
        return;
    } else {
        // * Graphic and theme settings
        this.invertNodeContrast = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.INVERT_NODES, false);
        this.statusBarString = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.STATUSBAR_STRING, Constants.GUI.STATUSBAR_DEFAULT_STRING);
        if (this.statusBarString.length &gt; 8) {
            this.statusBarString = Constants.GUI.STATUSBAR_DEFAULT_STRING;
        }
        this.statusBarColor = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.STATUSBAR_COLOR, Constants.GUI.STATUSBAR_DEFAULT_COLOR);
        if (!utils.isHexColor(this.statusBarColor)) {
            this.statusBarColor = Constants.GUI.STATUSBAR_DEFAULT_COLOR;
        }
        // * Interface elements visibility defaults
        // TODO : Should use default values in a centralized way
        this.checkForChangeExternalFiles = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.CHECK_FOR_CHANGE_EXTERNAL_FILES, "none");
        this.defaultReloadIgnore = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.DEFAULT_RELOAD_IGNORE, "none");
        this.treeInExplorer = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.TREE_IN_EXPLORER, true);
        this.showOpenAside = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_OPEN_ASIDE, true);
        this.showEditOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_EDIT, false);
        this.showArrowsOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_ARROWS, false);
        this.showAddOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_ADD, false);
        this.showMarkOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_MARK, false);
        this.showCloneOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_CLONE, false);
        this.showCopyOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_COPY, false);
        // * Interface settings
        this.leoTreeBrowse = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.LEO_TREE_BROWSE, true);
        this.treeKeepFocus = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.TREE_KEEP_FOCUS, true);
        this.treeKeepFocusWhenAside = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.TREE_KEEP_FOCUS_WHEN_ASIDE, false);
        // * Server and connection automation
        this.leoPythonCommand = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.LEO_PYTHON_COMMAND, "");
        this.startServerAutomatically = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.AUTO_START_SERVER, false);
        this.connectToServerAutomatically = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.AUTO_CONNECT, false);
        this.connectionAddress = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.IP_ADDRESS, Constants.TCPIP_DEFAULT_ADDRESS); // 'ws://'
        this.connectionPort = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.IP_PORT, Constants.TCPIP_DEFAULT_PORT); // 32125
        // * Set context for tree items visibility that are based on config options
        this._leoIntegration.sendConfigToServer(this.getConfig());
        utils.setContext(Constants.CONTEXT_FLAGS.LEO_TREE_BROWSE, this.leoTreeBrowse);
        utils.setContext(Constants.CONTEXT_FLAGS.TREE_IN_EXPLORER, this.treeInExplorer);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_OPEN_ASIDE, this.showOpenAside);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_EDIT, this.showEditOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_ARROWS, this.showArrowsOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_ADD, this.showAddOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_MARK, this.showMarkOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_CLONE, this.showCloneOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_COPY, this.showCopyOnNodes);
    }
}
</t>
<t tx="felix.20200718031424.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { RefreshType } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { LeoSettingsWebview } from "./webviews/leoSettingsWebview";
import { LeoButtonNode } from "./leoButtonNode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718031424.10">[CMD.CONTRACT_ALL, () =&gt; w_leo.nodeCommand(BRIDGE.CONTRACT_ALL, U, REFRESH_TREE, false)],
[CMD.CONTRACT_ALL_FO, () =&gt; w_leo.nodeCommand(BRIDGE.CONTRACT_ALL, U, REFRESH_TREE, true)],
[CMD.CONTRACT_OR_GO_LEFT, () =&gt; w_leo.nodeCommand(BRIDGE.CONTRACT_OR_GO_LEFT, U, REFRESH_BOTH, true)],

[CMD.EXPAND_AND_GO_RIGHT, () =&gt; w_leo.nodeCommand(BRIDGE.EXPAND_AND_GO_RIGHT, U, REFRESH_BOTH, true)],
</t>
<t tx="felix.20200718031424.11">// [cmd.GIT_DIFF, () =&gt; leo.nodeCommand(bridge.GIT_DIFF, u, refreshBoth, true)],
</t>
<t tx="felix.20200718031424.12">[CMD.GOTO_NEXT_CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.GOTO_NEXT_CLONE, p_node, REFRESH_BOTH, true)],
[CMD.GOTO_NEXT_CLONE_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_NEXT_CLONE, U, REFRESH_BOTH, false)],
[CMD.GOTO_NEXT_CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_NEXT_CLONE, U, REFRESH_BOTH, true)],

[CMD.GOTO_NEXT_MARKED, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_NEXT_MARKED, U, REFRESH_BOTH, true)],

[CMD.GOTO_FIRST_VISIBLE, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_FIRST_VISIBLE, U, REFRESH_BOTH, true)],
[CMD.GOTO_LAST_SIBLING, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_LAST_SIBLING, U, REFRESH_BOTH, true)],
[CMD.GOTO_LAST_VISIBLE, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_LAST_VISIBLE, U, REFRESH_BOTH, true)],
[CMD.GOTO_NEXT_VISIBLE, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_NEXT_VISIBLE, U, REFRESH_BOTH, true)],
[CMD.GOTO_PREV_VISIBLE, () =&gt; w_leo.nodeCommand(BRIDGE.GOTO_PREV_VISIBLE, U, REFRESH_BOTH, true)],

</t>
<t tx="felix.20200718031424.13">[CMD.DEHOIST, () =&gt; w_leo.nodeCommand(BRIDGE.DEHOIST, U, REFRESH_BOTH, false)],
[CMD.DEHOIST_FO, () =&gt; w_leo.nodeCommand(BRIDGE.DEHOIST, U, REFRESH_BOTH, true)],

[CMD.HOIST, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.HOIST_PNODE, p_node, REFRESH_BOTH, true)],
[CMD.HOIST_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.HOIST_PNODE, U, REFRESH_BOTH, false)],
[CMD.HOIST_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.HOIST_PNODE, U, REFRESH_BOTH, true)],
</t>
<t tx="felix.20200718031424.14">[CMD.CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.CLONE_PNODE, p_node, REFRESH_TREE, false)],
[CMD.CLONE_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.CLONE_PNODE, U, REFRESH_TREE, false)],
[CMD.CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.CLONE_PNODE, U, REFRESH_TREE, true)],

[CMD.INSERT, (p_node: LeoNode) =&gt; w_leo.insertNode(p_node, false)],
[CMD.INSERT_SELECTION, () =&gt; w_leo.insertNode(U, false)],
[CMD.INSERT_SELECTION_FO, () =&gt; w_leo.insertNode(U, true)],

// * Special command for when inserting rapidly more than one node without even specifying a headline label,
// such as spamming CTRL+I rapidly.
[CMD.INSERT_SELECTION_INTERRUPT, () =&gt; w_leo.insertNode(U, U, true)],
</t>
<t tx="felix.20200718031424.15">[CMD.MARK, (p_node: LeoNode) =&gt; w_leo.changeMark(true, p_node, false)],
[CMD.MARK_SELECTION, () =&gt; w_leo.changeMark(true, U, false)],
[CMD.MARK_SELECTION_FO, () =&gt; w_leo.changeMark(true, U, true)],

[CMD.UNMARK, (p_node: LeoNode) =&gt; w_leo.changeMark(false, p_node, false)],
[CMD.UNMARK_SELECTION, () =&gt; w_leo.changeMark(false, U, false)],
[CMD.UNMARK_SELECTION_FO, () =&gt; w_leo.changeMark(false, U, true)],
</t>
<t tx="felix.20200718031424.16">[CMD.MOVE_DOWN, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_DOWN, p_node, REFRESH_TREE, false)],
[CMD.MOVE_DOWN_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_DOWN, U, REFRESH_TREE, false)],
[CMD.MOVE_DOWN_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_DOWN, U, REFRESH_TREE, true)],

[CMD.MOVE_LEFT, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_LEFT, p_node, REFRESH_TREE, false)],
[CMD.MOVE_LEFT_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_LEFT, U, REFRESH_TREE, false)],
[CMD.MOVE_LEFT_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_LEFT, U, REFRESH_TREE, true)],

[CMD.MOVE_RIGHT, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_RIGHT, p_node, REFRESH_TREE, false)],
[CMD.MOVE_RIGHT_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_RIGHT, U, REFRESH_TREE, false)],
[CMD.MOVE_RIGHT_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_RIGHT, U, REFRESH_TREE, true)],

[CMD.MOVE_UP, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_UP, p_node, REFRESH_TREE, false)],
[CMD.MOVE_UP_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_UP, U, REFRESH_TREE, false)],
[CMD.MOVE_UP_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.MOVE_PNODE_UP, U, REFRESH_TREE, true)],
</t>
<t tx="felix.20200718031424.17">[CMD.PAGE_UP, () =&gt; w_leo.nodeCommand(BRIDGE.PAGE_UP, U, REFRESH_BOTH, true)],
[CMD.PAGE_DOWN, () =&gt; w_leo.nodeCommand(BRIDGE.PAGE_DOWN, U, REFRESH_BOTH, true)],
</t>
<t tx="felix.20200718031424.18">[CMD.DEMOTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.DEMOTE_PNODE, p_node, REFRESH_TREE, false)],
[CMD.DEMOTE_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.DEMOTE_PNODE, U, REFRESH_TREE, false)],
[CMD.DEMOTE_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.DEMOTE_PNODE, U, REFRESH_TREE, true)],

[CMD.PROMOTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.PROMOTE_PNODE, p_node, REFRESH_TREE, false)],
[CMD.PROMOTE_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.PROMOTE_PNODE, U, REFRESH_TREE, false)],
[CMD.PROMOTE_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.PROMOTE_PNODE, U, REFRESH_TREE, true)],
</t>
<t tx="felix.20200718031424.19">[CMD.SORT_CHILDREN, () =&gt; w_leo.nodeCommand(BRIDGE.SORT_CHILDREN, U, REFRESH_TREE, false)],
[CMD.SORT_SIBLING, () =&gt; w_leo.nodeCommand(BRIDGE.SORT_SIBLINGS, U, REFRESH_TREE, false)],
[CMD.SORT_SIBLING_FO, () =&gt; w_leo.nodeCommand(BRIDGE.SORT_SIBLINGS, U, REFRESH_TREE, true)],
</t>
<t tx="felix.20200718031424.2">@language typescript
/**
 * * Called when extension is activated.
 * It creates the leoIntegration and the 'welcome/Settings' webview instances.
 */
export function activate(p_context: vscode.ExtensionContext) {

    // * Reset Extension context flags (used in 'when' clauses in package.json)
    utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, false); // Connected to a leobridge server?
    utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, false); // Having a Leo file opened on that server?

    const w_leoIntegExtension = vscode.extensions.getExtension(Constants.PUBLISHER + '.' + Constants.NAME)!;
    const w_leoIntegVersion = w_leoIntegExtension.packageJSON.version;
    const w_leo: LeoIntegration = new LeoIntegration(p_context);
    const w_leoSettingsWebview: LeoSettingsWebview = new LeoSettingsWebview(p_context, w_leo);
    const w_previousVersion = p_context.globalState.get&lt;string&gt;(Constants.VERSION_STATE_KEY);
    const w_start = process.hrtime(); // For calculating total startup time duration

    // Shortcut pointers for readability
    const U = undefined;
    const BRIDGE = Constants.LEOBRIDGE;
    const CMD = Constants.COMMANDS;
    const NO_REFRESH = RefreshType.NoRefresh;
    const REFRESH_TREE = RefreshType.RefreshTree;
    const REFRESH_BOTH = RefreshType.RefreshTreeAndBody;
    const showInfo = vscode.window.showInformationMessage;

    const w_commands: [string, (...args: any[]) =&gt; any][] = [

        // ! REMOVE TESTS ENTRIES FROM PACKAGE.JSON FOR MASTER BRANCH RELEASES !
        ["test", () =&gt; w_leo.test()], // Test function useful when debugging
        ["testFromOutline", () =&gt; w_leo.test(true)], // Test function useful when debugging.

        // Define entries for all commands
        [CMD.EXECUTE, () =&gt; w_leo.executeScript()],
        @others
    ];

    w_commands.map(function (p_command) {
        p_context.subscriptions.push(vscode.commands.registerCommand(...p_command));
    });

    showWelcomeIfNewer(w_leoIntegVersion, w_previousVersion).then(() =&gt; {
        w_leo.startNetworkServices(); // Start server and/or connect to it, as specified in settings
        p_context.globalState.update(Constants.VERSION_STATE_KEY, w_leoIntegVersion);
        console.log('leoInteg startup launched in ', getDurationMilliseconds(w_start), 'ms');
    });
}
</t>
<t tx="felix.20200718031424.20">[CMD.REDO, () =&gt; w_leo.nodeCommand(BRIDGE.REDO, U, REFRESH_BOTH, false)],
[CMD.REDO_FO, () =&gt; w_leo.nodeCommand(BRIDGE.REDO, U, REFRESH_BOTH, true)],

[CMD.UNDO, () =&gt; w_leo.nodeCommand(BRIDGE.UNDO, U, REFRESH_BOTH, false)],
[CMD.UNDO_FO, () =&gt; w_leo.nodeCommand(BRIDGE.UNDO, U, REFRESH_BOTH, true)],
</t>
<t tx="felix.20200718031424.21">[CMD.CONNECT, () =&gt; w_leo.connect()],
[CMD.START_SERVER, () =&gt; w_leo.startServer()],
</t>
<t tx="felix.20200718031424.22">[CMD.SELECT_NODE, (p_node: LeoNode) =&gt; w_leo.selectTreeNode(p_node, false, false)],
// Called by nodes in tree when selected
[CMD.OPEN_ASIDE, (p_node: LeoNode) =&gt; w_leo.selectTreeNode(p_node, false, true)],

[CMD.SHOW_OUTLINE, () =&gt; w_leo.showOutline(true)],
// Also focuses on outline

[CMD.SHOW_LOG, () =&gt; w_leo.showLogPane()],
[CMD.SHOW_BODY, () =&gt; w_leo.showBody(false)],
// Also focuses on body

[CMD.SHOW_WELCOME, () =&gt; w_leoSettingsWebview.openWebview()],
[CMD.SHOW_SETTINGS, () =&gt; w_leoSettingsWebview.openWebview()],
// Same as 'show welcome screen'

</t>
<t tx="felix.20200718031424.24">/**
 * * Called when extension is deactivated
 */
export function deactivate() {
    console.log('deactivate called for extension "leointeg"');
}

</t>
<t tx="felix.20200718031424.25">/**
 * * Show welcome screen if needed, based on last version executed
 * @param p_version Current version, as a string, from packageJSON.version
 * @param p_previousVersion Previous version, as a string, from context.globalState.get service
 * @returns a promise that triggers when command to show the welcome screen is finished, or immediately if not needed
 */
async function showWelcomeIfNewer(p_version: string, p_previousVersion: string | undefined): Promise&lt;unknown&gt; {
    let w_showWelcomeScreen: boolean = false;
    if (p_previousVersion === undefined) {
        console.log('leoInteg first-time install');
        w_showWelcomeScreen = true;
    } else {
        if (p_previousVersion !== p_version) {
            console.log(`leoInteg upgraded from v${p_previousVersion} to v${p_version}`);
        }
        const [w_major, w_minor] = p_version.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        const [w_prevMajor, w_prevMinor] = p_previousVersion.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        if (
            (w_major === w_prevMajor &amp;&amp; w_minor === w_prevMinor) ||
            // Don't notify on downgrades
            (w_major &lt; w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &lt; w_prevMinor))
        ) {
            w_showWelcomeScreen = false;
        } else if (w_major !== w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &gt; w_prevMinor)) {
            // Will show on major or minor upgrade (Formatted as 'Major.Minor.Revision' eg. 1.2.3)
            w_showWelcomeScreen = true;
        }
    }
    if (w_showWelcomeScreen) {
        return vscode.commands.executeCommand(Constants.COMMANDS.SHOW_WELCOME);
    } else {
        return Promise.resolve();
    }
}

</t>
<t tx="felix.20200718031424.26">/**
 * * Returns the milliseconds between a given starting process.hrtime tuple and the current call to process.hrtime
 * @param p_start starting process.hrtime to subtract from current immediate time
 * @returns number of milliseconds passed since the given start hrtime
 */
function getDurationMilliseconds(p_start: [number, number]): number {
    const [secs, nanosecs] = process.hrtime(p_start);
    return secs * 1000 + Math.floor(nanosecs / 1000000);
}
</t>
<t tx="felix.20200718031424.4">// TODO : @boltex More commands to implement #15, #23, #24
[CMD.CLONE_FIND_ALL, () =&gt; showInfo("TODO: cloneFindAll command")],
[CMD.CLONE_FIND_ALL_FLATTENED, () =&gt; showInfo("TODO: cloneFindAllFlattened command")],
[CMD.CLONE_FIND_MARKED, () =&gt; showInfo("TODO: cloneFindMarked command")],
[CMD.CLONE_FIND_FLATTENED_MARKED, () =&gt; showInfo("TODO: cloneFindFlattenedMarked command")],
[CMD.EXTRACT, () =&gt; showInfo("TODO: extract command")],
[CMD.EXTRACT_NAMES, () =&gt; showInfo("TODO: extractNames command")],
[CMD.COPY_MARKED, () =&gt; showInfo("TODO: copyMarked command")],
[CMD.DIFF_MARKED_NODES, () =&gt; showInfo("TODO: diffMarkedNodes command")],
[CMD.MARK_CHANGED_ITEMS, () =&gt; showInfo("TODO: markChangedItems command")],
[CMD.MARK_SUBHEADS, () =&gt; showInfo("TODO: markSubheads command")],
[CMD.UNMARK_ALL, () =&gt; showInfo("TODO: unmarkAll command")],
[CMD.CLONE_MARKED_NODES, () =&gt; showInfo("TODO: cloneMarkedNodes command")],
[CMD.DELETE_MARKED_NODES, () =&gt; showInfo("TODO: deleteMarkedNodes command")],
[CMD.MOVE_MARKED_NODES, () =&gt; showInfo("TODO: moveMarkedNode command")],
</t>
<t tx="felix.20200718031424.5">// Test for undeclared commands VERDICT IT WORKS!
[CMD.CLICK_BUTTON, (p_node: LeoButtonNode) =&gt; w_leo.clickButton(p_node)],

// Cannot be undeclared because its referenced in package.json
[CMD.REMOVE_BUTTON, (p_node: LeoButtonNode) =&gt; w_leo.removeButton(p_node)],
</t>
<t tx="felix.20200718031424.6">[CMD.CLOSE_FILE, () =&gt; w_leo.closeLeoFile()],
[CMD.NEW_FILE, () =&gt; w_leo.newLeoFile()],
[CMD.OPEN_FILE, () =&gt; w_leo.openLeoFile()],
[CMD.SAVE_AS_FILE, () =&gt; w_leo.saveAsLeoFile()],
[CMD.SAVE_FILE, () =&gt; w_leo.saveLeoFile()],
[CMD.SAVE_FILE_FO, () =&gt; w_leo.saveLeoFile(true)],
[CMD.SWITCH_FILE, () =&gt; w_leo.switchLeoFile()],

// Test for undeclared commands VERDICT IT WORKS!
[CMD.SET_OPENED_FILE, (p_index: number) =&gt; w_leo.selectOpenedLeoDocument(p_index)],

[CMD.REFRESH_FROM_DISK, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.REFRESH_FROM_DISK_PNODE, p_node, REFRESH_BOTH, false)],
[CMD.REFRESH_FROM_DISK_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.REFRESH_FROM_DISK_PNODE, U, REFRESH_BOTH, false)],
[CMD.REFRESH_FROM_DISK_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.REFRESH_FROM_DISK_PNODE, U, REFRESH_BOTH, true)],
</t>
<t tx="felix.20200718031424.7">[CMD.HEADLINE, (p_node: LeoNode) =&gt; w_leo.editHeadline(p_node, false)],
[CMD.HEADLINE_SELECTION, () =&gt; w_leo.editHeadline(U, false)],
[CMD.HEADLINE_SELECTION_FO, () =&gt; w_leo.editHeadline(U, true)],
</t>
<t tx="felix.20200718031424.8"></t>
<t tx="felix.20200718031424.9">// cut/copy/paste/delete given node.
[CMD.COPY, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.COPY_PNODE, p_node, NO_REFRESH, false)],
[CMD.CUT, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.CUT_PNODE, p_node, REFRESH_TREE, false)],
[CMD.DELETE, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.DELETE_PNODE, p_node, REFRESH_TREE, false)],
[CMD.PASTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.PASTE_PNODE, p_node, REFRESH_TREE, false)],
[CMD.PASTE_CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand(BRIDGE.PASTE_CLONE_PNODE, p_node, REFRESH_TREE, false)],

// cut/copy/paste/delete c.p..
[CMD.COPY_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.COPY_PNODE, U, NO_REFRESH, false)],
[CMD.CUT_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.CUT_PNODE, U, REFRESH_TREE, false)],
[CMD.CUT_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.CUT_PNODE, U, REFRESH_TREE, true)],
[CMD.DELETE_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.DELETE_PNODE, U, REFRESH_TREE, false)],
[CMD.DELETE_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.DELETE_PNODE, U, REFRESH_TREE, true)],
[CMD.PASTE_CLONE_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.PASTE_CLONE_PNODE, U, REFRESH_TREE, false)],
[CMD.PASTE_CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.PASTE_CLONE_PNODE, U, REFRESH_TREE, true)],
[CMD.PASTE_SELECTION, () =&gt; w_leo.nodeCommand(BRIDGE.PASTE_PNODE, U, REFRESH_TREE, false)],
[CMD.PASTE_SELECTION_FO, () =&gt; w_leo.nodeCommand(BRIDGE.PASTE_PNODE, U, REFRESH_TREE, true)],
</t>
<t tx="felix.20200718035737.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import {
    AskMessageItem, RefreshType, runAskYesNoDialogParameters,
    runWarnMessageDialogParameters, runInfoMessageDialogParameters,
    showSaveAsDialogParameters
} from "./types";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others

/*
    TODO : Should Reproduce those interactive controls that may be asked by Leo and redo a true UI bridge

def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    return self.simulateDialog("aboutLeoDialog", None)

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog", None)

def runAskOkDialog(self, c, title, message=None, text="Ok"):
    return self.simulateDialog("okDialog", "Ok")

def runAskOkCancelNumberDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
):
    return self.simulateDialog("numberDialog", -1)

def runAskOkCancelStringDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
    default="",
    wide=False,
):
    return self.simulateDialog("stringDialog", '')

def runCompareDialog(self, c):
    return self.simulateDialog("compareDialog", '')

def runOpenFileDialog(self, c, title, filetypes, defaultextension,
    multiple=False,
    startpath=None,
):
    return self.simulateDialog("openFileDialog", None)

def runSaveFileDialog(self, c, initialfile, title, filetypes, defaultextension):
    return self.simulateDialog("saveFileDialog", None)

def runAskYesNoDialog(self, c, title,
    message=None,
    yes_all=False,
    no_all=False,
):
    return self.simulateDialog("yesNoDialog", "no")

def runAskYesNoCancelDialog(self, c, title,
    message=None,
    yesMessage="Yes",
    noMessage="No",
    yesToAllMessage=None,
    defaultButton="Yes",
    cancelMessage=None,
):
    return self.simulateDialog("yesNoCancelDialog", "cancel")

def simulateDialog(self, key, defaultVal):
    return defaultVal

*/
</t>
<t tx="felix.20200718035737.2">/**
 * * Handles the functions called by Leo through leoBridge such as adding a log pane entry, runAskYesNoDialog for file changes, etc.
 * * Some config settings affect this behavior, such as defaultReloadIgnore and checkForChangeExternalFiles
 */
export class LeoAsync {

    private _askResult: string = "";

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20200718035737.3">/**
 * * Adds message string to leoInteg's log pane, used when leoBridge gets an async 'log' command
 */
public log(p_message: string): void {
    this._leoIntegration.addLogPaneEntry(p_message);
}

</t>
<t tx="felix.20200718035737.4">/**
 * * Equivalent to runSaveFileDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * @param p_saveAsArg
 */
public showSaveAsDialog(p_saveAsArg: showSaveAsDialogParameters): void {
    // TODO : Check if needed
    console.log('TODO: SHOW SAVE AS DIALOG!');
}

</t>
<t tx="felix.20200718035737.5">/**
 * * Equivalent to runAskYesNoDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * * Opens a modal dialog to return one of 'yes', 'yes-all', 'no' or 'no-all' to be sent back with the leoBridge 'ASK_RESULT' action
 * @param p_askArg an async package object {"ask": title, "message": message, "yes_all": yes_all, "no_all": no_all}
 */
public showAskModalDialog(p_askArg: runAskYesNoDialogParameters): void {
    this._askResult = "no"; // defaults to not doing anything, matches isCloseAffordance just to be safe
    // Note: "last line" could be eventually used in the message
    // const w_lastLine = p_askArg.message.substr(p_askArg.message.lastIndexOf("\n") + 1);
    const w_items: AskMessageItem[] = [
        {
            title: Constants.USER_MESSAGES.YES,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES,
            isCloseAffordance: false
        },
        {
            title: Constants.USER_MESSAGES.NO,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO,
            isCloseAffordance: true
        }
    ];
    if (p_askArg.yes_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.YES_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES_ALL,
            isCloseAffordance: false
        });
    }
    if (p_askArg.no_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.NO_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO_ALL,
            isCloseAffordance: false
        });
    }
    const w_askRefreshInfoMessage: Thenable&lt;AskMessageItem | undefined&gt; = vscode.window.showInformationMessage(
        p_askArg.message,
        { modal: true },
        ...w_items
    );
    w_askRefreshInfoMessage.then((p_result: AskMessageItem | undefined) =&gt; {
        if (p_result) {
            this._askResult = p_result.value;
        }
        const w_sendResultPromise = this._leoIntegration.sendAction(Constants.LEOBRIDGE.ASK_RESULT, '"' + this._askResult + '"'); // Quotes in string as a 'JSON parameter'
        if (this._askResult.includes(Constants.ASYNC_ASK_RETURN_CODES.YES)) {
            w_sendResultPromise.then(() =&gt; {
                // Might have answered 'yes/yesAll' and refreshed and changed the body text
                this._leoIntegration.launchRefresh(RefreshType.RefreshTreeAndBody, false); // TODO : #34 @boltex Deal with focus placement
            });
        }
    });
}

</t>
<t tx="felix.20200718035737.6">/**
 * * Equivalent to runAskOkDialog from Leo's qt_gui.py, used when leoBridge gets an async 'warn' command
 * @param p_waitArg an async package object {"warn": "", "message": ""}
 */
public showWarnModalMessage(p_waitArg: runWarnMessageDialogParameters): void {
    vscode.window.showInformationMessage(
        p_waitArg.message,
        { modal: true }
    ).then(() =&gt; {
        this._leoIntegration.sendAction(Constants.LEOBRIDGE.ASK_RESULT, Constants.ASYNC_ASK_RETURN_CODES.OK); // Quotes in string as a 'JSON parameter'
    });
}

</t>
<t tx="felix.20200718035737.7">/**
 * * Show non-blocking info message about detected file changes, used when leoBridge gets an async 'info' command
 * @param p_infoArg an async package object { "message": string; }
 */
public showChangesDetectedInfoMessage(p_infoArg: runInfoMessageDialogParameters): void {
    let w_message = Constants.USER_MESSAGES.CHANGES_DETECTED;
    switch (p_infoArg.message) {
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_REFRESHED:
            w_message += Constants.USER_MESSAGES.REFRESHED;
            this._leoIntegration.launchRefresh(RefreshType.RefreshTreeAndBody, false); // TODO : #34 @boltex Deal with focus placement
            break;
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_IGNORED:
            w_message += Constants.USER_MESSAGES.IGNORED;
            break;
        default:
            break;
    }
    vscode.window.showInformationMessage(w_message);
}
</t>
<t tx="felix.20200718040540.1">import * as vscode from "vscode";
import * as utils from "./utils";
import * as path from 'path';
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { BodyTimeInfo } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718040540.10">public stat(p_uri: vscode.Uri): vscode.FileStat | Thenable&lt;vscode.FileStat&gt; {
    // TODO : Fix extraneous stat(...) call(s)
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            // console.log('called stat on root');
            return { type: vscode.FileType.Directory, ctime: 0, mtime: 0, size: 0 };
        } else if (utils.leoUriToStr(p_uri) === this._lastGnx) {
            // If same as last checked, sending back time at absolute past
            return {
                type: vscode.FileType.File,
                ctime: 0,
                mtime: 0, // this._selectedBody.mtime, // IF this._selectedBody.mtime we get file changed on disk error!!
                size: this._lastGnxBodyLength
            };
        } else {
            const w_gnx = utils.leoUriToStr(p_uri);
            if (false &amp;&amp; this._selectedBody.gnx !== w_gnx &amp;&amp; this._renameBody.gnx !== w_gnx) {
                // ! TEST IF NEEDED !
                console.log('ERROR File not in list selected: ' + this._selectedBody.gnx +
                    " renamed: " + this._renameBody.gnx +
                    " stat asked on w_gnx: " + w_gnx);
                throw vscode.FileSystemError.FileNotFound();
            } else {
                return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BODY_LENGTH, '"' + w_gnx + '"')
                    .then((p_result) =&gt; {
                        let w_mtime: number = 0;
                        if (this._renameBody.gnx === w_gnx) {
                            w_mtime = this._renameBody.mtime;
                        } else {
                            w_mtime = this._selectedBody.mtime;
                        }
                        return Promise.resolve(
                            {
                                type: vscode.FileType.File,
                                ctime: 0,
                                mtime: w_mtime,
                                size: p_result.bodyLength ? p_result.bodyLength : 0
                            }
                        );
                    });
            }
        }
    } else {
        throw vscode.FileSystemError.FileNotFound(); // console.log("not ready");
    }
}

</t>
<t tx="felix.20200718040540.11">public readFile(p_uri: vscode.Uri): Thenable&lt;Uint8Array&gt; {
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            throw vscode.FileSystemError.FileIsADirectory();
        } else {
            const w_gnx = utils.leoUriToStr(p_uri);
            // if (!this._possibleGnxList.includes(w_gnx)) {
            if (this._selectedBody.gnx !== w_gnx &amp;&amp; this._renameBody.gnx !== w_gnx) {
                console.error("readFile: ERROR File not in list! readFile missing refreshes?");
                throw vscode.FileSystemError.FileNotFound();
            } else {
                return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BODY, '"' + w_gnx + '"')
                    .then((p_result) =&gt; {
                        if (p_result.bodyData) {
                            this._lastGnx = w_gnx;
                            this._lastBodyData = p_result.bodyData;
                            this._lastGnxBodyLength = p_result.bodyData.length;
                            return Promise.resolve(Buffer.from(p_result.bodyData));
                        } else if (p_result.bodyData === "") {
                            this._lastGnx = w_gnx;
                            this._lastGnxBodyLength = 0;
                            this._lastBodyData = "";
                            return Promise.resolve(Buffer.from(""));
                        } else {
                            if (this._lastGnx === w_gnx) {
                                // was last gnx of closed file about to be switched to new document selected
                                console.log('Passed in not found: ' + w_gnx);

                                return Promise.resolve(Buffer.from(this._lastBodyData));
                            }
                            console.error("ERROR =&gt; readFile of unknown GNX"); // is possibleGnxList updated correctly?
                            return Promise.resolve(Buffer.from(""));
                            //  throw vscode.FileSystemError.FileNotFound();
                        }
                    });
            }
        }
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20200718040540.12">public readDirectory(p_uri: vscode.Uri): Thenable&lt;[string, vscode.FileType][]&gt; {
    if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
        const w_directory: [string, vscode.FileType][] = [];
        w_directory.push([this._selectedBody.gnx, vscode.FileType.File]);
        return Promise.resolve(w_directory);
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20200718040540.13">public createDirectory(p_uri: vscode.Uri): void {
    console.warn('Called createDirectory with ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20200718040540.14">public writeFile(p_uri: vscode.Uri, p_content: Uint8Array, p_options: { create: boolean, overwrite: boolean }): void {
    this._leoIntegration.triggerBodySave(true);
    const w_gnx = utils.leoUriToStr(p_uri);
    const w_now = Date.now();
    if (this._selectedBody.gnx === w_gnx) {
        this._selectedBody.mtime = w_now;
    }
    if (this._renameBody.gnx === w_gnx) {
        this._renameBody.mtime = w_now;
    }
    this._fireSoon({ type: vscode.FileChangeType.Changed, uri: p_uri });
}

</t>
<t tx="felix.20200718040540.15">public rename(p_oldUri: vscode.Uri, p_newUri: vscode.Uri, p_options: { overwrite: boolean }): void {
    const w_gnx = utils.leoUriToStr(p_newUri);
    if (this._selectedBody.gnx === w_gnx) {
        this._selectedBody.mtime = Date.now();
    }
    if (this._renameBody.gnx === w_gnx) {
        this._renameBody.mtime = Date.now();
    }
    this._fireSoon(
        { type: vscode.FileChangeType.Deleted, uri: p_oldUri },
        { type: vscode.FileChangeType.Created, uri: p_newUri }
    );
}

</t>
<t tx="felix.20200718040540.16">public delete(uri: vscode.Uri): void {
    let w_dirname = uri.with({ path: path.posix.dirname(uri.path) }); // dirname is just a slash "/"
    this._fireSoon({ type: vscode.FileChangeType.Changed, uri: w_dirname }, { uri, type: vscode.FileChangeType.Deleted });
}

</t>
<t tx="felix.20200718040540.17">public copy(p_uri: vscode.Uri): void {
    console.warn('Called copy on ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

private _emitter = new vscode.EventEmitter&lt;vscode.FileChangeEvent[]&gt;();
private _bufferedEvents: vscode.FileChangeEvent[] = [];
private _fireSoonHandle?: NodeJS.Timer;

</t>
<t tx="felix.20200718040540.18">private _fireSoon(...p_events: vscode.FileChangeEvent[]): void {
    this._bufferedEvents.push(...p_events);
    if (this._fireSoonHandle) {
        clearTimeout(this._fireSoonHandle);
    }
    this._fireSoonHandle = setTimeout(() =&gt; {
        this._emitter.fire(this._bufferedEvents);
        this._bufferedEvents.length = 0; // clearing events array
    }, 5);
}
</t>
<t tx="felix.20200718040540.2">/**
 * * Body panes implementation as a file system using "leo" as a scheme identifier
 * Saving and renaming prevents flickering and prevents undos to 'traverse through' different gnx
 */
export class LeoBodyProvider implements vscode.FileSystemProvider {

    // * Simple structure to keep mtime of selected and renamed body virtual files
    private _selectedBody: BodyTimeInfo = { gnx: "", ctime: 0, mtime: 0 };
    private _renameBody: BodyTimeInfo = { gnx: "", ctime: 0, mtime: 0 };

    // * Last file read data with the readFile method
    private _lastGnx: string = ""; // gnx of last file read
    private _lastBodyData: string = ""; // body content of last file read
    private _lastGnxBodyLength: number = 0; // length of last file read

    // * List of currently opened body panes gnx (from 'watch' &amp; 'dispose' methods)
    private _openedBodiesGnx: string[] = [];

    // * List of all possible vNodes gnx in the currently opened leo file (since last refresh/tree operation)
    private _possibleGnxList: string[] = [];

    // * An event to signal that a resource has been changed
    // * It should fire for resources that are being [watched](#FileSystemProvider.watch) by clients of this provider
    private _onDidChangeFileEmitter = new vscode.EventEmitter&lt;vscode.FileChangeEvent[]&gt;();
    readonly onDidChangeFile: vscode.Event&lt;vscode.FileChangeEvent[]&gt; = this._onDidChangeFileEmitter.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718040540.3">/**
 * * Sets selected node body's modified time for this gnx virtual file
 * @param p_uri URI of file for which to set made-up modified time
 */
public setBodyTime(p_uri: vscode.Uri): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    this._selectedBody = {
        gnx: w_gnx,
        ctime: 0,
        mtime: (w_gnx === this._renameBody.gnx &amp;&amp; this._selectedBody.gnx === this._renameBody.gnx) ? this._renameBody.mtime : Date.now(),
    };
}

</t>
<t tx="felix.20200718040540.4">/**
 * * Sets renamed file modified time for this gnx, used for 'rename' hack to prevent text undos between gnx
 * @param p_uri URI of file for which to set made-up modified time
 */
public setRenameTime(p_gnx: string): void {
    this._renameBody = {
        gnx: p_gnx,
        ctime: 0,
        mtime: Date.now(),
    };
}

</t>
<t tx="felix.20200718040540.5">/**
 * * Refresh the body pane for a particular gnx by telling vscode that the file from the Leo file provider has changed
 * @param p_gnx Gnx of body associated with this virtual file, mostly Leo's selected node
 */
public fireRefreshFile(p_gnx: string): void {
    this._selectedBody = {
        gnx: p_gnx,
        ctime: 0,
        mtime: Date.now(),
    };
    this._onDidChangeFileEmitter.fire([{
        type: vscode.FileChangeType.Changed,
        uri: utils.strToLeoUri(p_gnx)
    } as vscode.FileChangeEvent]);
}

</t>
<t tx="felix.20200718040540.6">/**
 * * Refreshes the '_possibleGnxList' list of all unique gnx from Leo
 * @returns a promise that resolves to the fresh gnx string array
 */
public refreshPossibleGnxList(): Thenable&lt;string[]&gt; {
    // * Get updated list of possible gnx
    return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_ALL_GNX).then((p_result) =&gt; {
        if (p_result.allGnx) {
            this._possibleGnxList = p_result.allGnx;
        } else {
            this._possibleGnxList = [];
        }
        return Promise.resolve(this._possibleGnxList);
    });
}

</t>
<t tx="felix.20200718040540.7">/**
 * * Get list of bodies that should be closed: gnx from openedBodiesGnx that are not in possibleGnxList
 * @returns Promise that resolves in a string array
 */
public getExpiredGnxList(): Thenable&lt;string[]&gt; {
    return this.refreshPossibleGnxList()
        .then(p_possibleGnxList =&gt; {
            const w_gnxToClose: string[] = [];
            this._openedBodiesGnx.forEach(p_openedGnx =&gt; {
                if (!p_possibleGnxList.includes(p_openedGnx)) {
                    w_gnxToClose.push(p_openedGnx);
                }
            });
            this.fireDeleteExpiredGnx(w_gnxToClose);
            return Promise.resolve(w_gnxToClose);
        });
}

</t>
<t tx="felix.20200718040540.8">public watch(p_resource: vscode.Uri): vscode.Disposable {
    const w_gnx = utils.leoUriToStr(p_resource);
    if (!this._openedBodiesGnx.includes(w_gnx)) {
        this._openedBodiesGnx.push(w_gnx); // add gnx
    }
    return new vscode.Disposable(() =&gt; {
        const w_position = this._openedBodiesGnx.indexOf(w_gnx); // find and remove it
        if (w_position &gt; -1) {
            this._openedBodiesGnx.splice(w_position, 1);
        }
    });
}

</t>
<t tx="felix.20200718040540.9">public fireDeleteExpiredGnx(p_gnxList: string[]): void {
    p_gnxList.forEach(p_gnx =&gt; {
        const w_uri: vscode.Uri = utils.strToLeoUri(p_gnx);
        this._fireSoon({ uri: w_uri, type: vscode.FileChangeType.Deleted });
    });
}

</t>
<t tx="felix.20200718122313.1">def removeButton(self, p_package):
    '''Removes an entry from the buttonsDict by index string'''
    w_index = p_package['index']
    w_dict = self.commander.theScriptingController.buttonsDict
    w_key = None
    for i_key in w_dict:
        if(str(i_key) == w_index):
            w_key = i_key
    if w_key:
        del(w_dict[w_key])  # delete object member
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="felix.20200718122351.1">def runByName(self, p_package):
    pass

    print("runByName for string:")

    if "text" in p_package:
        print(p_package['text'])
    else:
        print("no string given")

    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="felix.20200718153505.1">import * as vscode from "vscode";
import * as WebSocket from 'ws';
import { Constants } from "./constants";
import { LeoBridgePackage, LeoAction } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoAsync } from "./leoAsync";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718153505.11">/**
 * * Process data that came from the Leo process
 * @param p_data given JSON data
 */
private _processAnswer(p_data: string): void {
    const w_parsedData = this._tryParseJSON(p_data);
    if (w_parsedData &amp;&amp; w_parsedData.id) {
        this._resolveBridgeReady(w_parsedData);
        this._callAction();
    } else if (w_parsedData &amp;&amp; w_parsedData.async) {
        // * Check for async messages such as log pane entries or other
        this._asyncAction(w_parsedData);
    } else {
        // unprocessed/unknown python output
        console.error("[leoBridge] Unprocessed or unknown JSON received: ", p_data);
    }
}

</t>
<t tx="felix.20200718153505.12">/**
 * * Spawn a websocket
 * @returns A promise for a LeoBridgePackage object containing only an 'id' member of 1 that will resolve when the 'leoBridge' is established
 */
public initLeoProcess(): Promise&lt;LeoBridgePackage&gt; {
    this._websocket = new WebSocket(Constants.TCPIP_DEFAULT_PROTOCOL +
        this._leoIntegration.config.connectionAddress +
        ":" + this._leoIntegration.config.connectionPort);
    // * Capture the python process output
    this._websocket.onmessage = (p_event) =&gt; {
        if (p_event.data) {
            this._processAnswer(p_event.data.toString());
        }
    };
    this._websocket.onerror = (p_event: WebSocket.ErrorEvent) =&gt; {
        console.error(`Websocket error: ${p_event.message}`);
    };
    this._websocket.onclose = (p_event: WebSocket.CloseEvent) =&gt; {
        // * Disconnected from server
        console.log(`Websocket closed, code: ${p_event.code}`);
        this._rejectAction(`Websocket closed, code: ${p_event.code}`);
        // TODO : Implement a better connection error handling
        if (this._leoIntegration.leoStates.leoBridgeReady) {
            this._leoIntegration.cancelConnect(`Websocket closed, code: ${p_event.code}`);
        }
    };
    // * Start first with 'preventCall' set to true: no need to call anything for the first 'ready'
    this._readyPromise = this.action("", "", { id: Constants.STARTING_PACKAGE_ID }, true);
    return this._readyPromise; // This promise will resolve when the started python process starts
}

</t>
<t tx="felix.20200718153505.13">/**
 * * Send into the python process input
 * @param p_data JSON Message string to be sent to leobridgeserver.py
 */
private _send(p_data: string): any {
    if (this._readyPromise) {
        this._readyPromise.then(() =&gt; { // using '.then' that was surely resolved already: to be buffered in case process isn't ready.
            if (this._websocket &amp;&amp; this._websocket.OPEN) {
                this._websocket.send(p_data); // p_message should be json
            }
        });
    }
}
</t>
<t tx="felix.20200718153505.2">/**
 * * Handles communication with the leobridgeserver.py python script via websockets
 */
export class LeoBridge {

    private _actionBusy: boolean = false; // A busy state meaning an action was started from the bottom but has yet to resolve

    private _leoBridgeSerialId: number = 0; // TODO : When doing error checking, see if this should be Constants.STARTING_PACKAGE_ID or 0 or 2... ?
    private _callStack: LeoAction[] = [];
    private _readyPromise: Promise&lt;LeoBridgePackage&gt; | undefined;

    // private _hasbin = require('hasbin'); // TODO : #10 @boltex See if this can help with anaconda/miniconda issues
    private _websocket: WebSocket | null = null;
    private _leoAsync: LeoAsync;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._leoAsync = new LeoAsync(_context, _leoIntegration);
    }

    @others
}
</t>
<t tx="felix.20200718153505.3">/**
 * * Places an action on top of a stack, to be resolved from the bottom
 * @param p_action Command string to be performed by Leo via leobridgeserver.py
 * @param p_jsonParam Optional JSON parameter for the specified action
 * @param p_deferredPayload Used to build this._readyPromise that resolves itself at startup
 * @param p_preventCall Flag for special action used to build this._readyPromise that resolves itself at startup
 * @returns a Promise that will contain the JSON package answered back by leobridgeserver.py
 */
public action(p_action: string, p_jsonParam = "null", p_deferredPayload?: LeoBridgePackage, p_preventCall?: boolean): Promise&lt;LeoBridgePackage&gt; {
    return new Promise((resolve, reject) =&gt; {
        const w_action: LeoAction = {
            parameter: this._buildActionParameter(p_action, p_jsonParam),
            deferredPayload: p_deferredPayload ? p_deferredPayload : undefined,
            resolveFn: resolve,
            rejectFn: reject
        };

        this._callStack.push(w_action);
        if (!p_preventCall) {
            this._callAction();
        }
    });
}

</t>
<t tx="felix.20200718153505.4">/**
 * * Actions invoked by Leo that can be called asynchronously at any time
 * @param w_parsedData that contains an 'async' string member, that was parsed from a _websocket.onmessage package
 */
private _asyncAction(w_parsedData: any): void {
    if (w_parsedData &amp;&amp; w_parsedData.async &amp;&amp; (typeof w_parsedData.async === "string")) {
        switch (w_parsedData.async) {
            case Constants.ASYNC_ACTIONS.ASYNC_LOG: {
                this._leoAsync.log(w_parsedData.log);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_ASK: {
                this._leoAsync.showAskModalDialog(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_WARN: {
                this._leoAsync.showWarnModalMessage(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_INFO: {
                this._leoAsync.showChangesDetectedInfoMessage(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_INTERVAL: {
                console.log("interval ", w_parsedData); // 'ping' interval for debugging
                break;
            }
            default: {
                console.error("[leoIntegration] Unknown async action ", w_parsedData);
                break;
            }
        }
    } else {
        console.error("[leoIntegration] Unknown async command from leoBridge");
    }
}

</t>
<t tx="felix.20200718153505.5">/**
 * * Build JSON string for action parameter to the leoBridge
 * @param p_action Action string to be invoked as command by Leo in the leobridgeserver.py script
 * @param p_jsonParam Optional JSON string to be added as a 'param' to the action sent to Leo
 */
private _buildActionParameter(p_action: string, p_jsonParam?: string): string {
    return "{\"id\":" + (++this._leoBridgeSerialId) + // no quotes, serial id is a number, pre incremented
        ", \"action\": \"" + p_action +  // action is string so surround with quotes
        "\", \"param\":" + p_jsonParam +  // param is already json, no need for added quotes
        "}";
}

</t>
<t tx="felix.20200718153505.6">/**
 * * Resolves promises with the answers from an action that was finished
 * @param p_object Parsed data that was given as the answer by the Leo command that finished
 */
private _resolveBridgeReady(p_object: string) {
    let w_bottomAction = this._callStack.shift();
    if (w_bottomAction) {
        if (w_bottomAction.deferredPayload) {
            // Used when the action already has a return value ready but is also waiting for python's side
            w_bottomAction.resolveFn(w_bottomAction.deferredPayload); // given back 'as is'
        } else {
            w_bottomAction.resolveFn(p_object);
        }
        this._actionBusy = false;
    } else {
        console.error("[leoBridge] Error stack empty");
    }
}

</t>
<t tx="felix.20200718153505.7">/**
 * * Rejects an action from the bottom of the stack
 * @param p_reason Given rejection 'reason'
 */
private _rejectAction(p_reason: string): void {
    const w_bottomAction = this._callStack.shift();
    if (w_bottomAction) {
        w_bottomAction.rejectFn(p_reason);
    }
}

</t>
<t tx="felix.20200718153505.8">/**
 * * Sends an action from the bottom of the stack
 */
private _callAction(): void {
    if (this._callStack.length &amp;&amp; !this._actionBusy) {
        this._actionBusy = true; // launch / resolve bottom one
        const w_action = this._callStack[0];
        this._send(w_action.parameter + "\n");
    }
}

</t>
<t tx="felix.20200718153505.9">/**
 * * JSON.parse encased in a Try/Catch block
 * @param p_jsonStr The JSON string to be parsed
 * @returns The resulting object or 'false' if unsuccessful
 */
private _tryParseJSON(p_jsonStr: string): boolean | any {
    try {
        var w_object = JSON.parse(p_jsonStr);
        // JSON.parse(null) returns null, and typeof null === "object", null is falsy, so this suffices:
        if (w_object &amp;&amp; typeof w_object === "object") {
            return w_object;
        }
    }
    catch (e) {
        console.error('[leoBridge] JSON was invalid: ' + p_jsonStr);
    }
    return false;
}

</t>
<t tx="felix.20200718155251.1">/**
 * * Busy state of the leoBridge's command stack
 */
public isBusy(): boolean {
    return this._actionBusy || !!this._callStack.length;
}

</t>
<t tx="felix.20200718162303.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoButton, Icon } from "./types";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718162303.2">/**
 * * Leo @buttons tree view node item implementation, for usage in a TreeDataProvider.
 */
export class LeoButtonNode extends vscode.TreeItem {

    // Context string that is checked in package.json with 'when' clauses
    public contextValue: string;

    private _isAdd: boolean;

    constructor(
        public button: LeoButton,
        private _leoIntegration: LeoIntegration
    ) {
        super(button.name);
        // Setup this instance (just differentiate 'script-button' for now)
        this.command = {
            command: Constants.COMMANDS.CLICK_BUTTON,
            title: '',
            arguments: [this]
        };
        this._isAdd = (this.button.index === "nullButtonWidget 1" &amp;&amp; this.button.name === "script-button");
        this.contextValue = "leoButtonNode";
    }

    @others
}
</t>
<t tx="felix.20200718162435.1">public get iconPath(): Icon {
    return this._leoIntegration.buttonIcons[this._isAdd ? 1 : 0];
}

</t>
<t tx="felix.20200718162442.1">public get id(): string {
    // Add prefix and suffix salt to index prevent accidental duplicates
    return "p" + this.button.index + "s" + this.button.name;
}

</t>
<t tx="felix.20200718162452.1">public get tooltip(): string {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON_TOOLTIP;
    } else {
        return this.button.name;
    }
}

</t>
<t tx="felix.20200718162459.1">public get description(): string | boolean {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON;
    } else {
        return false;
    }
}
</t>
<t tx="felix.20200718164130.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoButtonNode } from "./leoButtonNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoButton } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718164130.2">/**
 * * '@buttons' shown as a list with this TreeDataProvider implementation
 */
export class LeoButtonsProvider implements vscode.TreeDataProvider&lt;LeoButtonNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoButtonNode | undefined&gt; = new vscode.EventEmitter&lt;LeoButtonNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoButtonNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718164130.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718164130.4">public getTreeItem(element: LeoButtonNode): Thenable&lt;LeoButtonNode&gt; | LeoButtonNode {
    return element;
}

</t>
<t tx="felix.20200718164130.5">public getChildren(element?: LeoButtonNode): Thenable&lt;LeoButtonNode[]&gt; {

    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

        // call action to get get list, and convert to LeoButtonNode(s) array
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BUTTONS).then(p_package =&gt; {
            if (p_package &amp;&amp; p_package) {
                const w_list: LeoButtonNode[] = [];
                const w_buttons: LeoButton[] = p_package.buttons!;
                if (w_buttons &amp;&amp; w_buttons.length) {
                    w_buttons.forEach((i_button: LeoButton) =&gt; {
                        w_list.push(new LeoButtonNode(i_button, this._leoIntegration));
                    });
                }
                return Promise.resolve(w_list);
            } else {
                return Promise.resolve([]);
            }
        });
    } else {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
}

</t>
<t tx="felix.20200718164130.6">public getParent(element: LeoButtonNode): ProviderResult&lt;LeoButtonNode&gt; | null {
    return null; // A list, as such, entries are always child of root, so return null
}

</t>
<t tx="felix.20200718164509.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoDocument, Icon } from "./types";
import * as utils from "./utils";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718164509.2">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoDocumentNode extends vscode.TreeItem {

    // Context string is checked in package.json with 'when' clauses
    public contextValue: string;

    constructor(
        public documentEntry: LeoDocument,
        private _leoIntegration: LeoIntegration
    ) {
        super(documentEntry.name);
        // Setup this instance
        const w_isNamed: boolean = !!this.documentEntry.name;
        this.label = w_isNamed ? utils.getFileFromPath(this.documentEntry.name) : Constants.UNTITLED_FILE_NAME;
        this.tooltip = w_isNamed ? this.documentEntry.name : Constants.UNTITLED_FILE_NAME;
        this.command = {
            command: Constants.COMMANDS.SET_OPENED_FILE,
            title: '',
            arguments: [this.documentEntry.index]
        };
        // If this was created as a selected node, make sure it's selected as we may have opened/closed document
        if (this.documentEntry.selected) {
            this._leoIntegration.setDocumentSelection(this);
            this.contextValue = w_isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_UNTITLED;
        } else {
            this.contextValue = w_isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_UNTITLED;
        }
    }

    @others
}
</t>
<t tx="felix.20200718164635.1">public get iconPath(): Icon {
    return this._leoIntegration.documentIcons[this.documentEntry.changed ? 1 : 0];
}

</t>
<t tx="felix.20200718164638.1">public get id(): string {
    // Add prefix and suffix salt to numeric index prevent accidental duplicates
    return "p" + this.documentEntry.index + "s" + this.documentEntry.name;
}
</t>
<t tx="felix.20200718165108.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoDocumentNode } from "./leoDocumentNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoDocument } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718165108.2">/**
 * * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
export class LeoDocumentsProvider implements vscode.TreeDataProvider&lt;LeoDocumentNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoDocumentNode | undefined&gt; = new vscode.EventEmitter&lt;LeoDocumentNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoDocumentNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718165108.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718165108.4">public getTreeItem(element: LeoDocumentNode): Thenable&lt;LeoDocumentNode&gt; | LeoDocumentNode {
    return element;
}

</t>
<t tx="felix.20200718165108.5">public getChildren(element?: LeoDocumentNode): Thenable&lt;LeoDocumentNode[]&gt; {

    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

        // call action to get get list, and convert to LeoDocumentNode(s) array
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_OPENED_FILES).then(p_package =&gt; {
            if (p_package &amp;&amp; p_package) {
                const w_list: LeoDocumentNode[] = [];
                const w_files: LeoDocument[] = p_package.openedFiles!.files;

                let w_index: number = 0;

                if (w_files &amp;&amp; w_files.length) {
                    w_files.forEach((i_file: LeoDocument) =&gt; {
                        w_list.push(new LeoDocumentNode(i_file, this._leoIntegration));
                        w_index++;
                    });
                }

                return Promise.resolve(w_list);
            } else {
                return Promise.resolve([]);
            }
        });
    } else {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
}

</t>
<t tx="felix.20200718165108.6">public getParent(element: LeoDocumentNode): ProviderResult&lt;LeoDocumentNode&gt; | null {
    return null; // A list, as such, entries are always child of root, so return null
}
</t>
<t tx="felix.20200718165721.1"></t>
<t tx="felix.20200718170429.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import * as path from "path"; // TODO : Use this library to have reliable support for window-vs-linux file-paths

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718170429.2">/**
 * * Handles opening of file browser when choosing which Leo file to open
 */
export class LeoFilesBrowser {

    private _fileBrowserActive: boolean = false;

    constructor(private _context: vscode.ExtensionContext) { }

    @others
}
</t>
<t tx="felix.20200718170429.3">/**
 * * Find a folder to propose when opening the browse-for-leo-file chooser
 * @returns An Uri for path to a folder for initial opening
 */
private _getBestOpenFolderUri(): vscode.Uri {
    let w_openedFileEnvUri: vscode.Uri | boolean = false;
    let w_activeUri: vscode.Uri | undefined = undefined;

    if (vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders[0]) {
        w_activeUri = vscode.workspace.workspaceFolders[0].uri;
    }

    if (w_activeUri) {
        const w_defaultFolder = vscode.workspace.getWorkspaceFolder(w_activeUri);
        if (w_defaultFolder) {
            w_openedFileEnvUri = w_defaultFolder.uri; // Set as current opened document-path's folder
        }
    }
    if (!w_openedFileEnvUri) {
        w_openedFileEnvUri = vscode.Uri.file("~"); // TODO : set as home folder properly, this doesn't work
        // ! EXAMPLE WITH os : const homedir = require('os').homedir();
    }
    return w_openedFileEnvUri;
}

</t>
<t tx="felix.20200718170429.4">/**
 * * Open a file browser and let the user choose a Leo file or cancel the operation
 * @param p_saveAsFlag Optional, a flag that will ask for a 'save' path+filename.
 * @returns a promise resolving to a chosen path string, or rejected with an empty string if cancelled
 */
public getLeoFileUrl(p_saveAsFlag?: boolean): Promise&lt;string&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve("");
    }
    this._fileBrowserActive = true;
    return new Promise((resolve, reject) =&gt; {
        const w_filters: { [name: string]: string[] } = {};
        w_filters[Constants.FILE_OPEN_FILTER_MESSAGE] = [Constants.FILE_EXTENSION];

        if (p_saveAsFlag) {
            // Choose file
            vscode.window.showSaveDialog({
                saveLabel: "Save Leo File",
                defaultUri: this._getBestOpenFolderUri(),
                filters: { 'Leo File': ['leo'] }
            })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // single string
                        resolve(p_chosenLeoFile.fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                    } else {
                        reject("");
                    }
                });
        } else {
            vscode.window
                .showOpenDialog({
                    canSelectMany: false,
                    defaultUri: this._getBestOpenFolderUri(),
                    filters: w_filters
                })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // array instead of single string
                        resolve(p_chosenLeoFile[0].fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                    } else {
                        reject("");
                    }
                });
        }
    });
}
</t>
<t tx="felix.20200718170712.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { ArchivedPosition, Icon } from "./types"; // * TO HELP DEBUG

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718170712.2">/**
 * * Implementation of tree nodes for usage in a TreeDataProvider
 */
export class LeoNode extends vscode.TreeItem {

    public cursorSelection: any; // TODO : #39 @boltex Keep body's cursor and selection position from vscode to get it back
    public contextValue: string; // * Context string is checked in package.json with 'when' clauses

    public isRoot: boolean = false; // * for hoist/dehoist context flags purposes

    constructor(
        public label: string, // Node headline
        public gnx: string,
        public collapsibleState: vscode.TreeItemCollapsibleState, // Computed in receiver/creator
        public apJson: string, // Key for leo/python side of things
        public childIndex: number, // For debugging purposes
        public cloned: boolean,
        public dirty: boolean,
        public marked: boolean,
        public atFile: boolean,
        public hasBody: boolean,
        public u: any,
        private _leoIntegration: LeoIntegration,
        private _id: string
    ) {
        super(label, collapsibleState);
        this.contextValue = this._getNodeContextValue();
        this.command = {
            command: Constants.COMMANDS.SELECT_NODE,
            title: '',
            arguments: [this]
        };
    }

    // * TO HELP DEBUG

    // get description(): string {
    //     // * some smaller grayed-out text accompanying the main label
    //     const w_ap: ArchivedPosition = JSON.parse(this.apJson);
    //     return "child:" + w_ap.childIndex + " lvl:" + w_ap.level + " gnx:" + w_ap.gnx;
    // }

    // get description(): string {
    //     // * some smaller grayed-out text accompanying the main label
    //     return "id:" + this.id;
    // }

    @others
}
</t>
<t tx="felix.20200718170712.3">/**
 * * Sets this node properties (dirty, marked, etc.) by copying from a given node.
 * * This is needed by the outline provider when refreshing a single node.
 * @param p_node Node to copy properties from.
 * @returns Node itself with the new properties applied
 */
public copyProperties(p_node: LeoNode): LeoNode {
    this.label = p_node.label;
    this.gnx = p_node.gnx;
    this.collapsibleState = p_node.collapsibleState;
    this.apJson = p_node.apJson;
    this.childIndex = p_node.childIndex;
    this.cloned = p_node.cloned;
    this.dirty = p_node.dirty;
    this.marked = p_node.marked;
    this.atFile = p_node.atFile;
    this.hasBody = p_node.hasBody;
    this.isRoot = p_node.isRoot;
    this.contextValue = this._getNodeContextValue();
    return this;
}

</t>
<t tx="felix.20200718170712.4">/**
 * * Set this node as the root for hoist/dehoist context flags purposes
 */
public setRoot(): void {
    this.isRoot = true;
    this._leoIntegration.leoStates.leoRoot = true; // Set this special global 'selected node' flag
    this.contextValue = this._getNodeContextValue();
}

</t>
<t tx="felix.20200718170712.5">private _getNodeContextValue(): string {
    // Start it with 'leoNodeMarked' or 'leoNodeUnmarked'
    let w_contextValue = Constants.CONTEXT_FLAGS.NODE_UNMARKED;
    if (this.marked) {
        w_contextValue = Constants.CONTEXT_FLAGS.NODE_MARKED;
    }
    // then append 'leoNodeAtFile' to existing if needed
    if (this.atFile) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ATFILE;
    }
    // then append 'leoNodeCloned' to existing if needed
    if (this.cloned) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_CLONED;
    }
    // and finally, check for 'root' too
    if (this.isRoot) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ROOT;
    } else {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_NOT_ROOT;
    }
    return w_contextValue;
}

</t>
<t tx="felix.20200718170712.6">public getCursorSelection(): any {
    return this.cursorSelection;
}

</t>
<t tx="felix.20200718170712.7">public setCursorSelection(p_cursorSelection: any): void {
    this.cursorSelection = p_cursorSelection;
}

</t>
<t tx="felix.20200718171837.1">public get description(): string {
    // * some smaller grayed-out text accompanying the main label
    if (this.u) {
        return "\u{1F4CE} (" + Object.keys(this.u).length + ")";
    } else {
        return ""; // Falsy will not be shown
    }
}

</t>
<t tx="felix.20200718171849.1">public get tooltip(): string {
    if (this.u) {
        //  "\ntotal keys is :" + Object.keys(this.u).length
        return this.label + "\n" +
            JSON.stringify(this.u, undefined, 2);
    } else {
        return this.label; // * Whole headline as tooltip
    }
}
</t>
<t tx="felix.20200718171854.1">// Optional id for the tree item that has to be unique across tree.
// The id is used to preserve the selection and expansion state of the tree item.
// If not provided, an id is generated using the tree item's label.
// Note that when labels change, ids will change and that selection and expansion state cannot be kept stable anymore.
public get id(): string { return this._id; }

</t>
<t tx="felix.20200718171904.1">public get iconPath(): Icon {
    // From Leo's leoNodes.py computeIcon function
    // 1=has Body, 2=marked, 4=cloned, 8=dirty
    let w_dirty: boolean = this._leoIntegration.config.invertNodeContrast ? !this.dirty : this.dirty;
    let w_icon: number =
        (+w_dirty &lt;&lt; 3) |
        (+this.cloned &lt;&lt; 2) |
        (+this.marked &lt;&lt; 1) |
        +this.hasBody;
    return this._leoIntegration.nodeIcons[w_icon];
}

</t>
<t tx="felix.20200718180428.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoBridgePackage } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718180428.2">/**
 * * Leo outline implemented as a tree view with this TreeDataProvider implementation
 */
export class LeoOutlineProvider implements vscode.TreeDataProvider&lt;LeoNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoNode | undefined&gt; = this._onDidChangeTreeData.event;

    // used in leoOutline.ts to check if getTreeItem(element: LeoNode) should fetch from Leo, or return as-is
    private _refreshSingleNodeFlag: boolean = false;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718180428.3">/**
 * * Refresh a single node
 * @param p_node The outline's node itself as a LeoNode instance
 */
public refreshTreeNode(p_node: LeoNode): void {
    // We want to do a real refresh, not just giving back the same we've got as input in getTreeItem
    this._refreshSingleNodeFlag = true;
    this._onDidChangeTreeData.fire(p_node);
}

</t>
<t tx="felix.20200718180428.4">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718180428.5">public getTreeItem(element: LeoNode): Thenable&lt;LeoNode&gt; | LeoNode {
    if (this._refreshSingleNodeFlag) {
        this._refreshSingleNodeFlag = false;
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_PNODE, element.apJson)
            .then((p_package: LeoBridgePackage) =&gt; {
                const w_node = this._leoIntegration.apToLeoNode(p_package.node!, true, element);
                return element.copyProperties(w_node);
            });
    } else {
        return element;
    }
}

</t>
<t tx="felix.20200718180428.6">public getChildren(element?: LeoNode): Thenable&lt;LeoNode[]&gt; {
    if (!this._leoIntegration.leoStates.fileOpenedReady) {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
    if (element) {
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_CHILDREN, element.apJson)
            .then((p_package: LeoBridgePackage) =&gt; {
                return this._leoIntegration.arrayToLeoNodesArray(p_package.nodes!);
            });
    } else {
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_CHILDREN, "null")
            .then((p_package: LeoBridgePackage) =&gt; {
                const w_nodes = this._leoIntegration.arrayToLeoNodesArray(p_package.nodes!);
                if (w_nodes &amp;&amp; w_nodes.length === 1) {
                    w_nodes[0].setRoot();
                }
                return w_nodes;
            });
    }
}

</t>
<t tx="felix.20200718180428.7">public getParent(element: LeoNode): ProviderResult&lt;LeoNode&gt; | null {
    // * This method should be implemented in order to access reveal API.
    // ! But it should NOT have to be called because we will only try to 'select' already revealed nodes

    // ! Might be called if nodes are revealed while in vscode's refresh process
    // ! Parent asked for this way will go up till root and effectively refresh whole tree.
    // console.log('ERROR! GET PARENT CALLED! on: ', element.label);

    if (this._leoIntegration.leoStates.fileOpenedReady) {
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_PARENT, element ? element.apJson : "null")
            .then((p_package: LeoBridgePackage) =&gt; {
                if (p_package.node === null) {
                    return null;
                } else {
                    return this._leoIntegration.apToLeoNode(p_package.node!);
                }
            });
    } else {
        return null; // Default gives no parent
    }
}
</t>
<t tx="felix.20200718185403.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718185403.2">/**
 * * Statusbar indicator controller object
 */
export class LeoStatusBar {

    private _leoStatusBarItem: vscode.StatusBarItem;
    private _statusbarNormalColor = new vscode.ThemeColor(Constants.GUI.THEME_STATUSBAR);  // "statusBar.foreground"
    private _updateStatusBarTimeout: NodeJS.Timeout | undefined;
    private _string: string = ""; // Use this string with indicator, using this will replace the default from config

    // * Represents having focus on a leo tree, body or document panel to enable leo keybindings
    private _statusBarFlag: boolean = false;
    set statusBarFlag(p_value: boolean) {
        this._statusBarFlag = p_value;
    }
    get statusBarFlag(): boolean {
        return this._statusBarFlag;
    }

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._leoStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
        this._leoStatusBarItem.color = this._leoIntegration.config.statusBarColor;

        // this._leoStatusBarItem.command = Constants.COMMANDS.SWITCH_FILE;
        this._leoStatusBarItem.command = "leointeg.test"; // just call test function for now to help debugging
        this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR + this._leoIntegration.config.statusBarString;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;
        _context.subscriptions.push(this._leoStatusBarItem);
        this._leoStatusBarItem.hide();
    }

    @others
}
</t>
<t tx="felix.20200718185403.3">/**
 * * Makes the statusbar indicator visible
 */
public show(): void {
    this._leoStatusBarItem.show();
}

</t>
<t tx="felix.20200718185403.4">/**
 * * Hides the statusbar indicator
 */
public hide(): void {
    this._leoStatusBarItem.hide();
}

</t>
<t tx="felix.20200718185403.5">/**
 * * Sets string to replace default from config &amp; refresh it
 */
public setString(p_string: string): void {
    this._string = p_string;
    this._updateLeoObjectIndicator();
}

</t>
<t tx="felix.20200718185403.6">/**
 * * Updates the status bar visual indicator visual indicator with optional debouncing delay
 * @param p_state True/False flag for On or Off status
 * @param p_debounceDelay Optional, in milliseconds
 */
public update(p_state: boolean, p_debounceDelay?: number, p_forced?: boolean): void {
    if (p_forced || (p_state !== this.statusBarFlag)) {
        this.statusBarFlag = p_state;
        if (p_debounceDelay) {
            this._updateLeoObjectIndicatorDebounced(p_debounceDelay);
        } else {
            this._updateLeoObjectIndicator();
        }
    }
}

</t>
<t tx="felix.20200718185403.7">/**
 * * Updates the status bar visual indicator flag in a debounced manner
 * @param p_delay number of milliseconds
 */
private _updateLeoObjectIndicatorDebounced(p_delay: number): void {
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }
    this._updateStatusBarTimeout = setTimeout(() =&gt; {
        this._updateLeoObjectIndicator();
    }, p_delay);
}

</t>
<t tx="felix.20200718185403.8">/**
 * * Updates the status bar visual indicator flag directly
 */
private _updateLeoObjectIndicator(): void {
    // Can be called directly, so clear timer if any
    if (this._updateStatusBarTimeout) { 
        clearTimeout(this._updateStatusBarTimeout);
    }
    
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_SELECTED, !!this.statusBarFlag);
    
    this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR +
        (this._string ? this._string : this._leoIntegration.config.statusBarString) + " " +
        (this._leoIntegration.leoStates.leoOpenedFileName ? utils.getFileFromPath(this._leoIntegration.leoStates.leoOpenedFileName) : Constants.UNTITLED_FILE_NAME);
        
    // Also check in constructor for statusBar properties (the createStatusBarItem call itself)
    if (this.statusBarFlag &amp;&amp; this._leoIntegration.leoStates.fileOpenedReady) { 
        this._leoStatusBarItem.color = "#" + this._leoIntegration.config.statusBarColor;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;
    } else {
        this._leoStatusBarItem.color = this._statusbarNormalColor;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_OFF;
    }
}
</t>
<t tx="felix.20200718191946.1">import * as os from 'os';
import * as child from 'child_process';
import * as path from "path"; // TODO : Use this library to have reliable support for window-vs-linux file-paths
import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from './leoIntegration';

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718191946.2">/**
 * * Provides simple automatic leo bridge server startup
 */
export class ServerService {
    // TODO : See #10 @boltex Problem starting the leo-bridge server automatically with anaconda/miniconda on windows
    // See https://github.com/yhirose/vscode-filtertext/blob/master/src/extension.ts#L196

    private _platform: string;
    private _isWin32: boolean;

    /**
     * * Leo Bridge Server Process
     */
    private _serverProcess: child.ChildProcess | undefined;

    private _resolvePromise: ((value?: unknown) =&gt; void) | undefined;
    private _rejectPromise: ((reason?: any) =&gt; void) | undefined;

    private _isStarted: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._platform = os.platform();
        this._isWin32 = this._platform === "win32";
    }

    @others
}
</t>
<t tx="felix.20200718191946.3">/**
 * * Splits the received data into lines and parses output to detect server start event
 * * Otherwise just outputs lines to the terminal Output
 * @param p_data Data object (not pure string)
 */
private _gotTerminalData(p_data: string): void {
    p_data.toString().split("\n").forEach(p_line =&gt; {
        p_line = p_line.trim();
        if (p_line) { // * std out process line by line: json shouldn't have line breaks
            if (p_line.startsWith(Constants.SERVER_STARTED_TOKEN)) {
                if (this._resolvePromise &amp;&amp; !this._isStarted) {
                    this._isStarted = true;
                    this._resolvePromise(p_line); // * Server confirmed started
                }
            }
            this._leoIntegration.addTerminalPaneEntry(p_line); // Output message anyways
        }
    });
}

</t>
<t tx="felix.20200718191946.4">/**
 * * Get command from settings or best command for the current OS
 * @param p_leoPythonCommand String command to start python on this computer
 * @returns A promise that resolves when the server is started, or that is rejected in case of problem while starting
 */
public startServer(p_leoPythonCommand: string): Promise&lt;any&gt; {
    let w_pythonPath = "";
    this._leoIntegration.showTerminalPane();
    const w_serverScriptPath = this._context.extensionPath + Constants.SERVER_PATH;
    if (p_leoPythonCommand &amp;&amp; p_leoPythonCommand.length) {
        // Start by running command (see executeCommand for multiple useful snippets)
        w_pythonPath = p_leoPythonCommand; // Set path
        this._leoIntegration.addTerminalPaneEntry('Starting server with command: ' + p_leoPythonCommand);
    } else {
        w_pythonPath = Constants.DEFAULT_PYTHON;
        if (this._isWin32) {
            w_pythonPath = Constants.WIN32_PYTHON;
        }
        this._leoIntegration.addTerminalPaneEntry('Starting server with command : ' +
            w_pythonPath + ((this._isWin32 &amp;&amp; w_pythonPath === "py") ? " -3 " : "") +
            " " + w_serverScriptPath);
    }

    const w_serverStartPromise = new Promise((p_resolve, w_reject) =&gt; {
        // * Spawn a python child process for a leoBridge server
        this._resolvePromise = p_resolve;
        this._rejectPromise = w_reject;
    });

    let w_args: string[] = []; //  "\"" + w_serverScriptPath + "\"" // For on windows ??

    if (this._isWin32 &amp;&amp; w_pythonPath === "py") {
        w_args.push("-3");
    }
    w_args.push(w_serverScriptPath);
    this._serverProcess = child.spawn(w_pythonPath, w_args);

    if (this._serverProcess &amp;&amp; this._serverProcess.stdout) {
        // * Capture the python process output
        this._serverProcess.stdout.on("data", (p_data: string) =&gt; {
            this._gotTerminalData(p_data);
        });
    } else {
        console.error("No stdout");
    }
    if (this._serverProcess &amp;&amp; this._serverProcess.stderr) {
        // * Capture other python process outputs
        this._serverProcess.stderr.on("data", (p_data: string) =&gt; {
            console.log(`stderr: ${p_data}`);
            this._isStarted = false;
            utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);
            this._serverProcess = undefined;
            if (this._rejectPromise) {
                this._rejectPromise(`stderr: ${p_data}`);
            }
        });
    } else {
        console.error("No stderr");
    }
    if (this._serverProcess) {
        this._serverProcess!.on("close", (p_code: any) =&gt; {
            console.log(`leoBridge exited with code ${p_code}`);
            this._isStarted = false;
            utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);
            this._serverProcess = undefined;
            if (this._rejectPromise) {
                this._rejectPromise(`leoBridge exited with code ${p_code}`);
            }
        });
    }

    return w_serverStartPromise;
}
</t>
<t tx="felix.20200718192351.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { LeoPackageStates } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718192411.1">/**
 * * Holds state flags used to restrict command and icon availability
 */
export class LeoStates {

    @others
}
</t>
<t tx="felix.20200718192411.2">public setSelectedNodeFlags(p_node: LeoNode): void {
    this.leoRoot = false; // * RESET the root flag : It is set by vscode instead right after getting list of children for root of outline
    this.leoMarked = p_node.marked;
    this.leoCloned = p_node.cloned;
    this.leoDirty = p_node.dirty;
    this.leoEmpty = !p_node.hasBody;
    this.leoChild = !(p_node.collapsibleState === vscode.TreeItemCollapsibleState.None);
    this.leoAtFile = p_node.atFile;
}

</t>
<t tx="felix.20200718192411.3">public setLeoStateFlags(p_states: LeoPackageStates): void {
    this.leoChanged = p_states.changed;
    this.leoCanUndo = p_states.canUndo;
    this.leoCanRedo = p_states.canRedo;
    this.leoCanDemote = p_states.canDemote;
    this.leoCanPromote = p_states.canPromote;
    this.leoCanDehoist = p_states.canDehoist;
}
</t>
<t tx="felix.20200718193219.1">// * Connected to a Leo bridge server
private _leoBridgeReady: boolean = false; // Used along with executeCommand 'setContext' with Constants.CONTEXT_FLAGS.BRIDGE_READY
get leoBridgeReady(): boolean {
    return this._leoBridgeReady;
}
set leoBridgeReady(p_value: boolean) {
    this._leoBridgeReady = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, p_value);
}

</t>
<t tx="felix.20200718193222.1">// * A Leo file is opened
private _fileOpenedReady: boolean = false; // Used along with executeCommand 'setContext' with Constants.CONTEXT_FLAGS.TREE_OPENED
get fileOpenedReady(): boolean {
    return this._fileOpenedReady;
}
set fileOpenedReady(p_value: boolean) {
    this._fileOpenedReady = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, p_value);
    this._leoIntegration.setTreeViewTitle(
        p_value ? Constants.GUI.TREEVIEW_TITLE : Constants.GUI.TREEVIEW_TITLE_INTEGRATION
    );
}

</t>
<t tx="felix.20200718193226.1">// * Currently opened Leo file path and name, empty string if new unsaved file.
private _leoOpenedFileName: string = "";
get leoOpenedFileName(): string {
    return this._leoOpenedFileName;
}
set leoOpenedFileName(p_name: string) {
    if (p_name &amp;&amp; p_name.length) {
        this._leoOpenedFileName = p_name;
        utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, true);
    } else {
        this._leoOpenedFileName = "";
        utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, false);
    }
}

</t>
<t tx="felix.20200718193230.1">// * 'states' flags for currently opened tree view
private _leoChanged: boolean = false;
get leoChanged(): boolean {
    return this._leoChanged;
}
set leoChanged(p_value: boolean) {
    this._leoChanged = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CHANGED, p_value);
}

</t>
<t tx="felix.20200718193233.1">private _leoCanUndo: boolean = false;
get leoCanUndo(): boolean {
    return this._leoCanUndo;
}
set leoCanUndo(p_value: boolean) {
    this._leoCanUndo = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_UNDO, p_value);
}

</t>
<t tx="felix.20200718193235.1">private _leoCanRedo: boolean = false;
get leoCanRedo(): boolean {
    return this._leoCanRedo;
}
set leoCanRedo(p_value: boolean) {
    this._leoCanRedo = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_REDO, p_value);
}

</t>
<t tx="felix.20200718193238.1">private _leoCanDemote: boolean = false;
get leoCanDemote(): boolean {
    return this._leoCanDemote;
}
set leoCanDemote(p_value: boolean) {
    this._leoCanDemote = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEMOTE, p_value);
}

</t>
<t tx="felix.20200718193241.1">private _leoCanPromote: boolean = false;
get leoCanPromote(): boolean {
    return this._leoCanPromote;
}
set leoCanPromote(p_value: boolean) {
    this._leoCanPromote = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_PROMOTE, p_value);
}

</t>
<t tx="felix.20200718193244.1">private _leoCanDehoist: boolean = false;
get leoCanDehoist(): boolean {
    return this._leoCanDehoist;
}
set leoCanDehoist(p_value: boolean) {
    this._leoCanDehoist = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEHOIST, p_value);
}

</t>
<t tx="felix.20200718193338.1">// * 'states' flags about current selection, for visibility and commands availability
private _leoMarked: boolean = false;
get leoMarked(): boolean {
    return this._leoMarked;
}
set leoMarked(p_value: boolean) {
    this._leoMarked = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_value);
}

</t>
<t tx="felix.20200718193341.1">private _leoCloned: boolean = false;
get leoCloned(): boolean {
    return this._leoCloned;
}
set leoCloned(p_value: boolean) {
    this._leoCloned = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CLONE, p_value);
}

</t>
<t tx="felix.20200718193343.1">private _leoDirty: boolean = false;
get leoDirty(): boolean {
    return this._leoDirty;
}
set leoDirty(p_value: boolean) {
    this._leoDirty = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_DIRTY, p_value);
}

</t>
<t tx="felix.20200718193348.1">private _leoEmpty: boolean = false;
get leoEmpty(): boolean {
    return this._leoEmpty;
}
set leoEmpty(p_value: boolean) {
    this._leoEmpty = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_EMPTY, p_value);
}

</t>
<t tx="felix.20200718193350.1">private _leoChild: boolean = false;
get leoChild(): boolean {
    return this._leoChild;
}
set leoChild(p_value: boolean) {
    this._leoChild = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CHILD, p_value);
}

</t>
<t tx="felix.20200718193353.1">private _leoAtFile: boolean = false;
get leoAtFile(): boolean {
    return this._leoAtFile;
}
set leoAtFile(p_value: boolean) {
    this._leoAtFile = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_ATFILE, p_value);
}

</t>
<t tx="felix.20200718193403.1">// * Special is-root 'state' flag about current selection, for visibility and commands availability
private _leoRoot: boolean = false;
get leoRoot(): boolean {
    return this._leoRoot;
}
set leoRoot(p_value: boolean) {
    this._leoRoot = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_ROOT, p_value);
}

</t>
<t tx="felix.20200718193500.1">constructor(
    private _context: vscode.ExtensionContext,
    private _leoIntegration: LeoIntegration
) { }

</t>
<t tx="felix.20200718193719.1"></t>
<t tx="felix.20200718193731.1"></t>
<t tx="felix.20200718194857.1">import * as vscode from "vscode";
import { LeoNode } from "./leoNode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718194857.10">/**
 * * Main JSON information package format used between leointeg and Leo
 */
export interface LeoBridgePackage {
    id: number; // TODO : Could be used for error checking
    // * Each of those top level member is an answer from a Constants.LEOBRIDGE command
    allGnx?: string[];
    bodyLength?: number;
    bodyData?: string;
    node?: ArchivedPosition;
    nodes?: ArchivedPosition[];
    states?: LeoPackageStates;
    closed?: {
        total: number;
        filename?: string;
        node?: ArchivedPosition;
    },
    opened?: {
        total: number;
        filename: string;
        node: ArchivedPosition;
    },
    setOpened?: {
        total: number;
        filename: string;
        node: ArchivedPosition
    },
    openedFiles?: {
        index: number;
        files: LeoDocument[]
    }
    buttons?: LeoButton[]
    commands?: string[]
}

</t>
<t tx="felix.20200718194857.11">/**
 * * Leo document structure used in the 'Opened Leo Documents' tree view provider sent back by the server
 */
export interface LeoDocument {
    name: string;
    index: number;
    changed: boolean;
    selected: boolean;
}

</t>
<t tx="felix.20200718194857.12">/**
 * * Leo '@button' structure used in the '@buttons' tree view provider sent back by the server
 */
export interface LeoButton {
    name: string;
    index: string; // STRING KEY
}

</t>
<t tx="felix.20200718194857.13">/**
 * * Icon path names used in leoNodes for rendering in treeview
 */
export interface Icon {
    light: string;
    dark: string;
}

</t>
<t tx="felix.20200718194857.14">/**
 * * LeoBody virtual file time information object
 */
export interface BodyTimeInfo {
    gnx: string;
    ctime: number;
    mtime: number;
}

</t>
<t tx="felix.20200718194857.15">/**
 * * Parameter structure used in the 'runSaveFileDialog' equivalent when asking user input
 */
export interface showSaveAsDialogParameters {
    // See TODO in leoAsync.ts
    "initialFile": string;
    "title": string;
    "message": string;
    "filetypes": string[];
    "defaultExtension": string;
}

</t>
<t tx="felix.20200718194857.16">/**
 * * Parameter structure used in the 'runAskYesNoDialog' equivalent when asking user input
 */
export interface runAskYesNoDialogParameters {
    "ask": string;
    "message": string;
    "yes_all": boolean;
    "no_all": boolean;
}

</t>
<t tx="felix.20200718194857.17">/**
 * * Parameter structure used in the 'runAskOkDialog' equivalent when showing a warning
 */
export interface runWarnMessageDialogParameters {
    "warn": string;
    "message": string;
}

</t>
<t tx="felix.20200718194857.18">/**
 * * Parameter structure for non-blocking info message about detected file changes
 */
export interface runInfoMessageDialogParameters {
    "message": string;
}

</t>
<t tx="felix.20200718194857.19">/**
 * * Used in showAskModalDialog to get answer from user interaction
 */
export interface AskMessageItem extends vscode.MessageItem {
    value: string;
}

</t>
<t tx="felix.20200718194857.2">/**
 * * Types of the various JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
export interface ConfigMembers {
    checkForChangeExternalFiles: string;
    defaultReloadIgnore: string;
    leoTreeBrowse: boolean;
    treeKeepFocus: boolean;
    treeKeepFocusWhenAside: boolean;
    statusBarString: string;
    statusBarColor: string;
    treeInExplorer: boolean;
    showOpenAside: boolean;
    showEditOnNodes: boolean;
    showArrowsOnNodes: boolean;
    showAddOnNodes: boolean;
    showMarkOnNodes: boolean;
    showCloneOnNodes: boolean;
    showCopyOnNodes: boolean;
    invertNodeContrast: boolean;
    leoPythonCommand: string;
    startServerAutomatically: boolean;
    connectToServerAutomatically: boolean;
    connectionAddress: string;
    connectionPort: number;
}

</t>
<t tx="felix.20200718194857.20">/**
 * * Used in switch Leo document to get answer from user interaction
 */
export interface ChooseDocumentItem extends vscode.QuickPickItem {
    value: number;
}
</t>
<t tx="felix.20200718194857.3">/**
 * * When refreshing the outline and getting to Leo's selected node
 */
export const enum RevealType {
    NoReveal = 0, // In apToLeoNode conversion, If if the global revealType is "NoReveal" and its the selected node, re-use the old id
    Reveal,
    RevealSelect,
    RevealSelectFocus
}

</t>
<t tx="felix.20200718194857.4">/**
 * * User command's refresh-type for when coming back from executing the command
 */
export const enum RefreshType {
    NoRefresh = 0, // only for 'copy-node' so far
    RefreshTree,   // Refresh tree and show body pane if not already opened, but no need to refresh it
    RefreshTreeAndBody // undo, redo, execute and others can also modify the current body, so refresh the filesystem gnx too
}

</t>
<t tx="felix.20200718194857.5">/**
 * * Command parameter for when 'stacking' front end commands
 */
export interface UserCommand {
    action: string;
    node?: LeoNode | undefined;  // We can START a stack with a targeted command
    providedHeadline?: string | undefined;
    refreshType: RefreshType;
    fromOutline: boolean;
}

</t>
<t tx="felix.20200718194857.6">/**
 * * Actions to be performed by Leo, pushed and resolved as a stack
 */
export interface LeoAction {
    parameter: string; // to pass along with action to python's side
    deferredPayload?: any | undefined; // Used when the action already has a return value ready but is also waiting for python's side
    resolveFn: (result: any) =&gt; void; // call that with an answer from python's (or other) side
    rejectFn: (reason: any) =&gt; void; // call if problem is encountered
}

</t>
<t tx="felix.20200718194857.7">/**
 * * Simple 'string log entry' package format
 */
export interface LeoLogEntry {
    log: string;
}

</t>
<t tx="felix.20200718194857.8">/**
 * * ArchivedPosition format package from Leo's leoflexx.py
 */
export interface ArchivedPosition {
    hasBody: boolean;       // bool(p.b),
    hasChildren: boolean;   // p.hasChildren()
    childIndex: number;     // p._childIndex
    cloned: boolean;        // p.isCloned()
    dirty: boolean;         // p.isDirty()
    expanded: boolean;      // p.isExpanded()
    gnx: string;            // p.v.gnx
    level: number;          // p.level()
    headline: string;       // p.h
    marked: boolean;        // p.isMarked()
    atFile: boolean         // p.isAnyAtFileNode():
    selected: boolean;      // p == commander.p
    u?: any;               // User Attributes
    stack: {
        gnx: string;        // stack_v.gnx
        childIndex: number; // stack_childIndex
        headline: string;   // stack_v.h
    }[];                    // for (stack_v, stack_childIndex) in p.stack]
}

</t>
<t tx="felix.20200718194857.9">/**
 * * Items in the package object gotten back from 'getStates'
 */
export interface LeoPackageStates {
    changed: boolean;
    canUndo: boolean;
    canRedo: boolean;
    canDemote: boolean;
    canPromote: boolean;
    canDehoist: boolean;
}

</t>
<t tx="felix.20200718195558.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { Icon } from "./types";
import { LeoNode } from "./leoNode";

// String and other types/structures helper functions, along with common vscode API calls

@language typescript
@tabwidth -4
@others

</t>
<t tx="felix.20200718195558.10">/**
 * * Builds a 'Leo Scheme' vscode.Uri from a gnx (or strings like 'LEO BODY' or empty strings to decorate breadcrumbs)
 * @param p_str leo node gnx strings are used to build Uri
 * @returns A vscode 'Uri' object
 */
export function strToLeoUri(p_str: string): vscode.Uri {
    return vscode.Uri.parse(Constants.URI_SCHEME_HEADER + p_str);
}

</t>
<t tx="felix.20200718195558.11">/**
 * * Gets the gnx, (or another string like 'LEO BODY' or other), from a vscode.Uri object
 * @param p_uri Source uri to extract from
 * @returns The string source that was used to build this Uri
 */
export function leoUriToStr(p_uri: vscode.Uri): string {
    // TODO : Use length of a constant or something other than 'fsPath'
    // For now, just remove the '/' (or backslash on Windows) before the path string
    return p_uri.fsPath.substr(1);
}

</t>
<t tx="felix.20200718195558.12">/**
 * * Sets a vscode context variable with the 'vscode.commands.executeCommand' and 'setContext' method
 * @param p_key Key string name such as constants 'bridgeReady' or 'treeOpened', etc.
 * @param p_value Value to be assigned to the p_key 'key'
 * @returns A Thenable that was returned by the executeCommand call to set the context
 */
export function setContext(p_key: string, p_value: any): Thenable&lt;unknown&gt; {
    return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.SET_CONTEXT, p_key, p_value);
}
</t>
<t tx="felix.20200718195558.2">/**
 * * Build a string for representing a number that's 2 digits wide, padding with a zero if needed
 * @param p_number Between 0 and 99
 * @returns a 2 digit wide string representation of the number, left padded with zeros as needed.
 */
export function padNumber2(p_number: number): string {
    return ("0" + p_number).slice(-2);
}

</t>
<t tx="felix.20200718195558.3">/**
 * * Build all possible strings for node icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array of the 16 vscode node icons used in this vscode expansion
 */
export function buildNodeIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return Array(16).fill("").map((p_val, p_index) =&gt; {
        return {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT)
        };
    });
}

</t>
<t tx="felix.20200718195558.4">/**
 * * Build all possible strings for documents icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildDocumentIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_DOCUMENT),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_DOCUMENT)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_DOCUMENT_DIRTY),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_DOCUMENT_DIRTY)
        }
    ];
}

</t>
<t tx="felix.20200718195558.5">/**
 * * Build all possible strings for buttons icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildButtonsIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON_ADD),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON_ADD)
        }
    ];
}

</t>
<t tx="felix.20200718195558.6">/**
 * * Builds and returns a JSON string with 'node' and 'text' members
 * @param p_nodeJson Targeted tree node in the proper JSON format
 * @param p_text Desired text sent along with node in the parameters of the action to be 'called'
 * @returns JSON string suitable for being a parameter of a leoBridge action
 */
export function buildNodeAndTextJson(p_nodeJson: string, p_text: string): string {
    return "{\"node\":" + p_nodeJson +
        ", \"text\": " + JSON.stringify(p_text) +
        "}";
}

</t>
<t tx="felix.20200718195558.7">/**
 * * Extracts the file name from a full path, such as "foo.bar" from "/abc/def/foo.bar"
 * @param p_path Full path such as "/var/drop/foo/boo/moo.js" or "C:\Documents and Settings\img\recycled log.jpg"
 * @returns file name string such as "moo.js" or "recycled log.jpg""
 */
export function getFileFromPath(p_path: string): string {
    return p_path.replace(/^.*[\\\/]/, '');
}

</t>
<t tx="felix.20200718195558.8">/**
 * * Checks if a node would become dirty if it were to now have body content at all
 * @param p_node LeoNode from vscode's outline
 * @param p_newHasBody Flag to signify presence of body content, to be compared with its current state
 * @returns True if it would change the icon with actual body content, false otherwise
 */
export function isIconChangedByEdit(p_node: LeoNode, p_newHasBody: boolean): boolean {
    if (!p_node.dirty || (p_node.hasBody === !p_newHasBody)) {
        return true;
    }
    return false;
}

</t>
<t tx="felix.20200718195558.9">/**
 * * Checks if a string is formatted as a valid rrggbb color code.
 * @param p_hexString hexadecimal 6 digits string, without leading '0x'
 * @returns True if the string is a valid representation of an hexadecimal 6 digit number
 */
export function isHexColor(p_hexString: string): boolean {
    return typeof p_hexString === 'string'
        &amp;&amp; p_hexString.length === 6
        &amp;&amp; !isNaN(Number('0x' + p_hexString));
}

</t>
</tnodes>
</leo_file>
