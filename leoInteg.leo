<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20200722190504.1"><vh>Startup</vh>
<v t="ekr.20200724052304.1"><vh>@button backup</vh></v>
<v t="ekr.20200808100711.1"><vh>@settings</vh>
<v t="ekr.20200808100717.1"><vh>@string target-language = plain</vh></v>
</v>
<v t="ekr.20200722125546.1"><vh>script: Print all command names</vh></v>
<v t="ekr.20200815113508.1"><vh>script: Find empty nodes that have no children</vh></v>
</v>
<v t="felix.20200718220811.1"><vh>Documentation</vh>
<v t="felix.20200718220818.1"><vh>@clean README.md</vh>
<v t="felix.20200718221645.1"><vh>Requirements</vh></v>
<v t="felix.20200718222035.1"><vh>Features</vh></v>
<v t="felix.20200718222043.1"><vh>Keybindings</vh></v>
<v t="felix.20200718222048.1"><vh>Derive External Files</vh></v>
<v t="felix.20200718222053.1"><vh>Automate Synchronization</vh></v>
<v t="felix.20200718222058.1"><vh>Status Bar Indicator</vh></v>
<v t="felix.20200718222102.1"><vh>Extension Settings</vh></v>
<v t="felix.20210829192609.1"><vh>Server Settings</vh></v>
<v t="felix.20200718222108.1"><vh>Issues</vh></v>
<v t="felix.20200718222113.1"><vh>How it works</vh></v>
<v t="felix.20200718222118.1"><vh>Acknowledgments</vh></v>
</v>
<v t="felix.20200718220833.1"><vh>@clean CHANGELOG.md</vh>
<v t="felix.20220216005511.1"><vh>1.0.6</vh></v>
<v t="felix.20211210001626.1"><vh>1.0.5</vh></v>
<v t="felix.20211018004333.1"><vh>1.0.4</vh></v>
<v t="felix.20211007215423.1"><vh>1.0.3</vh></v>
<v t="felix.20210928231455.1"><vh>1.0.2</vh></v>
<v t="felix.20210919194446.1"><vh>1.0.1</vh></v>
<v t="felix.20210923233342.1"><vh>1.0.0</vh></v>
<v t="felix.20210919194259.1"><vh>0.1.20</vh></v>
<v t="felix.20210901215735.1"><vh>0.1.19</vh></v>
<v t="felix.20210916004954.1"><vh>0.1.18</vh></v>
<v t="felix.20210816230003.1"><vh>0.1.17</vh></v>
<v t="felix.20210725153617.1"><vh>0.1.16</vh></v>
<v t="felix.20210718163005.1"><vh>0.1.15</vh></v>
<v t="felix.20210612000127.1"><vh>0.1.14</vh></v>
<v t="felix.20210509210502.1"><vh>0.1.13</vh></v>
<v t="felix.20200718222417.1"><vh>0.1.12</vh></v>
<v t="felix.20200718222419.1"><vh>0.1.11</vh></v>
<v t="felix.20200718222422.1"><vh>0.1.10</vh></v>
<v t="felix.20200718222425.1"><vh>0.1.9</vh></v>
<v t="felix.20200718222427.1"><vh>0.1.8</vh></v>
<v t="felix.20200718222429.1"><vh>0.1.7</vh></v>
<v t="felix.20200718222433.1"><vh>0.1.6</vh></v>
<v t="felix.20200718222435.1"><vh>0.1.5</vh></v>
<v t="felix.20200718222437.1"><vh>0.1.4</vh></v>
<v t="felix.20200718222439.1"><vh>0.1.3</vh></v>
<v t="felix.20200718222440.1"><vh>0.1.2</vh></v>
<v t="felix.20200718222442.1"><vh>0.1.1</vh></v>
<v t="felix.20200718222445.1"><vh>0.0.1</vh></v>
</v>
<v t="felix.20200718220833.2"><vh>@clean CONTRIBUTING.md</vh>
<v t="felix.20200718222731.1"><vh>Introduction</vh></v>
<v t="felix.20200718222739.1"><vh>Development requirements</vh></v>
<v t="felix.20200718222741.1"><vh>Getting the source</vh></v>
<v t="felix.20200718222745.1"><vh>Choosing a debug profile</vh></v>
<v t="felix.20200718222748.1"><vh>Starting the extension</vh></v>
<v t="felix.20200718222754.1"><vh>The python server script</vh></v>
<v t="felix.20200718222757.1"><vh>Issues</vh></v>
</v>
</v>
<v t="felix.20210829223822.1"><vh>Archives</vh>
<v t="felix.20191126232434.2"><vh>@@file leobridgeserver.py</vh>
<v t="felix.20191128002414.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="felix.20191128002417.1"><vh>&lt;&lt; constants &gt;&gt;</vh></v>
<v t="felix.20200302204251.1"><vh>class IdleTimeManager</vh>
<v t="felix.20200302204251.2"><vh>itm.add_callback</vh></v>
<v t="felix.20200302204251.3"><vh>itm.on_idle</vh></v>
<v t="felix.20200302204251.4"><vh>itm.start</vh></v>
</v>
<v t="felix.20200302205810.1"><vh>class ExternalFilesController</vh>
<v t="felix.20200302205810.2"><vh>efc.ctor</vh></v>
<v t="felix.20200302205810.7"><vh>efc.on_idle</vh></v>
<v t="felix.20200302205810.8"><vh>efc.idle_check_commander</vh></v>
<v t="felix.20200302205810.9"><vh>efc.idle_check_at_file_node</vh></v>
<v t="felix.20200304221925.1"><vh>efc.integResult</vh></v>
<v t="felix.20200302205810.21"><vh>efc.utilities</vh>
<v t="felix.20200302205810.22"><vh>efc.ask</vh></v>
<v t="felix.20200302205810.23"><vh>efc.checksum</vh></v>
<v t="felix.20200302205810.25"><vh>efc.get_mtime</vh></v>
<v t="felix.20200302205810.26"><vh>efc.get_time</vh></v>
<v t="felix.20200302205810.27"><vh>efc.has_changed</vh></v>
<v t="felix.20200302205810.28"><vh>efc.is_enabled</vh></v>
<v t="felix.20200302205810.29"><vh>efc.join</vh></v>
<v t="felix.20200302205810.30"><vh>efc.set_time</vh></v>
<v t="felix.20200302205810.31"><vh>efc.warn</vh></v>
</v>
<v t="felix.20200308145948.1"><vh>other called methods</vh>
<v t="felix.20200308150856.1"><vh>open_with</vh></v>
<v t="felix.20200308150848.1"><vh>check_overwrite</vh></v>
<v t="felix.20200308150821.1"><vh>shut_down</vh></v>
<v t="felix.20200308150842.1"><vh>destroy_frame</vh></v>
</v>
</v>
<v t="felix.20200928174406.1"><vh>class IntegTextWrapper</vh>
<v t="felix.20200928174406.2"><vh>stw.ctor</vh></v>
<v t="felix.20200928174406.3"><vh>stw.Clipboard</vh></v>
<v t="felix.20200928174406.4"><vh>stw.Do-nothings</vh></v>
<v t="felix.20200928174406.5"><vh>stw.Text</vh>
<v t="felix.20200928174406.6"><vh>stw.appendText</vh></v>
<v t="felix.20200928174406.7"><vh>stw.delete</vh></v>
<v t="felix.20200928174406.8"><vh>stw.deleteTextSelection</vh></v>
<v t="felix.20200928174406.9"><vh>stw.get</vh></v>
<v t="felix.20200928174406.10"><vh>stw.getAllText</vh></v>
<v t="felix.20200928174406.11"><vh>stw.getInsertPoint</vh></v>
<v t="felix.20200928174406.12"><vh>stw.getSelectedText</vh></v>
<v t="felix.20200928174406.13"><vh>stw.getSelectionRange</vh></v>
<v t="felix.20201028223533.1"><vh>stw.getXScrollPosition</vh></v>
<v t="felix.20201102223052.1"><vh>stw.getYScrollPosition</vh></v>
<v t="felix.20200928174406.14"><vh>stw.hasSelection</vh></v>
<v t="felix.20200928174406.15"><vh>stw.insert</vh></v>
<v t="felix.20200928174406.16"><vh>stw.selectAllText</vh></v>
<v t="felix.20200928174406.17"><vh>stw.setAllText</vh></v>
<v t="felix.20200928174406.18"><vh>stw.setInsertPoint</vh></v>
<v t="felix.20201028223434.1"><vh>stw.setXScrollPosition</vh></v>
<v t="felix.20201102223046.1"><vh>stw.setYScrollPosition</vh></v>
<v t="felix.20200928174406.19"><vh>stw.setSelectionRange</vh></v>
<v t="felix.20200928174406.20"><vh>stw.toPythonIndex</vh></v>
<v t="felix.20200928174406.21"><vh>stw.toPythonIndexRowCol</vh></v>
</v>
</v>
<v t="felix.20191126232434.4"><vh>class LeoBridgeIntegController</vh>
<v t="felix.20191126232434.5"><vh>__init__</vh></v>
<v t="felix.20200303214235.1"><vh>_asyncIdleLoop</vh></v>
<v t="felix.20200626012709.1"><vh>_returnNo</vh></v>
<v t="felix.20200626030820.1"><vh>_returnYes</vh></v>
<v t="felix.20200927213534.1"><vh>_getScript</vh></v>
<v t="felix.20200303214255.1"><vh>_idleTime</vh></v>
<v t="felix.20200623201853.1"><vh>_getTotalOpened</vh></v>
<v t="felix.20200623215904.1"><vh>_getFirstOpenedCommander</vh></v>
<v t="felix.20210528000603.1"><vh>_show_find_success</vh></v>
<v t="felix.20200304224909.1"><vh>sendAsyncOutput</vh></v>
<v t="felix.20200304220844.1"><vh>set_ask_result</vh></v>
<v t="felix.20200312231358.1"><vh>set_config</vh></v>
<v t="felix.20200219224515.1"><vh>logSignon</vh></v>
<v t="felix.20200924224017.1"><vh>JSON Output Functions</vh>
<v t="felix.20200924211032.1"><vh>setActionId</vh></v>
<v t="felix.20200924211034.1"><vh>asyncOutput</vh></v>
<v t="felix.20200924211037.1"><vh>sendLeoBridgePackage</vh></v>
<v t="felix.20200924211041.1"><vh>_outputError</vh></v>
<v t="felix.20200924211048.1"><vh>_outputBodyData</vh></v>
<v t="felix.20200927224639.1"><vh>_outputSelectionData</vh></v>
<v t="felix.20200924211051.1"><vh>_outputPNode</vh></v>
<v t="felix.20200924211054.1"><vh>_outputPNodes</vh></v>
</v>
<v t="felix.20200219222712.1"><vh>es</vh></v>
<v t="felix.20200211202929.1"><vh>initConnection</vh></v>
<v t="felix.20200924205439.1"><vh>_get_commander_method</vh></v>
<v t="felix.20200924205503.1"><vh>leoCommand</vh></v>
<v t="felix.20200924223845.1"><vh>Leo Documents</vh>
<v t="felix.20200622230608.1"><vh>get_all_open_commanders</vh></v>
<v t="felix.20210523154200.1"><vh>get_ui_states</vh></v>
<v t="felix.20200624172552.1"><vh>set_opened_file</vh></v>
<v t="felix.20191126232434.13"><vh>open_file</vh></v>
<v t="felix.20200924205915.1"><vh>open_files</vh></v>
<v t="felix.20191126232434.14"><vh>close_file</vh></v>
<v t="felix.20200216160305.1"><vh>save_file</vh></v>
<v t="felix.20210602203830.1"><vh>import_any_file</vh></v>
</v>
<v t="felix.20210523154320.1"><vh>Search</vh>
<v t="felix.20210523154326.1"><vh>get_search_settings</vh></v>
<v t="felix.20210523154352.1"><vh>set_search_settings</vh></v>
<v t="felix.20210601005209.1"><vh>find_all</vh></v>
<v t="felix.20210527225925.1"><vh>find_next</vh></v>
<v t="felix.20210527225930.1"><vh>find_previous</vh></v>
<v t="felix.20210531011702.1"><vh>replace</vh></v>
<v t="felix.20210531011713.1"><vh>replace_then_find</vh></v>
<v t="felix.20210531011822.1"><vh>replace_all</vh></v>
<v t="felix.20210531214057.1"><vh>clone_find_all</vh></v>
<v t="felix.20210531214103.1"><vh>clone_find_all_flattened</vh></v>
<v t="felix.20210601151758.1"><vh>find_var</vh></v>
<v t="felix.20210601151804.1"><vh>find_def</vh></v>
<v t="felix.20210601152841.1"><vh>goto_global_line</vh></v>
<v t="felix.20210620213815.1"><vh>clone_find_tag</vh></v>
<v t="felix.20210620213822.1"><vh>tag_children</vh></v>
<v t="felix.20220313212109.1"><vh>tag_node</vh></v>
<v t="felix.20220313212118.1"><vh>remove_tags</vh></v>
</v>
<v t="felix.20200924223910.1"><vh>At Buttons</vh>
<v t="felix.20200924210020.1"><vh>get_buttons</vh></v>
<v t="felix.20200924210024.1"><vh>remove_button</vh></v>
<v t="felix.20200924210029.1"><vh>click_button</vh></v>
</v>
<v t="felix.20200924223945.1"><vh>Minibuffer</vh>
<v t="felix.20200924210036.1"><vh>get_all_leo_commands</vh></v>
<v t="felix.20200924210058.1"><vh>_bad_commands</vh></v>
<v t="felix.20200924210112.1"><vh>_good_commands</vh></v>
<v t="felix.20200924210952.1"><vh>_getDocstringForCommand</vh></v>
</v>
<v t="felix.20200924224100.1"><vh>Overriden Leo Commands</vh>
<v t="felix.20200924211057.1"><vh>mark_node</vh></v>
<v t="felix.20200924211100.1"><vh>unmark_node</vh></v>
<v t="felix.20200924211104.1"><vh>clone_node</vh></v>
<v t="felix.20200924211121.1"><vh>cut_node</vh></v>
<v t="felix.20200924211125.1"><vh>delete_node</vh></v>
<v t="felix.20200924211127.1"><vh>insert_node</vh></v>
<v t="felix.20200924211132.1"><vh>insert_named_node</vh></v>
<v t="felix.20200924211135.1"><vh>undo</vh></v>
<v t="felix.20200924211138.1"><vh>redo</vh></v>
<v t="felix.20201025144113.1"><vh>test</vh></v>
</v>
<v t="felix.20191128001054.1"><vh>Outline and Body Interaction</vh>
<v t="felix.20200929215102.3"><vh>page_up</vh></v>
<v t="felix.20200929215102.4"><vh>page_down</vh></v>
<v t="felix.20200929215102.5"><vh>get_body_states</vh></v>
<v t="felix.20191126232434.16"><vh>get_children &amp; helper</vh>
<v t="felix.20191126232434.29"><vh>_yieldAllRootChildren</vh></v>
</v>
<v t="felix.20191126232434.17"><vh>get_parent</vh></v>
<v t="felix.20191201194046.1"><vh>get_all_gnx</vh></v>
<v t="felix.20191126232434.19"><vh>get_body</vh></v>
<v t="felix.20191126232434.20"><vh>get_body_length</vh></v>
<v t="felix.20191126232434.22"><vh>set_body</vh></v>
<v t="felix.20210512000301.1"><vh>get_focus</vh></v>
<v t="felix.20200929230231.1"><vh>set_selection</vh></v>
<v t="felix.20191126232434.23"><vh>set_headline</vh></v>
<v t="felix.20191126232434.24"><vh>set_current_position &amp; helper</vh>
<v t="felix.20191216195906.1"><vh>_findPNodeFromGnx</vh></v>
</v>
<v t="felix.20191126232434.25"><vh>expand_node</vh></v>
<v t="felix.20191126232434.26"><vh>contract_node</vh></v>
</v>
<v t="felix.20191128003648.1"><vh>leoFlexx Conversion Functions</vh>
<v t="felix.20191126232434.27"><vh>_create_gnx_to_vnode</vh></v>
<v t="felix.20191126232434.28"><vh>_test_round_trip_positions</vh></v>
<v t="felix.20191126232434.30"><vh>_ap_to_p</vh></v>
<v t="felix.20191126232434.31"><vh>_p_to_ap</vh></v>
</v>
</v>
<v t="felix.20201129184357.1"><vh>printAction</vh></v>
<v t="felix.20191126232435.1"><vh>main leoBridgeServer loop</vh></v>
</v>
<v t="felix.20210621233316.1"><vh>@file leoserver.py</vh></v>
</v>
<v t="ekr.20200722190517.1"><vh>Files: Other</vh>
<v t="ekr.20200815123601.1"><vh>@clean package.json</vh>
<v t="ekr.20200815123601.2"><vh>configuration</vh>
<v t="ekr.20200815123601.3"><vh>External Files Change Detection</vh></v>
<v t="ekr.20200815123601.4"><vh>Interface Behavior</vh></v>
<v t="ekr.20200815123601.5"><vh>Statusbar Indicator</vh></v>
<v t="ekr.20200815123601.6"><vh>Interface Appearance</vh></v>
<v t="felix.20210703013251.1"><vh>Body Pane Icons</vh></v>
<v t="ekr.20200815123601.7"><vh>Leo Bridge Options</vh></v>
</v>
<v t="ekr.20200815123601.8"><vh>viewsContainers</vh></v>
<v t="ekr.20200815123601.9"><vh>views</vh></v>
<v t="ekr.20200815123601.10"><vh>languages</vh></v>
<v t="ekr.20200815123601.11"><vh>grammars</vh></v>
<v t="ekr.20200815123601.12"><vh>snippets</vh></v>
<v t="ekr.20200815123601.13"><vh>commands</vh>
<v t="felix.20220228223901.1"><vh>TEST - REMOVE IN PROD</vh></v>
<v t="ekr.20200815123601.15"><vh>Show Webviews</vh></v>
<v t="ekr.20200815123601.16"><vh>Server</vh></v>
<v t="ekr.20200815123601.17"><vh>Scripting &amp; @buttons</vh></v>
<v t="ekr.20200815123601.18"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.19"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.20"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.21"><vh>Node Editing</vh></v>
<v t="felix.20201105010614.1"><vh>Text Editing</vh></v>
<v t="ekr.20200815123601.22"><vh>Move Nodes</vh></v>
<v t="ekr.20200815123601.23"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.24"><vh>Goto Nodes</vh></v>
<v t="ekr.20200815123601.25"><vh>Hoist/Dehoist</vh></v>
<v t="ekr.20200815123601.26"><vh>Undo/Redo</vh></v>
<v t="felix.20210517001143.1"><vh>Search</vh></v>
<v t="felix.20220307235733.1"><vh>Nav</vh></v>
<v t="felix.20210517001459.1"><vh>Mark Nodes</vh></v>
</v>
<v t="ekr.20200815123601.28"><vh>viewsWelcome</vh>
<v t="ekr.20200815123601.29"><vh>Leo Integration</vh>
<v t="ekr.20200815123601.30"><vh>Not Ready: [start], [connect] and settings</vh></v>
<v t="ekr.20200815123601.31"><vh>Not Ready : [connect] and settings</vh></v>
<v t="ekr.20200815123601.33"><vh>Not Ready: Connecting...</vh></v>
<v t="ekr.20200815123601.34"><vh>Ready: [open] and settings</vh></v>
</v>
<v t="ekr.20200815123601.35"><vh>Leo Documents</vh>
<v t="ekr.20200815123601.36"><vh>Not Ready</vh></v>
<v t="ekr.20200815123601.37"><vh>Ready: Empty</vh></v>
</v>
<v t="ekr.20200815123601.38"><vh>leoButtons</vh>
<v t="ekr.20200815123601.39"><vh>Not Ready</vh></v>
<v t="ekr.20200815123601.40"><vh>Ready: No Opened Files</vh></v>
<v t="ekr.20200815123601.41"><vh>Ready: No Buttons</vh></v>
</v>
<v t="felix.20210522233604.1"><vh>leoFind</vh>
<v t="felix.20210522233744.1"><vh>Not Ready</vh></v>
</v>
</v>
<v t="ekr.20200815123601.42"><vh>menus</vh>
<v t="ekr.20200815123601.43"><vh>commandPalette</vh>
<v t="ekr.20200815123601.44"><vh>Server</vh></v>
<v t="ekr.20200815123601.45"><vh>Scripting &amp; @buttons</vh></v>
<v t="ekr.20200815123601.46"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.47"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.48"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.49"><vh>Node Editing</vh></v>
<v t="felix.20210530160638.1"><vh>Text Editing</vh></v>
<v t="ekr.20200815123601.50"><vh>Move Nodes</vh></v>
<v t="ekr.20200815123601.51"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.52"><vh>Goto Nodes</vh></v>
<v t="ekr.20200815123601.53"><vh>Hoist/Dehoist</vh></v>
<v t="ekr.20200815123601.54"><vh>Undo/Redo</vh></v>
<v t="felix.20220308220651.1"><vh>Nav</vh></v>
<v t="felix.20210530153353.1"><vh>Search</vh></v>
<v t="felix.20210530153359.1"><vh>Mark Nodes</vh></v>
<v t="ekr.20200815123601.56"><vh>Hidden Commands</vh>
<v t="ekr.20200815123601.57"><vh>VSCode Settings Commands</vh></v>
<v t="felix.20210709004123.1"><vh>Status Bar Click</vh></v>
<v t="ekr.20200815123601.58"><vh>Scripting &amp; @buttons</vh></v>
<v t="ekr.20200815123601.59"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.60"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.61"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.62"><vh>Node Editing</vh></v>
<v t="ekr.20200815123601.63"><vh>Move Nodes</vh></v>
<v t="ekr.20200815123601.64"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.65"><vh>Goto Nodes</vh></v>
<v t="ekr.20200815123601.66"><vh>Hoist/Dehoist</vh></v>
<v t="ekr.20200815123601.67"><vh>Undo/Redo</vh></v>
<v t="felix.20210530161800.1"><vh>Search</vh></v>
</v>
</v>
<v t="ekr.20200815123601.68"><vh>explorer/context</vh></v>
<v t="felix.20210610022645.1"><vh>editor/title</vh></v>
<v t="felix.20210713005825.1"><vh>editor/context</vh></v>
<v t="felix.20201215210439.1"><vh>view/title</vh></v>
<v t="felix.20201215210510.1"><vh>view/item/context</vh></v>
<v t="felix.20210821212114.1"><vh>extension/context</vh></v>
</v>
<v t="ekr.20200815123601.76"><vh>keybindings</vh>
<v t="ekr.20200815123601.77"><vh>Scripting</vh></v>
<v t="ekr.20200815123601.78"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.79"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.80"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.81"><vh>Node Editing</vh></v>
<v t="felix.20201105010253.1"><vh>Text Editing</vh></v>
<v t="ekr.20200815123601.82"><vh>Move Nodes</vh>
<v t="ekr.20200815123601.83"><vh>Move Down</vh></v>
<v t="ekr.20200815123601.84"><vh>Move left</vh></v>
<v t="ekr.20200815123601.85"><vh>Move right</vh></v>
<v t="ekr.20200815123601.86"><vh>Move Up</vh></v>
</v>
<v t="ekr.20200815123601.87"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.88"><vh>Goto Nodes</vh></v>
<v t="felix.20211114150842.1"><vh>Undo/Redo</vh></v>
<v t="felix.20210517004335.1"><vh>Search</vh></v>
<v t="felix.20210812004050.1"><vh>VSCode Commands</vh></v>
</v>
<v t="ekr.20200815123601.89"><vh>resourceLabelFormatters</vh></v>
</v>
<v t="ekr.20200722130456.1"><vh>@edit .gitignore</vh></v>
</v>
<v t="felix.20200718165721.1"><vh>Files: Typescript</vh>
<v t="felix.20200718024635.1"><vh>@clean src/commandStack.ts</vh>
<v t="felix.20200718024635.2"><vh>class CommandStack</vh>
<v t="felix.20200718024635.3"><vh>size</vh></v>
<v t="felix.20200718024635.4"><vh>newSelection</vh></v>
<v t="felix.20200718024635.5"><vh>add</vh></v>
<v t="felix.20200718024635.6"><vh>_tryStart</vh></v>
<v t="felix.20200718024635.7"><vh>_runStackCommand</vh></v>
<v t="felix.20200718024635.8"><vh>_resolveResult</vh></v>
</v>
</v>
<v t="felix.20200718030926.1"><vh>@clean src/config.ts</vh>
<v t="felix.20200718030926.2"><vh>class Config</vh>
<v t="felix.20200718030926.3"><vh>getConfig</vh></v>
<v t="felix.20210727224122.1"><vh>getFontConfig</vh></v>
<v t="felix.20200718030926.4"><vh>setLeoIntegSettings</vh></v>
<v t="felix.20210727224135.1"><vh>setFontConfig</vh></v>
<v t="felix.20210818223534.1"><vh>setEnablePreview</vh></v>
<v t="felix.20210821203119.1"><vh>clearCloseEmptyGroups</vh></v>
<v t="felix.20210904235707.1"><vh>setCloseOnFileDelete</vh></v>
<v t="felix.20210818225820.1"><vh>checkEnablePreview</vh></v>
<v t="felix.20210821202347.1"><vh>checkCloseEmptyGroups</vh></v>
<v t="felix.20210904235646.1"><vh>checkCloseOnFileDelete</vh></v>
<v t="felix.20200718030926.5"><vh>buildFromSavedSettings</vh></v>
</v>
</v>
<v t="felix.20200718020912.1"><vh>@clean src/constants.ts</vh>
<v t="felix.20200718020912.2"><vh>class Constants</vh>
<v t="felix.20200718020912.3"><vh>general constants</vh></v>
<v t="felix.20210530233134.1"><vh>find panel ids</vh></v>
<v t="felix.20200718020912.5"><vh>workbench interface panels</vh></v>
<v t="felix.20200718020912.6"><vh>user messages</vh></v>
<v t="felix.20210602213308.1"><vh>import file types</vh></v>
<v t="felix.20200718020912.7"><vh>ask/save buttons</vh></v>
<v t="felix.20201126235315.1"><vh>at-buttons strings</vh></v>
<v t="felix.20200718020912.8"><vh>configuration keys</vh></v>
<v t="ekr.20200815084016.1"><vh>config defaults</vh></v>
<v t="felix.20200718020912.9"><vh>context flags</vh></v>
<v t="felix.20201208235246.1"><vh>vscode commands</vh></v>
<v t="felix.20200718020912.10"><vh>async actions</vh></v>
<v t="felix.20200718020912.11"><vh>async info messages codes</vh></v>
<v t="felix.20200718020912.12"><vh>async ask return codes</vh></v>
<v t="felix.20201103000337.1"><vh>body language code strings</vh></v>
<v t="felix.20200718020912.13"><vh>leoBridge action strings</vh></v>
<v t="felix.20200718020912.15"><vh>commands strings</vh></v>
<v t="felix.20210602151654.1"><vh>minibuffer overridden commands</vh></v>
</v>
</v>
<v t="felix.20200718031424.1"><vh>@clean src/extension.ts</vh>
<v t="felix.20200718031424.2"><vh>activate</vh>
<v t="ekr.20200815113156.1"><vh>&lt;&lt; Define entries for all commands &gt;&gt;</vh></v>
</v>
<v t="felix.20200718031424.24"><vh>deactivate</vh></v>
<v t="felix.20210917225004.1"><vh>closeLeoTextEditors</vh></v>
<v t="felix.20200718031424.25"><vh>showWelcomeIfNewer</vh></v>
</v>
<v t="felix.20200718035737.1"><vh>@clean src/leoAsync.ts</vh>
<v t="ekr.20200815083608.1"><vh>class LeoAsync</vh>
<v t="ekr.20200815083608.2"><vh>log</vh></v>
<v t="felix.20210804175113.1"><vh>refresh</vh></v>
<v t="ekr.20200815083608.3"><vh>showSaveAsDialog</vh></v>
<v t="ekr.20200815083609.1"><vh>showAskModalDialog</vh></v>
<v t="ekr.20200815083609.2"><vh>showWarnModalMessage</vh></v>
<v t="ekr.20200815083609.3"><vh>showChangesDetectedInfoMessage</vh></v>
<v t="ekr.20200815084550.1"><vh>&lt;&lt; TODO &gt;&gt;</vh></v>
</v>
</v>
<v t="felix.20200718040540.1"><vh>@clean src/leoBody.ts</vh>
<v t="felix.20200718040540.2"><vh>class LeoBodyProvider</vh>
<v t="felix.20200718040540.3"><vh>setBodyTime</vh></v>
<v t="felix.20200718040540.5"><vh>fireRefreshFile</vh></v>
<v t="felix.20200718040540.6"><vh>refreshPossibleGnxList</vh></v>
<v t="felix.20200718040540.8"><vh>watch</vh></v>
<v t="felix.20200718040540.10"><vh>stat</vh></v>
<v t="felix.20200718040540.11"><vh>readFile</vh></v>
<v t="felix.20200718040540.12"><vh>readDirectory</vh></v>
<v t="felix.20200718040540.13"><vh>createDirectory</vh></v>
<v t="felix.20200718040540.14"><vh>writeFile</vh></v>
<v t="felix.20200718040540.15"><vh>rename</vh></v>
<v t="felix.20200718040540.16"><vh>delete</vh></v>
<v t="felix.20200718040540.17"><vh>copy</vh></v>
<v t="felix.20211129222933.1"><vh>_tryFullRefresh</vh></v>
<v t="felix.20200718040540.18"><vh>_fireSoon</vh></v>
</v>
</v>
<v t="felix.20200718153505.1"><vh>@clean src/leoBridge.ts</vh>
<v t="felix.20200718153505.2"><vh>class LeoBridge</vh>
<v t="felix.20200718153505.3"><vh>action</vh></v>
<v t="felix.20200718155251.1"><vh>isBusy</vh></v>
<v t="felix.20200718153505.4"><vh>_asyncAction</vh></v>
<v t="felix.20200718153505.5"><vh>_buildActionParameter</vh></v>
<v t="felix.20200718153505.6"><vh>_resolveBridgeReady</vh></v>
<v t="felix.20200718153505.7"><vh>_rejectAction</vh></v>
<v t="felix.20200718153505.8"><vh>_callAction</vh></v>
<v t="felix.20200718153505.9"><vh>_tryParseJSON</vh></v>
<v t="felix.20200718153505.11"><vh>_processAnswer</vh></v>
<v t="felix.20200718153505.12"><vh>initLeoProcess</vh></v>
<v t="felix.20210802163703.1"><vh>closeLeoProcess</vh></v>
<v t="felix.20200718153505.13"><vh>_send</vh></v>
</v>
</v>
<v t="felix.20220307233825.1"><vh>@clean src/leoGoto.ts</vh></v>
<v t="felix.20220307233828.1"><vh>@clean src/leoGotoNode.ts</vh></v>
<v t="felix.20200718162303.1"><vh>@clean src/leoButtonNode.ts</vh>
<v t="felix.20200718162303.2"><vh>class LeoButtonNode</vh>
<v t="felix.20200718162435.1"><vh>iconPath</vh></v>
<v t="felix.20200718162442.1"><vh>id</vh></v>
<v t="felix.20200718162452.1"><vh>tooltip</vh></v>
<v t="felix.20200718162459.1"><vh>description</vh></v>
</v>
</v>
<v t="felix.20200718164130.1"><vh>@clean src/leoButtons.ts</vh>
<v t="felix.20200718164130.2"><vh>class LeoButtonsProvider</vh>
<v t="felix.20200718164130.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718164130.4"><vh>getTreeItem</vh></v>
<v t="felix.20200718164130.5"><vh>getChildren</vh></v>
<v t="felix.20200718164130.6"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718164509.1"><vh>@clean src/leoDocumentNode.ts</vh>
<v t="felix.20200718164509.2"><vh>class LeoDocumentNode</vh>
<v t="felix.20200718164635.1"><vh>iconPath</vh></v>
<v t="felix.20200718164638.1"><vh>id</vh></v>
</v>
</v>
<v t="felix.20200718165108.1"><vh>@clean src/leoDocuments.ts</vh>
<v t="felix.20200718165108.2"><vh>class LeoDocumentsProvider</vh>
<v t="felix.20200718165108.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718165108.4"><vh>getTreeItem</vh></v>
<v t="felix.20200718165108.5"><vh>getChildren</vh></v>
<v t="felix.20200718165108.6"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718170429.1"><vh>@clean src/leoFileBrowser.ts</vh>
<v t="felix.20200718170429.2"><vh>class LeoFilesBrowser</vh>
<v t="felix.20200718170429.3"><vh>_getBestOpenFolderUri</vh></v>
<v t="felix.20210602160216.1"><vh>getImportFileUrl</vh></v>
<v t="felix.20200718170429.4"><vh>getLeoFileUrl</vh></v>
<v t="felix.20210915234252.1"><vh>getLeoJsFileUrl</vh></v>
</v>
</v>
<v t="felix.20200718170712.1"><vh>@clean src/leoNode.ts</vh>
<v t="felix.20200718170712.2"><vh>class LeoNode</vh>
<v t="felix.20200718170712.4"><vh>setRoot</vh></v>
<v t="felix.20200718170712.5"><vh>_getNodeContextValue</vh></v>
<v t="felix.20200718171904.1"><vh>get_iconPath</vh></v>
<v t="felix.20200718171854.1"><vh>get_id</vh></v>
<v t="felix.20200718171837.1"><vh>get_description</vh></v>
<v t="felix.20200718171849.1"><vh>get tooltip</vh></v>
</v>
</v>
<v t="felix.20200719025231.1"><vh>@clean src/leoIntegration.ts</vh>
<v t="felix.20200719025231.2"><vh>class LeoIntegration</vh>
<v t="felix.20200719025231.3"><vh>Constructor</vh></v>
<v t="felix.20200719025231.4"><vh>Server</vh>
<v t="felix.20200719025231.5"><vh>sendAction</vh></v>
<v t="felix.20200719025231.6"><vh>startNetworkServices</vh></v>
<v t="felix.20200719025231.7"><vh>startServer</vh></v>
<v t="felix.20210717204048.1"><vh>killServer</vh></v>
<v t="felix.20210802162424.1"><vh>stopConnection</vh></v>
<v t="felix.20200719025231.8"><vh>connect</vh></v>
<v t="felix.20200719025231.9"><vh>cancelConnect</vh></v>
<v t="felix.20210613210351.1"><vh>chooseLeoFolder</vh></v>
<v t="felix.20200719031346.1"><vh>sendConfigToServer</vh></v>
</v>
<v t="felix.20200719025231.10"><vh>Recently Opened Files</vh>
<v t="felix.20200719025231.11"><vh>_openLastFiles</vh></v>
<v t="felix.20200719025231.12"><vh>_addRecentAndLastFile</vh></v>
<v t="felix.20200719025231.13"><vh>_removeRecentFile</vh></v>
<v t="felix.20200719025231.14"><vh>_removeLastFile</vh></v>
<v t="felix.20200719025231.15"><vh>showRecentLeoFiles</vh></v>
</v>
<v t="ekr.20200815085229.1"><vh>Log pane</vh>
<v t="ekr.20200815085316.4"><vh>showLogPane</vh></v>
<v t="ekr.20200815085316.5"><vh>hideLogPane</vh></v>
<v t="ekr.20200815085316.6"><vh>addLogPaneEntry</vh></v>
</v>
<v t="felix.20200719031802.1"><vh>Document States</vh>
<v t="felix.20200719025231.19"><vh>_triggerGetStates</vh></v>
<v t="felix.20200719025231.20"><vh>_isBusy</vh></v>
<v t="felix.20201107224112.1"><vh>_isBusyTriggerSave</vh></v>
<v t="felix.20200719025231.21"><vh>_isCurrentFileNamed</vh></v>
<v t="felix.20200719025231.22"><vh>_setupNoOpenedLeoDocument</vh></v>
<v t="felix.20200719025231.23"><vh>_setupOpenedLeoDocument</vh></v>
</v>
<v t="felix.20200719030811.1"><vh>UI Change Events</vh>
<v t="felix.20200719025231.24"><vh>_onChangeConfiguration</vh></v>
<v t="ekr.20200815085628.1"><vh>_onDidOpenTextDocument</vh></v>
<v t="felix.20200719025231.25"><vh>_onChangeCollapsedState</vh></v>
<v t="felix.20200719025231.26"><vh>_onTreeViewVisibilityChanged</vh></v>
<v t="felix.20200719025231.27"><vh>_onDocTreeViewVisibilityChanged</vh></v>
<v t="ekr.20200815085705.1"><vh>_onButtonsTreeViewVisibilityChanged</vh></v>
<v t="felix.20220310224330.1"><vh>_onGotoTreeViewVisibilityChanged</vh></v>
<v t="felix.20200719025231.29"><vh>_onActiveEditorChanged</vh></v>
<v t="felix.20210418014039.1"><vh>_changedTextEditorViewColumn</vh></v>
<v t="felix.20210418014040.1"><vh>_changedVisibleTextEditors</vh></v>
<v t="felix.20210418014040.2"><vh>_changedWindowState</vh></v>
<v t="felix.20200928004727.1"><vh>_onChangeEditorSelection</vh></v>
<v t="felix.20201014020145.1"><vh>_onChangeEditorScroll</vh></v>
<v t="felix.20200719025231.31"><vh>_onDocumentChanged</vh></v>
</v>
<v t="felix.20200719030842.1"><vh>Body Editing</vh>
<v t="felix.20200719025231.32"><vh>triggerBodySave</vh></v>
<v t="felix.20200928133238.1"><vh>_bodySaveSelection</vh></v>
<v t="felix.20200719025231.33"><vh>_bodySaveDocument</vh></v>
<v t="felix.20210806175431.1"><vh>_bodySaveDeactivate</vh></v>
</v>
<v t="felix.20200719030902.1"><vh>Refresh UI</vh>
<v t="felix.20200719025231.34"><vh>setDocumentSelection</vh></v>
<v t="felix.20200719025231.35"><vh>showOutline</vh></v>
<v t="felix.20201114185218.1"><vh>setTreeViewTitle</vh></v>
<v t="ekr.20200815085806.1"><vh>configTreeRefresh</vh></v>
<v t="ekr.20200815085830.1"><vh>_refreshOutline</vh></v>
<v t="ekr.20200815085830.2"><vh>_revealTreeViewNode</vh></v>
<v t="ekr.20200815085830.3"><vh>launchRefresh</vh></v>
<v t="ekr.20200815085830.5"><vh>_gotSelection</vh></v>
<v t="felix.20210528012836.1"><vh>getBridgeFocus</vh></v>
</v>
<v t="felix.20200719030909.1"><vh>Conversion</vh>
<v t="felix.20200719025231.38"><vh>apToLeoNode</vh></v>
<v t="felix.20200719025231.39"><vh>_apToLeoNodeConvertReveal</vh></v>
<v t="felix.20200719025231.40"><vh>arrayToLeoNodesArray</vh></v>
</v>
<v t="felix.20200719031115.1"><vh>Body Pane Management</vh>
<v t="ekr.20200815090152.1"><vh>_tryApplyNodeToBody</vh></v>
<v t="felix.20200719025231.47"><vh>_switchBody</vh></v>
<v t="felix.20200719025231.48"><vh>_locateOpenedBody</vh></v>
<v t="felix.20210418230204.1"><vh>_findUriColumn</vh></v>
<v t="felix.20210418230204.2"><vh>_findGnxColumn</vh></v>
<v t="felix.20210418013332.1"><vh>_hideDeleteBody</vh></v>
<v t="felix.20210418220343.1"><vh>_checkPreviewMode</vh></v>
<v t="felix.20200719025231.49"><vh>closeBody</vh></v>
<v t="felix.20210718155134.1"><vh>cleanupBody</vh></v>
<v t="felix.20200719025231.50"><vh>showBody</vh></v>
<v t="felix.20220215235325.1"><vh>_setBodyLanguage</vh></v>
<v t="felix.20211111214657.1"><vh>refreshBodyStates</vh></v>
<v t="felix.20211111233213.1"><vh>debouncedRefreshBodyStates</vh></v>
</v>
<v t="felix.20200719025231.51"><vh>Commands</vh>
<v t="felix.20201114185813.1"><vh>minibuffer</vh></v>
<v t="felix.20200719025231.52"><vh>selectTreeNode</vh></v>
<v t="ekr.20200815090400.1"><vh>nodeCommand</vh></v>
<v t="felix.20200719025231.54"><vh>changeMark</vh></v>
<v t="felix.20200719025231.55"><vh>editHeadline</vh></v>
<v t="felix.20200719025231.56"><vh>insertNode</vh></v>
<v t="felix.20220222012540.1"><vh>copyNode</vh></v>
<v t="felix.20220222012528.1"><vh>cutNode</vh></v>
<v t="felix.20220222012552.1"><vh>pasteNode</vh></v>
<v t="felix.20220222012602.1"><vh>pasteAsCloneNode</vh></v>
</v>
<v t="felix.20220222014050.1"><vh>Clipboard</vh>
<v t="felix.20220222014050.2"><vh>replaceClipboardWith</vh></v>
<v t="felix.20220222014050.3"><vh>asyncGetTextFromClipboard</vh></v>
<v t="felix.20220222014050.4"><vh>getTextFromClipboard</vh></v>
</v>
<v t="felix.20220308213523.1"><vh>Nav</vh>
<v t="felix.20220308213538.1"><vh>findQuick</vh></v>
<v t="felix.20220308213547.1"><vh>findQuickSelected</vh></v>
<v t="felix.20220308213552.1"><vh>findQuickTimeline</vh></v>
<v t="felix.20220308213557.1"><vh>findQuickChanged</vh></v>
<v t="felix.20220308213600.1"><vh>findQuickHistory</vh></v>
<v t="felix.20220308213605.1"><vh>findQuick_marked</vh></v>
<v t="felix.20220308213619.1"><vh>findQuickGoAnywhere</vh></v>
<v t="felix.20220309215616.1"><vh>gotoNavEntry</vh></v>
</v>
<v t="felix.20210530225640.1"><vh>Search</vh>
<v t="felix.20220305225942.1"><vh>navEnter</vh></v>
<v t="felix.20220305231404.1"><vh>navTextChange</vh></v>
<v t="felix.20210516233931.1"><vh>startSearch</vh></v>
<v t="felix.20210613212439.1"><vh>newHeadline</vh></v>
<v t="felix.20210613205741.1"><vh>_inputFindPattern</vh></v>
<v t="felix.20210516234059.1"><vh>find</vh></v>
<v t="felix.20210713000442.1"><vh>findSymbol</vh></v>
<v t="felix.20210530223726.1"><vh>replace</vh></v>
<v t="felix.20210530230354.1"><vh>replaceAll</vh></v>
<v t="felix.20210530230400.1"><vh>cloneFind</vh></v>
<v t="felix.20210530225306.1"><vh>setSearchOption</vh></v>
<v t="felix.20210525232728.1"><vh>loadSearchSettings</vh></v>
<v t="felix.20210524215215.1"><vh>saveSearchSettings</vh></v>
<v t="felix.20210601164915.1"><vh>gotoGlobalLine</vh></v>
<v t="felix.20210620220655.1"><vh>tagChildren</vh></v>
<v t="felix.20220313211902.1"><vh>tag_node</vh></v>
<v t="felix.20220313211907.1"><vh>remove_tags</vh></v>
<v t="felix.20210620220702.1"><vh>cloneFindTag</vh></v>
</v>
<v t="felix.20200719025231.57"><vh>Leo Documents</vh>
<v t="felix.20200719025231.58"><vh>saveAsLeoFile</vh></v>
<v t="felix.20210915233602.1"><vh>saveAsLeoJsFile</vh></v>
<v t="felix.20200719025231.59"><vh>saveLeoFile</vh></v>
<v t="felix.20200719025231.60"><vh>switchLeoFile</vh></v>
<v t="felix.20200719025231.61"><vh>selectOpenedLeoDocument</vh></v>
<v t="fil.20210609233100.1"><vh>clearRecentLeoFiles</vh></v>
<v t="felix.20200719025231.64"><vh>closeLeoFile</vh></v>
<v t="felix.20200719025231.65"><vh>newLeoFile</vh></v>
<v t="felix.20200719025231.66"><vh>openLeoFile</vh></v>
<v t="felix.20210602155312.1"><vh>importFile</vh></v>
</v>
<v t="felix.20200719033306.1"><vh>AtButtons</vh>
<v t="ekr.20200815090517.1"><vh>clickAtButton</vh></v>
<v t="felix.20220221003719.1"><vh>_handleRClicks</vh></v>
<v t="felix.20211017002435.1"><vh>gotoScript</vh></v>
<v t="ekr.20200815090517.2"><vh>removeAtButton</vh></v>
</v>
<v t="felix.20200719033511.1"><vh>Other</vh>
<v t="felix.20210610022836.1"><vh>prevNextNode</vh></v>
<v t="felix.20210524231157.1"><vh>setFindPanel</vh></v>
<v t="felix.20200719025231.69"><vh>statusBarOnClick</vh></v>
<v t="felix.20200719025231.70"><vh>test</vh></v>
</v>
</v>
</v>
<v t="felix.20200718180428.1"><vh>@clean src/leoOutline.ts</vh>
<v t="felix.20200718180428.2"><vh>class LeoOutlineProvider</vh>
<v t="felix.20200718180428.4"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718180428.5"><vh>getTreeItem</vh></v>
<v t="felix.20200718180428.6"><vh>getChildren</vh></v>
<v t="felix.20200718180428.7"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718192351.1"><vh>@clean src/leoStates.ts</vh>
<v t="felix.20200718192411.1"><vh>class LeoStates</vh>
<v t="felix.20200718193719.1"><vh>General State Flags</vh>
<v t="felix.20200718193219.1"><vh>leoBridgeReady &amp; helper</vh></v>
<v t="felix.20200718193222.1"><vh>fileOpenedReady &amp; helper</vh></v>
<v t="felix.20200718193226.1"><vh>leoOpenedFileName</vh></v>
<v t="felix.20200718193230.1"><vh>leoChanged &amp; helper</vh></v>
<v t="felix.20200718193233.1"><vh>leoCanUndo &amp; helper</vh></v>
<v t="felix.20200718193235.1"><vh>leoCanRedo &amp; helper</vh></v>
<v t="felix.20200718193238.1"><vh>leoCanDemote &amp; helper</vh></v>
<v t="felix.20200718193241.1"><vh>leoCanPromote &amp; helper</vh></v>
<v t="felix.20200718193244.1"><vh>leoCanDehoist &amp; helper</vh></v>
</v>
<v t="felix.20200718193731.1"><vh>Selected Node Flags</vh>
<v t="felix.20200718193338.1"><vh>leoMarked</vh></v>
<v t="felix.20200718193341.1"><vh>leoCloned</vh></v>
<v t="felix.20200718193343.1"><vh>leoDirty</vh></v>
<v t="felix.20200718193348.1"><vh>leoEmpty</vh></v>
<v t="felix.20200718193350.1"><vh>leoChild</vh></v>
<v t="felix.20200718193353.1"><vh>leoAtFile</vh></v>
<v t="felix.20200718193403.1"><vh>leoRoot</vh></v>
</v>
<v t="felix.20200718193500.1"><vh>constructor</vh></v>
<v t="felix.20200718192411.2"><vh>selectedNodeFlags</vh></v>
<v t="felix.20200718192411.3"><vh>leoStateFlags</vh></v>
</v>
</v>
<v t="felix.20200718185403.1"><vh>@clean src/leoStatusBar.ts</vh>
<v t="felix.20200718185403.2"><vh>class LeoStatusBar</vh>
<v t="felix.20200718185403.3"><vh>show</vh></v>
<v t="felix.20200718185403.4"><vh>hide</vh></v>
<v t="felix.20200718185403.5"><vh>setString</vh></v>
<v t="felix.20200718185403.6"><vh>update</vh></v>
<v t="felix.20200718185403.7"><vh>_updateLeoObjectIndicatorDebounced</vh></v>
<v t="felix.20200718185403.8"><vh>_updateLeoObjectIndicator</vh></v>
</v>
</v>
<v t="felix.20200718191946.1"><vh>@clean src/serverManager.ts</vh>
<v t="felix.20200718191946.2"><vh>class ServerService</vh>
<v t="felix.20200718191946.4"><vh>startServer</vh></v>
<v t="felix.20210717192921.1"><vh>killServer</vh></v>
<v t="ekr.20200815091220.1"><vh>_gotTerminalData</vh></v>
</v>
</v>
<v t="felix.20200718194857.1"><vh>@clean src/types.d.ts</vh>
<v t="felix.20210727225050.1"><vh>IVsCodeApi</vh></v>
<v t="felix.20200718194857.2"><vh>ConfigMembers</vh></v>
<v t="felix.20201017224340.1"><vh>ConfigSetting</vh></v>
<v t="felix.20210727224655.1"><vh>FontSettings</vh></v>
<v t="felix.20200718194857.3"><vh>RevealType</vh></v>
<v t="felix.20200718194857.4"><vh>RefreshType</vh></v>
<v t="felix.20200718194857.5"><vh>UserCommand</vh></v>
<v t="felix.20200718194857.6"><vh>LeoAction</vh></v>
<v t="felix.20200718194857.7"><vh>LeoLogEntry</vh></v>
<v t="felix.20200718194857.8"><vh>ArchivedPosition</vh></v>
<v t="ekr.20200815091408.1"><vh>LeoPackageStates</vh></v>
<v t="felix.20200718194857.10"><vh>LeoBridgePackage</vh></v>
<v t="felix.20200718194857.11"><vh>LeoDocument</vh></v>
<v t="felix.20200718194857.12"><vh>LeoButton</vh></v>
<v t="felix.20220308203528.1"><vh>LeoGoto</vh></v>
<v t="felix.20210522152922.1"><vh>LeoSearchScope</vh></v>
<v t="felix.20210522152739.1"><vh>LeoSearchSettings</vh></v>
<v t="felix.20210523162125.1"><vh>LeoGuiFindTabManagerSettings</vh></v>
<v t="felix.20200718194857.13"><vh>Icon</vh></v>
<v t="felix.20200718194857.14"><vh>BodyTimeInfo</vh></v>
<v t="felix.20201119002510.1"><vh>BodyPosition</vh></v>
<v t="felix.20201006195046.1"><vh>BodySelectionInfo</vh></v>
<v t="felix.20200718194857.15"><vh>showSaveAsDialogParameters</vh></v>
<v t="felix.20200718194857.16"><vh>runAskYesNoDialogParameters</vh></v>
<v t="felix.20200718194857.17"><vh>runWarnMessageDialogParameters</vh></v>
<v t="felix.20200718194857.18"><vh>runInfoMessageDialogParameters</vh></v>
<v t="felix.20200718194857.19"><vh>AskMessageItem</vh></v>
<v t="felix.20200718194857.20"><vh>ChooseDocumentItem</vh></v>
<v t="felix.20220220191549.1"><vh>ChooseRClickItem</vh></v>
<v t="felix.20220221001803.1"><vh>RClick</vh></v>
</v>
<v t="felix.20200718195558.1"><vh>@clean src/utils.ts</vh>
<v t="felix.20210706233101.1"><vh>uniqueId</vh></v>
<v t="felix.20210706233106.1"><vh>getUniqueId</vh></v>
<v t="felix.20200718195558.2"><vh>padNumber2</vh></v>
<v t="ekr.20200815091619.1"><vh>hashNode</vh></v>
<v t="felix.20201106200100.1"><vh>addFileToGlobal</vh></v>
<v t="felix.20201106200109.1"><vh>removeFileFromGlobal</vh></v>
<v t="felix.20200718195558.3"><vh>buildNodeIconPaths</vh></v>
<v t="felix.20200718195558.4"><vh>buildDocumentIconPaths</vh></v>
<v t="ekr.20200815091945.1"><vh>buildButtonsIconPaths</vh></v>
<v t="felix.20200718195558.6"><vh>buildNodeAndTextJson</vh></v>
<v t="felix.20210614235023.1"><vh>chooseLeoFolderDialog</vh></v>
<v t="felix.20201018163510.1"><vh>getDurationMilliseconds</vh></v>
<v t="felix.20200718195558.7"><vh>getFileFromPath</vh></v>
<v t="felix.20200718195558.8"><vh>isIconChangedByEdit</vh></v>
<v t="felix.20200718195558.9"><vh>isHexColor</vh></v>
<v t="felix.20200718195558.10"><vh>strToLeoUri</vh></v>
<v t="felix.20200718195558.11"><vh>leoUriToStr</vh></v>
<v t="felix.20200718195558.12"><vh>setContext</vh></v>
<v t="felix.20210612214028.1"><vh>findNextAvailablePort</vh></v>
<v t="felix.20210820231649.1"><vh>findSingleAvailablePort</vh></v>
</v>
<v t="felix.20210522001751.1"><vh>@clean src/webviews/leoFindPanelWebview.ts</vh>
<v t="felix.20210522001814.1"><vh>class LeoFindPanelProvider</vh>
<v t="fil.20210603195851.1"><vh>resolveWebviewView</vh></v>
<v t="fil.20210603195902.1"><vh>_getHtmlForWebview</vh></v>
<v t="fil.20210603195909.1"><vh>getNonce</vh></v>
</v>
</v>
<v t="fil.20210603195218.1"><vh>@clean src/webviews/leoSettingsWebview.ts</vh>
<v t="fil.20210603195319.1"><vh>class LeoSettingsWebview</vh>
<v t="fil.20210603195319.2"><vh>changedConfiguration</vh></v>
<v t="fil.20210603195319.3"><vh>openWebview</vh></v>
<v t="fil.20210603195319.4"><vh>_getBaseHtml</vh></v>
</v>
</v>
</v>
<v t="fil.20210603223013.1"><vh>Files: Find Panel Webview</vh>
<v t="fil.20210603223013.2"><vh>@clean find-panel/main.css</vh></v>
<v t="fil.20210603223013.4"><vh>@clean find-panel/main.js</vh>
<v t="felix.20220301224252.1"><vh>main function</vh></v>
</v>
<v t="fil.20210603223014.2"><vh>@clean find-panel/reset.css</vh></v>
<v t="fil.20210603223014.4"><vh>@clean find-panel/vscode.css</vh></v>
</v>
<v t="fil.20210603223933.1"><vh>Files: Settings Panel Webview</vh>
<v t="fil.20210603223933.2"><vh>@clean src/webviews/settingsPanel/colors.ts</vh>
<v t="fil.20210603223933.3"><vh>adjustLight</vh></v>
<v t="fil.20210603223933.4"><vh>darken</vh></v>
<v t="fil.20210603223933.5"><vh>lighten</vh></v>
<v t="fil.20210603223933.6"><vh>opacity</vh></v>
<v t="fil.20210603223933.7"><vh>toRgba</vh></v>
</v>
<v t="fil.20210603223933.9"><vh>@clean src/webviews/settingsPanel/index.html</vh>
<v t="fil.20210603223933.10"><vh>&lt;html&gt;</vh></v>
</v>
<v t="fil.20210603223933.165"><vh>@clean src/webviews/settingsPanel/index.ts</vh>
<v t="fil.20210603223933.166"><vh>main</vh>
<v t="fil.20210603223934.1"><vh>listenAll</vh></v>
<v t="fil.20210603223934.2"><vh>chooseLeoServerPath</vh></v>
<v t="fil.20210603223934.3"><vh>onBind</vh></v>
<v t="fil.20210603223934.4"><vh>onInputSelected</vh></v>
<v t="fil.20210603223934.5"><vh>onInputChecked</vh></v>
<v t="fil.20210603223934.6"><vh>onInputBlurred</vh></v>
<v t="fil.20210603223934.7"><vh>onInputFocused</vh></v>
<v t="fil.20210603223934.8"><vh>onInputChanged</vh></v>
<v t="felix.20210725221438.1"><vh>onVscodeInputChanged</vh></v>
<v t="felix.20210725221447.1"><vh>setFontControls</vh></v>
<v t="fil.20210603223934.9"><vh>setControls</vh></v>
<v t="fil.20210603223934.10"><vh>setVisibility</vh></v>
<v t="fil.20210603223934.11"><vh>parseStateExpression</vh></v>
<v t="fil.20210603223934.12"><vh>evaluateStateExpression</vh></v>
<v t="fil.20210603223934.13"><vh>getSettingValue</vh></v>
</v>
</v>
<v t="fil.20210603223934.15"><vh>@clean src/webviews/settingsPanel/theme.ts</vh>
<v t="fil.20210603223934.16"><vh>initializeAndWatchThemeColors</vh></v>
</v>
<v t="fil.20210603223956.2"><vh>@clean src/webviews/settingsPanel/scss/main.scss</vh></v>
<v t="fil.20210603223956.4"><vh>@clean src/webviews/settingsPanel/scss/popup.scss</vh></v>
</v>
<v t="ekr.20200808100339.1"><vh>----- TS Classes</vh>
<v t="felix.20200718024635.2"></v>
<v t="felix.20200718030926.2"></v>
<v t="felix.20200718020912.2"></v>
<v t="ekr.20200815083608.1"></v>
<v t="felix.20200718040540.2"></v>
<v t="felix.20200718153505.2"></v>
<v t="felix.20200718162303.2"></v>
<v t="felix.20200718164130.2"></v>
<v t="felix.20200718164509.2"></v>
<v t="felix.20200718165108.2"></v>
<v t="felix.20200718170429.2"></v>
<v t="felix.20210522001814.1"></v>
<v t="felix.20200719025231.2"></v>
<v t="felix.20200718170712.2"></v>
<v t="fil.20210603195319.1"></v>
<v t="felix.20200718192411.1"></v>
<v t="felix.20200718180428.2"></v>
<v t="felix.20200718185403.2"></v>
<v t="felix.20200718191946.2"></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20200722125546.1">@language python

g.cls()
d = c.commandsDict  # keys are command names, values are functions.
for command_name in sorted(d):
    if command_name.startswith('@'):
        continue
    func = d.get(command_name)
    # Prefer func.__func_name__ to func.__name__: Leo's decorators change func.__name__!
    func_name = getattr(func, '__func_name__', func.__name__)
    # print(f"{command_name:&gt;40} {func_name}")
    print(command_name)
print('len(d)', len(d))

</t>
<t tx="ekr.20200722190504.1"></t>
<t tx="ekr.20200722190517.1"></t>
<t tx="ekr.20200724052304.1">c.backup_helper(sub_dir='leoInteg')
</t>
<t tx="ekr.20200808100339.1"></t>
<t tx="ekr.20200808100711.1"></t>
<t tx="ekr.20200808100717.1">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20200815083608.1">/**
 * * Handles the functions called by Leo through leoBridge such as adding a log pane entry, runAskYesNoDialog for file changes, etc.
 * * Some config settings affect this behavior, such as defaultReloadIgnore and checkForChangeExternalFiles
 */
export class LeoAsync {

    private _askResult: string = "";

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others

}

&lt;&lt; TODO &gt;&gt;
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200815083608.2">/**
 * * Adds message string to leoInteg's log pane, used when leoBridge gets an async 'log' command
 */
public log(p_message: string, p_color?: string): void {
    if (p_color &amp;&amp; p_color === Constants.LOG_ALERT_COLOR) {
        // Red Detected: Force showing the log pane for 'errors' in the log pane.
        this._leoIntegration.showLogPane();
    }
    this._leoIntegration.addLogPaneEntry(p_message);
}

</t>
<t tx="ekr.20200815083608.3">/**
 * * Equivalent to runSaveFileDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * @param p_saveAsArg
 */
public showSaveAsDialog(p_saveAsArg: showSaveAsDialogParameters): void {
    console.log('TODO: SHOW SAVE AS DIALOG!');
}

</t>
<t tx="ekr.20200815083609.1">/**
 * * Equivalent to runAskYesNoDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * * Opens a modal dialog to return one of 'yes', 'yes-all', 'no' or 'no-all' to be sent back with the leoBridge 'ASK_RESULT' action
 * @param p_askArg an async package object {"ask": title, "message": message, "yes_all": yes_all, "no_all": no_all}
 */
public showAskModalDialog(p_askArg: runAskYesNoDialogParameters): void {
    this._askResult = "no"; // defaults to not doing anything, matches isCloseAffordance just to be safe
    // Note: "last line" could be eventually used in the message
    // const w_lastLine = p_askArg.message.substr(p_askArg.message.lastIndexOf("\n") + 1);
    const w_items: AskMessageItem[] = [
        {
            title: Constants.USER_MESSAGES.YES,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES,
            isCloseAffordance: false
        },
        {
            title: Constants.USER_MESSAGES.NO,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO,
            isCloseAffordance: true
        }
    ];
    if (p_askArg.yes_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.YES_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES_ALL,
            isCloseAffordance: false
        });
    }
    if (p_askArg.no_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.NO_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO_ALL,
            isCloseAffordance: false
        });
    }
    const w_askRefreshInfoMessage: Thenable&lt;AskMessageItem | undefined&gt; = vscode.window.showInformationMessage(
        p_askArg.message,
        { modal: true },
        ...w_items
    );
    w_askRefreshInfoMessage.then((p_result: AskMessageItem | undefined) =&gt; {
        if (p_result) {
            this._askResult = p_result.value;
        }
        const w_sendResultPromise = this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.ASK_RESULT,
            JSON.stringify({ "result": this._askResult })
        );
        if (this._askResult.includes(Constants.ASYNC_ASK_RETURN_CODES.YES)) {
            w_sendResultPromise.then(() =&gt; {
                //  this._leoIntegration.launchRefresh({ tree: true, body: true, buttons: true, states: true, documents: true }, false);
                return this._leoIntegration.sendAction(Constants.LEOBRIDGE.DO_NOTHING);
            }).then((p_package) =&gt; {
                // refresh and reveal selection
                this._leoIntegration.launchRefresh(
                    { tree: true, body: true, states: true, buttons: true, documents: true },
                    false,
                    p_package.node
                );
            });
        }
    });
}

</t>
<t tx="ekr.20200815083609.2">/**
 * * Equivalent to runAskOkDialog from Leo's qt_gui.py, used when leoBridge gets an async 'warn' command
 * @param p_waitArg an async package object {"warn": "", "message": ""}
 */
public showWarnModalMessage(p_waitArg: runWarnMessageDialogParameters): void {
    vscode.window.showInformationMessage(
        p_waitArg.message,
        { modal: true }
    ).then(() =&gt; {
        this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.ASK_RESULT,
            JSON.stringify({ "result": Constants.ASYNC_ASK_RETURN_CODES.OK })
        );
    });
}

</t>
<t tx="ekr.20200815083609.3">/**
 * * Show non-blocking info message about detected file changes, used when leoBridge gets an async 'info' command
 * @param p_infoArg an async package object { "message": string; }
 */
public showChangesDetectedInfoMessage(p_infoArg: runInfoMessageDialogParameters): void {
    let w_message = "";
    switch (p_infoArg.message) {
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_REFRESHED:
            w_message = Constants.USER_MESSAGES.CHANGES_DETECTED + Constants.USER_MESSAGES.REFRESHED;

            this._leoIntegration.sendAction(Constants.LEOBRIDGE.DO_NOTHING)
                .then((p_package) =&gt; {
                    // refresh and reveal selection
                    this._leoIntegration.launchRefresh(
                        { tree: true, body: true, states: true, buttons: true, documents: true },
                        false,
                        p_package.node
                    );
                });

            break;
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_IGNORED:
            w_message = Constants.USER_MESSAGES.CHANGES_DETECTED + Constants.USER_MESSAGES.IGNORED;
            break;
        default:
            w_message = p_infoArg.message;
            break;
    }
    vscode.window.showInformationMessage(w_message);
}

</t>
<t tx="ekr.20200815084016.1">/**
 * * Configuration Defaults used in config.ts
 * Used when setting itself and getting parameters from vscode
 */
public static CONFIG_DEFAULTS = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "none",  // Used in leoBridge scrip,
    DEFAULT_RELOAD_IGNORE: "none", // Used in leoBridge scrip,
    LEO_TREE_BROWSE: true,
    TREE_KEEP_FOCUS: true,
    TREE_KEEP_FOCUS_WHEN_ASIDE: false,
    STATUSBAR_STRING: "", // Strings like "Literate", "Leo", UTF-8 also supported: \u{1F981}
    STATUSBAR_COLOR: "fb7c47",
    TREE_IN_EXPLORER: true,
    SHOW_OPEN_ASIDE: true,
    SHOW_EDIT: true,
    SHOW_ARROWS: false,
    SHOW_ADD: false,
    SHOW_MARK: false,
    SHOW_CLONE: false,
    SHOW_COPY: false,

    SHOW_EDITION_BODY: true,
    SHOW_CLIPBOARD_BODY: true,
    SHOW_PROMOTE_BODY: true,
    SHOW_EXECUTE_BODY: true,
    SHOW_EXTRACT_BODY: true,
    SHOW_IMPORT_BODY: true,
    SHOW_REFRESH_BODY: true,
    SHOW_HOIST_BODY: true,
    SHOW_MARK_BODY: true,
    SHOW_SORT_BODY: true,

    INVERT_NODES: false,
    LEO_PYTHON_COMMAND: "",
    LEO_EDITOR_PATH: "",
    AUTO_START_SERVER: false,
    AUTO_CONNECT: false,
    IP_ADDRESS: "localhost",
    IP_LOOPBACK: "127.0.0.1",
    IP_PORT: 32125,

    SET_DETACHED: true,
    LIMIT_USERS: 1
};

</t>
<t tx="ekr.20200815084550.1">/*
    TODO : Should Reproduce those interactive controls that may be asked by Leo, and redo a true UI bridge

def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    return self.simulateDialog("aboutLeoDialog", None)

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog", None)

def runAskOkDialog(self, c, title, message=None, text="Ok"):
    return self.simulateDialog("okDialog", "Ok")

def runAskOkCancelNumberDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
):
    return self.simulateDialog("numberDialog", -1)

def runAskOkCancelStringDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
    default="",
    wide=False,
):
    return self.simulateDialog("stringDialog", '')

def runCompareDialog(self, c):
    return self.simulateDialog("compareDialog", '')

def runOpenFileDialog(self, c, title, filetypes, defaultextension,
    multiple=False,
    startpath=None,
):
    return self.simulateDialog("openFileDialog", None)

def runSaveFileDialog(self, c, initialfile, title, filetypes, defaultextension):
    return self.simulateDialog("saveFileDialog", None)

def runAskYesNoDialog(self, c, title,
    message=None,
    yes_all=False,
    no_all=False,
):
    return self.simulateDialog("yesNoDialog", "no")

def runAskYesNoCancelDialog(self, c, title,
    message=None,
    yesMessage="Yes",
    noMessage="No",
    yesToAllMessage=None,
    defaultButton="Yes",
    cancelMessage=None,
):
    return self.simulateDialog("yesNoCancelDialog", "cancel")

def simulateDialog(self, key, defaultVal):
    return defaultVal

*/
</t>
<t tx="ekr.20200815085229.1"></t>
<t tx="ekr.20200815085316.4">/**
 * * Reveals the log pane if not already visible
 */
public showLogPane(): void {
    this._leoLogPane.show(true);
}

</t>
<t tx="ekr.20200815085316.5">/**
 * * Hides the log pane
 */
public hideLogPane(): void {
    this._leoLogPane.hide();
}

</t>
<t tx="ekr.20200815085316.6">/**
 * * Adds a message string to leoInteg's log pane. Used when leoBridge receives an async 'log' command.
 * @param p_message The string to be added in the log
 */
public addLogPaneEntry(p_message: string): void {
    this._leoLogPane.appendLine(p_message);
}

</t>
<t tx="ekr.20200815085628.1">/**
 * * Handles the opening of a file in vscode, and check if it's a Leo file to suggest opening options
 * @param p_event The opened document event passed by vscode
 */
private _onDidOpenTextDocument(p_document: vscode.TextDocument): void {
    if (
        this.leoStates.leoBridgeReady &amp;&amp;
        p_document.uri.scheme === Constants.URI_FILE_SCHEME &amp;&amp;
        p_document.uri.fsPath.toLowerCase().endsWith('.leo')
    ) {
        if (!this._hasShownContextOpenMessage) {
            vscode.window.showInformationMessage(Constants.USER_MESSAGES.RIGHT_CLICK_TO_OPEN);
            this._hasShownContextOpenMessage = true;
        }
        // ? Use a picker for more 'intense' interaction ?
        // vscode.window.showQuickPick(
        //     [Constants.USER_MESSAGES.YES, Constants.USER_MESSAGES.NO],
        //     { placeHolder: Constants.USER_MESSAGES.OPEN_WITH_LEOINTEG }
        // )
        //     .then(p_result =&gt; {
        //         if (p_result &amp;&amp; p_result === Constants.USER_MESSAGES.YES) {
        //             const w_uri = p_document.uri;
        //             vscode.window.showTextDocument(p_document.uri, { preview: true, preserveFocus: false })
        //                 .then(() =&gt; {
        //                     return vscode.commands.executeCommand('workbench.action.closeActiveEditor');
        //                 })
        //                 .then(() =&gt; {
        //                     this.openLeoFile(w_uri);
        //                 });
        //         }
        //     });
    }
}

</t>
<t tx="ekr.20200815085705.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onButtonsTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {
    if (p_explorerView) {
    } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this.refreshButtonsPane();
    }
}

</t>
<t tx="ekr.20200815085806.1">/**
 * * Refresh tree for 'node hover icons' to show up properly after changing their settings
 */
public configTreeRefresh(): void {
    if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
        this._preventShowBody = true;
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="ekr.20200815085830.1">/**
 * * Refreshes the outline. A reveal type can be passed along to specify the reveal type for the selected node
 * @param p_incrementTreeID Flag meaning for the _treeId counter to be incremented
 * @param p_revealType Facultative reveal type to specify type of reveal when the 'selected node' is encountered
 */
private _refreshOutline(p_incrementTreeID: boolean, p_revealType?: RevealType): void {
    if (p_incrementTreeID) {
        this._treeId++;
    }
    if (typeof p_revealType !== "undefined") {
        // To check if selected node should self-select while redrawing whole tree
        this._revealType = p_revealType; // To be read/cleared (in arrayToLeoNodesArray instead of directly by nodes)
    }
    // Force showing last used Leo outline first
    try {
        if (this.lastSelectedNode &amp;&amp; !(this._leoTreeExView.visible || this._leoTreeView.visible)) {

            this._lastTreeView.reveal(this.lastSelectedNode).then(
                () =&gt; {
                    this._retriedRefresh = false;
                    this._leoTreeProvider.refreshTreeRoot();
                },
                (p_reason) =&gt; {
                    // Reveal failed: retry once.
                    this._leoTreeProvider.refreshTreeRoot();
                }
            );

        } else {
            this._leoTreeProvider.refreshTreeRoot();
        }
    } catch (error) {
        // Also retry once on error
        this._leoTreeProvider.refreshTreeRoot();
    }
}

</t>
<t tx="ekr.20200815085830.2">/**
 * * 'TreeView.reveal' for any opened leo outline that is currently visible
 * @param p_leoNode The node to be revealed
 * @param p_options Options object for the revealed node to either also select it, focus it, and expand it
 * @returns Thenable from the reveal tree node action, resolves directly if no tree visible
 */
private _revealTreeViewNode(
    p_leoNode: LeoNode,
    p_options?: { select?: boolean; focus?: boolean; expand?: boolean | number }
): Thenable&lt;void&gt; {
    let w_treeview: vscode.TreeView&lt;LeoNode&gt; | false = false;
    if (this._leoTreeView.visible) {
        w_treeview = this._leoTreeView;
    }
    if (this._leoTreeExView.visible &amp;&amp; this.config.treeInExplorer) {
        w_treeview = this._leoTreeExView;
    }
    try {
        if (w_treeview) {
            return w_treeview.reveal(p_leoNode, p_options).then(
                () =&gt; {
                    // ok
                    this._retriedRefresh = false;
                },
                (p_reason) =&gt; {
                    if (!this._retriedRefresh) {
                        this._retriedRefresh = true;
                        // Reveal failed. Retry refreshOutline once
                        this._refreshOutline(true, RevealType.RevealSelect);
                    }
                }
            );
        }

    } catch (p_error) {
        console.error("_revealTreeViewNode error: ", p_error);
        // Retry refreshOutline once
        if (!this._retriedRefresh) {
            this._retriedRefresh = true;
            // Reveal failed. Retry refreshOutline once
            this._refreshOutline(true, RevealType.RevealSelect);
        }
    }
    return Promise.resolve(); // Defaults to resolving even if both are hidden
}

</t>
<t tx="ekr.20200815085830.3">/**
 * * Launches refresh for UI components and states
 * @param p_refreshType choose to refresh the outline, or the outline and body pane along with it
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_ap An archived position
 */
public launchRefresh(
    p_refreshType: ReqRefresh,
    p_fromOutline: boolean,
    p_ap?: ArchivedPosition
): void {
    // Set w_revealType, it will ultimately set this._revealType.
    // Used when finding the OUTLINE's selected node and setting or preventing focus into it
    // Set this._fromOutline. Used when finding the selected node and showing the BODY to set or prevent focus in it
    this._refreshType = Object.assign({}, p_refreshType);
    let w_revealType: RevealType;
    if (p_fromOutline) {
        this._fromOutline = true;
        w_revealType = RevealType.RevealSelectFocus;
    } else {
        this._fromOutline = false;
        w_revealType = RevealType.RevealSelect;
    }
    if (
        p_ap &amp;&amp;
        this._refreshType.body &amp;&amp;
        this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty
    ) {
        // When this refresh is launched with 'refresh body' requested, we need to lose any pending edits and save on vscode's side.
        // do this only if gnx is different from what is coming from Leo in this refresh cycle
        if (
            p_ap.gnx !== utils.leoUriToStr(this._bodyLastChangedDocument.uri) &amp;&amp;
            !this._bodyLastChangedDocumentSaved
        ) {
            this._bodyLastChangedDocument.save(); // Voluntarily save to 'clean' any pending body
            this._bodyLastChangedDocumentSaved = true;
        }

        if (p_ap.gnx === utils.leoUriToStr(this._bodyLastChangedDocument.uri)) {
            this._leoFileSystem.preventSaveToLeo = true;
            this._bodyLastChangedDocument.save();
        }
    }
    // * _focusInterrupt insertNode Override
    if (this._focusInterrupt) {
        // this._focusInterrupt = false; // TODO : Test if reverting this in _gotSelection is 'ok'
        w_revealType = RevealType.RevealSelect;
    }
    // * Either the whole tree refreshes, or a single tree node is revealed when just navigating
    if (this._refreshType.tree) {
        this._refreshType.tree = false;
        this._refreshOutline(true, w_revealType);
    } else if (this._refreshType.node &amp;&amp; p_ap) {
        // * Force single node "refresh" by revealing it, instead of "refreshing" it
        this._refreshType.node = false;
        const w_node = this.apToLeoNode(p_ap);
        this.leoStates.setSelectedNodeFlags(w_node);
        this._revealTreeViewNode(w_node, {
            select: true,
            focus: true, // FOCUS FORCED TO TRUE always leave focus on tree when navigating
        });
        if (this._refreshType.body) {
            this._refreshType.body = false;
            this._tryApplyNodeToBody(w_node, false, true); // ! NEEDS STACK AND THROTTLE!
        }
    }
    this.getStates();
}

</t>
<t tx="ekr.20200815085830.5">/**
 * * Handle the selected node that was reached while converting received ap_nodes to LeoNodes
 * @param p_node The selected node that was reached while receiving 'children' from tree view api implementing Leo's outline
 */
private _gotSelection(p_node: LeoNode): void {
    // * Use the 'from outline' concept to decide if focus should be on body or outline after editing a headline
    let w_showBodyKeepFocus: boolean = this._fromOutline; // Will preserve focus where it is without forcing into the body pane if true
    if (this._focusInterrupt) {
        this._focusInterrupt = false;
        w_showBodyKeepFocus = true;
    }
    this._tryApplyNodeToBody(p_node, false, w_showBodyKeepFocus);
}

</t>
<t tx="ekr.20200815090152.1">/**
 * * Makes sure the body now reflects the selected node.
 * This is called after 'selectTreeNode', or after '_gotSelection' when refreshing.
 * @param p_node Node that was just selected
 * @param p_aside Flag to indicate opening 'Aside' was required
 * @param p_showBodyKeepFocus Flag used to keep focus where it was instead of forcing in body
 * @param p_force_open Flag to force opening the body pane editor
 * @returns a text editor of the p_node parameter's gnx (As 'leo' file scheme)
 */
private _tryApplyNodeToBody(
    p_node: LeoNode,
    p_aside: boolean,
    p_showBodyKeepFocus: boolean,
    p_force_open?: boolean
): Thenable&lt;vscode.TextEditor&gt; {
    // console.log('try to apply node -&gt; ', p_node.gnx);

    this.lastSelectedNode = p_node; // Set the 'lastSelectedNode' this will also set the 'marked' node context
    this._commandStack.newSelection(); // Signal that a new selected node was reached and to stop using the received selection as target for next command

    if (this._bodyTextDocument) {
        // if not first time and still opened - also not somewhat exactly opened somewhere.
        if (
            !this._bodyTextDocument.isClosed &amp;&amp;
            !this._locateOpenedBody(p_node.gnx) // LOCATE NEW GNX
        ) {
            // if needs switching by actually having different gnx
            if (utils.leoUriToStr(this.bodyUri) !== p_node.gnx) {
                this._locateOpenedBody(utils.leoUriToStr(this.bodyUri)); // * LOCATE OLD GNX FOR PROPER COLUMN*
                return this._bodyTextDocument.save().then(() =&gt; {
                    return this._switchBody(p_node.gnx, p_aside, p_showBodyKeepFocus);
                });
            }
        }
    } else {
        // first time?
        this.bodyUri = utils.strToLeoUri(p_node.gnx);
    }
    return this.showBody(p_aside, p_showBodyKeepFocus);
}

</t>
<t tx="ekr.20200815090400.1">/**
 * * Tries to add a command to the frontend stack, returns true if added, false otherwise
 * @param p_action A string commands for leobridgeserver.py, from Constants.LEOBRIDGE,
 * @param p_node Specific node to pass as parameter, or the selected node if omitted
 * @param p_refresh Specifies to either refresh nothing, the tree or body and tree when finished
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_text Specific string to pass along as parameter with the action, similar to p_node parameter
 * @returns Promise back from commands execution on leoBridgeServer if added, undefined otherwise
 * (see command stack 'rules' in commandStack.ts)
 */
public nodeCommand(p_userCommand: UserCommand): Promise&lt;LeoBridgePackage&gt; | undefined {
    // No forced vscode save-triggers for direct calls from extension.js
    this.triggerBodySave();
    const q_result = this._commandStack.add(p_userCommand);
    if (q_result) {
        return q_result;
    } else {
        // TODO : Use cleanup message string CONSTANT instead
        vscode.window.showInformationMessage(
            Constants.USER_MESSAGES.TOO_FAST + p_userCommand.action
        );
        return undefined;
    }
}

</t>
<t tx="ekr.20200815090517.1">/**
 * * Invoke an '@button' click directly by index string. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was clicked
 * @returns the launchRefresh promise started after it's done running the 'atButton' command
 */
public clickAtButton(p_node: LeoButtonNode): Promise&lt;boolean&gt; {
    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {

            if (p_node.rclicks.length) {
                // Has rclicks so show menu to choose
                this._rclickSelected = [];

                /* const w_choices: ChooseRClickItem[] = [];
                let w_index = 0;
                w_choices.push(
                    { label: p_node.button.name, picked: true, alwaysShow: true, index: w_index++ },
                    ...p_node.rclicks.map((p_rclick): ChooseRClickItem =&gt; { return { label: p_rclick.name, index: w_index++ }; })
                );

                const w_options: vscode.QuickPickOptions = {
                    placeHolder: Constants.USER_MESSAGES.CHOOSE_BUTTON
                };
                return vscode.window.showQuickPick(w_choices, w_options) */
                return this._handleRClicks(p_node.rclicks, p_node.button.name).then((p_picked) =&gt; {
                    if (
                        p_picked
                    ) {
                        // check if only one in this._rclickSelected and is zero: normal press
                        if (this._rclickSelected.length === 1 &amp;&amp; this._rclickSelected[0] === 0) {
                            // Normal button
                            return this.sendAction(
                                Constants.LEOBRIDGE.CLICK_BUTTON,
                                JSON.stringify({ index: p_node.button.index })
                            );
                        }
                        // if not decrement first one, and send this._rclickSelected as array of choices
                        this._rclickSelected[0] = this._rclickSelected[0] - 1;
                        return this.sendAction(
                            Constants.LEOBRIDGE.CLICK_BUTTON,
                            JSON.stringify({ index: p_node.button.index, rclick: this._rclickSelected })
                        );
                    }
                    // Escaped
                    return Promise.reject();
                });


            } else {
                // Normal button
                return this.sendAction(
                    Constants.LEOBRIDGE.CLICK_BUTTON,
                    JSON.stringify({ index: p_node.button.index })
                );
            }
        })
        .then((p_clickButtonResult: LeoBridgePackage) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.DO_NOTHING);
        })
        .then((p_package) =&gt; {
            // refresh and reveal selection
            this.launchRefresh({ tree: true, body: true, states: true, buttons: true, documents: true }, false, p_package.node);
            return Promise.resolve(true); // TODO launchRefresh should be a returned promise
        });
}

</t>
<t tx="ekr.20200815090517.2">/**
 * * Removes an '@button' from Leo's button dict, directly by index string. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was chosen to remove
 * @returns the launchRefresh promise started after it's done removing the button
 */
public removeAtButton(p_node: LeoButtonNode): Promise&lt;boolean&gt; {
    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {
            return this.sendAction(
                Constants.LEOBRIDGE.REMOVE_BUTTON,
                JSON.stringify({ index: p_node.button.index })
            );
        })
        .then((p_removeButtonResult: LeoBridgePackage) =&gt; {
            this.launchRefresh({ buttons: true }, false);
            return Promise.resolve(true); // TODO launchRefresh should be a returned promise
        });
}

</t>
<t tx="ekr.20200815091220.1">/**
 * * Splits the received data into lines and parses output to detect server start event
 * * Otherwise just outputs lines to the terminal Output
 * @param p_data Data object (not pure string)
 */
private _processServerOutput(p_data: string): void {
    let w_dataString = p_data.toString().replace(/\n$/, ""); // remove last
    w_dataString.toString().split("\n").forEach(p_line =&gt; {
        if (true || p_line) { // ? std out process line by line: json shouldn't have line breaks
            if (p_line.startsWith(Constants.SERVER_STARTED_TOKEN)) {
                if (this._resolvePromise &amp;&amp; !this._isStarted) {
                    this._isStarted = true;
                    this._resolvePromise(p_line); // * Server confirmed started
                }
            }
            this._leoIntegration.addLogPaneEntry(p_line); // Output message anyways
        }
    });
}

</t>
<t tx="ekr.20200815091408.1">/**
 * * Object sent back from leoInteg's 'getStates' command
 */
export interface LeoPackageStates {
    changed: boolean; // Leo document has changed (is dirty)
    canUndo: boolean; // Leo document can undo the last operation done
    canRedo: boolean; // Leo document can redo the last operation 'undone'
    canDemote: boolean; // Currently selected node can have its siblings demoted
    canPromote: boolean; // Currently selected node can have its children promoted
    canDehoist: boolean; // Leo Document is currently hoisted and can be de-hoisted
}

</t>
<t tx="ekr.20200815091619.1">/**
 * * Builds a string hash out of of an archived position, default without taking collapsed state into account
 * @param p_ap Archived position
 * @param p_salt To be added to the hashing process (Change when tree changes)
 */
export function hashNode(p_ap: ArchivedPosition, p_salt: string, p_withCollapse?: boolean): string {
    const w_string1: string = p_ap.headline + p_ap.gnx + p_ap.childIndex.toString(36);
    const w_string2: string = w_string1 + p_ap.childIndex.toString(36) + JSON.stringify(p_ap.stack);
    const w_first: string = murmur.murmur3(w_string2).toString(36);
    if (p_withCollapse) {
        p_salt += p_ap.expanded ? "1" : "0";
    }
    return p_salt + w_string1 + w_first + murmur.murmur3(w_first + w_string2).toString(36);
}

</t>
<t tx="ekr.20200815091945.1">/**
 * * Build all possible strings for buttons icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildButtonsIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON_RCLICK),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON_RCLICK)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON_ADD),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON_ADD)
        }
    ];
}

</t>
<t tx="ekr.20200815113156.1">// * Define entries for all commands
[CMD.MINIBUFFER, () =&gt; w_leo.minibuffer()], // Is referenced in package.json
[CMD.STATUS_BAR, () =&gt; w_leo.statusBarOnClick()],
[CMD.EXECUTE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXECUTE_SCRIPT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],

[CMD.CLICK_BUTTON, (p_node: LeoButtonNode) =&gt; w_leo.clickAtButton(p_node)], // Not referenced in package.json
[CMD.GOTO_SCRIPT, (p_node: LeoButtonNode) =&gt; w_leo.gotoScript(p_node)],
[CMD.REMOVE_BUTTON, (p_node: LeoButtonNode) =&gt; w_leo.removeAtButton(p_node)],

[CMD.CLOSE_FILE, () =&gt; w_leo.closeLeoFile()],
[CMD.NEW_FILE, () =&gt; w_leo.newLeoFile()],

[CMD.OPEN_FILE, (p_uri?: vscode.Uri) =&gt; w_leo.openLeoFile(p_uri)],
[CMD.IMPORT_ANY_FILE, () =&gt; w_leo.importAnyFile()], // No URL passed from the command definition.

[CMD.CLEAR_RECENT_FILES, () =&gt; w_leo.clearRecentLeoFiles()],
[CMD.RECENT_FILES, () =&gt; w_leo.showRecentLeoFiles()],
[CMD.SAVE_AS_FILE, () =&gt; w_leo.saveAsLeoFile()],
[CMD.SAVE_AS_LEOJS, () =&gt; w_leo.saveAsLeoJsFile()],
[CMD.SAVE_FILE, () =&gt; w_leo.saveLeoFile()],
// [CMD.SAVE_DISABLED, () =&gt; { }],
[CMD.SAVE_FILE_FO, () =&gt; w_leo.saveLeoFile(true)],
[CMD.SWITCH_FILE, () =&gt; w_leo.switchLeoFile()],

[CMD.SET_OPENED_FILE, (p_index: number) =&gt; w_leo.selectOpenedLeoDocument(p_index)],

[CMD.REFRESH_FROM_DISK, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.REFRESH_FROM_DISK_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: false
})],
[CMD.REFRESH_FROM_DISK_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REFRESH_FROM_DISK_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.REFRESH_FROM_DISK_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REFRESH_FROM_DISK_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.WRITE_AT_FILE_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.WRITE_AT_FILE_NODES,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.WRITE_AT_FILE_NODES_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.WRITE_AT_FILE_NODES,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],
[CMD.WRITE_DIRTY_AT_FILE_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.WRITE_DIRTY_AT_FILE_NODES,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.WRITE_DIRTY_AT_FILE_NODES_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.WRITE_DIRTY_AT_FILE_NODES,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.GIT_DIFF, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GIT_DIFF,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],

[CMD.HEADLINE, (p_node: LeoNode) =&gt; w_leo.editHeadline(p_node, true)],
[CMD.HEADLINE_SELECTION, () =&gt; w_leo.editHeadline(U, false)],
[CMD.HEADLINE_SELECTION_FO, () =&gt; w_leo.editHeadline(U, true)],

// cut/copy/paste/delete given node.
[CMD.COPY, (p_node: LeoNode) =&gt; w_leo.copyNode(p_node, true)],
[CMD.CUT, (p_node: LeoNode) =&gt; w_leo.cutNode(p_node, true)],

[CMD.DELETE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.PASTE, (p_node: LeoNode) =&gt; w_leo.pasteNode(p_node, true)],
[CMD.PASTE_CLONE, (p_node: LeoNode) =&gt; w_leo.pasteAsCloneNode(p_node, true)],

// cut/copy/paste/delete current selection (self.commander.p)
[CMD.COPY_SELECTION, () =&gt; w_leo.copyNode(U, false)],
[CMD.CUT_SELECTION, () =&gt; w_leo.cutNode(U, false)],
[CMD.CUT_SELECTION_FO, () =&gt; w_leo.cutNode(U, true)],

[CMD.DELETE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.DELETE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.PASTE_SELECTION, () =&gt; w_leo.pasteNode(U, false)],
[CMD.PASTE_SELECTION_FO, () =&gt; w_leo.pasteNode(U, true)],
[CMD.PASTE_CLONE_SELECTION, () =&gt; w_leo.pasteAsCloneNode(U, false)],
[CMD.PASTE_CLONE_SELECTION_FO, () =&gt; w_leo.pasteAsCloneNode(U, true)],

[CMD.CONTRACT_ALL, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.CONTRACT_ALL_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.CONTRACT_OR_GO_LEFT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_OR_GO_LEFT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.EXPAND_AND_GO_RIGHT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXPAND_AND_GO_RIGHT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.GOTO_NEXT_CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: p_node,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_NEXT_CLONE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: false
})],
[CMD.GOTO_NEXT_CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],

[CMD.GOTO_NEXT_MARKED, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_MARKED,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_FIRST_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_FIRST_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_LAST_SIBLING, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_LAST_SIBLING,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_LAST_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_LAST_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_NEXT_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_PREV_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_PREV_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],

[CMD.PAGE_UP, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PAGE_UP,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.PAGE_DOWN, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PAGE_DOWN,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],

[CMD.DEHOIST, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEHOIST,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.DEHOIST_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEHOIST,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.HOIST, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.HOIST_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.HOIST_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.CLONE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.INSERT, (p_node: LeoNode) =&gt; w_leo.insertNode(p_node, true, false)],
[CMD.INSERT_SELECTION, () =&gt; w_leo.insertNode(U, false, false)],
[CMD.INSERT_SELECTION_FO, () =&gt; w_leo.insertNode(U, true, false)],
[CMD.INSERT_CHILD, (p_node: LeoNode) =&gt; w_leo.insertNode(p_node, true, true)],
[CMD.INSERT_CHILD_SELECTION, () =&gt; w_leo.insertNode(U, false, true)],
[CMD.INSERT_CHILD_SELECTION_FO, () =&gt; w_leo.insertNode(U, true, true)],

// Special command for when inserting rapidly more than one node without
// even specifying a headline label, such as spamming CTRL+I rapidly.
[CMD.INSERT_SELECTION_INTERRUPT, () =&gt; w_leo.insertNode(U, false, false, true)],
[CMD.INSERT_CHILD_SELECTION_INTERRUPT, () =&gt; w_leo.insertNode(U, false, true, true)],

[CMD.MARK, (p_node: LeoNode) =&gt; w_leo.changeMark(true, p_node, true)],
[CMD.MARK_SELECTION, () =&gt; w_leo.changeMark(true, U, false)],
[CMD.MARK_SELECTION_FO, () =&gt; w_leo.changeMark(true, U, true)],

[CMD.UNMARK, (p_node: LeoNode) =&gt; w_leo.changeMark(false, p_node, true)],
[CMD.UNMARK_SELECTION, () =&gt; w_leo.changeMark(false, U, false)],
[CMD.UNMARK_SELECTION_FO, () =&gt; w_leo.changeMark(false, U, true)],

[CMD.EXTRACT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXTRACT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.EXTRACT_NAMES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXTRACT_NAMES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],

[CMD.MOVE_DOWN, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_DOWN_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_DOWN_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.MOVE_LEFT, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_LEFT_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_LEFT_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.MOVE_RIGHT, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_RIGHT_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_RIGHT_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.MOVE_UP, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_UP_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_UP_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.DEMOTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.DEMOTE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.DEMOTE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],
[CMD.PROMOTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.PROMOTE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.PROMOTE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.SORT_CHILDREN, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_CHILDREN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false,
    keepSelection: true
})],
[CMD.SORT_CHILDREN_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_CHILDREN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true,
    keepSelection: true
})],
[CMD.SORT_SIBLING, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_SIBLINGS,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false,
    keepSelection: true
})],
[CMD.SORT_SIBLING_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_SIBLINGS,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true,
    keepSelection: true
})],

[CMD.REDO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.REDO_DISABLED, () =&gt; { }],
[CMD.REDO_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.UNDO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.UNDO_DISABLED, () =&gt; { }],
[CMD.UNDO_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.CONNECT, () =&gt; w_leo.connect()],
[CMD.START_SERVER, () =&gt; w_leo.startServer()],
[CMD.STOP_SERVER, () =&gt; w_leo.killServer()],
[CMD.CHOOSE_LEO_FOLDER, () =&gt; w_leo.chooseLeoFolder()],

// Called by nodes in tree when selected either by mouse, or with enter
[CMD.SELECT_NODE, (p_node: LeoNode) =&gt; w_leo.selectTreeNode(p_node, false, false)],
[CMD.OPEN_ASIDE, (p_node: LeoNode) =&gt; w_leo.selectTreeNode(p_node, false, true)],

[CMD.SHOW_OUTLINE, () =&gt; w_leo.showOutline(true)], // Also focuses on outline

[CMD.SHOW_LOG, () =&gt; w_leo.showLogPane()],
[CMD.SHOW_BODY, () =&gt; w_leo.showBody(false)], // Also focuses on body

[CMD.SHOW_WELCOME, () =&gt; w_leoSettingsWebview.openWebview()],
[CMD.SHOW_SETTINGS, () =&gt; w_leoSettingsWebview.openWebview()], // Same as SHOW_WELCOME

[CMD.COPY_MARKED, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.COPY_MARKED,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.DIFF_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DIFF_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.MARK_CHANGED_ITEMS, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MARK_CHANGED_ITEMS,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.MARK_SUBHEADS, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MARK_SUBHEADS,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.UNMARK_ALL, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNMARK_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.CLONE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.DELETE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.MOVE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.PREV_NODE, () =&gt; w_leo.prevNextNode(false)],
[CMD.PREV_NODE_FO, () =&gt; w_leo.prevNextNode(false)],
[CMD.NEXT_NODE, () =&gt; w_leo.prevNextNode(true)],
[CMD.NEXT_NODE_FO, () =&gt; w_leo.prevNextNode(true)],

[CMD.FIND_QUICK, () =&gt; w_leo.findQuick()],
[CMD.FIND_QUICK_SELECTED, () =&gt; w_leo.findQuickSelected()],
[CMD.FIND_QUICK_TIMELINE, () =&gt; w_leo.findQuickTimeline()],
[CMD.FIND_QUICK_CHANGED, () =&gt; w_leo.findQuickChanged()],
[CMD.FIND_QUICK_HISTORY, () =&gt; w_leo.findQuickHistory()],
[CMD.FIND_QUICK_MARKED, () =&gt; w_leo.findQuickMarked()],
[CMD.FIND_QUICK_GO_ANYWHERE, () =&gt; w_leo.findQuickGoAnywhere()],
[CMD.GOTO_NAV_ENTRY, (p_node: LeoGotoNode) =&gt; w_leo.gotoNavEntry(p_node)],

[CMD.START_SEARCH, () =&gt; w_leo.startSearch()],
[CMD.FIND_ALL, () =&gt; w_leo.findAll(false)],
[CMD.FIND_NEXT, () =&gt; w_leo.find(false, false)],
[CMD.FIND_NEXT_FO, () =&gt; w_leo.find(true, false)],
[CMD.FIND_PREVIOUS, () =&gt; w_leo.find(false, true)],
[CMD.FIND_PREVIOUS_FO, () =&gt; w_leo.find(true, true)],
[CMD.FIND_VAR, () =&gt; w_leo.findSymbol(false)],
[CMD.FIND_DEF, () =&gt; w_leo.findSymbol(true)],
[CMD.REPLACE, () =&gt; w_leo.replace(false, false)],
[CMD.REPLACE_FO, () =&gt; w_leo.replace(true, false)],
[CMD.REPLACE_THEN_FIND, () =&gt; w_leo.replace(false, true)],
[CMD.REPLACE_THEN_FIND_FO, () =&gt; w_leo.replace(true, true)],
[CMD.REPLACE_ALL, () =&gt; w_leo.findAll(true)],
[CMD.GOTO_GLOBAL_LINE, () =&gt; w_leo.gotoGlobalLine()],
[CMD.TAG_CHILDREN, () =&gt; w_leo.tagChildren()],
[CMD.TAG_NODE, () =&gt; w_leo.tagNode()],
[CMD.REMOVE_TAGS, () =&gt; w_leo.removeTags()],

[CMD.CLONE_FIND_ALL, () =&gt; w_leo.cloneFind(false, false)],
[CMD.CLONE_FIND_ALL_FLATTENED, () =&gt; w_leo.cloneFind(false, true)],
[CMD.CLONE_FIND_TAG, () =&gt; w_leo.cloneFindTag()],
[CMD.CLONE_FIND_MARKED, () =&gt; w_leo.cloneFind(true, false)],
[CMD.CLONE_FIND_FLATTENED_MARKED, () =&gt; w_leo.cloneFind(true, true)],

[CMD.SET_FIND_EVERYWHERE_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.ENTIRE_OUTLINE)],
[CMD.SET_FIND_NODE_ONLY_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.NODE_ONLY)],
[CMD.SET_FIND_SUBOUTLINE_ONLY_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.SUBOUTLINE_ONLY)],
[CMD.TOGGLE_FIND_IGNORE_CASE_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.IGNORE_CASE)],
[CMD.TOGGLE_FIND_MARK_CHANGES_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.MARK_CHANGES)],
[CMD.TOGGLE_FIND_MARK_FINDS_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.MARK_FINDS)],
[CMD.TOGGLE_FIND_REGEXP_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.REG_EXP)],
[CMD.TOGGLE_FIND_WORD_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.WHOLE_WORD)],
[CMD.TOGGLE_FIND_SEARCH_BODY_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.SEARCH_BODY)],
[CMD.TOGGLE_FIND_SEARCH_HEADLINE_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.SEARCH_HEADLINE)],

[CMD.SET_ENABLE_PREVIEW, () =&gt; w_leo.config.setEnablePreview()],
[CMD.CLEAR_CLOSE_EMPTY_GROUPS, () =&gt; w_leo.config.clearCloseEmptyGroups()],
[CMD.SET_CLOSE_ON_FILE_DELETE, () =&gt; w_leo.config.setCloseOnFileDelete()],
</t>
<t tx="ekr.20200815113508.1">@language python
g.cls()

def is_significant(p):
    s = p.b
    for ch in '()[]{};':
        s = s.replace(ch, '')
    return s.strip()

for p in c.all_unique_positions():
    if not is_significant(p) and not p.hasChildren():
        print(p.h)
print('done')

</t>
<t tx="ekr.20200815123601.1">@language json
@tabwidth -2
{
  "name": "leointeg",
  "displayName": "Leo Editor Integration with Visual Studio Code",
  "description": "Use Leo, the literate editor with outline, directly in vscode.",
  "version": "1.0.7",
  "author": {
    "name": "Félix"
  },
  "publisher": "boltex",
  "license": "SEE LICENSE IN LICENSE",
  "repository": {
    "type": "git",
    "url": "https://github.com/boltex/leointeg"
  },
  "engines": {
    "vscode": "^1.64.0"
  },
  "keywords": [
    "leo",
    "literate",
    "tree",
    "outline",
    "programming"
  ],
  "categories": [
    "Other"
  ],
  "activationEvents": [
    "onStartupFinished"
  ],
  "qna": false,
  "main": "./dist/extension",
  "icon": "resources/leoapp128px.png",
  "galleryBanner": {
    "color": "#fff3dc",
    "theme": "light"
  },
  "contributes": {
    @others
  },
  "scripts": {
    "vscode:prepublish": "webpack --mode production",
    "webpack": "webpack --mode development",
    "webpack-dev": "webpack --mode development --watch",
    "test-compile": "tsc -p ./",
    "lint": "tslint -p ./"
  },
  "devDependencies": {
    "@types/debounce": "^1.2.0",
    "@types/glob": "^7.1.3",
    "@types/mocha": "^7.0.2",
    "@types/murmurhash-js": "^1.0.3",
    "@types/node": "^14.11.2",
    "@types/vscode": "^1.64.0",
    "@types/ws": "^7.2.6",
    "clean-webpack-plugin": "^3.0.0",
    "csp-html-webpack-plugin": "^4.0.0",
    "css-loader": "^3.5.3",
    "eslint": "^7.9.0",
    "fork-ts-checker-webpack-plugin": "^4.1.6",
    "glob": "^7.1.6",
    "html-loader": "^1.1.0",
    "html-webpack-exclude-assets-plugin": "0.0.7",
    "html-webpack-plugin": "^3.2.0",
    "imagemin-webpack-plugin": "^2.4.2",
    "mini-css-extract-plugin": "^0.9.0",
    "mocha": "^7.2.0",
    "node-sass": "^4.14.1",
    "sass-loader": "^8.0.2",
    "ts-loader": "^7.0.5",
    "tslint": "^6.1.3",
    "typescript": "^3.9.7",
    "vscode-test": "^1.4.0",
    "webpack": "^4.44.2",
    "webpack-cli": "^3.3.12"
  },
  "dependencies": {
    "bufferutil": "^4.0.1",
    "debounce": "^1.2.0",
    "hasbin": "^1.2.3",
    "murmurhash-js": "^1.0.0",
    "portfinder": "^1.0.28",
    "tree-kill": "^1.2.2",
    "ws": "^7.4.6"
  }
}
</t>
<t tx="ekr.20200815123601.10">"languages": [
  {
    "id": "leobody.plain",
    "aliases": [
      "Leo Body Plain",
      "leobody"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.plain.language-configuration.json"
  },
  {
    "id": "leobody.python",
    "aliases": [
      "Leo Body Python",
      "leobody.python"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.python.language-configuration.json"
  },
  {
    "id": "leobody.typescript",
    "aliases": [
      "Leo Body Typescript",
      "leobody.typescript"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.typescript.language-configuration.json"
  },
  {
    "id": "leobody.javascript",
    "aliases": [
      "Leo Body Javascript",
      "leobody.javascript"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.javascript.language-configuration.json"
  },
  {
    "id": "leobody.c",
    "aliases": [
      "Leo Body c",
      "leobody.c"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.c.language-configuration.json"
  },
  {
    "id": "leobody.cpp",
    "aliases": [
      "Leo Body C++",
      "leobody.cpp"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.cpp.language-configuration.json"
  },
  {
    "id": "leobody.css",
    "aliases": [
      "Leo Body CSS",
      "leobody.css"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.css.language-configuration.json"
  },
  {
    "id": "leobody.fortran",
    "aliases": [
      "Leo Body Fortran",
      "leobody.fortran"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.fortran.language-configuration.json"
  },
  {
    "id": "leobody.fortran90",
    "aliases": [
      "Leo Body Fortran90",
      "leobody.fortran90"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.fortran.language-configuration.json"
  },
  {
    "id": "leobody.html",
    "aliases": [
      "Leo Body HTML",
      "leobody.html"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.html.language-configuration.json"
  },
  {
    "id": "leobody.java",
    "aliases": [
      "Leo Body Java",
      "leobody.java"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.java.language-configuration.json"
  },
  {
    "id": "leobody.json",
    "aliases": [
      "Leo Body Json",
      "leobody.json"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.json.language-configuration.json"
  },
  {
    "id": "leobody.markdown",
    "aliases": [
      "Leo Body Markdown",
      "leobody.markdown"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.markdown.language-configuration.json"
  },
  {
    "id": "leobody.php",
    "aliases": [
      "Leo Body PHP",
      "leobody.php"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.php.language-configuration.json"
  },
  {
    "id": "leobody.restructuredtext",
    "aliases": [
      "Leo Body reStructuredText",
      "leobody.restructuredtext"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.rst.language-configuration.json"
  },
  {
    "id": "leobody.rust",
    "aliases": [
      "Leo Body Rust",
      "leobody.rust"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.rust.language-configuration.json"
  }
],
</t>
<t tx="ekr.20200815123601.11">"grammars": [
  {
    "language": "leobody.plain",
    "scopeName": "source.leobody.plain",
    "path": "./syntaxes/leobody.plain.tmLanguage.json"
  },
  {
    "language": "leobody.python",
    "scopeName": "source.leobody.python",
    "path": "./syntaxes/leobody.python.tmLanguage.json"
  },
  {
    "language": "leobody.typescript",
    "scopeName": "source.leobody.typescript",
    "path": "./syntaxes/leobody.typescript.tmLanguage.json"
  },
  {
    "language": "leobody.javascript",
    "scopeName": "source.leobody.javascript",
    "path": "./syntaxes/leobody.javascript.tmLanguage.json"
  },
  {
    "language": "leobody.c",
    "scopeName": "source.leobody.c",
    "path": "./syntaxes/leobody.c.tmLanguage.json"
  },
  {
    "language": "leobody.cpp",
    "scopeName": "source.leobody.cpp",
    "path": "./syntaxes/leobody.cpp.tmLanguage.json"
  },
  {
    "language": "leobody.css",
    "scopeName": "source.leobody.css",
    "path": "./syntaxes/leobody.css.tmLanguage.json"
  },
  {
    "language": "leobody.fortran",
    "scopeName": "source.leobody.fortran",
    "path": "./syntaxes/leobody.fortran.tmLanguage.json"
  },
  {
    "language": "leobody.fortran90",
    "scopeName": "source.leobody.fortran90",
    "path": "./syntaxes/leobody.fortran90.tmLanguage.json"
  },
  {
    "language": "leobody.html",
    "scopeName": "source.leobody.html",
    "path": "./syntaxes/leobody.html.tmLanguage.json"
  },
  {
    "language": "leobody.java",
    "scopeName": "source.leobody.java",
    "path": "./syntaxes/leobody.java.tmLanguage.json"
  },
  {
    "language": "leobody.json",
    "scopeName": "source.leobody.json",
    "path": "./syntaxes/leobody.json.tmLanguage.json"
  },
  {
    "language": "leobody.markdown",
    "scopeName": "source.leobody.markdown",
    "path": "./syntaxes/leobody.markdown.tmLanguage.json"
  },
  {
    "language": "leobody.php",
    "scopeName": "source.leobody.php",
    "path": "./syntaxes/leobody.php.tmLanguage.json"
  },
  {
    "language": "leobody.restructuredtext",
    "scopeName": "source.leobody.restructuredtext",
    "path": "./syntaxes/leobody.rst.tmLanguage.json"
  },
  {
    "language": "leobody.rust",
    "scopeName": "source.leobody.rust",
    "path": "./syntaxes/leobody.rust.tmLanguage.json"
  },
  {
    "injectTo": [
      "source.leobody.c",
      "source.leobody.cpp",
      "source.leobody.css",
      "source.leobody.fortran",
      "source.leobody.fortran90",
      "source.leobody.html",
      "source.leobody.java",
      "source.leobody.javascript",
      "source.leobody.json",
      "source.leobody.markdown",
      "source.leobody.php",
      "source.leobody.plain",
      "source.leobody.python",
      "source.leobody.restructuredtext",
      "source.leobody.rust",
      "source.leobody.typescript"
    ],
    "path": "./syntaxes/leobody.tmLanguage.json",
    "scopeName": "leo.injection"
  }
],
</t>
<t tx="ekr.20200815123601.12">"snippets": [
  {
    "language": "leobody.c",
    "path": "./snippets/c.code-snippets"
  },
  {
    "language": "leobody.cpp",
    "path": "./snippets/cpp.code-snippets"
  },
  {
    "language": "leobody.fortran90",
    "path": "./snippets/fortran90.code-snippets"
  },
  {
    "language": "leobody.javascript",
    "path": "./snippets/javascript.code-snippets"
  },
  {
    "language": "leobody.typescript",
    "path": "./snippets/typescript.code-snippets"
  },
  {
    "language": "leobody.java",
    "path": "./snippets/java.code-snippets"
  },
  {
    "language": "leobody.php",
    "path": "./snippets/php.code-snippets"
  },
  {
    "language": "leobody.markdown",
    "path": "./snippets/markdown.code-snippets"
  },
  {
    "language": "leobody.restructuredtext",
    "path": "./snippets/restructuredtext.code-snippets"
  },
  {
    "language": "leobody.rust",
    "path": "./snippets/rust.code-snippets"
  }
],
</t>
<t tx="ekr.20200815123601.13">"commands": [
  @others
],
</t>
<t tx="ekr.20200815123601.15">{
  "command": "leointeg.setEnablePreview",
  "category": "Leo",
  "title": "Set Enable-Preview"
},
{
  "command": "leointeg.clearCloseEmptyGroups",
  "category": "Leo",
  "title": "Clear Close-Empty-Groups"
},
{
  "command": "leointeg.setCloseOnFileDelete",
  "category": "Leo",
  "title": "Set Close-On-File-Delete"
},
{
  "command": "leointeg.showSettingsPage",
  "title": "Open Settings",
  "category": "Leo",
  "icon": {
    "light": "resources/light/gear.svg",
    "dark": "resources/dark/gear.svg"
  }
},
{
  "command": "leointeg.showWelcomePage",
  "title": "Welcome",
  "category": "Leo"
},
</t>
<t tx="ekr.20200815123601.16">{
  "command": "leointeg.chooseLeoFolder",
  "title": "Choose Leo Installation Folder",
  "shortTitle": "Set Leo Folder",
  "category": "Leo"
},
{
  "command": "leointeg.startServer",
  "category": "Leo",
  "title": "Start a Leo Server",
  "icon": {
    "light": "resources/light/start-server.svg",
    "dark": "resources/dark/start-server.svg"
  }
},
{
  "command": "leointeg.stopServer",
  "category": "Leo",
  "title": "Stop the Leo Server",
  "icon": {
    "light": "resources/light/close-server.svg",
    "dark": "resources/dark/close-server.svg"
  }
},
{
  "command": "leointeg.connectToServer",
  "title": "Connect to a Leo Server",
  "category": "Leo",
  "icon": {
    "light": "resources/light/connect.svg",
    "dark": "resources/dark/connect.svg"
  }
},
</t>
<t tx="ekr.20200815123601.17">{
  "command": "leointeg.executeScript",
  "title": "Execute Script",
  "category": "Leo",
  "icon": {
    "light": "resources/light/execute.svg",
    "dark": "resources/dark/execute.svg"
  }
},
{
  "command": "leointeg.statusBar",
  "category": "Leo",
  "title": "Statusbar Click"
},
{
  "command": "leointeg.minibuffer",
  "category": "Leo",
  "title": "Minibuffer"
},
{
  "command": "leointeg.gotoScript",
  "category": "Leo",
  "title": "Goto Script"
},
{
  "command": "leointeg.removeButton",
  "category": "Leo",
  "title": "Remove Button"
},
</t>
<t tx="ekr.20200815123601.18">{
  "command": "leointeg.showBody",
  "category": "Leo",
  "title": "Focus on Body"
},
{
  "command": "leointeg.showOutline",
  "category": "Leo",
  "title": "Focus on Tree"
},
{
  "command": "leointeg.showLogPane",
  "category": "Leo",
  "title": "Show Log Pane",
  "icon": {
    "light": "resources/light/show-log.svg",
    "dark": "resources/dark/show-log.svg"
  }
},
</t>
<t tx="ekr.20200815123601.19">{
  "command": "leointeg.openLeoFile",
  "title": "Open Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/folder.svg",
    "dark": "resources/dark/folder.svg"
  }
},
{
  "command": "leointeg.importAnyFile",
  "title": "Import File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/import.svg",
    "dark": "resources/dark/import.svg"
  }
},
{
  "command": "leointeg.clearRecentFiles",
  "category": "Leo",
  "title": "Clear Recent Files",
  "icon": {
    "light": "resources/light/clear-files.svg",
    "dark": "resources/dark/clear-files.svg"
  }
},
{
  "command": "leointeg.recentLeoFiles",
  "category": "Leo",
  "title": "Recent Files"
},
{
  "command": "leointeg.switchLeoFile",
  "title": "Switch Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/switch.svg",
    "dark": "resources/dark/switch.svg"
  }
},
{
  "command": "leointeg.newLeoFile",
  "title": "New Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/new-file.svg",
    "dark": "resources/dark/new-file.svg"
  }
},
{
  "command": "leointeg.closeLeoFile",
  "title": "Close Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leointeg.saveLeoFile",
  "category": "Leo",
  "title": "Save Leo File",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leointeg.saveLeoFileFromOutline",
  "category": "Leo",
  "title": "Save Leo File",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leointeg.saveAsLeoFile",
  "category": "Leo",
  "title": "Save Leo File as...",
  "icon": {
    "light": "resources/light/save-as.svg",
    "dark": "resources/dark/save-as.svg"
  }
},
{
  "command": "leointeg.saveAsLeoJsFile",
  "category": "Leo",
  "title": "Save as leojs JSON File...",
  "icon": {
    "light": "resources/light/save-as-leojs.svg",
    "dark": "resources/dark/save-as-leojs.svg"
  }
},
{
  "command": "leointeg.refreshFromDisk",
  "category": "Leo",
  "title": "Refresh from Disk",
  "icon": {
    "light": "resources/light/refresh.svg",
    "dark": "resources/dark/refresh.svg"
  }
},
{
  "command": "leointeg.refreshFromDiskSelection",
  "category": "Leo",
  "title": "Refresh from Disk",
  "icon": {
    "light": "resources/light/refresh.svg",
    "dark": "resources/dark/refresh.svg"
  }
},
{
  "command": "leointeg.refreshFromDiskSelectionFromOutline",
  "category": "Leo",
  "title": "Refresh from Disk",
  "icon": {
    "light": "resources/light/refresh.svg",
    "dark": "resources/dark/refresh.svg"
  }
},
{
  "command": "leointeg.writeAtFileNodes",
  "category": "Leo",
  "title": "Write @&lt;file&gt; Nodes"
},
{
  "command": "leointeg.writeAtFileNodesFromOutline",
  "category": "Leo",
  "title": "Write @&lt;file&gt; Nodes"
},
{
  "command": "leointeg.writeDirtyAtFileNodes",
  "category": "Leo",
  "title": "Write Dirty @&lt;file&gt; Nodes"
},
{
  "command": "leointeg.writeDirtyAtFileNodesFromOutline",
  "category": "Leo",
  "title": "Write Dirty @&lt;file&gt; Nodes"
},
{
  "command": "leointeg.gitDiff",
  "category": "Leo",
  "title": "Git Diff"
},
</t>
<t tx="ekr.20200815123601.2">"configuration": {
  "title": "Leo Integration — Use 'Leo: Open Settings' for a richer, interactive experience",
  "properties": {
    @others
  }
},
</t>
<t tx="ekr.20200815123601.20">{
  "command": "leointeg.openAside",
  "category": "Leo",
  "title": "Open to the Side"
},
{
  "command": "leointeg.contractAll",
  "category": "Leo",
  "title": "Contract All",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
{
  "command": "leointeg.contractAllFromOutline",
  "category": "Leo",
  "title": "Contract All",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
{
  "command": "leointeg.prev",
  "category": "Leo",
  "title": "Prev",
  "icon": {
    "light": "resources/light/prev.svg",
    "dark": "resources/dark/prev.svg"
  }
},
{
  "command": "leointeg.prevFromOutline",
  "category": "Leo",
  "title": "Prev",
  "icon": {
    "light": "resources/light/prev.svg",
    "dark": "resources/dark/prev.svg"
  }
},
{
  "command": "leointeg.next",
  "category": "Leo",
  "title": "Next",
  "icon": {
    "light": "resources/light/next.svg",
    "dark": "resources/dark/next.svg"
  }
},
{
  "command": "leointeg.nextFromOutline",
  "category": "Leo",
  "title": "Next",
  "icon": {
    "light": "resources/light/next.svg",
    "dark": "resources/dark/next.svg"
  }
},
</t>
<t tx="ekr.20200815123601.21">{
  "command": "leointeg.editHeadline",
  "category": "Leo",
  "title": "Edit Headline",
  "icon": {
    "light": "resources/light/edit.svg",
    "dark": "resources/dark/edit.svg"
  }
},
{
  "command": "leointeg.editSelectedHeadline",
  "category": "Leo",
  "title": "Edit Headline"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "category": "Leo",
  "title": "Edit Headline"
},
{
  "command": "leointeg.copyNode",
  "category": "Leo",
  "title": "Copy Node",
  "icon": {
    "light": "resources/light/clipboard.svg",
    "dark": "resources/dark/clipboard.svg"
  }
},
{
  "command": "leointeg.copyNodeSelection",
  "category": "Leo",
  "title": "Copy Node",
  "icon": {
    "light": "resources/light/clipboard.svg",
    "dark": "resources/dark/clipboard.svg"
  }
},
{
  "command": "leointeg.cutNode",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.cutNodeSelection",
  "category": "Leo",
  "title": "Cut Node",
  "icon": {
    "light": "resources/light/cut.svg",
    "dark": "resources/dark/cut.svg"
  }
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.pasteNode",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "category": "Leo",
  "title": "Paste Node",
  "icon": {
    "light": "resources/light/paste.svg",
    "dark": "resources/dark/paste.svg"
  }
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAsClone",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelection",
  "category": "Leo",
  "title": "Paste Node as Clone",
  "icon": {
    "light": "resources/light/paste-clone.svg",
    "dark": "resources/dark/paste-clone.svg"
  }
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.delete",
  "category": "Leo",
  "title": "Delete",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leointeg.deleteSelection",
  "category": "Leo",
  "title": "Delete Node",
  "icon": {
    "light": "resources/light/delete.svg",
    "dark": "resources/dark/delete.svg"
  }
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "category": "Leo",
  "title": "Delete Node"
},
</t>
<t tx="ekr.20200815123601.22">{
  "command": "leointeg.moveOutlineDown",
  "category": "Leo",
  "title": "Move Outline Down",
  "icon": {
    "light": "resources/light/arrow-down.svg",
    "dark": "resources/dark/arrow-down.svg"
  }
},
{
  "command": "leointeg.moveOutlineDownSelection",
  "category": "Leo",
  "title": "Move Outline Down"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Down"
},
{
  "command": "leointeg.moveOutlineLeft",
  "category": "Leo",
  "title": "Move Outline Left",
  "icon": {
    "light": "resources/light/arrow-left.svg",
    "dark": "resources/dark/arrow-left.svg"
  }
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "category": "Leo",
  "title": "Move Outline Left"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Left"
},
{
  "command": "leointeg.moveOutlineRight",
  "category": "Leo",
  "title": "Move Outline Right",
  "icon": {
    "light": "resources/light/arrow-right.svg",
    "dark": "resources/dark/arrow-right.svg"
  }
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "category": "Leo",
  "title": "Move Outline Right"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Right"
},
{
  "command": "leointeg.moveOutlineUp",
  "category": "Leo",
  "title": "Move Outline Up",
  "icon": {
    "light": "resources/light/arrow-up.svg",
    "dark": "resources/dark/arrow-up.svg"
  }
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "category": "Leo",
  "title": "Move Outline Up"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Up"
},
</t>
<t tx="ekr.20200815123601.23">{
  "command": "leointeg.insertNode",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.insertChildNode",
  "category": "Leo",
  "title": "Insert Child",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leointeg.insertNodeSelection",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/insert.svg",
    "dark": "resources/dark/insert.svg"
  }
},
{
  "command": "leointeg.insertChildNodeSelection",
  "category": "Leo",
  "title": "Insert Child",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/insert.svg",
    "dark": "resources/dark/insert.svg"
  }
},
{
  "command": "leointeg.insertChildNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Insert Child",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/insert.svg",
    "dark": "resources/dark/insert.svg"
  }
},
{
  "command": "leointeg.insertChildNodeSelectionInterrupt",
  "category": "Leo",
  "title": "Insert Child",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leointeg.cloneNode",
  "category": "Leo",
  "title": "Clone Node",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leointeg.cloneNodeSelection",
  "category": "Leo",
  "title": "Clone Node",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Clone Node",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leointeg.promote",
  "category": "Leo",
  "title": "Promote Children",
  "icon": {
    "light": "resources/light/promote.svg",
    "dark": "resources/dark/promote.svg"
  }
},
{
  "command": "leointeg.promoteSelection",
  "category": "Leo",
  "title": "Promote Children",
  "icon": {
    "light": "resources/light/promote.svg",
    "dark": "resources/dark/promote.svg"
  }
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "category": "Leo",
  "title": "Promote Children",
  "icon": {
    "light": "resources/light/promote.svg",
    "dark": "resources/dark/promote.svg"
  }
},
{
  "command": "leointeg.demote",
  "category": "Leo",
  "title": "Demote Siblings",
  "icon": {
    "light": "resources/light/demote.svg",
    "dark": "resources/dark/demote.svg"
  }
},
{
  "command": "leointeg.demoteSelection",
  "category": "Leo",
  "title": "Demote Siblings",
  "icon": {
    "light": "resources/light/demote.svg",
    "dark": "resources/dark/demote.svg"
  }
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "category": "Leo",
  "title": "Demote Siblings",
  "icon": {
    "light": "resources/light/demote.svg",
    "dark": "resources/dark/demote.svg"
  }
},
{
  "command": "leointeg.sortChildrenSelection",
  "category": "Leo",
  "title": "Sort Children"
},
{
  "command": "leointeg.sortChildrenSelectionFromOutline",
  "category": "Leo",
  "title": "Sort Children"
},
{
  "command": "leointeg.sortSiblingsSelection",
  "category": "Leo",
  "title": "Sort Siblings",
  "icon": {
    "light": "resources/light/sort.svg",
    "dark": "resources/dark/sort.svg"
  }
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "category": "Leo",
  "title": "Sort Siblings",
  "icon": {
    "light": "resources/light/sort.svg",
    "dark": "resources/dark/sort.svg"
  }
},
</t>
<t tx="ekr.20200815123601.24">{
  "command": "leointeg.gotoFirstVisible",
  "category": "Leo",
  "title": "Goto First Visible"
},
{
  "command": "leointeg.gotoLastVisible",
  "category": "Leo",
  "title": "Goto Last Visible"
},
{
  "command": "leointeg.pageUp",
  "category": "Leo",
  "title": "Page Up"
},
{
  "command": "leointeg.pageDown",
  "category": "Leo",
  "title": "Page Down"
},
{
  "command": "leointeg.gotoLastSibling",
  "category": "Leo",
  "title": "Goto Last Sibling"
},
{
  "command": "leointeg.gotoNextVisible",
  "category": "Leo",
  "title": "Goto Next Visible"
},
{
  "command": "leointeg.gotoPrevVisible",
  "category": "Leo",
  "title": "Goto Prev Visible"
},
{
  "command": "leointeg.contractOrGoLeft",
  "category": "Leo",
  "title": "Contract Or Go Left"
},
{
  "command": "leointeg.expandAndGoRight",
  "category": "Leo",
  "title": "Expand And Go Right"
},
{
  "command": "leointeg.gotoNextMarked",
  "category": "Leo",
  "title": "Goto Next Marked"
},
{
  "command": "leointeg.gotoNextClone",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "category": "Leo",
  "title": "Goto Next Clone"
},
</t>
<t tx="ekr.20200815123601.25">{
  "command": "leointeg.hoistNode",
  "category": "Leo",
  "title": "Hoist",
  "icon": {
    "light": "resources/light/hoist.svg",
    "dark": "resources/dark/hoist.svg"
  }
},
{
  "command": "leointeg.hoistSelection",
  "category": "Leo",
  "title": "Hoist",
  "icon": {
    "light": "resources/light/hoist.svg",
    "dark": "resources/dark/hoist.svg"
  }
},
{
  "command": "leointeg.hoistSelectionFromOutline",
  "category": "Leo",
  "title": "Hoist",
  "icon": {
    "light": "resources/light/hoist.svg",
    "dark": "resources/dark/hoist.svg"
  }
},
{
  "command": "leointeg.deHoist",
  "category": "Leo",
  "title": "De-Hoist",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
{
  "command": "leointeg.deHoistFromOutline",
  "category": "Leo",
  "title": "De-Hoist",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
</t>
<t tx="ekr.20200815123601.26">{
  "command": "leointeg.undo",
  "category": "Leo",
  "title": "Undo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leointeg.undoDisabled",
  "category": "Leo",
  "title": "Can't Undo",
  "icon": {
    "light": "resources/light/undo-disabled.svg",
    "dark": "resources/dark/undo-disabled.svg"
  }
},
{
  "command": "leointeg.undoFromOutline",
  "category": "Leo",
  "title": "Undo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leointeg.redo",
  "category": "Leo",
  "title": "Redo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
{
  "command": "leointeg.redoDisabled",
  "category": "Leo",
  "title": "Can't Redo",
  "icon": {
    "light": "resources/light/redo-disabled.svg",
    "dark": "resources/dark/redo-disabled.svg"
  }
},
{
  "command": "leointeg.redoFromOutline",
  "category": "Leo",
  "title": "Redo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
</t>
<t tx="ekr.20200815123601.28">"viewsWelcome": [
  @others
],
</t>
<t tx="ekr.20200815123601.29"></t>
<t tx="ekr.20200815123601.3">"leoIntegration.checkForChangeExternalFiles": {
  "scope": "application",
  "default": "none",
  "type": "string",
  "description": "Set default for checking changes to external files",
  "enum": [
    "none",
    "force-check",
    "force-ignore"
  ],
  "enumDescriptions": [
    "Default from Leo's config",
    "Check for changes",
    "Ignore all changes"
  ]
},
"leoIntegration.defaultReloadIgnore": {
  "scope": "application",
  "default": "none",
  "type": "string",
  "description": "Set default for derived files to always reload, or always ignore, when changes are detected",
  "enum": [
    "none",
    "yes-all",
    "no-all"
  ],
  "enumDescriptions": [
    "Choose each time",
    "Reload All",
    "Ignore All"
  ]
},
</t>
<t tx="ekr.20200815123601.30">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Start Server](command:leointeg.startServer)\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; leoStartupFinished &amp;&amp; !leoConnecting || !leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically &amp;&amp; !leoConnecting"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Start Server](command:leointeg.startServer)\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; leoStartupFinished &amp;&amp; !leoConnecting || !leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically &amp;&amp; !leoConnecting"
},
</t>
<t tx="ekr.20200815123601.31">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; startServerAutomatically &amp;&amp; !connectToServerAutomatically &amp;&amp; !leoConnecting || !leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !connectToServerAutomatically &amp;&amp; !leoConnecting"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; startServerAutomatically &amp;&amp; !connectToServerAutomatically &amp;&amp; !leoConnecting || !leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !connectToServerAutomatically &amp;&amp; !leoConnecting"
},
</t>
<t tx="ekr.20200815123601.33">{
  "view": "leoIntegration",
  "contents": "Connecting...",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; leoConnecting || !leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; connectToServerAutomatically &amp;&amp; !leoConnecting &amp;&amp; !leoStartupFinished"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Connecting...",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; leoConnecting || !leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; connectToServerAutomatically &amp;&amp; !leoConnecting  &amp;&amp; !leoStartupFinished"
},
</t>
<t tx="ekr.20200815123601.34">{
  "view": "leoIntegration",
  "contents": "Connected\n[Open Leo File](command:leointeg.openLeoFile)\nView LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Connected\n[Open Leo File](command:leointeg.openLeoFile)\nView LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.35"></t>
<t tx="ekr.20200815123601.36">{
  "view": "leoDocuments",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
{
  "view": "leoDocumentsExplorer",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
</t>
<t tx="ekr.20200815123601.37">{
  "view": "leoDocuments",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoDocumentsExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.38"></t>
<t tx="ekr.20200815123601.39">{
  "view": "leoButtons",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
{
  "view": "leoButtonsExplorer",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
</t>
<t tx="ekr.20200815123601.4">"leoIntegration.leoTreeBrowse": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Specifies whether to use Leo's style of tree browsing with the arrow keys"
},
"leoIntegration.treeKeepFocus": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Specifies whether to keep focus in the outline when selecting a node - overridden by \"leoTreeBrowse\""
},
"leoIntegration.treeKeepFocusWhenAside": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Specifies whether to keep focus in the outline when opening a body pane on the side"
},
</t>
<t tx="ekr.20200815123601.40">{
  "view": "leoButtons",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoButtonsExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.41">{
  "view": "leoButtons",
  "contents": "There are no @buttons in this outline",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "view": "leoButtonsExplorer",
  "contents": "There are no @buttons in this outline",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.42">"menus": {
  @others
},
</t>
<t tx="ekr.20200815123601.43">"commandPalette": [
  @others
],
</t>
<t tx="ekr.20200815123601.44">{
  "command": "leointeg.startServer",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; !leoServerStarted"
},
{
  "command": "leointeg.stopServer",
  "when": "leoServerStarted"
},
{
  "command": "leointeg.connectToServer",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.45">{
  "command": "leointeg.executeScript",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.minibuffer",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.46">{
  "command": "leointeg.showLogPane",
  "when": "leoBridgeReady"
},
</t>
<t tx="ekr.20200815123601.47">{
  "command": "leointeg.openLeoFile",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.importAnyFile",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "command": "leointeg.recentLeoFiles",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.switchLeoFile",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "command": "leointeg.newLeoFile",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.closeLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.saveLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.saveAsLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.refreshFromDiskSelection",
  "when": "leoTreeOpened &amp;&amp; leoAtFile"
},
{
  "command": "leointeg.gitDiff",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.writeAtFileNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.writeDirtyAtFileNodes",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.48">{
  "command": "leointeg.contractAll",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.49">{
  "command": "leointeg.editSelectedHeadline",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markSelection",
  "when": "leoTreeOpened &amp;&amp; !leoMarked"
},
{
  "command": "leointeg.unmarkSelection",
  "when": "leoTreeOpened &amp;&amp; leoMarked"
},
{
  "command": "leointeg.copyNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cutNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.deleteSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.5">"leoIntegration.statusBarString": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Sets the message string of the Status Bar Indicator"
},
"leoIntegration.statusBarColor": {
  "scope": "application",
  "default": "fb7c47",
  "type": "string",
  "description": "Specifies the hexadecimal color string for the Status Bar Indicator"
},
</t>
<t tx="ekr.20200815123601.50">{
  "command": "leointeg.moveOutlineDownSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.51">{
  "command": "leointeg.insertNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.insertChildNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.promoteSelection",
  "when": "leoTreeOpened &amp;&amp; leoCanPromote"
},
{
  "command": "leointeg.demoteSelection",
  "when": "leoTreeOpened &amp;&amp; leoCanDemote"
},
{
  "command": "leointeg.sortChildrenSelection",
  "when": "leoTreeOpened &amp;&amp; leoChild"
},
{
  "command": "leointeg.sortSiblingsSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.52">{
  "command": "leointeg.gotoNextMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "when": "leoTreeOpened &amp;&amp; leoCloned"
},
</t>
<t tx="ekr.20200815123601.53">{
  "command": "leointeg.hoistSelection",
  "when": "leoTreeOpened &amp;&amp; !leoRoot"
},
{
  "command": "leointeg.deHoist",
  "when": "leoTreeOpened &amp;&amp; leoCanDehoist"
},
</t>
<t tx="ekr.20200815123601.54">{
  "command": "leointeg.undo",
  "when": "leoTreeOpened &amp;&amp; leoCanUndo"
},
{
  "command": "leointeg.redo",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.56"></t>
<t tx="ekr.20200815123601.57">{
  "command": "leointeg.setEnablePreview",
  "when": "false"
},
{
  "command": "leointeg.clearCloseEmptyGroups",
  "when": "false"
},
{
  "command": "leointeg.setCloseOnFileDelete",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.58">{
  "command": "leointeg.gotoScript",
  "when": "false"
},
{
  "command": "leointeg.removeButton",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.59">{
  "command": "leointeg.showBody",
  "when": "false"
},
{
  "command": "leointeg.showOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.6">"leoIntegration.treeInExplorer": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Show the outline tree in the explorer view"
},
"leoIntegration.showOpenAside": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Offer 'Open to the Side' in nodes context menu"
},
"leoIntegration.showEditOnNodes": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Edit Headline' button on tree nodes"
},
"leoIntegration.showArrowsOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Move Node' arrow buttons on tree nodes"
},
"leoIntegration.showAddOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Insert' button on tree nodes"
},
"leoIntegration.showMarkOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Mark/Unmark' buttons on tree nodes"
},
"leoIntegration.showCloneOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Clone' button on tree nodes"
},
"leoIntegration.showCopyOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Copy' button on tree nodes"
},
"leoIntegration.invertNodeContrast": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Inverts the contrast of the dirty/clean border aspect of tree nodes"
},
</t>
<t tx="ekr.20200815123601.60">{
  "command": "leointeg.saveLeoFileFromOutline",
  "when": "false"
},
{
  "command": "leointeg.refreshFromDisk",
  "when": "false"
},
{
  "command": "leointeg.refreshFromDiskSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.writeAtFileNodesFromOutline",
  "when": "false"
},
{
  "command": "leointeg.writeDirtyAtFileNodesFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.61">{
  "command": "leointeg.openAside",
  "when": "false"
},
{
  "command": "leointeg.contractAllFromOutline",
  "when": "false"
},
{
  "command": "leointeg.prevFromOutline",
  "when": "false"
},
{
  "command": "leointeg.nextFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.62">{
  "command": "leointeg.editHeadline",
  "when": "false"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "when": "false"
},
{
  "command": "leointeg.mark",
  "when": "false"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.unmark",
  "when": "false"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.copyNode",
  "when": "false"
},
{
  "command": "leointeg.cutNode",
  "when": "false"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.pasteNode",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAsClone",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.delete",
  "when": "false"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.63">{
  "command": "leointeg.moveOutlineDown",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineLeft",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineRight",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineUp",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.64">{
  "command": "leointeg.insertNode",
  "when": "false"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "when": "false"
},
{
  "command": "leointeg.insertChildNode",
  "when": "false"
},
{
  "command": "leointeg.insertChildNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.insertChildNodeSelectionInterrupt",
  "when": "false"
},
{
  "command": "leointeg.cloneNode",
  "when": "false"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.promote",
  "when": "false"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.demote",
  "when": "false"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.sortChildrenSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.65">{
  "command": "leointeg.gotoNextClone",
  "when": "false"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.gotoFirstVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoLastVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoLastSibling",
  "when": "false"
},
{
  "command": "leointeg.gotoNextVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoPrevVisible",
  "when": "false"
},
{
  "command": "leointeg.contractOrGoLeft",
  "when": "false"
},
{
  "command": "leointeg.expandAndGoRight",
  "when": "false"
},
{
  "command": "leointeg.pageUp",
  "when": "false"
},
{
  "command": "leointeg.pageDown",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.66">{
  "command": "leointeg.hoistNode",
  "when": "false"
},
{
  "command": "leointeg.hoistSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.deHoistFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.67">{
  "command": "leointeg.undoFromOutline",
  "when": "false"
},
{
  "command": "leointeg.redoFromOutline",
  "when": "false"
},
{
  "command": "leointeg.undoDisabled",
  "when": "false"
},
{
  "command": "leointeg.redoDisabled",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.68">"explorer/context": [
  {
    "command": "leointeg.openLeoFile",
    "when": "resourceScheme == file &amp;&amp; resourceExtname == .leo",
    "group": "navigation@1"
  }
],
</t>
<t tx="ekr.20200815123601.7">"leoIntegration.leoEditorPath": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Specifies the location of your Leo-Editor installation"
},
"leoIntegration.leoPythonCommand": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Specifies the command to start python (Defaults to 'py' on windows and 'python3' otherwise)"
},
"leoIntegration.startServerAutomatically": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Starts a Leo server automatically, by running the Leo server script"
},
"leoIntegration.connectToServerAutomatically": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Connect automatically to a Leo server on specified 'Connection Port' upon activation of this extension"
},
"leoIntegration.connectionAddress": {
  "default": "localhost",
  "scope": "application",
  "type": "string",
  "description": "Connection host"
},
"leoIntegration.connectionPort": {
  "default": 32125,
  "scope": "application",
  "minimum": 0,
  "maximum": 65535,
  "type": "number",
  "description": "Connection port"
},
"leoIntegration.setDetached": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Starts the server process with the 'detached' flag - Allows a dialog to be shown after closing for unsaved Leo documents"
},
"leoIntegration.limitUsers": {
  "default": 1,
  "scope": "application",
  "minimum": 1,
  "maximum": 255,
  "type": "number",
  "description": "Limit of concurrent connections - Allows for multi-user synchronous editing"
}
</t>
<t tx="ekr.20200815123601.76">"keybindings": [
  @others
],
</t>
<t tx="ekr.20200815123601.77">{
  "command": "leointeg.executeScript",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.minibuffer",
  "key": "alt+x",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.78">{
  "command": "leointeg.showOutline",
  "key": "alt+t",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.showOutline",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.showBody",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "alt+d",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "ctrl+g",
  "mac": "cmd+g",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.showBody",
  "key": "tab",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.showBody",
  "key": "enter",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.79">{
  "command": "leointeg.saveLeoFileFromOutline",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.saveLeoFile",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.newLeoFile",
  "key": "ctrl+n",
  "mac": "cmd+n",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.openLeoFile",
  "key": "ctrl+o",
  "mac": "cmd+o",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.writeAtFileNodes",
  "key": "ctrl+shift+w",
  "mac": "cmd+shift+w",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.writeAtFileNodesFromOutline",
  "key": "ctrl+shift+w",
  "mac": "cmd+shift+w",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.writeDirtyAtFileNodes",
  "key": "ctrl+shift+q",
  "mac": "cmd+shift+q",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.writeDirtyAtFileNodesFromOutline",
  "key": "ctrl+shift+q",
  "mac": "cmd+shift+q",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
</t>
<t tx="ekr.20200815123601.8">"viewsContainers": {
  "activitybar": [
    {
      "id": "leoIntegrationView",
      "title": "Leo",
      "icon": "resources/icon.svg"
    }
  ]
},
</t>
<t tx="ekr.20200815123601.80">{
  "command": "leointeg.contractAll",
  "key": "alt+-",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.contractAllFromOutline",
  "key": "alt+-",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
</t>
<t tx="ekr.20200815123601.81">{
  "command": "leointeg.editSelectedHeadline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.markSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.unmarkSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.82"></t>
<t tx="ekr.20200815123601.83">{
  "command": "leointeg.moveOutlineDownSelection",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineDownSelection",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "shift+down",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.84">{
  "command": "leointeg.moveOutlineLeftSelection",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "shift+left",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.85">{
  "command": "leointeg.moveOutlineRightSelection",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "shift+right",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.86">{
  "command": "leointeg.moveOutlineUpSelection",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "shift+up",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.87">{
  "command": "leointeg.sortSiblingsSelection",
  "key": "alt+a",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "key": "alt+a",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.promoteSelection",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.demoteSelection",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelection",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "!terminalFocus &amp;&amp; !panelFocus &amp;&amp; leoTreeOpened &amp;&amp; !sideBarFocus &amp;&amp; !editorTextFocus"
},
{
  "command": "leointeg.insertNodeSelection",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "key": "insert",
  "mac": "insert",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "!terminalFocus &amp;&amp; !panelFocus &amp;&amp; leoTreeOpened &amp;&amp; !sideBarFocus &amp;&amp; !editorTextFocus"
},
{
  "command": "leointeg.insertChildNodeSelection",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.insertChildNodeSelectionFromOutline",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.insertChildNodeSelectionInterrupt",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "!terminalFocus &amp;&amp; !panelFocus &amp;&amp; leoTreeOpened &amp;&amp; !sideBarFocus &amp;&amp; !editorTextFocus"
},
{
  "command": "leointeg.cloneNodeSelection",
  "key": "ctrl+`",
  "win": "ctrl+oem_3",
  "linux": "ctrl+`",
  "mac": "cmd+`",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "key": "ctrl+`",
  "win": "ctrl+oem_3",
  "linux": "ctrl+`",
  "mac": "cmd+`",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.cutNodeSelection",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.deleteSelection",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "key": "delete",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.88">{
  "command": "leointeg.gotoFirstVisible",
  "key": "alt+home",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.gotoLastSibling",
  "key": "alt+end",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.gotoFirstVisible",
  "key": "home",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.gotoLastVisible",
  "key": "end",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.pageUp",
  "key": "pageup",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.pageDown",
  "key": "pagedown",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "key": "alt+n",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "key": "alt+n",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "down",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "alt+down",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "up",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "alt+up",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; !editorHasSelection  &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "left",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "alt+left",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; !editorHasSelection  &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "right",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration/"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "alt+right",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; !editorHasSelection  &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
</t>
<t tx="ekr.20200815123601.89">"resourceLabelFormatters": [
  {
    "scheme": "leo",
    "formatting": {
      "label": "LEO: BODY",
      "separator": "/",
      "workspaceSuffix": ""
    }
  }
]
</t>
<t tx="ekr.20200815123601.9">"views": {
  "explorer": [
    {
      "id": "leoIntegrationExplorer",
      "name": "Leo Integration",
      "contextualTitle": "Leo",
      "when": "treeInExplorer",
      "visibility": "visible"
    },
    {
      "id": "leoDocumentsExplorer",
      "name": "Leo Documents",
      "contextualTitle": "Leo",
      "when": "treeInExplorer &amp;&amp; leoTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leoButtonsExplorer",
      "name": "Leo Buttons",
      "contextualTitle": "Leo",
      "when": "treeInExplorer &amp;&amp; leoTreeOpened",
      "visibility": "collapsed"
    },
    {
      "type": "webview",
      "id": "leoFindPanelExplorer",
      "contextualTitle": "Leo",
      "name": "Leo Find",
      "title": "Leo Find",
      "when": "treeInExplorer &amp;&amp; leoTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leoGotoPanelExplorer",
      "name": "Leo Goto",
      "contextualTitle": "Leo",
      "when": "treeInExplorer &amp;&amp; leoTreeOpened",
      "visibility": "collapsed"
    }
  ],
  "leoIntegrationView": [
    {
      "id": "leoIntegration",
      "contextualTitle": "Leo",
      "name": "Integration",
      "visibility": "visible"
    },
    {
      "id": "leoDocuments",
      "contextualTitle": "Leo",
      "name": "Documents",
      "visibility": "collapsed"
    },
    {
      "id": "leoButtons",
      "contextualTitle": "Leo",
      "name": "Buttons",
      "visibility": "collapsed"
    },
    {
      "type": "webview",
      "contextualTitle": "Leo",
      "id": "leoFindPanel",
      "name": "Find",
      "title": "Find",
      "when": "leoTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leoGotoPanel",
      "contextualTitle": "Leo",
      "name": "Goto",
      "visibility": "collapsed"
    }
  ]
},
</t>
<t tx="felix.20191126232434.13">def open_file(self, param):
    """
    Open a leo file via leoBridge controller, or create a new document if empty string.
    Returns an object that contains a 'opened' member.
    """
    w_found = False
    w_filename = param.get('filename')  # Optional.
    # If not empty string (asking for New file) then check if already opened
    if w_filename:
        for w_commander in self.g.app.commanders():
            if w_commander.fileName() == w_filename:
                w_found = True
                self.commander = w_commander

    if not w_found:
        if os.path.isfile(w_filename):
            # create self.commander by opening the file
            self.commander = self.bridge.openLeoFile(w_filename)
            self.commander.findCommands.ftm = StringFindTabManager(
                self.commander)
            self.commander.frame.body.wrapper = IntegTextWrapper(
                self.commander, "integBody", self.g)

    # Leo at this point has done this too: g.app.windowList.append(c.frame)
    # and so, now, app.commanders() yields this: return [f.c for f in g.app.windowList]

    if self.commander:
        self.commander.closed = False
        if not w_found:
            self.commander.selectPosition(self.commander.p)

        self._create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self._p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage(w_result)
    else:
        return self._outputError('Error in openFile')

</t>
<t tx="felix.20191126232434.14">def close_file(self, param):
    """
    Closes a leo file. A file can then be opened with "openFile".
    Returns a 'total' member in the package if close is successful

    """
    if self.commander:
        # First, revert to prevent asking user.
        if param["forced"] and self.commander.changed:
            self.commander.revert()
        # Then, if still possible, close it.
        if param["forced"] or not self.commander.changed:
            self.commander.closed = True
            self.commander.close()
        else:
            # Cannot close, ask to save, ignore or cancel
            return self.sendLeoBridgePackage()

    # Switch commanders to first available
    w_total = self._getTotalOpened()
    if w_total:
        self.commander = self._getFirstOpenedCommander()
    else:
        self.commander = None

    if self.commander:
        self._create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self._p_to_ap(self.commander.p)}
    else:
        w_result = {"total": 0}

    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20191126232434.16">def get_children(self, param):
    '''EMIT OUT list of children of a node'''
    w_ap = param.get("ap")  # At least node parameter is present
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p and w_p.hasChildren():
            return self._outputPNodes(w_p.children())
        else:
            return self._outputPNodes([])  # default empty array
    else:
        if self.commander.hoistStack:
            return self._outputPNodes([self.commander.hoistStack[-1].p])
        else:
            # this outputs all Root Children
            return self._outputPNodes(self._yieldAllRootChildren())

</t>
<t tx="felix.20191126232434.17">def get_parent(self, param):
    '''EMIT OUT the parent of a node, as an array, even if unique or empty'''
    w_ap = param.get("ap")  # At least node parameter is present
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p and w_p.hasParent():
            return self._outputPNode(w_p.getParent())  # if not root
    return self._outputPNode()  # default empty for root as default

</t>
<t tx="felix.20191126232434.19">def get_body(self, param):
    '''EMIT OUT body of a node'''
    # TODO : if not found, send code to prevent unresolved promise if 'document switch' occurred shortly before
    w_gnx = param.get("gnx")  # At least node parameter is present
    if w_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(w_gnx)  # vitalije
        if w_v:
            if w_v.b:
                return self._outputBodyData(w_v.b)
            else:
                return self._outputBodyData()  # default "" empty string
    # Send as empty to fix unresolved promise if 'document switch' occurred shortly before
    return self._outputBodyData()

</t>
<t tx="felix.20191126232434.2">#! python3
@language python
@tabwidth -4
&lt;&lt; imports &gt;&gt;
&lt;&lt; constants &gt;&gt;
@others
if __name__ == '__main__':
    # Startup
    try:
        main()
    except KeyboardInterrupt:
        print("\nKeyboard Interupt: Stopping leobridge server", flush=True)
        sys.exit()
</t>
<t tx="felix.20191126232434.20">def get_body_length(self, param):
    '''EMIT OUT body string length of a node'''
    w_gnx = param.get("gnx")  # At least node parameter is present
    if w_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(w_gnx)  # vitalije
        if w_v and w_v.b:
            # Length in bytes, not just by character count.
            return self.sendLeoBridgePackage({"len": len(w_v.b.encode('utf-8'))})
    # TODO : May need to signal inexistent by self.sendLeoBridgePackage()
    return self.sendLeoBridgePackage({"len": 0})  # empty as default

</t>
<t tx="felix.20191126232434.22">def set_body(self, param):
    '''Change Body text of a v node'''
    w_gnx = param['gnx']
    w_body = param['body']
    for w_p in self.commander.all_positions():
        if w_p.v.gnx == w_gnx:
            # TODO : Before setting undo and trying to set body, first check if different than existing body
            w_bunch = self.commander.undoer.beforeChangeNodeContents(
                w_p)  # setup undoable operation
            w_p.v.setBodyString(w_body)
            self.commander.undoer.afterChangeNodeContents(
                w_p, "Body Text", w_bunch)
            if self.commander.p.v.gnx == w_gnx:
                self.commander.frame.body.wrapper.setAllText(w_body)
            if not self.commander.isChanged():
                self.commander.setChanged()
            if not w_p.v.isDirty():
                w_p.setDirty()
            break
    # additional forced string setting
    if w_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(w_gnx)  # vitalije
        if w_v:
            w_v.b = w_body
    return self._outputPNode(self.commander.p)  # return selected node

</t>
<t tx="felix.20191126232434.23">def set_headline(self, param):
    '''Change Headline of a node'''
    w_newHeadline = param['name']
    w_ap = param["ap"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            # set this node's new headline
            w_bunch = self.commander.undoer.beforeChangeNodeContents(w_p)
            w_p.h = w_newHeadline
            self.commander.undoer.afterChangeNodeContents(
                w_p, 'Change Headline', w_bunch)
            return self._outputPNode(w_p)
    return self._outputError("Error in setNewHeadline")

</t>
<t tx="felix.20191126232434.24">def set_current_position(self, param):
    '''Select a node, or the first one found with its GNX'''
    w_ap = param.get("ap")  # At least node parameter is present
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            if self.commander.positionExists(w_p):
                # set this node as selection
                self.commander.selectPosition(w_p)
            else:
                w_foundPNode = self._findPNodeFromGnx(w_ap['gnx'])
                if w_foundPNode:
                    self.commander.selectPosition(w_foundPNode)
                else:
                    print("Set Selection node does not exist! ap was:" +
                          json.dumps(w_ap), flush=True)
    # * return the finally selected node
    if self.commander.p:
        return self._outputPNode(self.commander.p)
    else:
        return self._outputPNode()

</t>
<t tx="felix.20191126232434.25">def expand_node(self, param):
    '''Expand a node'''
    w_ap = param.get("ap")  # At least node parameter is present
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            w_p.expand()
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.26">def contract_node(self, param):
    '''Collapse a node'''
    w_ap = param.get("ap")  # At least node parameter is present
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            w_p.contract()
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.27">def _create_gnx_to_vnode(self):
    '''Make the first gnx_to_vnode array with all unique nodes'''
    t1 = time.process_time()
    self.gnx_to_vnode = {
        v.gnx: v for v in self.commander.all_unique_nodes()}
    # This is likely the only data that ever will be needed.
    if 0:
        print('app.create_all_data: %5.3f sec. %s entries' % (
            (time.process_time()-t1), len(list(self.gnx_to_vnode.keys()))), flush=True)
    self._test_round_trip_positions()

</t>
<t tx="felix.20191126232434.28">def _test_round_trip_positions(self):
    '''(From Leo plugin leoflexx.py) Test the round tripping of p_to_ap and ap_to_p.'''
    # Bug fix: p_to_ap updates app.gnx_to_vnode. Save and restore it.
    old_d = self.gnx_to_vnode.copy()
    old_len = len(list(self.gnx_to_vnode.keys()))
    # t1 = time.process_time()
    qtyAllPositions = 0
    for p in self.commander.all_positions():
        qtyAllPositions += 1
        ap = self._p_to_ap(p)
        p2 = self._ap_to_p(ap)
        assert p == p2, (repr(p), repr(p2), repr(ap))
    gnx_to_vnode = old_d
    new_len = len(list(gnx_to_vnode.keys()))
    assert old_len == new_len, (old_len, new_len)
    # print('Leo file opened. Its outline contains ' + str(qtyAllPositions) + " nodes positions.", flush=True)
    # print(('Testing app.test_round_trip_positions for all nodes: Total time: %5.3f sec.' % (time.process_time()-t1)), flush=True)

</t>
<t tx="felix.20191126232434.29">def _yieldAllRootChildren(self):
    '''Return all root children P nodes'''
    p = self.commander.rootPosition()
    while p:
        yield p
        p.moveToNext()

</t>
<t tx="felix.20191126232434.30">def _ap_to_p(self, ap):
    '''
    (From Leo plugin leoflexx.py) Convert an archived position to a true Leo position.
    Return false if no key
    '''
    childIndex = ap['childIndex']
    tag= "_ap_to_p"
    try:
        v = self.gnx_to_vnode[ap['gnx']]  # Trap this
        stack = [
            (self.gnx_to_vnode[d['gnx']], d['childIndex'])
            for d in ap['stack']
        ]
    except Exception:
        return False
    p = leoNodes.position(v, childIndex, stack)
    if not self.commander.positionExists(p):  # pragma: no cover.
        print(
            f"{tag}: Bad ap: {ap!r}\n"
            # f"{tag}: position: {p!r}\n"
            f"{tag}: v {v!r} childIndex: {childIndex!r}\n"
            f"{tag}: stack: {stack!r}")

    return p

</t>
<t tx="felix.20191126232434.31">def _p_to_ap(self, p):
    '''(From Leo plugin leoflexx.py) Converts Leo position to a serializable archived position.'''
    if not p.v:
        print('app.p_to_ap: no p.v: %r %s' % (p), flush=True)
        assert False
    p_gnx = p.v.gnx
    # * Expand gnx-vnode translation table for any new node encountered
    if p_gnx not in self.gnx_to_vnode:
        self.gnx_to_vnode[p_gnx] = p.v
    # * necessary properties for outline
    w_ap = {
        'childIndex': p._childIndex,
        'gnx': p.v.gnx,
        'level': p.level(),
        'headline': p.h,
        'stack': [{
            'gnx': stack_v.gnx,
            'childIndex': stack_childIndex,
            'headline': stack_v.h,
        } for (stack_v, stack_childIndex) in p.stack],
    }
    # TODO : Convert all those booleans into an 8 bit integer 'status' flag
    # TODO : Send p.v.u as simple boolean flag and let user inspect ...
    # TODO ... it with context menu command instead of hover tooltip.
    if p.v.u:
        w_ap['u'] = p.v.u
    if bool(p.b):
        w_ap['hasBody'] = True
    if p.hasChildren():
        w_ap['hasChildren'] = True
    if p.isCloned():
        w_ap['cloned'] = True
    if p.isDirty():
        w_ap['dirty'] = True
    if p.isExpanded():
        w_ap['expanded'] = True
    if p.isMarked():
        w_ap['marked'] = True
    if p.isAnyAtFileNode():
        w_ap['atFile'] = True
    if p == self.commander.p:
        w_ap['selected'] = True
    return w_ap


</t>
<t tx="felix.20191126232434.4">class LeoBridgeIntegController:
    '''Leo Bridge Controller'''
    # pylint: disable=no-else-return

    @others
</t>
<t tx="felix.20191126232434.5">def __init__(self):
    self.gnx_to_vnode = []  # utility array - see leoflexx.py in leoPluginsRef.leo
    self.bridge = leoBridge.controller(
        gui='nullGui',
        loadPlugins=True,   # True: attempt to load plugins.
        readSettings=True,  # True: read standard settings files.
        silent=True,       # True: don't print signon messages.
        # True: prints what would be sent to the log pane.
        verbose=False,
    )
    self.g = self.bridge.globals()

    # * Trace outputs to pythons stdout, also prints the function call stack
    # self.g.trace('test trace')

    # * Intercept Log Pane output: Sends to client's log pane
    self.g.es = self.es  # pointer - not a function call

    # print(dir(self.g), flush=True)
    self.currentActionId = 0  # Id of action being processed, STARTS AT 0 = Initial 'ready'

    # * Currently Selected Commander (opened from leo.core.leoBridge or chosen via the g.app.windowList 2 list)
    self.commander = None

    self.leoIntegConfig = None
    self.webSocket = None
    self.loop = None

    # * Replacement instances to Leo's codebase : getScript, IdleTime, idleTimeManager and externalFilesController
    self.g.getScript = self._getScript
    self.g.IdleTime = self._idleTime
    self.g.app.idleTimeManager = IdleTimeManager(self.g)
    # attach instance to g.app for calls to set_time, etc.
    self.g.app.externalFilesController = ExternalFilesController(self)
    # TODO : Maybe use those yes/no replacement right before actual usage instead of in init. (to allow re-use/switching)
    # override for "revert to file" operation
    self.g.app.gui.runAskYesNoDialog = self._returnYes
    self.g.app.gui.show_find_success = self._show_find_success
    self.headlineWidget = self.g.bunch(_name='tree')

    # * setup leoBackground to get messages from leo
    try:
        self.g.app.idleTimeManager.start()  # To catch derived file changes
    except Exception:
        print('ERROR with idleTimeManager')

</t>
<t tx="felix.20191126232435.1">def main():
    '''python script for leo integration via leoBridge'''
    global wsHost, wsPort
    print("Starting Leobridgeserver.py (Launch with -h for help)", flush=True)
    # replace default host address and port if provided as arguments

    args = None
    # See https://docs.python.org/3/library/getopt.html for 'getopt' usage
    try:
        opts, args = getopt.getopt(sys.argv[1:], "ha:p:", [
                                   "help", "address=", "port="])
    except getopt.GetoptError:
        print('leobridgeserver.py -a &lt;address&gt; -p &lt;port&gt;')
        print('defaults to localhost on port 32125', flush=True)
        if args:
            print("unused args: " + str(args), flush=True)
        sys.exit(2)
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            print('leobridgeserver.py -a &lt;address&gt; -p &lt;port&gt;')
            print('defaults to localhost on port 32125', flush=True)
            sys.exit()
        elif opt in ("-a", "--address"):
            wsHost = arg
        elif opt in ("-p", "--port"):
            wsPort = arg

    # * start Server
    integController = LeoBridgeIntegController()

    # * This is a basic example loop
    # async def asyncInterval(timeout):
    #     dummyCounter = 0
    #     strTimeout = str(timeout) + ' sec interval'
    #     while True:
    #         await asyncio.sleep(timeout)
    #         dummyCounter = dummyCounter+1
    #         await integController.asyncOutput("{\"interval\":" + str(timeout+dummyCounter) + "}")  # as number
    #         print(strTimeout)

    async def leoBridgeServer(websocket, path):
        try:
            integController.initConnection(websocket)
            # * Start by sending empty as 'ok'.
            await websocket.send(integController.sendLeoBridgePackage())
            integController.logSignon()
            async for json_string_message in websocket:
                messageObject = json.loads(json_string_message)
                if messageObject and messageObject['action']:
                    action = messageObject['action']
                    param = messageObject['param']
                    # printAction(w_param)  # Debug output
                    # * Storing id of action in global var instead of passing as parameter.
                    integController.setActionId(messageObject['id'])
                    # ! functions called this way need to accept at least a parameter other than 'self'
                    # ! See : getSelectedNode and getAllGnx
                    if action[0] == "!":
                        w_func = getattr(integController, action[1:], None)
                        w_answer = w_func(param)
                    elif action[0] == "_":
                        integController._outputError(
                            'Error : Command starting with underscore')
                    else:
                        # Attempt to execute the command directly on the commander/subcommander.
                        w_answer = integController.leoCommand(
                            action, param)
                else:
                    w_answer = "Error in processCommand"
                    print(w_answer, flush=True)
                await websocket.send(w_answer)
        except websockets.exceptions.ConnectionClosedError:
            print("Websocket connection closed", flush=True)
        except Exception:
            print('Exception in leobridgeserver.py!', flush=True)
            # Like g.es_exception()...
            typ, val, tb = sys.exc_info()
            for line in traceback.format_exception(typ, val, tb):
                print(line.rstrip(), flush=True)
        finally:
            asyncio.get_event_loop().stop()

    localLoop = asyncio.get_event_loop()
    start_server = websockets.serve(leoBridgeServer, wsHost, wsPort)
    # localLoop.create_task(asyncInterval(5)) # Starts a test loop of async communication.
    localLoop.run_until_complete(start_server)
    # This SERVER_STARTED_TOKEN special string signals server startup success.
    print(SERVER_STARTED_TOKEN + " at " + wsHost + " on port: " +
          str(wsPort) + " [ctrl+c] to break", flush=True)
    localLoop.run_forever()
    print("Stopping leobridge server", flush=True)


</t>
<t tx="felix.20191128001054.1"></t>
<t tx="felix.20191128002414.1">import leo.core.leoBridge as leoBridge
import leo.core.leoNodes as leoNodes
from leo.core.leoGui import StringFindTabManager
import asyncio
import getopt
import json
import os.path
import sys
import time
import traceback
import websockets
</t>
<t tx="felix.20191128002417.1"># server defaults
wsHost = "localhost"
wsPort = 32125

# To help in printout
commonActions = ["getChildren", "getBody", "getBodyLength"]

# Special string signals server startup success
SERVER_STARTED_TOKEN = "LeoBridge started"


</t>
<t tx="felix.20191128003648.1"></t>
<t tx="felix.20191201194046.1">def get_all_gnx(self, param):
    '''Get gnx array from all unique nodes'''
    w_all_gnx = [
        p.v.gnx for p in self.commander.all_unique_positions(copy=False)]
    return self.sendLeoBridgePackage({"gnx": w_all_gnx})

</t>
<t tx="felix.20191216195906.1">def _findPNodeFromGnx(self, p_gnx):
    '''Return first p node with this gnx or false'''
    for p in self.commander.all_unique_positions():
        if p.v.gnx == p_gnx:
            return p
    return False

</t>
<t tx="felix.20200211202929.1">def initConnection(self, p_webSocket):
    self.webSocket = p_webSocket
    self.loop = asyncio.get_event_loop()

</t>
<t tx="felix.20200216160305.1">def save_file(self, param):
    '''Saves the leo file. New or dirty derived files are rewritten'''
    if self.commander:
        try:
            if "name" in param:
                self.commander.save(fileName=param['name'])
            else:
                self.commander.save()
        except Exception as e:
            self.g.trace('Error while saving')
            print("Error while saving", param['name'], flush=True)
            print(str(e),  param['name'],  flush=True)

    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200219222712.1">def es(self, * args, **keys):
    '''Output to the Log Pane'''
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
        'nodeLink': None,
    }
    d = self.g.doKeywordArgs(keys, d)
    s = self.g.translateArgs(args, d)
    w_package = {"async": "log", "log": s}
    self.sendAsyncOutput(w_package)

</t>
<t tx="felix.20200219224515.1">def logSignon(self):
    '''Simulate the Initial Leo Log Entry'''
    if self.loop:
        self.g.app.computeSignon()
        self.g.es(str(self.g.app.signon))
        self.g.es(str(self.g.app.signon1))
    else:
        print('no loop in logSignon', flush=True)

</t>
<t tx="felix.20200302204251.1">class IdleTimeManager:
    """
    A singleton class to manage idle-time handling. This class handles all
    details of running code at idle time, including running 'idle' hooks.

    Any code can call g.app.idleTimeManager.add_callback(callback) to cause
    the callback to be called at idle time forever.
    """
    # TODO : REVISE/REPLACE WITH OWN SYSTEM

    def __init__(self, g):
        """Ctor for IdleTimeManager class."""
        self.g = g
        self.callback_list = []
        self.timer = None
        self.on_idle_count = 0

    @others

</t>
<t tx="felix.20200302204251.2">def add_callback(self, callback):
    """Add a callback to be called at every idle time."""
    self.callback_list.append(callback)

</t>
<t tx="felix.20200302204251.3">def on_idle(self, timer):
    """IdleTimeManager: Run all idle-time callbacks."""
    if not self.g.app:
        return
    if self.g.app.killed:
        return
    if not self.g.app.pluginsController:
        self.g.trace('No g.app.pluginsController', self.g.callers())
        timer.stop()
        return  # For debugger.
    self.on_idle_count += 1
    # Handle the registered callbacks.
    # print("list length : ", len(self.callback_list))
    for callback in self.callback_list:
        try:
            callback()
        except Exception:
            self.g.es_exception()
            self.g.es_print(f"removing callback: {callback}")
            self.callback_list.remove(callback)
    # Handle idle-time hooks.
    self.g.app.pluginsController.on_idle()

</t>
<t tx="felix.20200302204251.4">def start(self):
    """Start the idle-time timer."""
    self.timer = self.g.IdleTime(
        self.on_idle,
        delay=500,  # Milliseconds
        tag='IdleTimeManager.on_idle')
    if self.timer:
        self.timer.start()

</t>
<t tx="felix.20200302205810.1">class ExternalFilesController:
    '''EFC Modified from Leo's sources'''
    # pylint: disable=no-else-return

    @others

</t>
<t tx="felix.20200302205810.2">def __init__(self, integController):
    '''Ctor for ExternalFiles class.'''
    self.on_idle_count = 0
    self.integController = integController
    self.checksum_d = {}
    # Keys are full paths, values are file checksums.
    self.enabled_d = {}
    # For efc.on_idle.
    # Keys are commanders.
    # Values are cached @bool check-for-changed-external-file settings.
    self.has_changed_d = {}
    # Keys are commanders. Values are boolean.
    # Used only to limit traces.
    self.unchecked_commanders = []
    # Copy of g.app.commanders()
    self.unchecked_files = []
    # Copy of self file. Only one files is checked at idle time.
    self._time_d = {}
    # Keys are full paths, values are modification times.
    # DO NOT alter directly, use set_time(path) and
    # get_time(path), see set_time() for notes.
    self.yesno_all_time = 0  # previous yes/no to all answer, time of answer
    self.yesno_all_answer = None  # answer, 'yes-all', or 'no-all'

    # if yesAll/noAll forced, then just show info message after idle_check_commander
    self.infoMessage = None
    # False or "detected", "refreshed" or "ignored"

    self.integController.g.app.idleTimeManager.add_callback(self.on_idle)

    self.waitingForAnswer = False
    self.lastPNode = None  # last p node that was asked for if not set to "AllYes\AllNo"
    self.lastCommander = None

</t>
<t tx="felix.20200302205810.21"></t>
<t tx="felix.20200302205810.22">def ask(self, c, path, p=None):
    '''
    Ask user whether to overwrite an @&lt;file&gt; tree.
    Return True if the user agrees.
    '''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["defaultReloadIgnore"].lower(
        )
        if not bool('none' in w_check_config):
            if bool('yes' in w_check_config):
                self.infoMessage = "refreshed"
                return True
            else:
                self.infoMessage = "ignored"
                return False
    # let original function resolve

    if self.yesno_all_time + 3 &gt;= time.time() and self.yesno_all_answer:
        self.yesno_all_time = time.time()  # Still reloading?  Extend time.
        # if yesAll/noAll forced, then just show info message
        w_yesno_all_bool = bool('yes' in self.yesno_all_answer.lower())

        return w_yesno_all_bool
    if not p:
        where = 'the outline node'
    else:
        where = p.h

    _is_leo = path.endswith(('.leo', '.db'))

    if _is_leo:
        s = '\n'.join([
            f'{self.integController.g.splitLongFileName(path)} has changed outside Leo.',
            'Overwrite it?'
        ])
    else:
        s = '\n'.join([
            f'{self.integController.g.splitLongFileName(path)} has changed outside Leo.',
            f"Reload {where} in Leo?",
        ])

    w_package = {"async": "ask", "ask": 'Overwrite the version in Leo?',
                 "message": s, "yes_all": not _is_leo, "no_all": not _is_leo}

    self.integController.sendAsyncOutput(w_package)
    self.waitingForAnswer = True
    return False
    # result = self.integController.g.app.gui.runAskYesNoDialog(c, 'Overwrite the version in Leo?', s,
    # yes_all=not _is_leo, no_all=not _is_leo)

    # if result and "-all" in result.lower():
    # self.yesno_all_time = time.time()
    # self.yesno_all_answer = result.lower()

    # return bool(result and 'yes' in result.lower())

</t>
<t tx="felix.20200302205810.23">def checksum(self, path):
    '''Return the checksum of the file at the given path.'''
    import hashlib
    return hashlib.md5(open(path, 'rb').read()).hexdigest()

</t>
<t tx="felix.20200302205810.25">def get_mtime(self, path):
    '''Return the modification time for the path.'''
    return self.integController.g.os_path_getmtime(self.integController.g.os_path_realpath(path))

</t>
<t tx="felix.20200302205810.26">def get_time(self, path):
    '''
    return timestamp for path

    see set_time() for notes
    '''
    return self._time_d.get(self.integController.g.os_path_realpath(path))

</t>
<t tx="felix.20200302205810.27">def has_changed(self, path):
    '''Return True if p's external file has changed outside of Leo.'''
    if not path:
        return False
    if not self.integController.g.os_path_exists(path):
        return False
    if self.integController.g.os_path_isdir(path):
        return False
    #
    # First, check the modification times.
    old_time = self.get_time(path)
    new_time = self.get_mtime(path)
    if not old_time:
        # Initialize.
        self.set_time(path, new_time)
        self.checksum_d[path] = self.checksum(path)
        return False
    if old_time == new_time:
        return False
    #
    # Check the checksums *only* if the mod times don't match.
    old_sum = self.checksum_d.get(path)
    new_sum = self.checksum(path)
    if new_sum == old_sum:
        # The modtime changed, but it's contents didn't.
        # Update the time, so we don't keep checking the checksums.
        # Return False so we don't prompt the user for an update.
        self.set_time(path, new_time)
        return False
    # The file has really changed.
    assert old_time, path
    # #208: external change overwrite protection only works once.
    # If the Leo version is changed (dirtied) again,
    # overwrite will occur without warning.
    # self.set_time(path, new_time)
    # self.checksum_d[path] = new_sum
    return True

</t>
<t tx="felix.20200302205810.28">def is_enabled(self, c):
    '''Return the cached @bool check_for_changed_external_file setting.'''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["checkForChangeExternalFiles"].lower(
        )
        if bool('check' in w_check_config):
            return True
        if bool('ignore' in w_check_config):
            return False
    # let original function resolve
    d = self.enabled_d
    val = d.get(c)
    if val is None:
        val = c.config.getBool(
            'check-for-changed-external-files', default=False)
        d[c] = val
    return val

</t>
<t tx="felix.20200302205810.29">def join(self, s1, s2):
    '''Return s1 + ' ' + s2'''
    return f"{s1} {s2}"

</t>
<t tx="felix.20200302205810.30">def set_time(self, path, new_time=None):
    '''
    Implements c.setTimeStamp.

    Update the timestamp for path.

    NOTE: file paths with symbolic links occur with and without those links
    resolved depending on the code call path.  This inconsistency is
    probably not Leo's fault but an underlying Python issue.
    Hence the need to call realpath() here.
    '''

    # print("called set_time for " + str(path), flush=True)

    t = new_time or self.get_mtime(path)
    self._time_d[self.integController.g.os_path_realpath(path)] = t

</t>
<t tx="felix.20200302205810.31">def warn(self, c, path, p):
    '''
    Warn that an @asis or @nosent node has been changed externally.

    There is *no way* to update the tree automatically.
    '''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["defaultReloadIgnore"].lower(
        )

        if w_check_config != "none":
            # if not 'none' then do not warn, just infoMessage 'warn' at most
            if not self.infoMessage:
                self.infoMessage = "warn"
            return

    # let original function resolve
    if self.integController.g.unitTesting or c not in self.integController.g.app.commanders():
        return
    if not p:
        self.integController.g.trace('NO P')
        return

    s = '\n'.join([
        '%s has changed outside Leo.\n' % self.integController.g.splitLongFileName(
            path),
        'Leo can not update this file automatically.\n',
        'This file was created from %s.\n' % p.h,
        'Warning: refresh-from-disk will destroy all children.'
    ])

    w_package = {"async": "warn",
                 "warn": 'External file changed', "message": s}

    self.integController.sendAsyncOutput(w_package)
    self.waitingForAnswer = True

</t>
<t tx="felix.20200302205810.7">def on_idle(self):
    '''
    Check for changed open-with files and all external files in commanders
    for which @bool check_for_changed_external_file is True.
    '''
    # Fix for flushing the terminal console to pass
    # python through node.js when using start server in leoInteg
    sys.stdout.flush()

    if not self.integController.g.app or self.integController.g.app.killed:
        return
    if self.waitingForAnswer:
        return

    self.on_idle_count += 1

    if self.unchecked_commanders:
        # Check the next commander for which
        # @bool check_for_changed_external_file is True.
        c = self.unchecked_commanders.pop()
        self.lastCommander = c
        self.idle_check_commander(c)
    else:
        # Add all commanders for which
        # @bool check_for_changed_external_file is True.
        self.unchecked_commanders = [
            z for z in self.integController.g.app.commanders() if self.is_enabled(z)
        ]

</t>
<t tx="felix.20200302205810.8">def idle_check_commander(self, c):
    '''
    Check all external files corresponding to @&lt;file&gt; nodes in c for
    changes.
    '''
    # #1100: always scan the entire file for @&lt;file&gt; nodes.
    # #1134: Nested @&lt;file&gt; nodes are no longer valid, but this will do no harm.

    self.infoMessage = None  # reset infoMessage
    # False or "detected", "refreshed" or "ignored"

    for p in c.all_unique_positions():
        if self.waitingForAnswer:
            break
        if p.isAnyAtFileNode():
            self.idle_check_at_file_node(c, p)

    # if yesAll/noAll forced, then just show info message
    if self.infoMessage:
        w_package = {"async": "info", "message": self.infoMessage}
        self.integController.sendAsyncOutput(w_package)

</t>
<t tx="felix.20200302205810.9">def idle_check_at_file_node(self, c, p):
    '''Check the @&lt;file&gt; node at p for external changes.'''
    trace = False
    # Matt, set this to True, but only for the file that interests you.\
    # trace = p.h == '@file unregister-leo.leox'
    path = self.integController.g.fullPath(c, p)
    has_changed = self.has_changed(path)
    if trace:
        self.integController.g.trace('changed', has_changed, p.h)
    if has_changed:
        self.lastPNode = p  # can be set here because its the same process for ask/warn
        if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
            # Fix #1081: issue a warning.
            self.warn(c, path, p=p)
        elif self.ask(c, path, p=p):
            self.lastCommander.selectPosition(self.lastPNode)
            c.refreshFromDisk()

        # Always update the path &amp; time to prevent future warnings.
        self.set_time(path)
        self.checksum_d[path] = self.checksum(path)

</t>
<t tx="felix.20200303214235.1">async def _asyncIdleLoop(self, p_seconds, p_fn):
    while True:
        await asyncio.sleep(p_seconds)
        p_fn(self)

</t>
<t tx="felix.20200303214255.1">def _idleTime(self, fn, delay, tag):
    # TODO : REVISE/REPLACE WITH OWN SYSTEM
    asyncio.get_event_loop().create_task(self._asyncIdleLoop(delay/1000, fn))

</t>
<t tx="felix.20200304220844.1">def set_ask_result(self, param):
    '''Got the result to an asked question/warning from client'''
    w_result = param.get("result");
    if not w_result:
        return self._outputError("Error in set_ask_result, no param result")
    self.g.app.externalFilesController.integResult(w_result)
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200304221925.1">def integResult(self, p_result):
    '''Received result from client'''
    # Got the result to an asked question/warning from the client
    if not self.waitingForAnswer:
        print("ERROR: Received Result but no Asked Dialog", flush=True)
        return
    # check if p_resultwas from a warn (ok) or an ask ('yes','yes-all','no','no-all')
    # act accordingly

    path = self.integController.g.fullPath(
        self.lastCommander, self.lastPNode)

    # 1- if ok, unblock 'warn'
    # 2- if no, unblock 'ask'
    # ------------------------------------------ Nothing special to do

    # 3- if noAll, set noAll, and unblock 'ask'
    if p_result and "-all" in p_result.lower():
        self.yesno_all_time = time.time()
        self.yesno_all_answer = p_result.lower()
    # ------------------------------------------ Also covers setting yesAll in #5

    # 4- if yes, REFRESH self.lastPNode, and unblock 'ask'
    # 5- if yesAll,REFRESH self.lastPNode, set yesAll, and unblock 'ask'
    if bool(p_result and 'yes' in p_result.lower()):
        self.lastCommander.selectPosition(self.lastPNode)
        self.lastCommander.refreshFromDisk()

    # Always update the path &amp; time to prevent future warnings for this PNode.
    self.set_time(path)
    self.checksum_d[path] = self.checksum(path)

    self.waitingForAnswer = False  # unblock
    # unblock: run the loop as if timer had hit
    self.idle_check_commander(self.lastCommander)

</t>
<t tx="felix.20200304224909.1">def sendAsyncOutput(self, p_package):
    if "async" not in p_package:
        print('[sendAsyncOutput] Error async member missing in package parameter')
        print(json.dumps(p_package, separators=(',', ':')), flush=True)
        return
    if self.loop:
        self.loop.create_task(self.asyncOutput(
            json.dumps(p_package, separators=(',', ':'))))
    else:
        print('[sendAsyncOutput] Error loop not ready' +
              json.dumps(p_package, separators=(',', ':')))

</t>
<t tx="felix.20200308145948.1"># Some methods are called in the usual (non-leoBridge without 'efc') save process.
# Those may be called by the 'save' function, like check_overwrite,
# or by any other functions from the instance of leo.core.leoBridge that's running.

</t>
<t tx="felix.20200308150821.1">def shut_down(self):
    return

</t>
<t tx="felix.20200308150842.1">def destroy_frame(self, f):
    return

</t>
<t tx="felix.20200308150848.1">def check_overwrite(self, c, fn):
    # print("check_overwrite!! ", flush=True)
    return True

</t>
<t tx="felix.20200308150856.1">def open_with(self, c, d):
    return

</t>
<t tx="felix.20200312231358.1">def set_config(self, p_config):
    '''Got leoInteg's config from client'''
    self.leoIntegConfig = p_config
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200622230608.1">def get_all_open_commanders(self, param):
    '''Return array of opened file path/names to be used as openFile parameters to switch files'''
    w_files = []
    for w_commander in self.g.app.commanders():
        if not w_commander.closed:
            w_isSelected = False
            w_isChanged = w_commander.changed
            if self.commander == w_commander:
                w_isSelected = True
            w_entry = {
                "name": w_commander.mFileName,
                "changed": w_isChanged,
                "selected": w_isSelected
            }
            w_files.append(w_entry)

    return self.sendLeoBridgePackage({"files": w_files})

</t>
<t tx="felix.20200623201853.1">def _getTotalOpened(self):
    '''Get total of opened commander (who have closed == false)'''
    w_total = 0
    for w_commander in self.g.app.commanders():
        if not w_commander.closed:
            w_total = w_total + 1
    return w_total

</t>
<t tx="felix.20200623215904.1">def _getFirstOpenedCommander(self):
    '''Get first opened commander, or False if there are none.'''
    for w_commander in self.g.app.commanders():
        if not w_commander.closed:
            return w_commander
    return False

</t>
<t tx="felix.20200624172552.1">def set_opened_file(self, param):
    '''Choose the new active commander from array of opened file path/names by numeric index'''
    w_openedCommanders = []

    for w_commander in self.g.app.commanders():
        if not w_commander.closed:
            w_openedCommanders.append(w_commander)

    w_index = param['index']  # index in param

    if w_openedCommanders[w_index]:
        self.commander = w_openedCommanders[w_index]

    if self.commander:
        self.commander.closed = False
        self._create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self._p_to_ap(self.commander.p)}
        # maybe needed for frame wrapper
        self.commander.selectPosition(self.commander.p)
        return self.sendLeoBridgePackage(w_result)
    else:
        return self._outputError('Error in setOpenedFile')

</t>
<t tx="felix.20200626012709.1">def _returnNo(self, *arguments, **kwargs):
    '''Used to override g.app.gui.ask[XXX] dialogs answers'''
    return "no"

</t>
<t tx="felix.20200626030820.1">def _returnYes(self, *arguments, **kwargs):
    '''Used to override g.app.gui.ask[XXX] dialogs answers'''
    return "yes"

</t>
<t tx="felix.20200718020912.1">import * as vscode from "vscode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718020912.10">/**
 * * Actions that can be invoked by Leo through leobridge
 */
public static ASYNC_ACTIONS = {
    ASYNC_LOG: "log",
    ASYNC_REFRESH: "refresh",
    ASYNC_ASK: "ask",
    ASYNC_WARN: "warn",
    ASYNC_INFO: "info",
    ASYNC_INTERVAL: "interval"
};

</t>
<t tx="felix.20200718020912.11">/**
 * * When async action was ASYNC_INFO
 */
public static ASYNC_INFO_MESSAGE_CODES = {
    ASYNC_REFRESHED: "refreshed",
    ASYNC_IGNORED: "ignored"
};

</t>
<t tx="felix.20200718020912.12">/**
 * * runAskYesNoDialog or runAskOkDialog result codes, used when async action requires a response
 */
public static ASYNC_ASK_RETURN_CODES = {
    YES: "yes",
    NO: "no",
    YES_ALL: "yes-all",
    NO_ALL: "no-all",
    OK: "ok"
};

</t>
<t tx="felix.20200718020912.13">/**
 * * Commands for leobridgeserver.py
 * A Command is a string, which is either:
 *  - The name of public method in leoserver.py, prefixed with '!'.
 *  - The name of a Leo command, prefixed with '-'
 *  - The name of a method of a Leo class, without prefix.
 */
public static LEOBRIDGE = {
    TEST: "!test",
    DO_NOTHING: "!do_nothing",
    GET_VERSION: "!get_version",
    // * Server Commands
    GET_COMMANDS: "!get_all_leo_commands", // "getCommands",
    APPLY_CONFIG: "!set_config", // "applyConfig",
    ASK_RESULT: "!set_ask_result", // "askResult",
    // * GUI
    GET_ALL_GNX: "!get_all_gnx", // "getAllGnx",
    GET_BODY_LENGTH: "!get_body_length", // "getBodyLength",
    GET_BODY_STATES: "!get_body_states", // "getBodyStates",
    GET_BODY: "!get_body", // "getBody",
    GET_PARENT: "!get_parent", // "getParent",
    GET_CHILDREN: "!get_children", // "getChildren",
    SET_SELECTED_NODE: "!set_current_position", // "setSelectedNode",
    SET_BODY: "!set_body", // "setBody",
    SET_SELECTION: "!set_selection", // "setSelection",
    SET_HEADLINE: "!set_headline", // "setNewHeadline",
    EXPAND_NODE: "!expand_node", // "expandNode",
    COLLAPSE_NODE: "!contract_node", // "collapseNode",
    CONTRACT_ALL: "contractAllHeadlines",
    GET_STATES: "!get_ui_states", // "getStates",
    GET_UA: "!get_ua",
    SET_UA_MEMBER: "!set_ua_member",
    SET_UA: "!set_ua",
    // * Leo Documents
    GET_OPENED_FILES: "!get_all_open_commanders", //"getOpenedFiles",
    SET_OPENED_FILE: "!set_opened_file", // "setOpenedFile",
    OPEN_FILE: "!open_file", // "openFile",
    IMPORT_ANY_FILE: "!import_any_file", // "importAnyFile",
    OPEN_FILES: "!open_files", //  "openFiles",
    CLOSE_FILE: "!close_file", // "closeFile",
    SAVE_FILE: "!save_file", // "saveFile",
    // * @-Buttons
    GET_BUTTONS: "!get_buttons", // "getButtons",
    REMOVE_BUTTON: "!remove_button", // "removeButton",
    GOTO_SCRIPT: "!goto_script", // "goto Script command",
    CLICK_BUTTON: "!click_button", // "clickButton",
    // * Goto operations
    PAGE_UP: "!page_up", // "pageUp",
    PAGE_DOWN: "!page_down", // "pageDown",
    GOTO_FIRST_VISIBLE: "goToFirstVisibleNode",
    GOTO_LAST_VISIBLE: "goToLastVisibleNode",
    GOTO_LAST_SIBLING: "goToLastSibling",
    GOTO_NEXT_VISIBLE: "selectVisNext",
    GOTO_PREV_VISIBLE: "selectVisBack",
    GOTO_NEXT_MARKED: "goToNextMarkedHeadline",
    GOTO_NEXT_CLONE: "goToNextClone",
    CONTRACT_OR_GO_LEFT: "contractNodeOrGoToParent",
    EXPAND_AND_GO_RIGHT: "expandNodeAndGoToFirstChild",
    // * Leo Operations
    MARK_PNODE: "!mark_node", // "markPNode",
    UNMARK_PNODE: "!unmark_node", // "unmarkPNode",

    //COPY_PNODE: "copyOutline",
    COPY_PNODE: "!copy_node",

    CUT_PNODE: "!cut_node", // "cutPNode",

    // PASTE_PNODE: "pasteOutline",
    PASTE_PNODE: "!paste_node",

    // PASTE_CLONE_PNODE: "pasteOutlineRetainingClones",
    PASTE_CLONE_PNODE: "!paste_as_clone_node",

    DELETE_PNODE: "!delete_node", // "deletePNode",
    MOVE_PNODE_DOWN: "moveOutlineDown",
    MOVE_PNODE_LEFT: "moveOutlineLeft",
    MOVE_PNODE_RIGHT: "moveOutlineRight",
    MOVE_PNODE_UP: "moveOutlineUp",
    INSERT_PNODE: "!insert_node", // "insertPNode",
    INSERT_NAMED_PNODE: "!insert_named_node", // "insertNamedPNode",
    INSERT_CHILD_PNODE: "!insert_child_node",
    INSERT_CHILD_NAMED_PNODE: "!insert_child_named_node",
    CLONE_PNODE: "!clone_node", // "clonePNode",
    PROMOTE_PNODE: "promote",
    DEMOTE_PNODE: "demote",
    REFRESH_FROM_DISK_PNODE: "refreshFromDisk",
    WRITE_AT_FILE_NODES: '-write-at-file-nodes',
    WRITE_DIRTY_AT_FILE_NODES: '-write-dirty-at-file-nodes',
    SORT_CHILDREN: "sortChildren",
    SORT_SIBLINGS: "sortSiblings",
    UNDO: "!undo",
    REDO: "!redo",
    EXECUTE_SCRIPT: "executeScript",
    HOIST_PNODE: "hoist",
    DEHOIST: "dehoist",
    EXTRACT: "extract",
    EXTRACT_NAMES: "extractSectionNames",
    COPY_MARKED: "copyMarked",
    DIFF_MARKED_NODES: "-diff-marked-nodes",
    MARK_CHANGED_ITEMS: "markChangedHeadlines",
    MARK_SUBHEADS: "markSubheads",
    UNMARK_ALL: "unmarkAll",
    CLONE_MARKED_NODES: "cloneMarked",
    DELETE_MARKED_NODES: "deleteMarked",
    MOVE_MARKED_NODES: "moveMarked",
    GIT_DIFF: "gitDiff",
    GET_FOCUS: "!get_focus",

    GET_GOTO_PANEL: "!get_goto_panel", // To fill up panel when changing leo documents

    NAV_HEADLINE_SEARCH: "!nav_headline_search",
    NAV_SEARCH: "!nav_search",

    FIND_QUICK_TIMELINE: "!find_quick_timeline",
    FIND_QUICK_CHANGED: "!find_quick_changed",
    FIND_QUICK_HISTORY: "!find_quick_history",
    FIND_QUICK_MARKED: "!find_quick_marked",
    GOTO_NAV_ENTRY: "!goto_nav_entry",

    GET_SEARCH_SETTINGS: "!get_search_settings",
    SET_SEARCH_SETTINGS: "!set_search_settings",
    START_SEARCH: "!start_search",
    FIND_ALL: "!find_all",
    FIND_NEXT: "!find_next",
    FIND_PREVIOUS: "!find_previous",
    FIND_VAR: "!find_var",
    FIND_DEF: "!find_def",
    REPLACE: "!replace",
    REPLACE_THEN_FIND: "!replace_then_find",
    REPLACE_ALL: "!replace_all",
    GOTO_GLOBAL_LINE: "!goto_global_line",
    TAG_CHILDREN: "!tag_children",
    TAG_NODE: "!tag_node",
    REMOVE_TAGS: "!remove_tags",
    CLONE_FIND_TAG: "!clone_find_tag",
    CLONE_FIND_ALL: "!clone_find_all",
    CLONE_FIND_ALL_FLATTENED: "!clone_find_all_flattened",
    CLONE_FIND_MARKED: "!clone_find_all_marked",
    CLONE_FIND_FLATTENED_MARKED: "!clone_find_all_flattened_marked",
    GOTO_PREV_HISTORY: "goToPrevHistory",
    GOTO_NEXT_HISTORY: "goToNextHistory"
};

</t>
<t tx="felix.20200718020912.15">/**
 * * All commands this expansion exposes (in package.json, contributes &gt; commands)
 */
public static COMMANDS = {
    // * Access to the Settings/Welcome Webview
    SHOW_WELCOME: Constants.NAME + ".showWelcomePage", // Always available: not in the commandPalette section of package.json
    SHOW_SETTINGS: Constants.NAME + ".showSettingsPage", // Always available: not in the commandPalette section of package.json
    STATUS_BAR: Constants.NAME + ".statusBar", // Status Bar Click Command
    // * LeoBridge
    CHOOSE_LEO_FOLDER: Constants.NAME + ".chooseLeoFolder",
    START_SERVER: Constants.NAME + ".startServer",
    STOP_SERVER: Constants.NAME + ".stopServer",
    CONNECT: Constants.NAME + ".connectToServer",
    SET_OPENED_FILE: Constants.NAME + ".setOpenedFile",
    OPEN_FILE: Constants.NAME + ".openLeoFile", // sets focus on BODY
    CLEAR_RECENT_FILES: Constants.NAME + ".clearRecentFiles",
    IMPORT_ANY_FILE: Constants.NAME + ".importAnyFile",
    RECENT_FILES: Constants.NAME + ".recentLeoFiles", // shows recent Leo files, opens one on selection
    SWITCH_FILE: Constants.NAME + ".switchLeoFile",
    NEW_FILE: Constants.NAME + ".newLeoFile",
    SAVE_FILE: Constants.NAME + ".saveLeoFile",
    // SAVE_DISABLED: Constants.NAME + ".saveLeoFileDisabled", // Disabled - nop
    SAVE_FILE_FO: Constants.NAME + ".saveLeoFileFromOutline",
    SAVE_AS_FILE: Constants.NAME + ".saveAsLeoFile",
    SAVE_AS_LEOJS: Constants.NAME + ".saveAsLeoJsFile",
    CLOSE_FILE: Constants.NAME + ".closeLeoFile",
    CLICK_BUTTON: Constants.NAME + ".clickButton",
    REMOVE_BUTTON: Constants.NAME + ".removeButton",
    GOTO_SCRIPT: Constants.NAME + ".gotoScript",
    MINIBUFFER: Constants.NAME + ".minibuffer",
    GIT_DIFF: Constants.NAME + ".gitDiff",
    // * Outline selection
    SELECT_NODE: Constants.NAME + ".selectTreeNode",
    OPEN_ASIDE: Constants.NAME + ".openAside",
    // * Goto operations that always finish with focus in outline
    PAGE_UP: Constants.NAME + ".pageUp",
    PAGE_DOWN: Constants.NAME + ".pageDown",
    GOTO_FIRST_VISIBLE: Constants.NAME + ".gotoFirstVisible",
    GOTO_LAST_VISIBLE: Constants.NAME + ".gotoLastVisible",
    GOTO_LAST_SIBLING: Constants.NAME + ".gotoLastSibling",
    GOTO_NEXT_VISIBLE: Constants.NAME + ".gotoNextVisible",
    GOTO_PREV_VISIBLE: Constants.NAME + ".gotoPrevVisible",
    GOTO_NEXT_MARKED: Constants.NAME + ".gotoNextMarked",
    GOTO_NEXT_CLONE: Constants.NAME + ".gotoNextClone",
    GOTO_NEXT_CLONE_SELECTION: Constants.NAME + ".gotoNextCloneSelection",
    GOTO_NEXT_CLONE_SELECTION_FO: Constants.NAME + ".gotoNextCloneSelectionFromOutline",
    CONTRACT_OR_GO_LEFT: Constants.NAME + ".contractOrGoLeft",
    EXPAND_AND_GO_RIGHT: Constants.NAME + ".expandAndGoRight",
    // * Leo Operations
    UNDO: Constants.NAME + ".undo", // From command Palette
    UNDO_FO: Constants.NAME + ".undoFromOutline", // from button, return focus on OUTLINE
    UNDO_DISABLED: Constants.NAME + ".undoDisabled", // Disabled - nop
    REDO: Constants.NAME + ".redo", // From command Palette
    REDO_FO: Constants.NAME + ".redoFromOutline", // from button, return focus on OUTLINE
    REDO_DISABLED: Constants.NAME + ".redoDisabled", // Disabled - nop
    EXECUTE: Constants.NAME + ".executeScript",
    SHOW_BODY: Constants.NAME + ".showBody",
    SHOW_OUTLINE: Constants.NAME + ".showOutline",
    SHOW_LOG: Constants.NAME + ".showLogPane",
    SORT_CHILDREN: Constants.NAME + ".sortChildrenSelection",
    SORT_CHILDREN_FO: Constants.NAME + ".sortChildrenSelectionFromOutline",
    SORT_SIBLING: Constants.NAME + ".sortSiblingsSelection",
    SORT_SIBLING_FO: Constants.NAME + ".sortSiblingsSelectionFromOutline",
    CONTRACT_ALL: Constants.NAME + ".contractAll", // From command Palette
    CONTRACT_ALL_FO: Constants.NAME + ".contractAllFromOutline", // from button, return focus on OUTLINE
    PREV_NODE: Constants.NAME + ".prev",
    PREV_NODE_FO: Constants.NAME + ".prevFromOutline",
    NEXT_NODE: Constants.NAME + ".next",
    NEXT_NODE_FO: Constants.NAME + ".nextFromOutline",
    // * Commands from tree panel buttons or context: focus on OUTLINE
    MARK: Constants.NAME + ".mark",
    UNMARK: Constants.NAME + ".unmark",
    COPY: Constants.NAME + ".copyNode",
    CUT: Constants.NAME + ".cutNode",
    PASTE: Constants.NAME + ".pasteNode",
    PASTE_CLONE: Constants.NAME + ".pasteNodeAsClone",
    DELETE: Constants.NAME + ".delete",
    HEADLINE: Constants.NAME + ".editHeadline",
    MOVE_DOWN: Constants.NAME + ".moveOutlineDown",
    MOVE_LEFT: Constants.NAME + ".moveOutlineLeft",
    MOVE_RIGHT: Constants.NAME + ".moveOutlineRight",
    MOVE_UP: Constants.NAME + ".moveOutlineUp",
    INSERT: Constants.NAME + ".insertNode",
    INSERT_CHILD: Constants.NAME + ".insertChildNode",
    CLONE: Constants.NAME + ".cloneNode",
    PROMOTE: Constants.NAME + ".promote",
    DEMOTE: Constants.NAME + ".demote",
    REFRESH_FROM_DISK: Constants.NAME + ".refreshFromDisk",
    WRITE_AT_FILE_NODES: Constants.NAME + ".writeAtFileNodes",
    WRITE_AT_FILE_NODES_FO: Constants.NAME + ".writeAtFileNodesFromOutline",
    WRITE_DIRTY_AT_FILE_NODES: Constants.NAME + ".writeDirtyAtFileNodes",
    WRITE_DIRTY_AT_FILE_NODES_FO: Constants.NAME + ".writeDirtyAtFileNodesFromOutline",
    // * Commands from keyboard, while focus on BODY (command-palette returns to BODY for now)
    MARK_SELECTION: Constants.NAME + ".markSelection",
    UNMARK_SELECTION: Constants.NAME + ".unmarkSelection",
    COPY_SELECTION: Constants.NAME + ".copyNodeSelection", // Nothing to refresh/focus so no "FO" version
    CUT_SELECTION: Constants.NAME + ".cutNodeSelection",
    PASTE_SELECTION: Constants.NAME + ".pasteNodeAtSelection",
    PASTE_CLONE_SELECTION: Constants.NAME + ".pasteNodeAsCloneAtSelection",
    DELETE_SELECTION: Constants.NAME + ".deleteSelection",
    HEADLINE_SELECTION: Constants.NAME + ".editSelectedHeadline",
    MOVE_DOWN_SELECTION: Constants.NAME + ".moveOutlineDownSelection",
    MOVE_LEFT_SELECTION: Constants.NAME + ".moveOutlineLeftSelection",
    MOVE_RIGHT_SELECTION: Constants.NAME + ".moveOutlineRightSelection",
    MOVE_UP_SELECTION: Constants.NAME + ".moveOutlineUpSelection",

    INSERT_SELECTION: Constants.NAME + ".insertNodeSelection", // Can be interrupted
    INSERT_SELECTION_INTERRUPT: Constants.NAME + ".insertNodeSelectionInterrupt", // Interrupted version

    INSERT_CHILD_SELECTION: Constants.NAME + ".insertChildNodeSelection", // Can be interrupted
    INSERT_CHILD_SELECTION_INTERRUPT: Constants.NAME + ".insertChildNodeSelectionInterrupt", // Can be interrupted

    CLONE_SELECTION: Constants.NAME + ".cloneNodeSelection",
    PROMOTE_SELECTION: Constants.NAME + ".promoteSelection",
    DEMOTE_SELECTION: Constants.NAME + ".demoteSelection",
    REFRESH_FROM_DISK_SELECTION: Constants.NAME + ".refreshFromDiskSelection",
    // * Commands from keyboard, while focus on OUTLINE
    MARK_SELECTION_FO: Constants.NAME + ".markSelectionFromOutline",
    UNMARK_SELECTION_FO: Constants.NAME + ".unmarkSelectionFromOutline",
    // COPY_SELECTION Nothing to refresh/focus for "copy a node" so no "FO" version
    CUT_SELECTION_FO: Constants.NAME + ".cutNodeSelectionFromOutline",
    PASTE_SELECTION_FO: Constants.NAME + ".pasteNodeAtSelectionFromOutline",
    PASTE_CLONE_SELECTION_FO: Constants.NAME + ".pasteNodeAsCloneAtSelectionFromOutline",
    DELETE_SELECTION_FO: Constants.NAME + ".deleteSelectionFromOutline",
    HEADLINE_SELECTION_FO: Constants.NAME + ".editSelectedHeadlineFromOutline",
    MOVE_DOWN_SELECTION_FO: Constants.NAME + ".moveOutlineDownSelectionFromOutline",
    MOVE_LEFT_SELECTION_FO: Constants.NAME + ".moveOutlineLeftSelectionFromOutline",
    MOVE_RIGHT_SELECTION_FO: Constants.NAME + ".moveOutlineRightSelectionFromOutline",
    MOVE_UP_SELECTION_FO: Constants.NAME + ".moveOutlineUpSelectionFromOutline",
    INSERT_SELECTION_FO: Constants.NAME + ".insertNodeSelectionFromOutline",
    INSERT_CHILD_SELECTION_FO: Constants.NAME + ".insertChildNodeSelectionFromOutline",
    CLONE_SELECTION_FO: Constants.NAME + ".cloneNodeSelectionFromOutline",
    PROMOTE_SELECTION_FO: Constants.NAME + ".promoteSelectionFromOutline",
    DEMOTE_SELECTION_FO: Constants.NAME + ".demoteSelectionFromOutline",
    REFRESH_FROM_DISK_SELECTION_FO: Constants.NAME + ".refreshFromDiskSelectionFromOutline",
    HOIST: Constants.NAME + ".hoistNode",
    HOIST_SELECTION: Constants.NAME + ".hoistSelection",
    HOIST_SELECTION_FO: Constants.NAME + ".hoistSelectionFromOutline",
    DEHOIST: Constants.NAME + ".deHoist",
    DEHOIST_FO: Constants.NAME + ".deHoistFromOutline",
    EXTRACT: Constants.NAME + ".extract",
    EXTRACT_NAMES: Constants.NAME + ".extractNames",
    COPY_MARKED: Constants.NAME + ".copyMarked",
    DIFF_MARKED_NODES: Constants.NAME + ".diffMarkedNodes",
    MARK_CHANGED_ITEMS: Constants.NAME + ".markChangedItems",
    MARK_SUBHEADS: Constants.NAME + ".markSubheads",
    UNMARK_ALL: Constants.NAME + ".unmarkAll",
    CLONE_MARKED_NODES: Constants.NAME + ".cloneMarkedNodes",
    DELETE_MARKED_NODES: Constants.NAME + ".deleteMarkedNodes",
    MOVE_MARKED_NODES: Constants.NAME + ".moveMarkedNodes",

    FIND_QUICK: Constants.NAME + ".findQuick",
    FIND_QUICK_SELECTED: Constants.NAME + ".findQuickSelected",
    FIND_QUICK_TIMELINE: Constants.NAME + ".findQuickTimeline",
    FIND_QUICK_CHANGED: Constants.NAME + ".findQuickChanged",
    FIND_QUICK_HISTORY: Constants.NAME + ".history",
    FIND_QUICK_MARKED: Constants.NAME + ".markedList",
    FIND_QUICK_GO_ANYWHERE: Constants.NAME + ".goAnywhere",
    GOTO_NAV_ENTRY: Constants.NAME + ".gotoNav",

    START_SEARCH: Constants.NAME + ".startSearch",
    FIND_ALL: Constants.NAME + ".findAll",
    FIND_NEXT: Constants.NAME + ".findNext",
    FIND_NEXT_FO: Constants.NAME + ".findNextFromOutline",
    FIND_PREVIOUS: Constants.NAME + ".findPrevious",
    FIND_PREVIOUS_FO: Constants.NAME + ".findPreviousFromOutline",
    FIND_VAR: Constants.NAME + ".findVar",
    FIND_DEF: Constants.NAME + ".findDef",
    REPLACE: Constants.NAME + ".replace",
    REPLACE_FO: Constants.NAME + ".replaceFromOutline",
    REPLACE_THEN_FIND: Constants.NAME + ".replaceThenFind",
    REPLACE_THEN_FIND_FO: Constants.NAME + ".replaceThenFindFromOutline",
    REPLACE_ALL: Constants.NAME + ".replaceAll",
    CLONE_FIND_ALL: Constants.NAME + ".cloneFindAll",
    CLONE_FIND_ALL_FLATTENED: Constants.NAME + ".cloneFindAllFlattened",
    CLONE_FIND_TAG: Constants.NAME + ".cloneFindTag",
    CLONE_FIND_MARKED: Constants.NAME + ".cloneFindMarked",
    CLONE_FIND_FLATTENED_MARKED: Constants.NAME + ".cloneFindFlattenedMarked",
    GOTO_GLOBAL_LINE: Constants.NAME + ".gotoGlobalLine",
    TAG_CHILDREN: Constants.NAME + ".tagChildren",
    TAG_NODE: Constants.NAME + ".tagNode",
    REMOVE_TAGS: Constants.NAME + ".removeTags",
    SET_FIND_EVERYWHERE_OPTION: Constants.NAME + ".setFindEverywhereOption",
    SET_FIND_NODE_ONLY_OPTION: Constants.NAME + ".setFindNodeOnlyOption",
    SET_FIND_SUBOUTLINE_ONLY_OPTION: Constants.NAME + ".setFindSuboutlineOnlyOption",
    TOGGLE_FIND_IGNORE_CASE_OPTION: Constants.NAME + ".toggleFindIgnoreCaseOption",
    TOGGLE_FIND_MARK_CHANGES_OPTION: Constants.NAME + ".toggleFindMarkChangesOption",
    TOGGLE_FIND_MARK_FINDS_OPTION: Constants.NAME + ".toggleFindMarkFindsOption",
    TOGGLE_FIND_REGEXP_OPTION: Constants.NAME + ".toggleFindRegexpOption",
    TOGGLE_FIND_WORD_OPTION: Constants.NAME + ".toggleFindWordOption",
    TOGGLE_FIND_SEARCH_BODY_OPTION: Constants.NAME + ".toggleFindSearchBodyOption",
    TOGGLE_FIND_SEARCH_HEADLINE_OPTION: Constants.NAME + ".toggleFindSearchHeadlineOption",
    SET_ENABLE_PREVIEW: Constants.NAME + ".setEnablePreview",
    CLEAR_CLOSE_EMPTY_GROUPS: Constants.NAME + ".clearCloseEmptyGroups",
    SET_CLOSE_ON_FILE_DELETE: Constants.NAME + ".setCloseOnFileDelete",
};

</t>
<t tx="felix.20200718020912.2">/**
 * * Text and numeric constants used throughout leoInteg
 */
export class Constants {

    @others
}
</t>
<t tx="felix.20200718020912.3">public static PUBLISHER: string = "boltex";
public static NAME: string = "leointeg";
public static CONFIG_NAME: string = "leoIntegration";
public static CONFIG_WORKBENCH_ENABLED_PREVIEW: string = "workbench.editor.enablePreview";
public static CONFIG_REFRESH_MATCH: string = "OnNodes"; // substring to distinguish 'on-hover' icon commands

public static TREEVIEW_ID: string = Constants.CONFIG_NAME;
public static TREEVIEW_EXPLORER_ID: string = Constants.CONFIG_NAME + "Explorer";

public static DOCUMENTS_ID: string = "leoDocuments";
public static DOCUMENTS_EXPLORER_ID: string = "leoDocumentsExplorer";

public static BUTTONS_ID: string = "leoButtons";
public static BUTTONS_EXPLORER_ID: string = "leoButtonsExplorer";

public static FIND_ID: string = "leoFindPanel";
public static FIND_EXPLORER_ID: string = "leoFindPanelExplorer";

public static GOTO_ID: string = "leoGotoPanel";
public static GOTO_EXPLORER_ID: string = "leoGotoPanelExplorer";

public static VERSION_STATE_KEY: string = "leoIntegVersion";

public static FILE_EXTENSION: string = "leo";
public static JS_FILE_EXTENSION: string = "leojs";

public static LEO_LANGUAGE_PREFIX: string = "leobody."; // all lowercase
public static URI_LEO_SCHEME: string = "leo";
public static URI_FILE_SCHEME: string = "file";
public static URI_SCHEME_HEADER: string = "leo:/";
public static FILE_OPEN_FILTER_MESSAGE: string = "Leo Files";
public static UNTITLED_FILE_NAME: string = "untitled";
public static RECENT_FILES_KEY: string = "leoRecentFiles";
public static LAST_FILES_KEY: string = "leoLastFiles";

public static DEFAULT_PYTHON: string = "python3";
public static WIN32_PYTHON: string = "py";
public static SERVER_NAME: string = "/leoserver.py";
public static SERVER_STARTED_TOKEN: string = "LeoBridge started";
public static TCPIP_DEFAULT_PROTOCOL: string = "ws://";

public static ERROR_PACKAGE_ID: number = 0;
public static STARTING_PACKAGE_ID: number = 1;
public static STATUSBAR_DEBOUNCE_DELAY: number = 60;
public static DOCUMENTS_DEBOUNCE_DELAY: number = 80;
public static BUTTONS_DEBOUNCE_DELAY: number = 80;
public static REFRESH_ALL_DEBOUNCE_DELAY: number = 333;
public static STATES_DEBOUNCE_DELAY: number = 100;
public static BODY_STATES_DEBOUNCE_DELAY: number = 200;
public static GOTO_DEBOUNCE_DELAY: number = 50;

public static LOG_ALERT_COLOR: string = 'red';

</t>
<t tx="felix.20200718020912.5">/**
 * * Strings used in the workbench interface panels (not for messages or dialogs)
 */
public static GUI = {
    ICON_LIGHT_DOCUMENT: "resources/light/document.svg",
    ICON_DARK_DOCUMENT: "resources/dark/document.svg",
    ICON_LIGHT_DOCUMENT_DIRTY: "resources/light/document-dirty.svg",
    ICON_DARK_DOCUMENT_DIRTY: "resources/dark/document-dirty.svg",
    ICON_LIGHT_BUTTON: "resources/light/button.svg",
    ICON_DARK_BUTTON: "resources/dark/button.svg",
    ICON_LIGHT_BUTTON_RCLICK: "resources/light/button-rclick.svg",
    ICON_DARK_BUTTON_RCLICK: "resources/dark/button-rclick.svg",
    ICON_LIGHT_BUTTON_ADD: "resources/light/button-add.svg",
    ICON_DARK_BUTTON_ADD: "resources/dark/button-add.svg",
    ICON_LIGHT_PATH: "resources/light/box",
    ICON_DARK_PATH: "resources/dark/box",
    ICON_FILE_EXT: ".svg",
    STATUSBAR_INDICATOR: "$(keyboard) ",
    QUICK_OPEN_LEO_COMMANDS: "&gt;leo: ",
    EXPLORER_TREEVIEW_PREFIX: "LEO ",
    TREEVIEW_TITLE: "OUTLINE",
    TREEVIEW_TITLE_NOT_CONNECTED: "NOT CONNECTED",
    TREEVIEW_TITLE_CONNECTED: "CONNECTED",
    TREEVIEW_TITLE_INTEGRATION: "INTEGRATION",
    BODY_TITLE: "LEO BODY",
    LOG_PANE_TITLE: "Leo Log Window",
    TERMINAL_PANE_TITLE: "LeoBridge Server",
    THEME_STATUSBAR: "statusBar.foreground"
};

</t>
<t tx="felix.20200718020912.6">/**
 * * Basic user messages strings for messages and dialogs
 */
public static USER_MESSAGES = {
    SCRIPT_BUTTON: "from selected node",
    SCRIPT_BUTTON_TOOLTIP:
        "Creates a new button with the presently selected node.\n" +
        "For example, to run a script on any part of an outline:\n" +
        "\n" +
        "1.  Select the node containing a script. e.g. \"g.es(p.h)\"\n" +
        "2.  Press 'Script Button' to create a new button.\n" +
        "3.  Select another node on which to run the script.\n" +
        "4.  Press the *new* button.",
    SAVE_CHANGES: "Save changes to",
    BEFORE_CLOSING: "before closing?",
    CANCEL: "Cancel",
    OPEN_WITH_LEOINTEG: "Open this Leo file with LeoInteg?",
    OPEN_RECENT_FILE: "Open Recent Leo File",
    RIGHT_CLICK_TO_OPEN: "Right-click Leo files to open with LeoInteg",
    FILE_ALREADY_OPENED: "Leo file already opened",
    CHOOSE_OPENED_FILE: "Select an opened Leo File",
    FILE_NOT_OPENED: "No files opened.",
    STATUSBAR_TOOLTIP_ON: "Leo Key Bindings are in effect", // TODO : Add description of what happens if clicked
    STATUSBAR_TOOLTIP_OFF: "Leo Key Bindings off", // TODO : Add description of what happens if clicked
    PROMPT_EDIT_HEADLINE: "Edit Headline",
    PROMPT_INSERT_NODE: "Insert Node",
    DEFAULT_HEADLINE: "New Headline",
    TITLE_GOTO_GLOBAL_LINE: "Goto global line",
    PLACEHOLDER_GOTO_GLOBAL_LINE: "#",
    PROMPT_GOTO_GLOBAL_LINE: "Line number",
    TITLE_TAG_CHILDREN: "Tag Children",
    PLACEHOLDER_TAG_CHILDREN: "&lt;tag&gt;",
    PROMPT_TAG_CHILDREN: "Enter a tag name",
    TITLE_FIND_TAG: "Find Tag",
    PLACEHOLDER_CLONE_FIND_TAG: "&lt;tag&gt;",
    PROMPT_CLONE_FIND_TAG: "Enter a tag name",
    START_SERVER_ERROR: "Error - Cannot start server: ",
    CONNECT_FAILED: "Leo Server Connection Failed",
    CONNECT_ERROR: "Leo Server Connection Error: Incorrect id",
    CONNECTED: "Connected",
    ALREADY_CONNECTED: "Already connected",
    DISCONNECTED: "Disconnected",
    CLEARED_RECENT: "Cleared recent files list",
    CLOSE_ERROR: "Cannot close: No files opened.",
    LEO_PATH_MISSING: "Leo Editor Path Setting Missing",
    CANNOT_FIND_SERVER_SCRIPT: "Cannot find server script",
    YES: "Yes",
    NO: "No",
    YES_ALL: "Yes to all",
    NO_ALL: "No to all",
    CHOOSE_BUTTON: "Choose @button or @rclick",
    MINIBUFFER_PROMPT: "Minibuffer Full Command",
    CHANGES_DETECTED: "Changes to external files were detected.",
    REFRESHED: " Nodes refreshed.", // with leading space
    IGNORED: " They were ignored.", // with leading space
    TOO_FAST: "leoInteg is busy! ", // with trailing space
    MINIMUM_VERSION: "Missing Command: Please update Leo (min 6.6-final required)",
    UNKNOWN_LANGUAGE_NOT_SUPPORTED: "Language not yet supported.",
    LANGUAGE_NOT_SUPPORTED: " language not yet supported." // with leading space
};

</t>
<t tx="felix.20200718020912.7">/**
 * * Choices offered when about to lose current changes to a Leo Document
 */
public static ASK_SAVE_CHANGES_BUTTONS: vscode.MessageItem[] = [
    {
        title: Constants.USER_MESSAGES.YES,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.NO,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.CANCEL,
        isCloseAffordance: true
    }
];

</t>
<t tx="felix.20200718020912.8">/**
 * * String for JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public static CONFIG_NAMES = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "checkForChangeExternalFiles",
    DEFAULT_RELOAD_IGNORE: "defaultReloadIgnore",
    LEO_TREE_BROWSE: "leoTreeBrowse",
    TREE_KEEP_FOCUS: "treeKeepFocus",
    TREE_KEEP_FOCUS_WHEN_ASIDE: "treeKeepFocusWhenAside",
    STATUSBAR_STRING: "statusBarString",
    STATUSBAR_COLOR: "statusBarColor",
    TREE_IN_EXPLORER: "treeInExplorer",
    SHOW_OPEN_ASIDE: "showOpenAside",
    SHOW_EDIT: "showEditOnNodes",
    SHOW_ARROWS: "showArrowsOnNodes",
    SHOW_ADD: "showAddOnNodes",
    SHOW_MARK: "showMarkOnNodes",
    SHOW_CLONE: "showCloneOnNodes",
    SHOW_COPY: "showCopyOnNodes",

    SHOW_EDITION_BODY: "showEditionOnBody",
    SHOW_CLIPBOARD_BODY: "showClipboardOnBody",
    SHOW_PROMOTE_BODY: "showPromoteOnBody",
    SHOW_EXECUTE_BODY: "showExecuteOnBody",
    SHOW_EXTRACT_BODY: "showExtractOnBody",
    SHOW_IMPORT_BODY: "showImportOnBody",
    SHOW_REFRESH_BODY: "showRefreshOnBody",
    SHOW_HOIST_BODY: "showHoistOnBody",
    SHOW_MARK_BODY: "showMarkOnBody",
    SHOW_SORT_BODY: "showSortOnBody",

    INVERT_NODES: "invertNodeContrast",
    LEO_EDITOR_PATH: "leoEditorPath",
    LEO_PYTHON_COMMAND: "leoPythonCommand",
    AUTO_START_SERVER: "startServerAutomatically",
    AUTO_CONNECT: "connectToServerAutomatically",
    IP_ADDRESS: "connectionAddress",
    IP_PORT: "connectionPort",

    SET_DETACHED: "setDetached",
    LIMIT_USERS: "limitUsers"
};

</t>
<t tx="felix.20200718020912.9">/**
 * * Used in 'when' clauses, set with vscode.commands.executeCommand("setContext",...)
 */
public static CONTEXT_FLAGS = {
    // Main flags for connection and opened file
    STARTUP_FINISHED: "leoStartupFinished", // Initial extension finished auto-server-start-connect
    CONNECTING: "leoConnecting", // Initial extension finished auto-server-start-connect
    BRIDGE_READY: "leoBridgeReady", // Connected to leoBridge
    TREE_OPENED: "leoTreeOpened", // At least one Leo file opened
    TREE_TITLED: "leoTreeTitled", // Tree is a Leo file and not a new untitled document
    SERVER_STARTED: "leoServerStarted", // Auto-start or manually started
    // 'states' flags for currently opened tree view
    LEO_CHANGED: "leoChanged",
    LEO_CAN_UNDO: "leoCanUndo",
    LEO_CAN_REDO: "leoCanRedo",
    LEO_CAN_DEMOTE: "leoCanDemote",
    LEO_CAN_PROMOTE: "leoCanPromote",
    LEO_CAN_DEHOIST: "leoCanDehoist",
    // 'states' flags about current selection, for visibility and commands availability
    SELECTED_MARKED: "leoMarked", // no need for unmarked here, use !leoMarked
    SELECTED_CLONE: "leoCloned",
    SELECTED_DIRTY: "leoDirty",
    SELECTED_EMPTY: "leoEmpty",
    SELECTED_CHILD: "leoChild", // Has children
    SELECTED_ATFILE: "leoAtFile", // Can be refreshed
    SELECTED_ROOT: "leoRoot", // ! Not given by Leo: Computed by leoInteg/vscode instead
    // Statusbar Flag 'keybindings in effect'
    LEO_SELECTED: "leoObjectSelected", // keybindings "On": Outline or body has focus
    // Context Flags for 'when' clauses, used concatenated, for each outline node
    NODE_MARKED: "leoNodeMarked",  // Selected node is marked
    NODE_UNMARKED: "leoNodeUnmarked", // Selected node is unmarked (Needed for regexp)
    NODE_ATFILE: "leoNodeAtFile", // Selected node is an @file or @clean, etc...
    NODE_CLONED: "leoNodeCloned",
    NODE_ROOT: "leoNodeRoot",
    NODE_NOT_ROOT: "leoNodeNotRoot",
    // Flags for Leo documents tree view icons and hover node command buttons
    DOCUMENT_SELECTED_TITLED: "leoDocumentSelectedTitled",
    DOCUMENT_TITLED: "leoDocumentTitled",
    DOCUMENT_SELECTED_UNTITLED: "leoDocumentSelectedUntitled",
    DOCUMENT_UNTITLED: "leoDocumentUntitled",
    // Flags that match specific LeoInteg config settings
    LEO_TREE_BROWSE: Constants.CONFIG_NAMES.LEO_TREE_BROWSE, // Force ar'jan's suggestion of Leo's tree behavior override
    TREE_IN_EXPLORER: Constants.CONFIG_NAMES.TREE_IN_EXPLORER, // Leo outline also in the explorer view
    SHOW_OPEN_ASIDE: Constants.CONFIG_NAMES.SHOW_OPEN_ASIDE,   // Show 'open aside' in context menu
    SHOW_EDIT: Constants.CONFIG_NAMES.SHOW_EDIT,              // Hover Icons on outline nodes
    SHOW_ARROWS: Constants.CONFIG_NAMES.SHOW_ARROWS,           // Hover Icons on outline nodes
    SHOW_ADD: Constants.CONFIG_NAMES.SHOW_ADD,                 // Hover Icons on outline nodes
    SHOW_MARK: Constants.CONFIG_NAMES.SHOW_MARK,               // Hover Icons on outline nodes
    SHOW_CLONE: Constants.CONFIG_NAMES.SHOW_CLONE,             // Hover Icons on outline nodes
    SHOW_COPY: Constants.CONFIG_NAMES.SHOW_COPY,               // Hover Icons on outline nodes
    AUTO_START_SERVER: Constants.CONFIG_NAMES.AUTO_START_SERVER,   // Used at startup
    AUTO_CONNECT: Constants.CONFIG_NAMES.AUTO_CONNECT,             // Used at startup

    SHOW_EDITION_BODY: Constants.CONFIG_NAMES.SHOW_EDITION_BODY,
    SHOW_CLIPBOARD_BODY: Constants.CONFIG_NAMES.SHOW_CLIPBOARD_BODY,
    SHOW_PROMOTE_BODY: Constants.CONFIG_NAMES.SHOW_PROMOTE_BODY,
    SHOW_EXECUTE_BODY: Constants.CONFIG_NAMES.SHOW_EXECUTE_BODY,
    SHOW_EXTRACT_BODY: Constants.CONFIG_NAMES.SHOW_EXTRACT_BODY,
    SHOW_IMPORT_BODY: Constants.CONFIG_NAMES.SHOW_IMPORT_BODY,
    SHOW_REFRESH_BODY: Constants.CONFIG_NAMES.SHOW_REFRESH_BODY,
    SHOW_HOIST_BODY: Constants.CONFIG_NAMES.SHOW_HOIST_BODY,
    SHOW_MARK_BODY: Constants.CONFIG_NAMES.SHOW_MARK_BODY,
    SHOW_SORT_BODY: Constants.CONFIG_NAMES.SHOW_SORT_BODY

};

</t>
<t tx="felix.20200718024635.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { UserCommand, LeoBridgePackage, ReqRefresh } from "./types";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718024635.2">/**
 * * Front-facing, user command stack of actions
 * This implements a user-facing command stack, (push on top, remove bottom)
 * Commands can also be added while this stack has started resolving.
 * This 'stack' concept is similar to the 'LeoBridge' class used for interacting with Leo.
 */
export class CommandStack {

    private _stack: UserCommand[] = []; // Actual commands array
    private _busy: boolean = false; // Flag stating commands started resolving

    // Refresh type, for use after the last command has done resolving (From highest so far)
    private _finalRefreshType: ReqRefresh = {}; // new empty ReqRefresh

    // Flag used to set focus on outline instead of body when done resolving (From last pushed)
    private _finalFromOutline: boolean = false;

    // Received selection from the last command that finished as JSON string representation
    // It will be re-sent as 'target node' instead of lastSelectedNode if present
    private _selectedNode: string = ""; // Empty string is used as 'falsy'

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20200718024635.3">/**
 * * Returns the command stack size
 * @returns number of actions on the command stack
 */
public size(): number {
    return this._stack.length;
}

</t>
<t tx="felix.20200718024635.4">/**
 * * Signal to the command stack that a new selected node was received.
 * Command stack needs to know when to clear its own '_receivedSelection'
 */
public newSelection(): void {
    if (!this._busy) {
        this._selectedNode = "";
    }
}

</t>
<t tx="felix.20200718024635.5">/**
 * * Adds on top and try to execute the bottom command if not already running
 * Targeted command (targeting a specific node) can only be added on an empty stack
 * @param p_command Object that has the action, targeted node (if any), refresh type and 'fromOutline' flag
 * @returns true if added, false if it could not (due to front end stack 'rules')
 */
public add(p_command: UserCommand): Promise&lt;LeoBridgePackage&gt; | undefined {
    if (p_command.node &amp;&amp; this.size()) {
        return undefined; // Can only add a command which targets a node if the stack is empty
    } else {
        const q_promise = new Promise&lt;LeoBridgePackage&gt;((p_resolve, p_reject) =&gt; {
            p_command.resolveFn = p_resolve;
            p_command.rejectFn = p_reject;
        });
        this._stack.push(p_command);
        this._finalFromOutline = p_command.fromOutline; // Set final "focus-placement"
        this._tryStart();
        return q_promise;
    }
}

</t>
<t tx="felix.20200718024635.6">/**
 * * Try to launch commands that were added on the stack, if any.
 */
private _tryStart(): void {
    if (this.size() &amp;&amp; !this._busy) {
        // Ok to start, so set the busy flag and start from the bottom
        this._busy = true; // Cleared when the last command has returned (and the stack is empty)
        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}

</t>
<t tx="felix.20200718024635.7">/**
 * * Run the command at index 0: The bottom of the stack.
 */
private _runStackCommand(): Promise&lt;LeoBridgePackage&gt; {
    // Reference from bottom of stack, but don't remove it yet!
    const w_command: UserCommand = this._stack[0];

    let w_nodeJson: string = ""; // ap json used in building w_jsonParam
    let w_jsonParam: string = ""; // Finished parameter that is sent

    // First command uses given node or last selected node.
    // Other subsequent commands on stack will use _receivedSelection regardless.
    // (Commands such as 'collapse all' just ignore node parameter)
    if (w_command.node) {
        // Was node specific, so starting a new stack of commands
        w_nodeJson = w_command.node.apJson;
    } else {
        // Use received "selected node" unless first use, then use last selected node
        if (this._selectedNode) {
            w_nodeJson = this._selectedNode;
        } else {
            w_nodeJson = this._leoIntegration.lastSelectedNode ? this._leoIntegration.lastSelectedNode.apJson : "";
        }
        if (!w_nodeJson) {
            console.log('ERROR NO ARCHIVED POSITION JSON');
        }
    }
    w_jsonParam = utils.buildNodeCommandJson(w_nodeJson, w_command); // 'Insert Named Node' or 'Edit Headline'

    // Setup _finalRefreshType, if command requires higher than the one setup so far
    Object.assign(this._finalRefreshType, w_command.refreshType); // add all properties (expecting only 'true' properties)

    // Submit this action to Leo and return a promise of its packaged answer
    return this._leoIntegration.sendAction(w_command.action, w_jsonParam)
        .then((p_package) =&gt; {
            if (w_command.resolveFn) {
                w_command.resolveFn(p_package);
            }
            return p_package;
        },
            (p_reason) =&gt; {
                if (w_command.rejectFn) {
                    w_command.rejectFn(p_reason);
                }
                return p_reason;
            }
        );
}

</t>
<t tx="felix.20200718024635.8">/**
 * * Handle the result from the command that has finished: either launch the next one, or refresh accordingly.
 * @param p_package is the json return 'package' that was just received back from Leo
 */
private _resolveResult(p_package: LeoBridgePackage): void {
    this._stack.shift(); // Finally remove resolved command from stack bottom

    this._selectedNode = JSON.stringify(p_package.node);

    if (!this.size()) {
        // If last is done then do refresh outline and focus on outline, or body, as required
        this._busy = false;
        if (Object.keys(this._finalRefreshType).length) {
            // At least some type of refresh
            this._leoIntegration.launchRefresh(this._finalRefreshType, this._finalFromOutline, p_package.node);
        }
        // Reset refresh type and focus flag nonetheless
        this._finalRefreshType = {};
        this._finalFromOutline = false;
    } else {
        // Size &gt; 0, so call _runStackCommand again, keep _busy set to true
        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}

</t>
<t tx="felix.20200718030926.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { ConfigMembers, ConfigSetting, FontSettings } from "./types";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718030926.2">/**
 * * Configuration Settings Service
 */
export class Config implements ConfigMembers {

    // Config settings used in leobridgeserver.py, on Leo's side
    public checkForChangeExternalFiles: string = Constants.CONFIG_DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES;
    public defaultReloadIgnore: string = Constants.CONFIG_DEFAULTS.DEFAULT_RELOAD_IGNORE;
    // Config settings used in leoInteg/vscode's side
    public leoTreeBrowse: boolean = Constants.CONFIG_DEFAULTS.LEO_TREE_BROWSE;
    public treeKeepFocus: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS;
    public treeKeepFocusWhenAside: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE;
    public statusBarString: string = Constants.CONFIG_DEFAULTS.STATUSBAR_STRING;
    public statusBarColor: string = Constants.CONFIG_DEFAULTS.STATUSBAR_COLOR;
    public treeInExplorer: boolean = Constants.CONFIG_DEFAULTS.TREE_IN_EXPLORER;
    public showOpenAside: boolean = Constants.CONFIG_DEFAULTS.SHOW_OPEN_ASIDE;
    public showEditOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_EDIT;
    public showArrowsOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_ARROWS;
    public showAddOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_ADD;
    public showMarkOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_MARK;
    public showCloneOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_CLONE;
    public showCopyOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_COPY;

    public showEditionOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EDITION_BODY;
    public showClipboardOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_CLIPBOARD_BODY;
    public showPromoteOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_PROMOTE_BODY;
    public showExecuteOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EXECUTE_BODY;
    public showExtractOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EXTRACT_BODY;
    public showImportOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_IMPORT_BODY;
    public showRefreshOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_REFRESH_BODY;
    public showHoistOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_HOIST_BODY;
    public showMarkOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_MARK_BODY;
    public showSortOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_SORT_BODY;

    public invertNodeContrast: boolean = Constants.CONFIG_DEFAULTS.INVERT_NODES;
    public leoPythonCommand: string = Constants.CONFIG_DEFAULTS.LEO_PYTHON_COMMAND;
    public leoEditorPath: string = Constants.CONFIG_DEFAULTS.LEO_EDITOR_PATH;
    public startServerAutomatically: boolean = Constants.CONFIG_DEFAULTS.AUTO_START_SERVER;
    public connectToServerAutomatically: boolean = Constants.CONFIG_DEFAULTS.AUTO_CONNECT;
    public connectionAddress: string = Constants.CONFIG_DEFAULTS.IP_ADDRESS;
    public connectionPort: number = Constants.CONFIG_DEFAULTS.IP_PORT;

    public setDetached: boolean = Constants.CONFIG_DEFAULTS.SET_DETACHED;
    public limitUsers: number = Constants.CONFIG_DEFAULTS.LIMIT_USERS;

    private _isBusySettingConfig: boolean = false;
    private _needsTreeRefresh: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20200718030926.3">/**
 * * Get actual 'live' Leointeg configuration
 * @returns An object with config settings members such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public getConfig(): ConfigMembers {
    return {
        checkForChangeExternalFiles: this.checkForChangeExternalFiles,  // Used in leoBridge script
        defaultReloadIgnore: this.defaultReloadIgnore,  // Used in leoBridge script
        leoTreeBrowse: this.leoTreeBrowse,
        treeKeepFocus: this.treeKeepFocus,
        treeKeepFocusWhenAside: this.treeKeepFocusWhenAside,
        statusBarString: this.statusBarString,
        statusBarColor: this.statusBarColor,
        treeInExplorer: this.treeInExplorer,
        showOpenAside: this.showOpenAside,
        showEditOnNodes: this.showEditOnNodes,
        showArrowsOnNodes: this.showArrowsOnNodes,
        showAddOnNodes: this.showAddOnNodes,
        showMarkOnNodes: this.showMarkOnNodes,
        showCloneOnNodes: this.showCloneOnNodes,
        showCopyOnNodes: this.showCopyOnNodes,

        showEditionOnBody: this.showEditionOnBody,
        showClipboardOnBody: this.showClipboardOnBody,
        showPromoteOnBody: this.showPromoteOnBody,
        showExecuteOnBody: this.showExecuteOnBody,
        showExtractOnBody: this.showExtractOnBody,
        showImportOnBody: this.showImportOnBody,
        showRefreshOnBody: this.showRefreshOnBody,
        showHoistOnBody: this.showHoistOnBody,
        showMarkOnBody: this.showMarkOnBody,
        showSortOnBody: this.showSortOnBody,

        invertNodeContrast: this.invertNodeContrast,
        leoPythonCommand: this.leoPythonCommand,
        leoEditorPath: this.leoEditorPath,
        startServerAutomatically: this.startServerAutomatically,
        connectToServerAutomatically: this.connectToServerAutomatically,
        connectionAddress: this.connectionAddress,
        connectionPort: this.connectionPort,

        setDetached: this.setDetached,
        limitUsers: this.limitUsers,
    };
}

</t>
<t tx="felix.20200718030926.4">/**
 * * Apply changes to the expansion config settings and save them in user settings.
 * @param p_changes is an array of codes and values to be changed
 * @returns a promise that resolves upon completion
 */
public setLeoIntegSettings(p_changes: ConfigSetting[]): Promise&lt;void&gt; {
    this._isBusySettingConfig = true;
    const w_promises: Thenable&lt;void&gt;[] = [];
    const w_vscodeConfig = vscode.workspace.getConfiguration(Constants.CONFIG_NAME);
    p_changes.forEach(i_change =&gt; {
        if (i_change &amp;&amp; i_change.code.includes(Constants.CONFIG_REFRESH_MATCH)) {
            // Check if tree refresh is required for hover-icons to be displayed or hidden accordingly
            this._needsTreeRefresh = true;
        }
        if (w_vscodeConfig.inspect(i_change.code)!.defaultValue === i_change.value) {
            // Set as undefined - same as default
            w_promises.push(w_vscodeConfig.update(i_change.code, undefined, true));
        } else {
            // Set as value which is not default
            w_promises.push(w_vscodeConfig.update(i_change.code, i_change.value, true));
        }
    });
    return Promise.all(w_promises).then(() =&gt; {
        if (this._needsTreeRefresh) {
            this._needsTreeRefresh = false;
            setTimeout(() =&gt; {
                this._leoIntegration.configTreeRefresh();
            }, 200);
        }
        this._isBusySettingConfig = false;
        this.buildFromSavedSettings();
        return Promise.resolve();
    });
}

</t>
<t tx="felix.20200718030926.5">/**
 * * Build config from settings from vscode's saved config settings
 */
public buildFromSavedSettings(): void {
    // Shorthand pointers for readability
    const GET = vscode.workspace.getConfiguration;
    const NAME = Constants.CONFIG_NAME;
    const NAMES = Constants.CONFIG_NAMES;
    const DEFAULTS = Constants.CONFIG_DEFAULTS;
    const FLAGS = Constants.CONTEXT_FLAGS;

    if (this._isBusySettingConfig) {
        // * Currently setting config, wait until its done all, and this will be called automatically
        return;
    } else {
        this.checkForChangeExternalFiles = GET(NAME).get(NAMES.CHECK_FOR_CHANGE_EXTERNAL_FILES, DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES);
        this.defaultReloadIgnore = GET(NAME).get(NAMES.DEFAULT_RELOAD_IGNORE, DEFAULTS.DEFAULT_RELOAD_IGNORE);
        this.leoTreeBrowse = GET(NAME).get(NAMES.LEO_TREE_BROWSE, DEFAULTS.LEO_TREE_BROWSE);
        this.treeKeepFocus = GET(NAME).get(NAMES.TREE_KEEP_FOCUS, DEFAULTS.TREE_KEEP_FOCUS);
        this.treeKeepFocusWhenAside = GET(NAME).get(NAMES.TREE_KEEP_FOCUS_WHEN_ASIDE, DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE);
        this.statusBarString = GET(NAME).get(NAMES.STATUSBAR_STRING, DEFAULTS.STATUSBAR_STRING);
        if (this.statusBarString.length &gt; 8) {
            this.statusBarString = DEFAULTS.STATUSBAR_STRING;
        }
        this.statusBarColor = GET(NAME).get(NAMES.STATUSBAR_COLOR, DEFAULTS.STATUSBAR_COLOR);
        if (!utils.isHexColor(this.statusBarColor)) {
            this.statusBarColor = DEFAULTS.STATUSBAR_COLOR;
        }
        this.treeInExplorer = GET(NAME).get(NAMES.TREE_IN_EXPLORER, DEFAULTS.TREE_IN_EXPLORER);
        this.showOpenAside = GET(NAME).get(NAMES.SHOW_OPEN_ASIDE, DEFAULTS.SHOW_OPEN_ASIDE);
        this.showEditOnNodes = GET(NAME).get(NAMES.SHOW_EDIT, DEFAULTS.SHOW_EDIT);
        this.showArrowsOnNodes = GET(NAME).get(NAMES.SHOW_ARROWS, DEFAULTS.SHOW_ARROWS);
        this.showAddOnNodes = GET(NAME).get(NAMES.SHOW_ADD, DEFAULTS.SHOW_ADD);
        this.showMarkOnNodes = GET(NAME).get(NAMES.SHOW_MARK, DEFAULTS.SHOW_MARK);
        this.showCloneOnNodes = GET(NAME).get(NAMES.SHOW_CLONE, DEFAULTS.SHOW_CLONE);
        this.showCopyOnNodes = GET(NAME).get(NAMES.SHOW_COPY, DEFAULTS.SHOW_COPY);

        this.showEditionOnBody = GET(NAME).get(NAMES.SHOW_EDITION_BODY, DEFAULTS.SHOW_EDITION_BODY);
        this.showClipboardOnBody = GET(NAME).get(NAMES.SHOW_CLIPBOARD_BODY, DEFAULTS.SHOW_CLIPBOARD_BODY);
        this.showPromoteOnBody = GET(NAME).get(NAMES.SHOW_PROMOTE_BODY, DEFAULTS.SHOW_PROMOTE_BODY);
        this.showExecuteOnBody = GET(NAME).get(NAMES.SHOW_EXECUTE_BODY, DEFAULTS.SHOW_EXECUTE_BODY);
        this.showExtractOnBody = GET(NAME).get(NAMES.SHOW_EXTRACT_BODY, DEFAULTS.SHOW_EXTRACT_BODY);
        this.showImportOnBody = GET(NAME).get(NAMES.SHOW_IMPORT_BODY, DEFAULTS.SHOW_IMPORT_BODY);
        this.showRefreshOnBody = GET(NAME).get(NAMES.SHOW_REFRESH_BODY, DEFAULTS.SHOW_REFRESH_BODY);
        this.showHoistOnBody = GET(NAME).get(NAMES.SHOW_HOIST_BODY, DEFAULTS.SHOW_HOIST_BODY);
        this.showMarkOnBody = GET(NAME).get(NAMES.SHOW_MARK_BODY, DEFAULTS.SHOW_MARK_BODY);
        this.showSortOnBody = GET(NAME).get(NAMES.SHOW_SORT_BODY, DEFAULTS.SHOW_SORT_BODY);

        this.invertNodeContrast = GET(NAME).get(NAMES.INVERT_NODES, DEFAULTS.INVERT_NODES);
        this.leoEditorPath = GET(NAME).get(NAMES.LEO_EDITOR_PATH, DEFAULTS.LEO_EDITOR_PATH);
        this.leoPythonCommand = GET(NAME).get(NAMES.LEO_PYTHON_COMMAND, DEFAULTS.LEO_PYTHON_COMMAND);
        this.startServerAutomatically = GET(NAME).get(NAMES.AUTO_START_SERVER, DEFAULTS.AUTO_START_SERVER);
        this.connectToServerAutomatically = GET(NAME).get(NAMES.AUTO_CONNECT, DEFAULTS.AUTO_CONNECT);
        this.connectionAddress = GET(NAME).get(NAMES.IP_ADDRESS, DEFAULTS.IP_ADDRESS);
        this.connectionPort = GET(NAME).get(NAMES.IP_PORT, DEFAULTS.IP_PORT);

        this.setDetached = GET(NAME).get(NAMES.SET_DETACHED, DEFAULTS.SET_DETACHED);
        this.limitUsers = GET(NAME).get(NAMES.LIMIT_USERS, DEFAULTS.LIMIT_USERS);

        // * Set context for tree items visibility that are based on config options
        if (this._leoIntegration.leoStates.leoBridgeReady) {
            this._leoIntegration.sendConfigToServer(this.getConfig());
        }
        utils.setContext(FLAGS.LEO_TREE_BROWSE, this.leoTreeBrowse);
        utils.setContext(FLAGS.TREE_IN_EXPLORER, this.treeInExplorer);
        utils.setContext(FLAGS.SHOW_OPEN_ASIDE, this.showOpenAside);
        utils.setContext(FLAGS.SHOW_EDIT, this.showEditOnNodes);
        utils.setContext(FLAGS.SHOW_ARROWS, this.showArrowsOnNodes);
        utils.setContext(FLAGS.SHOW_ADD, this.showAddOnNodes);
        utils.setContext(FLAGS.SHOW_MARK, this.showMarkOnNodes);
        utils.setContext(FLAGS.SHOW_CLONE, this.showCloneOnNodes);
        utils.setContext(FLAGS.SHOW_COPY, this.showCopyOnNodes);

        utils.setContext(FLAGS.SHOW_EDITION_BODY, this.showEditionOnBody);
        utils.setContext(FLAGS.SHOW_CLIPBOARD_BODY, this.showClipboardOnBody);
        utils.setContext(FLAGS.SHOW_PROMOTE_BODY, this.showPromoteOnBody);
        utils.setContext(FLAGS.SHOW_EXECUTE_BODY, this.showExecuteOnBody);
        utils.setContext(FLAGS.SHOW_EXTRACT_BODY, this.showExtractOnBody);
        utils.setContext(FLAGS.SHOW_IMPORT_BODY, this.showImportOnBody);
        utils.setContext(FLAGS.SHOW_REFRESH_BODY, this.showRefreshOnBody);
        utils.setContext(FLAGS.SHOW_HOIST_BODY, this.showHoistOnBody);
        utils.setContext(FLAGS.SHOW_MARK_BODY, this.showMarkOnBody);
        utils.setContext(FLAGS.SHOW_SORT_BODY, this.showSortOnBody);

        utils.setContext(FLAGS.AUTO_CONNECT, this.connectToServerAutomatically);

        if (!this._leoIntegration.leoStates.leoStartupFinished &amp;&amp; this.leoEditorPath) {
            // Only relevant 'viewWelcome' content at startup.
            utils.setContext(FLAGS.AUTO_START_SERVER, this.startServerAutomatically);  // ok
            // utils.setContext(FLAGS.AUTO_CONNECT, this.connectToServerAutomatically);
        } else {
            utils.setContext(FLAGS.AUTO_START_SERVER, false); // Save option but not context flag
            //utils.setContext(FLAGS.AUTO_CONNECT, false);
        }
    }
}

</t>
<t tx="felix.20200718031424.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { ReqRefresh } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { LeoSettingsProvider } from "./webviews/leoSettingsWebview";
import { LeoButtonNode } from "./leoButtonNode";
import { LeoGotoNode } from "./leoGotoNode";

var LeoInteg: LeoIntegration | undefined = undefined;

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718031424.2">/**
 * * Called by vscode when extension is activated
 * It creates the leoIntegration instance
 * Will also open the 'welcome/Settings' webview instance if a new version is opened
 */
export function activate(p_context: vscode.ExtensionContext) {

    const w_start = process.hrtime(); // For calculating total startup time duration

    // * Reset Extension context flags (used in 'when' clauses in package.json)
    utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, false); // Connected to a leobridge server?
    utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, false); // Having a Leo file opened on that server?

    const w_leoIntegExtension = vscode.extensions.getExtension(Constants.PUBLISHER + '.' + Constants.NAME)!;
    const w_leoIntegVersion = w_leoIntegExtension.packageJSON.version;
    const w_leo: LeoIntegration = new LeoIntegration(p_context);
    if (w_leo) {
        LeoInteg = w_leo;
    }
    const w_leoSettingsWebview: LeoSettingsProvider = w_leo.leoSettingsWebview;
    const w_previousVersion = p_context.globalState.get&lt;string&gt;(Constants.VERSION_STATE_KEY);

    // Shortcut pointers for readability
    const U = undefined;
    const BRIDGE = Constants.LEOBRIDGE;
    const CMD = Constants.COMMANDS;
    // * Refresh helper variables: 'states' refresh will also refresh documents pane.
    const NO_REFRESH: ReqRefresh = {};
    const REFRESH_NODE_BODY: ReqRefresh = {
        node: true, // Reveal the returned 'selected position' without changes to the tree
        body: true, // Goto/select another node needs the body pane refreshed
        states: true // * Also refreshes documents pane if node's 'changed' state differ.
    };
    const REFRESH_TREE: ReqRefresh = {
        tree: true,
        states: true // * Also refreshes documents pane if node's 'changed' state differ.
    };
    const REFRESH_TREE_BODY: ReqRefresh = {
        tree: true,
        body: true,
        states: true // * Also refreshes documents pane if node's 'changed' state differ.
    };

    const w_commands: [string, (...args: any[]) =&gt; any][] = [

        // ! REMOVE TESTS ENTRIES FROM PACKAGE.JSON FOR MASTER BRANCH RELEASES !
        ["leointeg.test", () =&gt; w_leo.test()], // Test function useful when debugging
        // ["leointeg.testFromOutline", () =&gt; w_leo.test(true)], // Test function useful when debugging.

        &lt;&lt; Define entries for all commands &gt;&gt;
    ];

    w_commands.map(function (p_command) {
        p_context.subscriptions.push(vscode.commands.registerCommand(...p_command));
    });

    // * Close remaining Leo Bodies restored by vscode from last session.
    closeLeoTextEditors();

    // * Show a welcome screen on version updates, then start the actual extension.
    showWelcomeIfNewer(w_leoIntegVersion, w_previousVersion, w_leo)
        .then(() =&gt; {
            // if setting for preview mode enabled is false then show popup
            setTimeout(() =&gt; {
                // A second and a half to make sure first installs have finished setting those
                // and not to try to see if they're set too soon
                w_leo.config.checkEnablePreview();
                w_leo.config.checkCloseEmptyGroups();
                w_leo.config.checkCloseOnFileDelete();
            }, 1500);

            // Start server and/or connect to it, as per user settings
            w_leo.startNetworkServices();
            // Save version # for next startup comparison
            p_context.globalState.update(Constants.VERSION_STATE_KEY, w_leoIntegVersion);

            // * Log time taken for startup
            // console.log('leoInteg startup launched in ', utils.getDurationMs(w_start), 'ms');

        });
}

</t>
<t tx="felix.20200718031424.24">/**
 * * Called when extension is deactivated
 */
export function deactivate(): Promise&lt;boolean&gt; {
    closeLeoTextEditors();
    if (LeoInteg) {
        LeoInteg.activated = false;
        LeoInteg.cleanupBody().then(() =&gt; {
            LeoInteg?.stopConnection();
        });
        // Call to LeoInteg.stopServer() is not needed: server should handle disconnects.
        // Server should open tk GUI dialogs if dirty files still remain before closing itself.
        return new Promise((p_resolve, p_reject) =&gt; {
            setTimeout(() =&gt; {
                LeoInteg?.killServer();
                p_resolve(true);
            }, 30000);
        }
        );
    } else {
        return Promise.resolve(false);
    }
}

</t>
<t tx="felix.20200718031424.25">/**
 * * Show welcome screen if needed, based on last version executed
 * @param p_version Current version, as a string, from packageJSON.version
 * @param p_previousVersion Previous version, as a string, from context.globalState.get service
 * @returns A promise that triggers when command to show the welcome screen is finished, or immediately if not needed
 */
async function showWelcomeIfNewer(p_version: string, p_previousVersion: string | undefined, p_leoInteg: LeoIntegration): Promise&lt;unknown&gt; {
    let w_showWelcomeScreen: boolean = false;
    if (p_previousVersion === undefined) {
        console.log('leointeg first-time install');
        // Force-Set/Clear leointeg's required configuration settings
        p_leoInteg.config.setEnablePreview();
        p_leoInteg.config.clearCloseEmptyGroups();
        p_leoInteg.config.setCloseOnFileDelete();
        w_showWelcomeScreen = true;
    } else {
        if (p_previousVersion !== p_version) {
            vscode.window.showInformationMessage(`leoInteg upgraded from v${p_previousVersion} to v${p_version}`);
            // Force-Set/Clear leointeg's required configuration settings but show info messages
            p_leoInteg.config.checkEnablePreview(true);
            p_leoInteg.config.checkCloseEmptyGroups(true);
            p_leoInteg.config.checkCloseOnFileDelete(true);
        }
        const [w_major, w_minor] = p_version.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        const [w_prevMajor, w_prevMinor] = p_previousVersion.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        if (
            (w_major === w_prevMajor &amp;&amp; w_minor === w_prevMinor) ||
            // Don't notify on downgrades
            (w_major &lt; w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &lt; w_prevMinor))
        ) {
            w_showWelcomeScreen = false;
        } else if (w_major !== w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &gt; w_prevMinor)) {
            // Will show on major or minor upgrade (Formatted as 'Major.Minor.Revision' eg. 1.2.3)
            w_showWelcomeScreen = true;
        }
    }
    if (w_showWelcomeScreen) {
        return vscode.commands.executeCommand(Constants.COMMANDS.SHOW_WELCOME);
    } else {
        return Promise.resolve();
    }
}
</t>
<t tx="felix.20200718035737.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import {
    AskMessageItem,
    runAskYesNoDialogParameters,
    runWarnMessageDialogParameters,
    runInfoMessageDialogParameters,
    showSaveAsDialogParameters
} from "./types";
import { LeoIntegration } from "./leoIntegration";

@others
</t>
<t tx="felix.20200718040540.1">import * as vscode from "vscode";
import * as utils from "./utils";
import * as path from 'path';
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { BodyTimeInfo } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718040540.10">public stat(p_uri: vscode.Uri): vscode.FileStat | Thenable&lt;vscode.FileStat&gt; {
    // TODO : Fix/Check extraneous stat(...) call(s)
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        const w_gnx = utils.leoUriToStr(p_uri);
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            return { type: vscode.FileType.Directory, ctime: 0, mtime: 0, size: 0 };
        } else if (w_gnx === this._lastGnx &amp;&amp; this._openedBodiesGnx.includes(this._lastGnx)) {
            return {
                type: vscode.FileType.File,
                ctime: this._openedBodiesInfo[this._lastGnx].ctime,
                mtime: this._openedBodiesInfo[this._lastGnx].mtime,
                size: this._lastBodyLength
            };
        } else if (this._openedBodiesGnx.includes(w_gnx)) {
            return this._leoIntegration.sendAction(
                Constants.LEOBRIDGE.GET_BODY_LENGTH,
                JSON.stringify({ "gnx": w_gnx })
            ).then((p_result) =&gt; {
                return Promise.resolve(
                    {
                        type: vscode.FileType.File,
                        ctime: this._openedBodiesInfo[w_gnx].ctime,
                        mtime: this._openedBodiesInfo[w_gnx].mtime,
                        size: p_result.len ? p_result.len : 0
                    }
                );
            });
        }
    }
    // throw vscode.FileSystemError.FileNotFound();
    // (Instead of FileNotFound) should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
    return { type: vscode.FileType.File, ctime: 0, mtime: 0, size: 0 };
}

</t>
<t tx="felix.20200718040540.11">public readFile(p_uri: vscode.Uri): Thenable&lt;Uint8Array&gt; {
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            throw vscode.FileSystemError.FileIsADirectory();
        } else {
            const w_gnx = utils.leoUriToStr(p_uri);
            // if (!this._possibleGnxList.includes(w_gnx)) {
            if (!this._openedBodiesGnx.includes(w_gnx)) {
                console.error("readFile: ERROR File not in _openedBodiesGnx! readFile missing refreshes?");
                // throw vscode.FileSystemError.FileNotFound();
                // (Instead of FileNotFound) should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
                if (!this._errorRefreshFlag) {
                    this._tryFullRefresh();
                }
                return Promise.resolve(Buffer.from(""));
            } else {
                return this._leoIntegration.sendAction(
                    Constants.LEOBRIDGE.GET_BODY,
                    JSON.stringify({ "gnx": w_gnx })
                ).then((p_result) =&gt; {
                    if (p_result.body) {
                        this._errorRefreshFlag = false; // got body so reset possible flag!
                        this._lastGnx = w_gnx;
                        this._lastBodyData = p_result.body;
                        const w_buffer: Uint8Array = Buffer.from(p_result.body);
                        this._lastBodyLength = w_buffer.byteLength;
                        return Promise.resolve(w_buffer);
                    } else if (p_result.body === "") {
                        this._lastGnx = w_gnx;
                        this._lastBodyLength = 0;
                        this._lastBodyData = "";
                        return Promise.resolve(Buffer.from(""));
                    } else {
                        if (!this._errorRefreshFlag) {
                            this._tryFullRefresh();
                        }
                        if (this._lastGnx === w_gnx) {
                            // was last gnx of closed file about to be switched to new document selected
                            console.log('Passed in not found: ' + w_gnx);
                            return Promise.resolve(Buffer.from(this._lastBodyData));
                        }
                        console.error("ERROR =&gt; readFile of unknown GNX"); // is possibleGnxList updated correctly?
                        //  throw vscode.FileSystemError.FileNotFound();
                        // (Instead of FileNotFound) should be caught by _onActiveEditorChanged or _changedVisibleTextEditors
                        return Promise.resolve(Buffer.from(""));
                    }
                });
            }
        }
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20200718040540.12">public readDirectory(p_uri: vscode.Uri): Thenable&lt;[string, vscode.FileType][]&gt; {
    if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
        const w_directory: [string, vscode.FileType][] = [];
        w_directory.push([this._lastBodyTimeGnx, vscode.FileType.File]);
        return Promise.resolve(w_directory);
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20200718040540.13">public createDirectory(p_uri: vscode.Uri): void {
    console.warn('Called createDirectory with ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20200718040540.14">public writeFile(p_uri: vscode.Uri, p_content: Uint8Array, p_options: { create: boolean, overwrite: boolean }): void {
    if (!this.preventSaveToLeo) {
        this._leoIntegration.triggerBodySave(true); // Might have been a vscode 'save' via the menu
    } else {
        this.preventSaveToLeo = false;
    }
    const w_gnx = utils.leoUriToStr(p_uri);
    if (!this._openedBodiesGnx.includes(w_gnx)) {
        console.error("Leointeg: Tried to save body other than selected node's body", w_gnx);
        this._openedBodiesGnx.push(w_gnx);
    }
    const w_now = new Date().getTime();
    this._openedBodiesInfo[w_gnx] = {
        ctime: w_now,
        mtime: w_now
    };
    this._fireSoon({ type: vscode.FileChangeType.Changed, uri: p_uri });
}

</t>
<t tx="felix.20200718040540.15">public rename(p_oldUri: vscode.Uri, p_newUri: vscode.Uri, p_options: { overwrite: boolean }): void {
    console.warn('Called rename on ', p_oldUri.fsPath, p_newUri.fsPath); // should not happen
    this._fireSoon(
        { type: vscode.FileChangeType.Deleted, uri: p_oldUri },
        { type: vscode.FileChangeType.Created, uri: p_newUri }
    );
}

</t>
<t tx="felix.20200718040540.16">public delete(p_uri: vscode.Uri): void {
    // console.log("delete", p_uri.fsPath);
    const w_gnx = utils.leoUriToStr(p_uri);
    if (this._openedBodiesGnx.includes(w_gnx)) {
        this._openedBodiesGnx.splice(this._openedBodiesGnx.indexOf(w_gnx), 1);
        delete this._openedBodiesInfo[w_gnx];
    } else {
        // console.log("not deleted");
    }

    // dirname is just a slash "/"
    let w_dirname = p_uri.with({ path: path.posix.dirname(p_uri.path) });

    this._fireSoon(
        { type: vscode.FileChangeType.Changed, uri: w_dirname },
        { uri: p_uri, type: vscode.FileChangeType.Deleted }
    );
}

</t>
<t tx="felix.20200718040540.17">public copy(p_uri: vscode.Uri): void {
    console.warn('Called copy on ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20200718040540.18">private _fireSoon(...p_events: vscode.FileChangeEvent[]): void {
    this._bufferedEvents.push(...p_events);
    if (this._fireSoonHandle) {
        clearTimeout(this._fireSoonHandle);
    }
    this._fireSoonHandle = setTimeout(() =&gt; {
        this._onDidChangeFileEmitter.fire(this._bufferedEvents);
        this._bufferedEvents.length = 0; // clearing events array
    }, 5);
}

</t>
<t tx="felix.20200718040540.2">/**
 * * Body panes implementation as a file system using "leo" as a scheme identifier
 * Saving and renaming prevents flickering and prevents undos to 'traverse through' different gnx
 */
export class LeoBodyProvider implements vscode.FileSystemProvider {

    // * Flag normally false
    public preventSaveToLeo: boolean = false;
    private _errorRefreshFlag: boolean = false;

    // * Last file read data with the readFile method
    private _lastGnx: string = ""; // gnx of last file read
    private _lastBodyData: string = ""; // body content of last file read
    private _lastBodyLength: number = 0; // length of last file read

    // * List of currently opened body panes gnx (from 'watch' &amp; 'dispose' methods)
    private _watchedBodiesGnx: string[] = [];

    // * List of gnx that should be available (from more.selectNode and fs.delete)
    private _openedBodiesGnx: string[] = [];
    private _openedBodiesInfo: { [key: string]: BodyTimeInfo } = {};

    // * List of all possible vNodes gnx in the currently opened leo file (since last refresh/tree operation)
    private _possibleGnxList: string[] = []; // Maybe deprecated

    private _lastBodyTimeGnx: string = "";

    // * An event to signal that a resource has been changed
    // * It should fire for resources that are being [watched](#FileSystemProvider.watch) by clients of this provider
    private _onDidChangeFileEmitter = new vscode.EventEmitter&lt;vscode.FileChangeEvent[]&gt;();
    readonly onDidChangeFile: vscode.Event&lt;vscode.FileChangeEvent[]&gt; = this._onDidChangeFileEmitter.event;
    private _bufferedEvents: vscode.FileChangeEvent[] = [];
    private _fireSoonHandle?: NodeJS.Timer;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718040540.3">/**
 * * Sets selected node body's modified time for this gnx virtual file
 * @param p_uri URI of file for which to set made-up modified time
 */
public setBodyTime(p_uri: vscode.Uri): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    this._lastBodyTimeGnx = w_gnx;
    if (!this._openedBodiesGnx.includes(w_gnx)) {
        this._openedBodiesGnx.push(w_gnx);
    }
    const w_now = new Date().getTime();
    this._openedBodiesInfo[w_gnx] = {
        ctime: w_now,
        mtime: w_now
    };
}

</t>
<t tx="felix.20200718040540.5">/**
 * * Refresh the body pane for a particular gnx by telling vscode that the file from the Leo file provider has changed
 * @param p_gnx Gnx of body associated with this virtual file, mostly Leo's selected node
 */
public fireRefreshFile(p_gnx: string): void {
    if (!this._openedBodiesGnx.includes(p_gnx)) {
        console.error("ASKED TO REFRESH NOT EVEN IN SELECTED BODY: ", p_gnx);
        this._openedBodiesGnx.push(p_gnx);
    }
    const w_now = new Date().getTime();
    this._openedBodiesInfo[p_gnx] = {
        ctime: w_now,
        mtime: w_now
    };
    this._onDidChangeFileEmitter.fire([{
        type: vscode.FileChangeType.Changed,
        uri: utils.strToLeoUri(p_gnx)
    } as vscode.FileChangeEvent]);
}

</t>
<t tx="felix.20200718040540.6">/**
 * Maybe deprecated
 * * Refreshes the '_possibleGnxList' list of all unique gnx from Leo
 * @returns a promise that resolves to the fresh gnx string array
 */
public refreshPossibleGnxList(): Thenable&lt;string[]&gt; {
    // * Get updated list of possible gnx
    return this._leoIntegration.sendAction(
        Constants.LEOBRIDGE.GET_ALL_GNX
    ).then((p_result) =&gt; {
        this._possibleGnxList = p_result.gnx || [];
        return Promise.resolve(this._possibleGnxList);
    });
}

</t>
<t tx="felix.20200718040540.8">public watch(p_resource: vscode.Uri): vscode.Disposable {
    const w_gnx = utils.leoUriToStr(p_resource);
    if (!this._watchedBodiesGnx.includes(w_gnx)) {
        this._watchedBodiesGnx.push(w_gnx); // add gnx
    } else {
    }
    return new vscode.Disposable(() =&gt; {
        const w_position = this._watchedBodiesGnx.indexOf(w_gnx); // find and remove it
        if (w_position &gt; -1) {
            this._watchedBodiesGnx.splice(w_position, 1);
        }
    });
}

</t>
<t tx="felix.20200718153505.1">import * as vscode from "vscode";
import * as WebSocket from 'ws';
import { Constants } from "./constants";
import { LeoBridgePackage, LeoAction } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoAsync } from "./leoAsync";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718153505.11">/**
 * * Process data that came from the Leo process
 * @param p_data given JSON data
 */
private _processAnswer(p_data: string): void {
    const w_parsedData = this._tryParseJSON(p_data);
    // Check for ServerError

    if (w_parsedData &amp;&amp; w_parsedData['ServerError']) {
        const w_serverError: string = w_parsedData['ServerError'];
        // action not found
        if (w_serverError.includes("action not found")) {
            // Show update suggestion if not already shown
            if (!this._updateWarningShown) {
                this._updateWarningShown = true;
                vscode.window.showErrorMessage(Constants.USER_MESSAGES.MINIMUM_VERSION);
            }
        }
    }

    if (w_parsedData &amp;&amp; (w_parsedData.id === 0 || w_parsedData.id)) {
        this._resolveBridgeReady(w_parsedData);
        this._callAction();
    } else if (w_parsedData &amp;&amp; w_parsedData.async) {
        // * Check for async messages such as log pane entries or other
        this._asyncAction(w_parsedData);
    } else {
        // unprocessed/unknown python output
        console.error("[leoBridge] Unprocessed or unknown JSON received: ", p_data);
    }
}

</t>
<t tx="felix.20200718153505.12">/**
 * * Create a websocket connection to a Leo server
 * @param p_port optional port number to override config port
 * @returns A promise for a LeoBridgePackage object containing only an 'id' member of 1 that will resolve when the 'leoBridge' is established
 */
public initLeoProcess(p_port?: number): Promise&lt;LeoBridgePackage&gt; {
    this._websocket = new WebSocket(
        Constants.TCPIP_DEFAULT_PROTOCOL +
        this._leoIntegration.config.connectionAddress +
        ":" +
        (p_port ? p_port : this._leoIntegration.config.connectionPort)
    );
    // * Capture the python process output
    this._websocket.onmessage = (p_event) =&gt; {
        this._receivedTotal++;
        if (p_event.data) {
            this._processAnswer(p_event.data.toString());
        }
    };
    this._websocket.onerror = (p_event: WebSocket.ErrorEvent) =&gt; {
        console.error(`Websocket error: ${p_event.message}`);
    };
    this._websocket.onclose = (p_event: WebSocket.CloseEvent) =&gt; {
        // * Disconnected from server
        // console.log(`Websocket closed, code: ${p_event.code}`);
        if (!this._leoIntegration.activated) {
            return;
        }
        this._rejectAction(`Websocket closed, code: ${p_event.code}`);
        // TODO : Implement a better connection error handling
        if (this._leoIntegration.leoStates.leoBridgeReady) {
            this._leoIntegration.cancelConnect(`Websocket closed, code: ${p_event.code}`);
        }
    };
    // * Start first with 'preventCall' set to true: no need to call anything for the first 'ready'
    this._readyPromise = this.action("", "", { id: Constants.STARTING_PACKAGE_ID }, true);
    return this._readyPromise; // This promise will resolve when the started python process starts
}

</t>
<t tx="felix.20200718153505.13">/**
 * * Send into the python process input
 * @param p_data JSON Message string to be sent to leobridgeserver.py
 */
private _send(p_data: string): void {
    if (this._readyPromise) {
        this._readyPromise.then(() =&gt; { // using '.then' that was surely resolved already: to be buffered in case process isn't ready.
            if (this._websocket &amp;&amp; this._websocket.OPEN) {
                this._websocket.send(p_data); // p_message should be json
            }
        });
    }
}

</t>
<t tx="felix.20200718153505.2">/**
 * * Handles communication with the leobridgeserver.py python script via websockets
 * This implements a bridge-facing action stack, (push on top, remove bottom)
 * 'actions' get sent to Leo, and resolve a promise with the result when the answer comes back.
 * This 'stack' concept is similar to the 'CommandStack' class used for vscode's user interactions.
 */
export class LeoBridge {

    private _callStack: LeoAction[] = [];
    private _actionBusy: boolean = false; // Action was started from the bottom, but has yet to resolve

    private _leoBridgeSerialId: number = 0; // TODO : Error checking (should be Constants.STARTING_PACKAGE_ID or 0 or 2...?)
    private _readyPromise: Promise&lt;LeoBridgePackage&gt; | undefined;

    private _websocket: WebSocket | null = null;
    private _leoAsync: LeoAsync;

    private _updateWarningShown: boolean = false;

    private _receivedTotal: number = 0; // Websocket message received total

    // TODO : #10 @boltex See if this can help with anaconda/miniconda issues
    // private _hasbin = require('hasbin');

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._leoAsync = new LeoAsync(_context, _leoIntegration);
    }

    @others
}
</t>
<t tx="felix.20200718153505.3">/**
 * * Places an action on top of a stack, to be resolved from the bottom
 * @param p_action Command string to be performed by Leo via leobridgeserver.py
 * @param p_jsonParam Optional JSON parameter for the specified action
 * @param p_deferredPayload Used to build this._readyPromise that resolves itself at startup
 * @param p_preventCall Flag for special action used to build this._readyPromise that resolves itself at startup
 * @returns a Promise that will contain the JSON package answered back by leobridgeserver.py
 */
public action(p_action: string, p_jsonParam = "null", p_deferredPayload?: LeoBridgePackage, p_preventCall?: boolean): Promise&lt;LeoBridgePackage&gt; {
    return new Promise((p_resolve, p_reject) =&gt; {
        const w_action: LeoAction = {
            parameter: this._buildActionParameter(p_action, p_jsonParam),
            deferredPayload: p_deferredPayload ? p_deferredPayload : undefined,
            resolveFn: p_resolve,
            rejectFn: p_reject
        };

        this._callStack.push(w_action);
        if (!p_preventCall) {
            this._callAction();
        }
    });
}

</t>
<t tx="felix.20200718153505.4">/**
 * * Actions invoked by Leo that can be called asynchronously at any time
 * @param w_parsedData that contains an 'async' string member,
 * that was parsed from a _websocket.onmessage package
 */
private _asyncAction(w_parsedData: any): void {
    if (w_parsedData &amp;&amp; w_parsedData.async &amp;&amp; (typeof w_parsedData.async === "string")) {
        switch (w_parsedData.async) {
            case Constants.ASYNC_ACTIONS.ASYNC_LOG: {
                this._leoAsync.log(w_parsedData.log, w_parsedData.color);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_REFRESH: {
                this._leoAsync.refresh(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_ASK: {
                this._leoAsync.showAskModalDialog(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_WARN: {
                this._leoAsync.showWarnModalMessage(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_INFO: {
                this._leoAsync.showChangesDetectedInfoMessage(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_INTERVAL: {
                console.log("interval ", w_parsedData); // 'ping' interval for debugging
                break;
            }
            default: {
                console.error("[leoIntegration] Unknown async action ", w_parsedData);
                break;
            }
        }
    } else {
        console.error("[leoIntegration] Unknown async command from leoBridge");
    }
}

</t>
<t tx="felix.20200718153505.5">/**
 * * Build JSON string for action parameter to the leoBridge
 * @param p_action Action string to be invoked as command by Leo in the leobridgeserver.py script
 * @param p_jsonParam Optional JSON string to be added as a 'param' to the action sent to Leo
 * @returns the JSON string built from the action string and the parameters
 */
private _buildActionParameter(p_action: string, p_jsonParam?: string): string {
    return "{\"id\":" + (++this._leoBridgeSerialId) + // no quotes, serial id is a number, pre incremented
        ", \"action\": \"" + p_action +  // action is string so surround with quotes
        "\", \"param\":" + p_jsonParam +  // param is already json, no need for added quotes
        "}";
}

</t>
<t tx="felix.20200718153505.6">/**
 * * Resolves promises with the answers from an action that was finished
 * @param p_object Parsed data that was given as the answer by the Leo command that finished
 */
private _resolveBridgeReady(p_object: any): void {
    let w_bottomAction = this._callStack.shift();
    if (w_bottomAction) {
        if (w_bottomAction.deferredPayload) {
            // Used when the action already has a return value ready but is also waiting for python's side
            // We check if it's really the initial first, then replace the id and pass the results.
            if (w_bottomAction.deferredPayload.id === Constants.STARTING_PACKAGE_ID) {
                p_object.id = Constants.STARTING_PACKAGE_ID;
            }
            w_bottomAction.resolveFn(p_object); // given back with id=1 !
        } else {
            w_bottomAction.resolveFn(p_object);
        }
        this._actionBusy = false;
    } else {
        console.error("[leoBridge] Error stack empty");
    }
}

</t>
<t tx="felix.20200718153505.7">/**
 * * Rejects an action from the bottom of the stack
 * @param p_reason Given rejection 'reason'
 */
private _rejectAction(p_reason: string): void {
    const w_bottomAction = this._callStack.shift();
    if (w_bottomAction) {
        w_bottomAction.rejectFn(p_reason);
    }
}

</t>
<t tx="felix.20200718153505.8">/**
 * * Sends an action from the bottom of the stack
 */
private _callAction(): void {
    if (this._callStack.length &amp;&amp; !this._actionBusy) {
        this._actionBusy = true; // launch / resolve bottom one
        const w_action = this._callStack[0];
        this._send(w_action.parameter + "\n");
    }
}

</t>
<t tx="felix.20200718153505.9">/**
 * * JSON.parse encased in a Try/Catch block
 * @param p_jsonStr The JSON string to be parsed
 * @returns The resulting object or 'false' if unsuccessful
 */
private _tryParseJSON(p_jsonStr: string): boolean | any {
    try {
        var w_object = JSON.parse(p_jsonStr);
        // JSON.parse(null) returns null, and typeof null === "object", null is falsy, so this suffices:
        if (w_object &amp;&amp; typeof w_object === "object") {
            return w_object;
        }
    }
    catch (e) {
        console.error('[leoBridge] JSON was invalid: ' + p_jsonStr);
    }
    return false;
}

</t>
<t tx="felix.20200718155251.1">/**
 * * Busy state of the leoBridge's command stack
 * @returns true if leoBridge's command stack still has unresolved actions
 */
public isBusy(): boolean {
    return this._actionBusy || !!this._callStack.length;
}

</t>
<t tx="felix.20200718162303.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoButton, Icon, RClick } from "./types";
import * as utils from "./utils";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718162303.2">/**
 * * Leo @buttons tree view node item implementation, for usage in a TreeDataProvider.
 */
export class LeoButtonNode extends vscode.TreeItem {

    // Context string that is checked in package.json with 'when' clauses
    public contextValue: string;
    public rclicks: RClick[];

    private _id: string;

    // is the special 'add' button used to create button from a given node's script
    private _isAdd: boolean;

    constructor(
        public button: LeoButton,
        private _leoIntegration: LeoIntegration
    ) {
        super(button.name);
        // Cleanup button name of any directives starting with '@'
        // super(
        //     button.name.split(" ")
        //         .filter(item =&gt; item[0] !== "@")
        //         .join(" ")
        //         .trim()
        // );

        this._id = utils.getUniqueId();
        // Setup this instance (just differentiate 'script-button' for now)
        this.command = {
            command: Constants.COMMANDS.CLICK_BUTTON,
            title: '',
            arguments: [this]
        };
        this._isAdd = (this.button.index.startsWith(Constants.BUTTON_STRINGS.NULL_WIDGET) &amp;&amp;
            this.button.name === Constants.BUTTON_STRINGS.SCRIPT_BUTTON);
        this.rclicks = button.rclicks ? button.rclicks : [];
        this.contextValue = this._isAdd ? Constants.BUTTON_STRINGS.ADD_BUTTON : Constants.BUTTON_STRINGS.NORMAL_BUTTON;
    }

    @others
}
</t>
<t tx="felix.20200718162435.1">// @ts-ignore
public get iconPath(): Icon {
    return this._leoIntegration.buttonIcons[this._isAdd ? 2 : this.rclicks.length ? 1 : 0];
}

</t>
<t tx="felix.20200718162442.1">// @ts-ignore
public get id(): string {
    // Add prefix and suffix salt to index to prevent accidental duplicates
    return this._id;
    // return "p" + this.button.index + "s" + this.button.name;
}

</t>
<t tx="felix.20200718162452.1">// @ts-ignore
public get tooltip(): string {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON_TOOLTIP;
    } else {
        return this.button.name;
    }
}

</t>
<t tx="felix.20200718162459.1">// @ts-ignore
public get description(): string | boolean {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20200718164130.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoButtonNode } from "./leoButtonNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoButton } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718164130.2">/**
 * * '@buttons' shown as a list with this TreeDataProvider implementation
 */
export class LeoButtonsProvider implements vscode.TreeDataProvider&lt;LeoButtonNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoButtonNode | undefined&gt; = new vscode.EventEmitter&lt;LeoButtonNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoButtonNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718164130.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718164130.4">public getTreeItem(element: LeoButtonNode): Thenable&lt;LeoButtonNode&gt; | LeoButtonNode {
    return element;
}

</t>
<t tx="felix.20200718164130.5">public getChildren(element?: LeoButtonNode): Thenable&lt;LeoButtonNode[]&gt; {
    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

        // call action to get get list, and convert to LeoButtonNode(s) array
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BUTTONS).then(p_package =&gt; {
            if (p_package &amp;&amp; p_package.buttons) {
                const w_list: LeoButtonNode[] = [];
                const w_buttons: LeoButton[] = p_package.buttons;
                if (w_buttons &amp;&amp; w_buttons.length) {
                    w_buttons.forEach((p_button: LeoButton) =&gt; {
                        w_list.push(new LeoButtonNode(p_button, this._leoIntegration));
                    });
                }
                return w_list;
            } else {
                return [];
            }
        });
    } else {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
}

</t>
<t tx="felix.20200718164130.6">public getParent(element: LeoButtonNode): ProviderResult&lt;LeoButtonNode&gt; | null {
    // Buttons are just a list, as such, entries are always child of root so return null
    return null;
}

</t>
<t tx="felix.20200718164509.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoDocument, Icon } from "./types";
import * as utils from "./utils";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718164509.2">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoDocumentNode extends vscode.TreeItem {

    // Context string is checked in package.json with 'when' clauses
    public contextValue: string;
    private _id: string;

    constructor(
        public documentEntry: LeoDocument,
        private _leoIntegration: LeoIntegration
    ) {
        super(documentEntry.name);
        // Setup this instance
        this._id = utils.getUniqueId();
        const w_isNamed: boolean = !!this.documentEntry.name;
        this.label = w_isNamed ? utils.getFileFromPath(this.documentEntry.name) : Constants.UNTITLED_FILE_NAME;
        this.tooltip = w_isNamed ? this.documentEntry.name : Constants.UNTITLED_FILE_NAME;
        this.command = {
            command: Constants.COMMANDS.SET_OPENED_FILE,
            title: '',
            arguments: [this.documentEntry.index]
        };
        // If this was created as a selected node, make sure it's selected as we may have opened/closed document
        if (this.documentEntry.selected) {
            this._leoIntegration.setDocumentSelection(this);
            this.contextValue = w_isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_UNTITLED;
        } else {
            this.contextValue = w_isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_UNTITLED;
        }
    }

    @others
}
</t>
<t tx="felix.20200718164635.1">// @ts-ignore
public get iconPath(): Icon {
    return this._leoIntegration.documentIcons[this.documentEntry.changed ? 1 : 0];
}

</t>
<t tx="felix.20200718164638.1">// @ts-ignore
public get id(): string {
    // Add prefix and suffix salt to numeric index to prevent accidental duplicates
    // Should be unique when refreshed
    // return this._id;
    return "c" + (this.documentEntry.changed ? "y" : "n") +
        "p" + this.documentEntry.index +
        "s" + this.documentEntry.name;
}

</t>
<t tx="felix.20200718165108.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoDocumentNode } from "./leoDocumentNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoDocument } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718165108.2">/**
 * * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
export class LeoDocumentsProvider implements vscode.TreeDataProvider&lt;LeoDocumentNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoDocumentNode | undefined&gt; = new vscode.EventEmitter&lt;LeoDocumentNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoDocumentNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718165108.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718165108.4">public getTreeItem(element: LeoDocumentNode): Thenable&lt;LeoDocumentNode&gt; | LeoDocumentNode {
    return element;
}

</t>
<t tx="felix.20200718165108.5">public getChildren(element?: LeoDocumentNode): Thenable&lt;LeoDocumentNode[]&gt; {

    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

        // call action to get get list, and convert to LeoDocumentNode(s) array
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_OPENED_FILES).then(p_package =&gt; {
            if (p_package &amp;&amp; p_package.files) {
                const w_list: LeoDocumentNode[] = [];
                const w_files: LeoDocument[] = p_package.files;

                let w_index: number = 0;

                if (w_files &amp;&amp; w_files.length) {
                    w_files.forEach((i_file: LeoDocument) =&gt; {
                        i_file.index = w_index;
                        w_list.push(new LeoDocumentNode(i_file, this._leoIntegration));
                        w_index++;
                    });
                }
                return w_list;
            } else {
                return [];
            }
        });
    } else {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
}

</t>
<t tx="felix.20200718165108.6">public getParent(element: LeoDocumentNode): ProviderResult&lt;LeoDocumentNode&gt; | null {
    // Leo documents are just a list, as such, entries are always child of root, so return null
    return null;
}

</t>
<t tx="felix.20200718165721.1"></t>
<t tx="felix.20200718170429.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import * as path from "path"; // TODO : Use this to have reliable support for window-vs-linux file-paths

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718170429.2">/**
 * * Handles opening of file browser when choosing which Leo file to open
 */
export class LeoFilesBrowser {

    private _fileBrowserActive: boolean = false;

    constructor(private _context: vscode.ExtensionContext) { }

    @others
}
</t>
<t tx="felix.20200718170429.3">/**
 * * Finds a folder to propose when opening the browse-for-leo-file chooser
 * @returns An Uri for path to a folder for initial opening
 */
private _getBestOpenFolderUri(): vscode.Uri {
    let w_openedFileEnvUri: vscode.Uri | boolean = false;
    let w_activeUri: vscode.Uri | undefined = undefined;

    if (vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders[0]) {
        w_activeUri = vscode.workspace.workspaceFolders[0].uri;
    }

    if (w_activeUri) {
        const w_defaultFolder = vscode.workspace.getWorkspaceFolder(w_activeUri);
        if (w_defaultFolder) {
            w_openedFileEnvUri = w_defaultFolder.uri; // Set as current opened document-path's folder
        }
    }
    if (!w_openedFileEnvUri) {
        w_openedFileEnvUri = vscode.Uri.file("~"); // TODO : set as home folder properly, this doesn't work
        // ! EXAMPLE WITH os : const homedir = require('os').homedir();
    }
    return w_openedFileEnvUri;
}

</t>
<t tx="felix.20200718170429.4">/**
 * * Open a file browser and let the user choose a Leo file or cancel the operation
 * @param p_saveAsFlag Optional flag that will ask for a 'save' path+filename
 * @returns A promise resolving to a chosen path string, or rejected with an empty string if cancelled
 */
public getLeoFileUrl(p_saveAsFlag?: boolean): Promise&lt;string&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve("");
    }
    this._fileBrowserActive = true;
    return new Promise((p_resolve, p_reject) =&gt; {
        const w_filters: { [name: string]: string[] } = {};
        w_filters[Constants.FILE_OPEN_FILTER_MESSAGE] = [
            Constants.FILE_EXTENSION,
            Constants.JS_FILE_EXTENSION
        ];

        if (p_saveAsFlag) {
            // Choose file
            vscode.window.showSaveDialog({
                saveLabel: "Save Leo File",
                defaultUri: this._getBestOpenFolderUri(),
                filters: { 'Leo File': ['leo'] }
            })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // single string
                        p_resolve(p_chosenLeoFile.fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                    } else {
                        p_resolve(""); // not rejection - resolve empty string
                    }
                });
        } else {
            vscode.window
                .showOpenDialog({
                    canSelectMany: false,
                    defaultUri: this._getBestOpenFolderUri(),
                    canSelectFolders: false,
                    filters: w_filters
                })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // array instead of single string
                        p_resolve(p_chosenLeoFile[0].fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                    } else {
                        p_resolve("");
                    }
                });
        }
    });
}

</t>
<t tx="felix.20200718170712.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { ArchivedPosition, Icon } from "./types"; // ArchivedPosition included to help debug

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718170712.2">/**
 * * Implementation of tree nodes for usage in a TreeDataProvider
 */
export class LeoNode extends vscode.TreeItem {

    public contextValue: string; // * Context string is checked in package.json with 'when' clauses

    public isRoot: boolean = false; // * for hoist/dehoist context flags purposes

    constructor(
        public label: string, // Node headline
        public gnx: string,
        public collapsibleState: vscode.TreeItemCollapsibleState, // Computed in receiver/creator
        public apJson: string, // Key for leo/python side of things
        public childIndex: number, // For debugging purposes
        public cloned: boolean,
        public dirty: boolean,
        public marked: boolean,
        public atFile: boolean,
        public hasBody: boolean,
        public selected: boolean,
        public u: any,
        private _leoIntegration: LeoIntegration,
        private _id: string
    ) {
        super(label, collapsibleState);
        this.contextValue = this._getNodeContextValue();
        this.command = {
            command: Constants.COMMANDS.SELECT_NODE,
            title: '',
            arguments: [this]
        };
    }

    // * TO HELP DEBUG
    // get description(): string {
    //     // * some smaller grayed-out text accompanying the main label
    //     const w_ap: ArchivedPosition = JSON.parse(this.apJson);
    //     return "child:" + w_ap.childIndex + " lvl:" + w_ap.level + " gnx:" + w_ap.gnx;
    // }

    // get description(): string {
    //     // * some smaller grayed-out text accompanying the main label
    //     return "id:" + this.id;
    // }

    @others
}
</t>
<t tx="felix.20200718170712.4">/**
 * * Set this node as the root for hoist/dehoist context flags purposes
 */
public setRoot(): void {
    this.isRoot = true;
    if (this.selected) {
        // Set this special global 'selected node' flag
        this._leoIntegration.leoStates.leoRoot = true;
    }
    this.contextValue = this._getNodeContextValue();
}

</t>
<t tx="felix.20200718170712.5">/**
 * * Builds the node context string by concatenating coded constants
 * @returns the string made up of all status flags
 */
private _getNodeContextValue(): string {
    // Start it with 'leoNodeMarked' or 'leoNodeUnmarked'
    let w_contextValue = Constants.CONTEXT_FLAGS.NODE_UNMARKED;
    if (this.marked) {
        w_contextValue = Constants.CONTEXT_FLAGS.NODE_MARKED;
    }
    // then append 'leoNodeAtFile' to existing if needed
    if (this.atFile) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ATFILE;
    }
    // then append 'leoNodeCloned' to existing if needed
    if (this.cloned) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_CLONED;
    }
    // and finally, check for 'root' too
    if (this.isRoot) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ROOT;
    } else {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_NOT_ROOT;
    }
    return w_contextValue;
}

</t>
<t tx="felix.20200718171837.1">// @ts-ignore
public get description(): string {
    // * some smaller grayed-out text accompanying the main label
    if (this.u) {
        return "\u{1F4CE} (" + Object.keys(this.u).length + ")";
    } else {
        // return "id:" + this.id; // ! debug test
        // return "gnx:" + this.gnx; // ! debug test
        return ""; // Falsy will not be shown
    }
}

</t>
<t tx="felix.20200718171849.1">// @ts-ignore
public get tooltip(): string {
    if (this.u) {
        //  "\ntotal keys is :" + Object.keys(this.u).length
        return this.label + "\n" +
            JSON.stringify(this.u, undefined, 2);
    } else {
        return this.label; // * Whole headline as tooltip
    }
}

</t>
<t tx="felix.20200718171854.1">// Optional id for the tree item that has to be unique across tree.
// The id is used to preserve the selection and expansion state of the tree item.
// If not provided, an id is generated using the tree item's label.
// Note that when labels change, ids will change and that selection and expansion state cannot be kept stable anymore.
// @ts-ignore
public get id(): string { return this._id; }

</t>
<t tx="felix.20200718171904.1">// @ts-ignore
public get iconPath(): Icon {
    // From Leo's leoNodes.py computeIcon function
    // 1=has Body, 2=marked, 4=cloned, 8=dirty
    let w_dirty: boolean = this._leoIntegration.config.invertNodeContrast ? !this.dirty : this.dirty;
    let w_icon: number =
        (+w_dirty &lt;&lt; 3) |
        (+this.cloned &lt;&lt; 2) |
        (+this.marked &lt;&lt; 1) |
        +this.hasBody;
    return this._leoIntegration.nodeIcons[w_icon];
}

</t>
<t tx="felix.20200718180428.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import * as utils from './utils';
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoBridgePackage } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718180428.2">/**
 * * Leo outline implemented as a tree view with this TreeDataProvider
 */
export class LeoOutlineProvider implements vscode.TreeDataProvider&lt;LeoNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoNode | undefined&gt; = this._onDidChangeTreeData.event;

    private _rootNode: LeoNode | undefined;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718180428.4">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    // TODO : have this return a promise that resolves when the selected node is encountered by ap_to_p
    this._rootNode = undefined;
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718180428.5">public getTreeItem(element: LeoNode): Thenable&lt;LeoNode&gt; | LeoNode {
    return element;
}

</t>
<t tx="felix.20200718180428.6">public getChildren(element?: LeoNode): Thenable&lt;LeoNode[]&gt; {
    if (!this._leoIntegration.leoStates.fileOpenedReady) {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
    if (element) {
        return this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.GET_CHILDREN,
            utils.buildNodeCommandJson(element.apJson)
        ).then((p_package: LeoBridgePackage) =&gt; {
            return this._leoIntegration.arrayToLeoNodesArray(p_package.children!);
        });
    } else {
        return this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.GET_CHILDREN, "{}"
        ).then((p_package: LeoBridgePackage) =&gt; {
            const w_nodes = this._leoIntegration.arrayToLeoNodesArray(p_package.children!);
            if (w_nodes &amp;&amp; w_nodes.length === 1) {
                this._rootNode = w_nodes[0];
                this._rootNode.setRoot();
            }
            return w_nodes;
        });
    }
}

</t>
<t tx="felix.20200718180428.7">public getParent(element: LeoNode): ProviderResult&lt;LeoNode&gt; | null {
    // * This method should be implemented in order to access reveal API.
    // ! But it should NOT have to be called if only trying to 'select' already revealed nodes
    // ! Called when revealing single nodes

    // ! Might be called if nodes are revealed while in vscode's refresh process
    // ! Parent asked for this way will go up till root and effectively refresh whole tree.
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        // Check if joisted and is already up to root node
        if (this._rootNode &amp;&amp; element.gnx === this._rootNode.gnx &amp;&amp; element.childIndex === this._rootNode.childIndex) {
            if (
                JSON.stringify(JSON.parse(this._rootNode.apJson).stack) ===
                JSON.stringify(JSON.parse(element.apJson).stack)
            ) {
                return null; // Default gives no parent
            }
        }

        return this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.GET_PARENT,
            element ? utils.buildNodeCommandJson(element.apJson) : "{}"
        ).then((p_package: LeoBridgePackage) =&gt; {
            if (p_package.node === null) {
                return null;
            } else {
                return this._leoIntegration.apToLeoNode(p_package.node!);
            }
        });
    } else {
        return null; // Default gives no parent
    }
}

</t>
<t tx="felix.20200718185403.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718185403.2">/**
 * * Statusbar indicator controller service
 */
export class LeoStatusBar {

    private _leoStatusBarItem: vscode.StatusBarItem;
    private _statusbarNormalColor = new vscode.ThemeColor(Constants.GUI.THEME_STATUSBAR);  // "statusBar.foreground"
    private _updateStatusBarTimeout: NodeJS.Timeout | undefined;
    private _string: string = ""; // Use this string with indicator, using this will replace the default from config

    // * Represents having focus on a leo tree, body or document panel to enable leo keybindings
    private _statusBarFlag: boolean = false;
    set statusBarFlag(p_value: boolean) {
        this._statusBarFlag = p_value;
    }
    get statusBarFlag(): boolean {
        return this._statusBarFlag;
    }

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._leoStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
        this._leoStatusBarItem.color = this._leoIntegration.config.statusBarColor;

        this._leoStatusBarItem.command = Constants.COMMANDS.STATUS_BAR;
        // this._leoStatusBarItem.command = "leointeg.test"; // just call test function for now to help debugging
        this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR + this._leoIntegration.config.statusBarString;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;
        _context.subscriptions.push(this._leoStatusBarItem);
        this._leoStatusBarItem.hide();
    }

    @others
}
</t>
<t tx="felix.20200718185403.3">/**
 * * Makes the statusbar indicator visible
 */
public show(): void {
    this._leoStatusBarItem.show();
}

</t>
<t tx="felix.20200718185403.4">/**
 * * Hides the statusbar indicator
 */
public hide(): void {
    this._leoStatusBarItem.hide();
}

</t>
<t tx="felix.20200718185403.5">/**
 * * Sets string to replace default from config &amp; refresh it
 */
public setString(p_string: string): void {
    this._string = p_string;
    this._updateLeoObjectIndicator();
}

</t>
<t tx="felix.20200718185403.6">/**
 * * Updates the status bar visual indicator visual indicator with optional debouncing delay
 * @param p_state True/False flag for On or Off status
 * @param p_debounceDelay Optional, in milliseconds
 */
public update(p_state: boolean, p_debounceDelay?: number, p_forced?: boolean): void {
    if (p_forced || (p_state !== this.statusBarFlag)) {
        this.statusBarFlag = p_state;
        if (p_debounceDelay) {
            this._updateLeoObjectIndicatorDebounced(p_debounceDelay);
        } else {
            this._updateLeoObjectIndicator();
        }
    }
}

</t>
<t tx="felix.20200718185403.7">/**
 * * Updates the status bar visual indicator flag in a debounced manner
 * @param p_delay number of milliseconds
 */
private _updateLeoObjectIndicatorDebounced(p_delay: number): void {
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }
    this._updateStatusBarTimeout = setTimeout(() =&gt; {
        this._updateLeoObjectIndicator();
    }, p_delay);
}

</t>
<t tx="felix.20200718185403.8">/**
 * * Updates the status bar visual indicator flag directly
 */
private _updateLeoObjectIndicator(): void {
    // Can be called directly, so clear timer if any
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }

    utils.setContext(Constants.CONTEXT_FLAGS.LEO_SELECTED, !!this.statusBarFlag);

    this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR +
        (this._string ? this._string : this._leoIntegration.config.statusBarString) + " " +
        (this._leoIntegration.leoStates.leoOpenedFileName ? utils.getFileFromPath(this._leoIntegration.leoStates.leoOpenedFileName) : Constants.UNTITLED_FILE_NAME);

    // Also check in constructor for statusBar properties (the createStatusBarItem call itself)
    if (this.statusBarFlag &amp;&amp; this._leoIntegration.leoStates.fileOpenedReady) {
        this._leoStatusBarItem.color = "#" + this._leoIntegration.config.statusBarColor;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;
    } else {
        this._leoStatusBarItem.color = this._statusbarNormalColor;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_OFF;
    }
}

</t>
<t tx="felix.20200718191946.1">import * as os from 'os';
import * as fs from 'fs';
import * as child from 'child_process';
import * as path from "path"; // TODO : Use this to have reliable support for window-vs-linux file-paths
import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from './leoIntegration';
var kill = require('tree-kill');

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718191946.2">/**
 * * Leo bridge server service
 * Provides simple automatic leo bridge server startup functionality
 */
export class ServerService {
    // TODO : See #10 @boltex Problem starting the leo-bridge server automatically with anaconda/miniconda on windows
    // See https://github.com/yhirose/vscode-filtertext/blob/master/src/extension.ts#L196

    private _platform: string;
    private _isWin32: boolean;
    public usingPort: number = 0; // set to other than zero if server is started by leointeg itself

    /**
     * * Leo Bridge Server Process
     */
    private _serverProcess: child.ChildProcess | undefined;

    private _resolvePromise: ((value?: unknown) =&gt; void) | undefined;
    private _rejectPromise: ((reason?: any) =&gt; void) | undefined;

    private _isStarted: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._platform = os.platform();
        this._isWin32 = this._platform === "win32";
    }

    @others
}
</t>
<t tx="felix.20200718191946.4">/**
 * * Get command from settings or best command for the current OS
 * @param p_leoPythonCommand String command to start python on this computer
 * @returns A promise that resolves when the server is started, or that is rejected in case of problem while starting
 */
public startServer(p_leoPythonCommand: string, p_leoEditorPath: string, p_port: number): Promise&lt;any&gt; {

    /*
        * -----------------------------------------------------------------
        * Documentation for child_process.spawn(command[, args][, options])
        * -----------------------------------------------------------------

        The child_process.spawn() method spawns a new process
        using the given command, with command-line arguments in args.
        If omitted, args defaults to an empty array.

        If the shell option is enabled, do not pass unsanitized
        user input to this function. Any input containing shell
        metacharacters may be used to trigger arbitrary command execution.

        A third argument may be used to specify additional options, with these defaults:

        const defaults = {
            cwd: undefined,
            env: process.env
        };
    */

    if (!p_leoEditorPath) {
        return Promise.reject(Constants.USER_MESSAGES.LEO_PATH_MISSING);
    }

    let w_pythonPath = ""; // Command of child.spawn call

    // Show problems when running the server, if any.
    // this._leoIntegration.showTerminalPane(); // #203 Do not 'force' show the server output

    return utils.findNextAvailablePort(p_port).then((p_availablePort) =&gt; {
        if (!p_availablePort) {
            // vscode.window.showInformationMessage("Port " + p_port+" already in use.");
            return Promise.reject("Port " + p_port + " already in use.");
        }

        this.usingPort = p_availablePort;

        // Leo Editor installation path is mandatory - Start with Leo Editor's folder
        let w_serverScriptPath = p_leoEditorPath + "/leo/core";

        try {
            if (fs.existsSync(w_serverScriptPath + Constants.SERVER_NAME)) {
                w_serverScriptPath += Constants.SERVER_NAME;
            } else {
                return Promise.reject(Constants.USER_MESSAGES.CANNOT_FIND_SERVER_SCRIPT);
            }
        } catch (p_err) {
            console.error(p_err);
            return Promise.reject(Constants.USER_MESSAGES.CANNOT_FIND_SERVER_SCRIPT);
        }

        if (p_leoPythonCommand &amp;&amp; p_leoPythonCommand.length) {
            // Start by running command (see executeCommand for multiple useful snippets)
            w_pythonPath = p_leoPythonCommand; // Set path
        } else {
            w_pythonPath = Constants.DEFAULT_PYTHON;
            if (this._isWin32) {
                w_pythonPath = Constants.WIN32_PYTHON;
            }
        }

        const w_serverStartPromise = new Promise((p_resolve, p_reject) =&gt; {
            // Spawn a python child process for a leoBridge server
            this._resolvePromise = p_resolve;
            this._rejectPromise = p_reject;
        });

        // Setup arguments: Order is important!
        let w_args: string[] = []; //  "\"" + w_serverScriptPath + "\"" // For on windows ??

        // on windows, if the default py is used, make sure it's got a '-3'
        if (this._isWin32 &amp;&amp; w_pythonPath === "py") {
            w_args.push("-3");
        }

        // The server script itself
        w_args.push(w_serverScriptPath);

        if (this._leoIntegration.config.limitUsers &gt; 1 &amp;&amp;
            this._leoIntegration.config.limitUsers &lt; 256) {
            w_args.push("--limit");
            w_args.push(this._leoIntegration.config.limitUsers.toString());
        }

        // Add port
        w_args.push("--port");
        w_args.push(this.usingPort.toString());

        const w_options: child.SpawnOptions = {
            // Child to run independently of its parent process.
            // (Depends on the platform)
            detached: this._leoIntegration.config.setDetached,
            // If possible hide the terminal window that could appear
            windowsHide: true,
        };

        this._leoIntegration.addLogPaneEntry(
            'Starting server with command: ' +
            w_pythonPath + " " + w_args.join(" ")
        );

        // Spawn the process
        this._serverProcess = child.spawn(w_pythonPath, w_args, w_options);

        // To prevent the parent from waiting for a given subprocess to exit
        this._serverProcess.unref();

        // Capture the OUTPUT and send it to the "leo server" OutputChannel
        if (this._serverProcess &amp;&amp; this._serverProcess.stdout) {
            this._serverProcess.stdout.on("data", (p_data: string) =&gt; {
                this._processServerOutput(p_data);
            });
        } else {
            console.error("No stdout");
        }
        // Capture the ERROR channel and set flags on server errors
        if (this._serverProcess &amp;&amp; this._serverProcess.stderr) {
            this._serverProcess.stderr.on("data", (p_data: string) =&gt; {
                console.log(`stderr: ${p_data}`);
                this._isStarted = false;
                if (!this._leoIntegration.activated) {
                    return;
                }
                utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);
                this._serverProcess = undefined;
                if (this._rejectPromise) {
                    this._rejectPromise(`stderr: ${p_data}`);
                }
            });
        } else {
            console.error("No stderr");
        }
        // Capture the CLOSE event and set flags on server actually closing
        if (this._serverProcess) {
            this._serverProcess.on("close", (p_code: any) =&gt; {
                console.log(`Leo server exited with code ${p_code}`);
                this._isStarted = false;
                if (!this._leoIntegration.activated) {
                    return;
                }
                utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);
                this._serverProcess = undefined;
                if (this._rejectPromise) {
                    this._rejectPromise(`Leo server exited with code ${p_code}`);
                }
            });
        }
        // Give out the promise that will resolve when the server is started
        return w_serverStartPromise;
    });

}

</t>
<t tx="felix.20200718192351.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { LeoPackageStates } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718192411.1">/**
 * * Global states service
 * Holds state flags used to restrict command availability and icon visibility
 * Changes UI by changing vscode's context variables
 */
export class LeoStates {

    // * Currently establishing connection to a server
    private _leoConnecting: boolean = false;
    get leoConnecting(): boolean {
        return this._leoConnecting;
    }
    set leoConnecting(p_value: boolean) {
        this._leoConnecting = p_value;
        utils.setContext(Constants.CONTEXT_FLAGS.CONNECTING, p_value);
    }

    // * Finished startup check for server-start and auto-connect
    private _leoStartupFinished: boolean = false;
    get leoStartupFinished(): boolean {
        return this._leoStartupFinished;
    }
    set leoStartupFinished(p_value: boolean) {
        this._leoStartupFinished = p_value;
        utils.setContext(Constants.CONTEXT_FLAGS.STARTUP_FINISHED, p_value);
    }

    @others
}
</t>
<t tx="felix.20200718192411.2">public setSelectedNodeFlags(p_node: LeoNode): void {
    this.leoRoot = p_node.isRoot; // * ALSO set in setRoot of LeoNode class
    this.leoMarked = p_node.marked;
    this.leoCloned = p_node.cloned;
    this.leoDirty = p_node.dirty;
    this.leoEmpty = !p_node.hasBody;
    this.leoChild = !(p_node.collapsibleState === vscode.TreeItemCollapsibleState.None);
    this.leoAtFile = p_node.atFile;
}

</t>
<t tx="felix.20200718192411.3">public setLeoStateFlags(p_states: LeoPackageStates): void {
    this.leoChanged = p_states.changed; // Documents will be refresh if this changes
    this.leoCanUndo = p_states.canUndo;
    this.leoCanRedo = p_states.canRedo;
    this.leoCanDemote = p_states.canDemote;
    this.leoCanPromote = p_states.canPromote;
    this.leoCanDehoist = p_states.canDehoist;
}
</t>
<t tx="felix.20200718193219.1">// * Connected to a Leo bridge server
private _leoBridgeReady: boolean = false;
get leoBridgeReady(): boolean {
    return this._leoBridgeReady;
}
set leoBridgeReady(p_value: boolean) {
    this._leoBridgeReady = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, p_value);
}

</t>
<t tx="felix.20200718193222.1">// * A Leo file is opened
private _fileOpenedReady: boolean = false; // Sets context flag along with treeview title
get fileOpenedReady(): boolean {
    return this._fileOpenedReady;
}
set fileOpenedReady(p_value: boolean) {
    this._fileOpenedReady = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, p_value);
    this._leoIntegration.setTreeViewTitle(
        p_value ? Constants.GUI.TREEVIEW_TITLE : Constants.GUI.TREEVIEW_TITLE_INTEGRATION
    );
}

</t>
<t tx="felix.20200718193226.1">// * Currently opened Leo file path and name, empty string if new unsaved file.
private _leoOpenedFileName: string = "";
get leoOpenedFileName(): string {
    return this._leoOpenedFileName;
}
set leoOpenedFileName(p_name: string) {
    if (p_name &amp;&amp; p_name.length) {
        this._leoOpenedFileName = p_name;
        utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, true);
    } else {
        this._leoOpenedFileName = "";
        utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, false);
    }
}

</t>
<t tx="felix.20200718193230.1">// * 'states' flags for currently opened tree view
private _leoChanged: boolean = false;
get leoChanged(): boolean {
    return this._leoChanged;
}
set leoChanged(p_value: boolean) {
    if (this._leoChanged !== p_value) {
        // Refresh Documents Panel
        this._leoIntegration.refreshDocumentsPane();
    }
    this._leoChanged = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CHANGED, p_value);
}

</t>
<t tx="felix.20200718193233.1">private _leoCanUndo: boolean = false;
get leoCanUndo(): boolean {
    return this._leoCanUndo;
}
set leoCanUndo(p_value: boolean) {
    this._leoCanUndo = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_UNDO, p_value);
}

</t>
<t tx="felix.20200718193235.1">private _leoCanRedo: boolean = false;
get leoCanRedo(): boolean {
    return this._leoCanRedo;
}
set leoCanRedo(p_value: boolean) {
    this._leoCanRedo = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_REDO, p_value);
}

</t>
<t tx="felix.20200718193238.1">private _leoCanDemote: boolean = false;
get leoCanDemote(): boolean {
    return this._leoCanDemote;
}
set leoCanDemote(p_value: boolean) {
    this._leoCanDemote = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEMOTE, p_value);
}

</t>
<t tx="felix.20200718193241.1">private _leoCanPromote: boolean = false;
get leoCanPromote(): boolean {
    return this._leoCanPromote;
}
set leoCanPromote(p_value: boolean) {
    this._leoCanPromote = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_PROMOTE, p_value);
}

</t>
<t tx="felix.20200718193244.1">private _leoCanDehoist: boolean = false;
get leoCanDehoist(): boolean {
    return this._leoCanDehoist;
}
set leoCanDehoist(p_value: boolean) {
    this._leoCanDehoist = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEHOIST, p_value);
}

</t>
<t tx="felix.20200718193338.1">// * 'states' flags about current selection, for visibility and commands availability
private _leoMarked: boolean = false;
get leoMarked(): boolean {
    return this._leoMarked;
}
set leoMarked(p_value: boolean) {
    this._leoMarked = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_value);
}

</t>
<t tx="felix.20200718193341.1">private _leoCloned: boolean = false;
get leoCloned(): boolean {
    return this._leoCloned;
}
set leoCloned(p_value: boolean) {
    this._leoCloned = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CLONE, p_value);
}

</t>
<t tx="felix.20200718193343.1">private _leoDirty: boolean = false;
get leoDirty(): boolean {
    return this._leoDirty;
}
set leoDirty(p_value: boolean) {
    this._leoDirty = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_DIRTY, p_value);
}

</t>
<t tx="felix.20200718193348.1">private _leoEmpty: boolean = false;
get leoEmpty(): boolean {
    return this._leoEmpty;
}
set leoEmpty(p_value: boolean) {
    this._leoEmpty = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_EMPTY, p_value);
}

</t>
<t tx="felix.20200718193350.1">private _leoChild: boolean = false;
get leoChild(): boolean {
    return this._leoChild;
}
set leoChild(p_value: boolean) {
    this._leoChild = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CHILD, p_value);
}

</t>
<t tx="felix.20200718193353.1">private _leoAtFile: boolean = false;
get leoAtFile(): boolean {
    return this._leoAtFile;
}
set leoAtFile(p_value: boolean) {
    this._leoAtFile = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_ATFILE, p_value);
}

</t>
<t tx="felix.20200718193403.1">// * Special is-root 'state' flag about current selection, for visibility and commands availability
private _leoRoot: boolean = false;
get leoRoot(): boolean {
    return this._leoRoot;
}
set leoRoot(p_value: boolean) {
    this._leoRoot = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_ROOT, p_value);
}

</t>
<t tx="felix.20200718193500.1">constructor(
    private _context: vscode.ExtensionContext,
    private _leoIntegration: LeoIntegration
) { }

</t>
<t tx="felix.20200718193719.1"></t>
<t tx="felix.20200718193731.1"></t>
<t tx="felix.20200718194857.1">import * as vscode from "vscode";
import { LeoNode } from "./leoNode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718194857.10">/**
 * * Main interface for JSON sent from Leo back to leoInteg
 */
export interface LeoBridgePackage {
    // * Common to all result packages
    id: number;
    // * Possible answers from a "Constants.LEOBRIDGE" command
    gnx?: string[]; // get_all_gnx
    len?: number; // get_body_length
    body?: string; // get_body
    buttons?: LeoButton[]; // get_buttons
    navList?: LeoGoto[]; // get_goto
    navText?: string; // get_goto
    messages?: string[]; // get_goto
    navOptions?: { isTag: boolean, showParents: boolean }; // get_goto
    commands?: vscode.QuickPickItem[]; // getCommands
    commander?: {
        changed: boolean,
        fileName: string;
    }
    filename?: string; // set_opened_file, open_file(s), ?close_file
    files?: LeoDocument[]; // get_all_open_commanders
    focus?: string; // find_next, find_previous
    found?: boolean // find_next, find_previous
    index?: number; // get_all_open_commanders
    language?: string; // get_body_states
    wrap?: boolean; // get_body_states
    tabWidth?: number | boolean; // get_body_states either the tabwidth or falsy
    node?: ArchivedPosition; // get_parent, set_opened_file, open_file(s), ?close_file
    children?: ArchivedPosition[]; // get_children
    searchSettings?: LeoGuiFindTabManagerSettings // get_search_settings
    selection?: BodySelectionInfo; // get_body_states
    states?: LeoPackageStates; // get_ui_states
    string?: string; // from cut / copy outline
    total?: number; // set_opened_file, open_file(s), close_file
    version?: string;
    major?: number;
    minor?: number;
    patch?: number;
}

</t>
<t tx="felix.20200718194857.11">/**
 * * Leo document structure used in the 'Opened Leo Documents' tree view provider sent back by the server
 */
export interface LeoDocument {
    name: string;
    index: number;
    changed: boolean;
    selected: boolean;
}

</t>
<t tx="felix.20200718194857.12">/**
 * * Leo '@button' structure used in the '@buttons' tree view provider sent back by the server
 */
export interface LeoButton {
    name: string;
    rclicks?: RClick[];
    index: string; // STRING KEY
}

</t>
<t tx="felix.20200718194857.13">/**
 * * Icon path names used in leoNodes for rendering in treeview
 */
export interface Icon {
    light: string;
    dark: string;
}

</t>
<t tx="felix.20200718194857.14">/**
 * * LeoBody virtual file time information object
 */
export interface BodyTimeInfo {
    ctime: number;
    mtime: number;
}

</t>
<t tx="felix.20200718194857.15">/**
 * * Parameter structure used in the 'runSaveFileDialog' equivalent when asking user input
 */
export interface showSaveAsDialogParameters {
    // See TODO in leoAsync.ts
    initialFile: string;
    title: string;
    message: string;
    filetypes: string[];
    defaultExtension: string;
}

</t>
<t tx="felix.20200718194857.16">/**
 * * Parameter structure used in the 'runAskYesNoDialog' equivalent when asking user input
 */
export interface runAskYesNoDialogParameters {
    ask: string;
    message: string;
    yes_all: boolean;
    no_all: boolean;
}

</t>
<t tx="felix.20200718194857.17">/**
 * * Parameter structure used in the 'runAskOkDialog' equivalent when showing a warning
 */
export interface runWarnMessageDialogParameters {
    warn: string;
    message: string;
}

</t>
<t tx="felix.20200718194857.18">/**
 * * Parameter structure for non-blocking info message about detected file changes
 */
export interface runInfoMessageDialogParameters {
    message: string;
}

</t>
<t tx="felix.20200718194857.19">/**
 * * Used in showAskModalDialog to get answer from user interaction
 */
export interface AskMessageItem extends vscode.MessageItem {
    value: string;
}

</t>
<t tx="felix.20200718194857.2">/**
 * * Types of the various JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
export interface ConfigMembers {
    checkForChangeExternalFiles: string;
    defaultReloadIgnore: string;
    leoTreeBrowse: boolean;
    treeKeepFocus: boolean;
    treeKeepFocusWhenAside: boolean;
    statusBarString: string;
    statusBarColor: string;
    treeInExplorer: boolean;
    showOpenAside: boolean;
    showEditOnNodes: boolean;
    showArrowsOnNodes: boolean;
    showAddOnNodes: boolean;
    showMarkOnNodes: boolean;
    showCloneOnNodes: boolean;
    showCopyOnNodes: boolean;

    showEditionOnBody: boolean; // clone delete insert(s)
    showClipboardOnBody: boolean; // cut copy paste(s)
    showPromoteOnBody: boolean; // promote demote
    showExecuteOnBody: boolean; // extract(s)
    showExtractOnBody: boolean;
    showImportOnBody: boolean;
    showRefreshOnBody: boolean;
    showHoistOnBody: boolean;
    showMarkOnBody: boolean;
    showSortOnBody: boolean;

    invertNodeContrast: boolean;
    leoEditorPath: string;
    leoPythonCommand: string;
    startServerAutomatically: boolean;
    connectToServerAutomatically: boolean;
    connectionAddress: string;
    connectionPort: number;

    setDetached: boolean;
    limitUsers: number
}

</t>
<t tx="felix.20200718194857.20">/**
 * * Used in switch Leo document to get answer from user interaction
 */
export interface ChooseDocumentItem extends vscode.QuickPickItem {
    value: number;
}

</t>
<t tx="felix.20200718194857.3">/**
 * * When refreshing the outline and getting to Leo's selected node
 */
export const enum RevealType {
    NoReveal = 0, // In apToLeoNode conversion, If if the global revealType is "NoReveal" and its the selected node, re-use the old id
    Reveal,
    RevealSelect,
    RevealSelectFocus
}

</t>
<t tx="felix.20200718194857.4">/**
 * * Required Refresh Dictionary of "elements to refresh" flags
 */
export interface ReqRefresh {
    node?: boolean; // Reveal received selected node (Navigation only, no tree change)
    tree?: boolean; // Tree needs refresh
    body?: boolean; // Body needs refresh
    scroll?: boolean; // Body needs to scroll to selection
    states?: boolean; // States needs refresh (changed, canUndo, canRedo, canDemote, canPromote, canDehoist)
    buttons?: boolean; // Buttons needs refresh
    documents?: boolean; // Documents needs refresh
    nav?: boolean; // NAv panel needs refresh
}

</t>
<t tx="felix.20200718194857.5">/**
 * * Stackable front end commands
 */
export interface UserCommand {
    action: string; // String from Constants.LEOBRIDGE, which are commands for leobridgeserver
    node?: LeoNode | undefined;  // We can START a stack with a targeted command
    name?: string | undefined; // If a string is required, for headline, etc.
    refreshType: ReqRefresh; // Minimal refresh level required by this command
    fromOutline: boolean; // Focus back on outline instead of body
    keepSelection?: boolean; // Should bring back selection on node prior to command
    resolveFn?: (result: any) =&gt; void; // call that with an answer from python's (or other) side
    rejectFn?: (reason: any) =&gt; void; // call if problem is encountered
}

</t>
<t tx="felix.20200718194857.6">/**
 * * Stackable leoBridge actions to be performed by Leo
 */
export interface LeoAction {
    parameter: string; // to pass along with action to python's side
    deferredPayload?: any | undefined; // Used when the action already has a return value ready but is also waiting for python's side
    resolveFn: (result: any) =&gt; void; // call that with an answer from python's (or other) side
    rejectFn: (reason: any) =&gt; void; // call if problem is encountered
}

</t>
<t tx="felix.20200718194857.7">/**
 * * Simple 'string log entry' package format
 */
export interface LeoLogEntry {
    log: string;
}

</t>
<t tx="felix.20200718194857.8">/**
 * * ArchivedPosition format package from Leo's leoflexx.py
 */
export interface ArchivedPosition {
    hasBody: boolean;       // bool(p.b),
    hasChildren: boolean;   // p.hasChildren()
    childIndex: number;     // p._childIndex
    cloned: boolean;        // p.isCloned()
    dirty: boolean;         // p.isDirty()
    expanded: boolean;      // p.isExpanded()
    gnx: string;            // p.v.gnx
    level: number;          // p.level()
    headline: string;       // p.h
    marked: boolean;        // p.isMarked()
    atFile: boolean         // p.isAnyAtFileNode():
    selected: boolean;      // p == commander.p
    u?: any;               // User Attributes
    stack: {
        gnx: string;        // stack_v.gnx
        childIndex: number; // stack_childIndex
        headline: string;   // stack_v.h
    }[];                    // for (stack_v, stack_childIndex) in p.stack]
}

</t>
<t tx="felix.20200718195558.1">import * as vscode from "vscode";
import * as murmur from "murmurhash-js";
import { Constants } from "./constants";
import { Icon, UserCommand, ArchivedPosition } from "./types";
import { LeoNode } from "./leoNode";
var portfinder = require('portfinder');

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718195558.10">/**
 * * Builds a 'Leo Scheme' vscode.Uri from a gnx (or strings like 'LEO BODY' or empty strings to decorate breadcrumbs)
 * with a scheme header like "leo:/" or 'more:/'
 * @param p_str leo node gnx strings are used to build Uri
 * @returns A vscode 'Uri' object
 */
export function strToLeoUri(p_str: string): vscode.Uri {
    return vscode.Uri.parse(Constants.URI_SCHEME_HEADER + p_str);
}

</t>
<t tx="felix.20200718195558.11">/**
 * * Gets the gnx, (or another string like 'LEO BODY' or other), from a vscode.Uri object
 * @param p_uri Source uri to extract from
 * @returns The string source that was used to build this Uri
 */
export function leoUriToStr(p_uri: vscode.Uri): string {
    // TODO : Use length of a constant or something other than 'fsPath'
    // For now, just remove the '/' (or backslash on Windows) before the path string
    return p_uri.fsPath.substr(1);
}

</t>
<t tx="felix.20200718195558.12">/**
 * * Sets a vscode context variable with 'vscode.commands.executeCommand' &amp; 'setContext'
 * @param p_key Key string name such as constants 'bridgeReady' or 'treeOpened', etc.
 * @param p_value Value to be assigned to the p_key 'key'
 * @returns A Thenable that is returned by the executeCommand call
 */
export function setContext(p_key: string, p_value: any): Thenable&lt;unknown&gt; {
    return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.SET_CONTEXT, p_key, p_value);
}

</t>
<t tx="felix.20200718195558.2">/**
 * * Build a string for representing a number that's 2 digits wide, padding with a zero if needed
 * @param p_number Between 0 and 99
 * @returns a 2 digit wide string representation of the number, left padded with zeros as needed.
 */
export function padNumber2(p_number: number): string {
    return ("0" + p_number).slice(-2);
}

</t>
<t tx="felix.20200718195558.3">/**
 * * Build all possible strings for node icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array of the 16 vscode node icons used in this vscode expansion
 */
export function buildNodeIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return Array(16).fill("").map((p_val, p_index) =&gt; {
        return {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT)
        };
    });
}

</t>
<t tx="felix.20200718195558.4">/**
 * * Build all possible strings for documents icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildDocumentIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_DOCUMENT),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_DOCUMENT)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_DOCUMENT_DIRTY),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_DOCUMENT_DIRTY)
        }
    ];
}

</t>
<t tx="felix.20200718195558.6">/**
 * * Builds and returns a JSON string with 'node' and 'name' members
 * @param p_nodeJson Targeted tree node in the proper JSON format
 * @param p_command from which to extract possible name and 'keep selection' flag
 * @returns JSON string suitable for being a parameter of a leoBridge action
 */
export function buildNodeCommandJson(p_nodeJson: string, p_command?: UserCommand): string {
    let w_json = "{\"ap\":" + p_nodeJson; // already json
    if (p_command &amp;&amp; p_command.name) {
        w_json += ", \"name\": " + JSON.stringify(p_command.name);
    }
    if (p_command &amp;&amp; p_command.keepSelection) {
        w_json += ", \"keep\": true";
    }
    // TODO : Generalize this function to send any other members of p_command / other members
    w_json += "}";
    return w_json;
}

</t>
<t tx="felix.20200718195558.7">/**
 * * Extracts the file name from a full path, such as "foo.bar" from "/abc/def/foo.bar"
 * @param p_path Full path such as "/var/drop/foo/boo/moo.js" or "C:\Documents and Settings\img\recycled log.jpg"
 * @returns file name string such as "moo.js" or "recycled log.jpg""
 */
export function getFileFromPath(p_path: string): string {
    return p_path.replace(/^.*[\\\/]/, '');
}

</t>
<t tx="felix.20200718195558.8">/**
 * * Checks if a node would become dirty if it were to now have body content at all
 * @param p_node LeoNode from vscode's outline
 * @param p_newHasBody Flag to signify presence of body content, to be compared with its current state
 * @returns True if it would change the icon with actual body content, false otherwise
 */
export function isIconChangedByEdit(p_node: LeoNode, p_newHasBody: boolean): boolean {
    if (!p_node.dirty || (p_node.hasBody === !p_newHasBody)) {
        return true;
    }
    return false;
}

</t>
<t tx="felix.20200718195558.9">/**
 * * Checks if a string is formatted as a valid rrggbb color code.
 * @param p_hexString hexadecimal 6 digits string, without leading '0x'
 * @returns True if the string is a valid representation of an hexadecimal 6 digit number
 */
export function isHexColor(p_hexString: string): boolean {
    return typeof p_hexString === 'string'
        &amp;&amp; p_hexString.length === 6
        &amp;&amp; !isNaN(Number('0x' + p_hexString));
}

</t>
<t tx="felix.20200718220811.1"></t>
<t tx="felix.20200718220818.1">@language md
@tabwidth -4
# ![LeoEditor](https://raw.githubusercontent.com/boltex/leointeg/master/resources/leoapp.png) Leo for VS Code

_If you find LeoInteg useful, please consider [**sponsoring**](https://boltex.github.io/) it. Also please [write a review](https://marketplace.visualstudio.com/items?itemName=boltex.leointeg#review-details "Write a review") or [star it on GitHub](https://github.com/boltex/leointeg "Star it on GitHub")_

## Literate Programming with _Directed Acyclic Graphs_ ([dag](https://en.wikipedia.org/wiki/Directed_acyclic_graph))

### Break your code down into sections structured as an outline, to derive or parse back your files

&gt; Leo is a fundamentally different way of using and organizing data, programs and scripts.\
&gt; [Introduction Video](https://www.youtube.com/watch?v=SYwlfdEukD4) 🎥

See Leo, the Literate Editor with Outline, at [leoeditor.com](https://leoeditor.com/)
or on [github](https://github.com/leo-editor/leo-editor), and VS Code at [code.visualstudio.com](https://code.visualstudio.com/).

![Screenshot](https://raw.githubusercontent.com/boltex/leointeg/master/resources/animated-screenshot.gif)

@others
---

**🤍 To sponsor, donate or contribute see my [user page](https://boltex.github.io/) 🦁 Enjoy!**
</t>
<t tx="felix.20200718220833.1">@language md
@tabwidth -4
# Change Log

@others
</t>
<t tx="felix.20200718220833.2">@language md
@tabwidth -4
# How to install and run the development version

Thanks for trying out the development version of LeoInteg! :sunglasses: Contributions and pull requests are more than welcome!

@others
</t>
<t tx="felix.20200718221645.1">## Requirements

- Leo Editor 6.6b2 or later\
  _Install with :_ `pip install leo`\
   _Or with git._ (See [Installing Leo with git](http://leoeditor.com/installing.html#installing-leo-with-git))

- Websocket Python Library\
  _Install with :_ `pip install websockets`\
  (See [websockets.readthedocs.io/](https://websockets.readthedocs.io/))

</t>
<t tx="felix.20200718222035.1">## Features

- UI controls such as a **Leo Outline** in the explorer view, or as a standalone sidebar, **body pane**, **opened documents selector**, **find panel**, along with a **Log Window** and **Terminal** [output channels](https://code.visualstudio.com/api/extension-capabilities/common-capabilities#output-channel).
- Keybindings that match those of the Leo editor, including arrow keys behavior for outline keyboard navigation. (Can be turned off with the **'Leo Tree Browsing'** option setting)
- A **welcome screen** that also gives access to this extension's **settings**.
- **Derived files change detection**. See [External Files](#derive-external-files) below for more details
- **'@button' panel** for [creating your own commands with @buttons](https://leoeditor.com/tutorial-tips.html#use-button-nodes)
- Access **Leo commands** with context menus, outline-node hover icons, keyboard shortcuts, the command palette **`Ctrl+Shift+P`** or Leo's minibuffer **`Alt+X`**:
  - Open body panes to the side in any 'column'
  - Outline editing commands
  - Find operations
  - Clipboard operations
  - Undo/Redo commands

![Menu](https://raw.githubusercontent.com/boltex/leointeg/master/resources/context-hover-menus.png)

</t>
<t tx="felix.20200718222043.1">## Keybindings

| Outline Commands           |     |                  |                  |
| :------------------------- | :-- | :--------------- | :--------------- |
| `Ctrl + I`                 | or  | `Shift + Insert` | Insert Node      |
| `Ctrl + H`                 |     |                  | Edit Headline    |
| `Ctrl + Shift + C`         |     |                  | Copy Node        |
| `Ctrl + Shift + X`         |     |                  | Cut Node         |
| `Ctrl + Shift + V`         |     |                  | Paste Node       |
| `Ctrl + Shift + Backspace` | or  | `Delete`         | Delete Node      |
| `Ctrl + Backquote`         |     |                  | Clone Node       |
| `Ctrl + {`                 | and | `Ctrl + }`       | Promote / Demote |

| Moving Outline Nodes |     |                         |                    |
| :------------------- | :-- | :---------------------- | :----------------- |
| `Ctrl + U`           | or  | `Shift [+ Alt] + Up`    | Move Outline Up    |
| `Ctrl + D`           | or  | `Shift [+ Alt] + Down`  | Move Outline Down  |
| `Ctrl + L`           | or  | `Shift [+ Alt] + Left`  | Move Outline Left  |
| `Ctrl + R`           | or  | `Shift [+ Alt] + Right` | Move Outline Right |

_Move Outline commands need the 'Alt' key modifier only when focus is on body pane._

| Common Operations  |     |           |                     |
| :----------------- | :-- | :-------- | :------------------ |
| `Alt + -`          |     |           | Contract All        |
| `Ctrl + M`         |     |           | Mark / Unmark       |
| `Ctrl + B`         |     |           | Execute Script      |
| `Ctrl + T`         |     |           | Toggle Outline/Body |
| `Tab`              | or  | `Alt + D` | Focus on Body       |
| `Alt + T`          |     |           | Focus on Outline    |
| `Ctrl + Shift + D` |     |           | Extract             |
| `Ctrl + Shift + N` |     |           | Extract Names       |
| `Alt + A`          |     |           | Sort Siblings       |
| `Ctrl + F`         |     |           | Start Search        |
| `F3`               |     |           | Find Next           |
| `F2`               |     |           | Find Previous       |

| Tree Navigation    |     |                 |                          |
| :----------------- | :-- | :-------------- | :----------------------- |
| `Alt + Home`       | or  | `Home` \*       | Go To First Visible Node |
| `Alt + End`        |     |                 | Go To Last Sibling       |
|                    |     | `End` \*        | Go To Last Visible Node  |
| `Alt + N`          |     |                 | Go To Next Clone         |
| `Alt + Arrow Keys` | or  | `Arrow Keys` \* | Browse Tree              |
| `Ctrl + T`         |     |                 | Switch Tree/Body Focus   |
| `Tab`              |     |                 | Focus from Tree to Body  |
| `Alt + G`          |     |                 | Go To Global Line        |

\* _With the **'Leo Tree Browsing'** setting enabled by default, all arrows and numeric keypad keys change the outline's selection directly_

---

</t>
<t tx="felix.20200718222048.1">## Derive External Files

Use the **Save Leo File** command to derive external files.

Leo will detect derived file changes and will ask to either **refresh from disk** or **ignore the changes**.

![derive files](https://raw.githubusercontent.com/boltex/leointeg/master/resources/derived-file.gif)

</t>
<t tx="felix.20200718222053.1">## Automate Synchronization

The **change detection** process can be automated to always refresh, or ignore file changes:
A **notification** will inform you of the action taken instead.

![auto sync](https://raw.githubusercontent.com/boltex/leointeg/master/resources/auto-sync.gif)

</t>
<t tx="felix.20200718222058.1">## Status Bar Indicator

A customizable keyboard status bar indicator is shown when this extension is activated.
It will turn orange (or your choice of text and color), when leo's **keyboard shortcuts** are active.
This occurs when an outline node or a body pane has focus:

![Statusbar](https://raw.githubusercontent.com/boltex/leointeg/master/resources/statusbar-keyboard.gif)

</t>
<t tx="felix.20200718222102.1">## Extension Settings

### Open the command palette `Ctrl+Shift+P` and start typing `leo settings` to access LeoInteg's welcome/settings screen

&gt; _(Changes are auto-saved to the user's profile after 0.5 seconds)_

- Control the visibility of the outline pane in the explorer view.
- Decide how and when to refresh and synchronize content when derived (external) file are modified.
- Show additional icons on outline nodes (Move, delete, mark, copy, paste...)
- Choose to either focus on the body pane, or keep focus in the outline when a node is selected.
- Hide or show the "Open on the side" command in the context menu to open a node beside the active editor
- Set preferences for setting the address and port, and for automatically starting, and/or connecting to a Leo server.

![Settings](https://raw.githubusercontent.com/boltex/leointeg/master/resources/welcome-settings.gif)

</t>
<t tx="felix.20200718222108.1">## Issues

Main issues are listed below. See the repository's [Issues Page](https://github.com/boltex/leointeg/issues) to submit issues.

### Linux Keybindings

If you're experiencing trouble with the keyboard shortcuts for
the 'Clone Node' or the 'Promote' and 'Demote' commands,
set **"keyboard.dispatch": "keyCode"** in your vscode settings and restart vscode.
See [Troubleshoot Linux Keybindings](https://github.com/microsoft/vscode/wiki/Keybinding-Issues#troubleshoot-linux-keybindings)
for more information.

### Keybindings Conflicts Resolution

If you have a keybinding conflict that you would like to be resolved by Leo when the focus is on the body pane,
add **`&amp;&amp; resourceScheme != 'leo'`** to the keybinding's "_when_" condition. (Use **`Ctrl+K Ctrl+S`** in vscode to open the Keyboards Shortcuts panel)

### Move Outline Keyboard Commands

For some users, the **`Alt+[Arrow Keys]`**, **`Ctrl+D`** and **`Ctrl+T`** keybinding are already assigned.

To help with this conflict, tree-browsing, outline-move keyboard commands, and switch focus command will only trigger
with the additional condition of having no text selection in the editor.

So select at least one character to use the previously assigned original keyboard commands while focus is in the body pane.

&gt; Refer to the [issue tracker](https://github.com/boltex/leointeg/issues) page to learn more about the known issues, or to contribute with additional information if you encounter some yourself.

</t>
<t tx="felix.20200718222113.1">## How It Works

Leo integration into VS Code is done by starting
a [python server script](https://github.com/leo-editor/leo-editor/blob/devel/leo/core/leoserver.py) and connecting to it via
a [websocket](https://websockets.readthedocs.io/en/stable/intro.html)
to exchange JSON data. The server script leverages [leoBridge](https://leoeditor.com/leoBridge.html)
and re-uses code from the [leoflexx.py plugin](https://github.com/leo-editor/leo-editor/blob/devel/leo/plugins/leoflexx.py#L893).

The outline pane is made by implementing a
[TreeDataProvider for vscode's TreeView API](https://code.visualstudio.com/api/extension-guides/tree-view#tree-view-api-basics),
while the body-pane's _virtual document_ is made by [implementing a filesystem provider](https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api)
and using the node's gnx as identifier.

---

</t>
<t tx="felix.20200718222118.1">## Acknowledgments

### _Thanks to_

- [Edward K. Ream](https://github.com/edreamleo) creator of the [Leo Editor](https://leoeditor.com/)
- [Eric Amodio](https://github.com/eamodio) for the [welcome screen templates](https://github.com/eamodio/vscode-gitlens/tree/master/src/webviews)
- [Vitalije](https://github.com/vitalije) for his contributions and support
- [Arjan](https://github.com/ar-jan) for his suggestions and ideas
- [Thomas](https://github.com/tbpassin) for his contributions and support
- [Viktor](https://github.com/ranvik14) for his contributions and support
- [Gaurami](https://github.com/ATikhonov2) for his suggestions, bug reports and support
- [Kevin Henderson](https://github.com/kghenderson) for his suggestions and support
- [Ville M. Vainio](https://github.com/vivainio) for his contributions and suggestions

</t>
<t tx="felix.20200718222417.1">## 0.1.12

- Added support for multiple opened files along with the 'new', 'Close', 'Save-As' commands.
- Improved the icons and commands, which are visible, or invisible depending on context.
- Added 'tree view' listing the opened Leo documents which is available in the Leo view, and the explorer view.
- Added basic leonine syntax coloring. (No specific \@languages yet)
- Added selection support to the 'Execute-Script' command.

</t>
<t tx="felix.20200718222419.1">## 0.1.11

- Fixed undo operation for the _insert_ and _rename_ commands (Some other commands may still need fixes to their 'undo' support)
- Fixed crashing when editing body pane under Leo 6.2.

</t>
<t tx="felix.20200718222422.1">## 0.1.10

- Added more [welcome content](https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content) in outlines panes that have not yet opened a tree for starting a server, connecting to it, and added content to help with automation settings.
- Changed the starting default configuration setting for starting and connecting to the leoBridge server script to false.
- Made starting and connecting to the leoBridge server script easier to access in the interface, and in the welcome/settings webview.
- Added new CONTRIBUTING markdown file for running the development version of the leoInteg extension.
- Closes [#44](https://github.com/boltex/leointeg/issues/44).

</t>
<t tx="felix.20200718222425.1">## 0.1.9

- Added new compilation configuration (server, extension, or both) to help debugging.
- Support async output from leoBridge, for log pane and other events.
- External file change detection with modal dialogs matching Leo's gui dialogs.
- Added config options to bypass derived files change detection dialogs with defaults, allowing automatic synchronization of derived files in both directions.
- Added support for redo, refresh from disk and many any other core Leo commands and operations.
- Added support for rapid outline edition command entry, including 'insert node' command **`Ctrl+I`** and for replacing focus on relevant elements to mimic actual Leo interface workflow.
- Added [welcome content](https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content) in outlines panes that have not yet opened a tree to help with connecting and opening.
- Replaced body-editor content transfer logic and removed the related option in the expansion's settings. The body is sent to Leo when appropriate without need of a timed delay.
- _REMOVED FEATURE_ Rolled back 'multi-body' feature for simultaneous body panes from different gnx. Body panes from the same gnx are still available.

</t>
<t tx="felix.20200718222427.1">## 0.1.8

- Extension now built with webpack. [As recommended by vsCode's extension guidelines](https://code.visualstudio.com/api/working-with-extensions/bundling-extension#using-webpack)
- Added a 'Welcome Screen' webview (also compiled by webpack from html, scss and ts files) to show a greeting with basic info, and provide an easy way to change the configuration settings.
- Added commands accessible via either tree menu, context menu, and 'standard' Leo keyboard shortcuts:
  - Insert, delete
  - Cut/Copy/Paste/Clone/Paste as clone
  - Move, promote, demote node operations
  - Mark, unmark, sort children, sort siblings and undo

</t>
<t tx="felix.20200718222429.1">## 0.1.7

- Changed main mode of communication from stdin/out to tcp/ip websockets.
- Made a standalone 'Leo Server' python script.

</t>
<t tx="felix.20200718222433.1">## 0.1.6

- Major 'Browsing' update before adding outline editing and file saving &amp; derivation (Thanks for testing!)
- Refactored and simplified communication between vscode and leoBridge.
- Stabilized browsing with multiple simultaneous body panes.
- Added Leo Outline into explorer view.
- Supports new command to open a node on the side from the context menu.
- Multiple configuration options: Open Settings with CTRL+',' type 'leo', or look for 'leo integration' in extensions.

_Note: Headline and body edition does not affect the Leo file yet._

</t>
<t tx="felix.20200718222435.1">## 0.1.5

- Stabilized tree browsing, along with headline and body editing.

</t>
<t tx="felix.20200718222437.1">## 0.1.4

- Major Refactor to streamline codebase; Eliminated code duplication.
- Complete rewrite after going trying out most of what is possible with both vscode and leo APIs.
- New body pane system that prevents corrupting undos across different positions: It uses the node's actual gnx instead of a generic "body" string as a file path for the custom filesystem.

</t>
<t tx="felix.20200718222439.1">## 0.1.3

- This version creates a body panel via a custom filesystem: 'leo'. It only has a file, "leo:/body", the body of the currently selected node.

_Note: This editable body panel does not affect Leo file yet._

</t>
<t tx="felix.20200718222440.1">## 0.1.2

- Prototype Goal Achieved!
- Browsing Now shows body text too, just like browsing in Leo without editing body nor headlines. (read only for now)

</t>
<t tx="felix.20200718222442.1">## 0.1.1

- Leo File Opening.
- Basic outline browsing, along with the recognizable node icons.

</t>
<t tx="felix.20200718222445.1">## 0.0.1

- Initial basic skeleton of this extension. Press F5 to view icon and test the startup of the extension!
- Implemented [leoBridge](https://leoeditor.com/leoBridge.html) interaction.

![LeoEditor](https://raw.githubusercontent.com/boltex/leointeg/master/resources/leoapp96px.png)
</t>
<t tx="felix.20200718222731.1">## Introduction

[Video tutorial of installation and startup](https://www.youtube.com/watch?v=rutt11xL54I):

[![Installation and startup video](https://img.youtube.com/vi/rutt11xL54I/0.jpg)](https://www.youtube.com/watch?v=rutt11xL54I)

If you're new to vscode and want to try out Leo with this vscode extension, you might want to look at this [Getting Started](https://code.visualstudio.com/docs#vscode-in-action) page to get an overview of vscode.

Furthermore, if you've never ran a vscode extension in an **Extension Development Host**, here is a [short overview about running and modifying a simple extension](https://code.visualstudio.com/api/get-started/your-first-extension).

If you're having problems with the procedures below, try [running this sample extension](https://github.com/Microsoft/vscode-extension-samples/tree/master/helloworld-sample#running-the-sample) first to catch underlying problems or missing dependencies.

</t>
<t tx="felix.20200718222739.1">## Development requirements

- **use Leo's 'devel' branch** (This is temporary until Leo's 6.4 release)

- Make sure you have [Node.js](https://nodejs.org/en/download/) and [Git](https://git-scm.com/downloads) installed. Version up to **14.19** of node works fine for compiling this project.

- Also check your vscode, and other software versions by opening the 'about' dialog from the help menu. You should at least match or exceed the versions below.

On Windows:

![about](resources/vscode-about-win.png)

On Linux:

![about](resources/vscode-about.png)

</t>
<t tx="felix.20200718222741.1">## Getting the source and its development dependencies

- Clone the repository using the command line by typing : `git clone https://github.com/boltex/leointeg.git`

![clone](resources/git-clone.png)

- Although you could 'cd' into the leoInteg folder and run some commands from the same terminal, let's instead use the terminal from within vscode. So open the leoInteg folder with vscode instead, either with the context menu as shown below, or by choosing "Open Folder..." from within vscode:

![open with vscode](resources/open-with-vscode.png)

- With vscode now opened with the **leoInteg folder as its workspace**, use the `ctrl+shift+p` keyboard shortcut to open command palette and toggle the terminal. (You can find any command through the command palette)

![open terminal](resources/open-terminal.png)

- Install the development dependencies by entering the `npm install` command in the terminal. **(Important if you also just _pulled_ updated sources)**

- When the command has finished running, you should see logged results in the terminal and also that a new **node_modules** folder was created.

![dependencies](resources/node-modules.png)

- You're now ready to **compile and run** the development version of the leoInteg extension.

</t>
<t tx="felix.20200718222745.1">## Choosing a debug profile

- Bring up the **Run view**, by selecting the Run icon in the **Activity Bar**. _(Screenshot below)_

- When simply running the extension, choose the **Run Extension** profile.

![profile](resources/debug-profile.png)

&gt; (**Optional**) To contribute code to the python server script, or run it through the vscode debugger, you may need to install the [python development extension](https://marketplace.visualstudio.com/items?itemName=ms-python.python).

- For simply running and using leoInteg, just start the extension and the server as shown below.

</t>
<t tx="felix.20200718222748.1">## Starting the extension

- Use the **Start Debugging** command (or press **F5**) to start another vscode window with the expansion _installed and running_ within it.

![extension started](resources/leointeg-started.png)

- If any problems occurred during the extension compilation it will be logged in the vscode instance that started the debug process in its **task-webpack** terminal panel. Otherwise if its running, the extension itself will be logging any messages in the **debug-console** panel. (See animation below)

![extension logs](resources/debug-anim.gif)

</t>
<t tx="felix.20200718222754.1">## The python server script

- This extension needs the **`leobridgeserver.py`** or the **`leoserver.py`** script to be running from Leo's own installation folder. That is where the two extra extension requirements come into play:

## Server Script Requirement

- Having the [Websocket Python Library installed](https://websockets.readthedocs.io/en/stable/intro.html)

### 3 ways to start the server script

1. You can have LeoInteg try to start a server script instance itself via the **Start Leo Server** command or button. It will use the 'py' command on Windows and 'python3' command on other OSes by default. _You can automate this process via leoInteg's configuration settings._
2. You can have vscode's **Debug View** start it, as a debug session starts, by choosing a debug profile that includes the server script. It's then possible to step in, inspect and debug the python server script. _The [python development extension](https://marketplace.visualstudio.com/items?itemName=ms-python.python) may be required._
   **If using those debug view profiles, the server files have to be de-commented from the leointeg.leo file, or copied from the leo-editor/leo/core folder.**
3. You can also start it yourself manually, by running the leoserver.py script (preferably from your leo-editor/leo/core folder) in a terminal or command prompt of your liking.

For more details about all possible arguments, run it from a command prompt with the 'help' argument like so:\
**`...leo-editor/leo/core/leoserver.py --help`**

For more information about the Leo server see [Using leoserver.py](https://leoeditor.com/leoserver.html) from Leo's official documentation.

### Using Anaconda or other custom python installations

- LeoInteg provides configuration options to specify how to launch python interpreter but this may not be enough to get it to start on your system, see [#10](https://github.com/boltex/leointeg/issues/10) and other issues relating to configurations in _sitecustomize.py_ file as noted in [Leo's google group forum](https://groups.google.com/d/msg/leo-editor/FAP8lVnWLyQ/lWHWEYH9AgAJ).

- If Leointeg or vscode cannot start running the server script on you system or OS, a **workaround** is to start the server script beforehand manually with whichever python interpreter you have installed.

![launch server](resources/manual-server-start.png)

- It will terminate automatically when a user disconnect.

**Note**: If force-closing the server from the integrated vscode terminal, use the 'Kill terminal' button instead of the 'X' that just hides the panel.

![kill terminal](resources/kill-terminal.png)

</t>
<t tx="felix.20200718222757.1">## Issues

More information can be found on the repository's [Issues Page](https://github.com/boltex/leointeg/issues), where details and troubleshooting can be addressed more directly.
</t>
<t tx="felix.20200719025231.1">import * as vscode from 'vscode';
import { debounce } from 'debounce';
import * as utils from './utils';
import { Constants } from './constants';
import {
    LeoBridgePackage,
    RevealType,
    ArchivedPosition,
    Icon,
    ConfigMembers,
    ReqRefresh,
    ChooseDocumentItem,
    LeoDocument,
    UserCommand,
    BodySelectionInfo,
    LeoGuiFindTabManagerSettings,
    LeoSearchSettings,
    ChooseRClickItem,
    RClick
} from './types';
import { Config } from './config';
import { LeoFilesBrowser } from './leoFileBrowser';
import { LeoNode } from './leoNode';
import { LeoOutlineProvider } from './leoOutline';
import { LeoBodyProvider } from './leoBody';
import { LeoBridge } from './leoBridge';
import { ServerService } from './serverManager';
import { LeoStatusBar } from './leoStatusBar';
import { CommandStack } from './commandStack';
import { LeoDocumentsProvider } from './leoDocuments';
import { LeoDocumentNode } from './leoDocumentNode';
import { LeoStates } from './leoStates';
import { LeoButtonsProvider } from './leoButtons';
import { LeoButtonNode } from './leoButtonNode';
import { LeoFindPanelProvider } from './webviews/leoFindPanelWebview';
import { LeoSettingsProvider } from './webviews/leoSettingsWebview';
import { LeoGotoNode } from './leoGotoNode';
import { LeoGotoProvider } from './leoGoto';

@others
@language typescript
@tabwidth -4
</t>
<t tx="felix.20200719025231.10"></t>
<t tx="felix.20200719025231.11">/**
 * * Open Leo files found in "context.workspaceState.leoFiles"
 * @returns promise that resolves with editor of last opened from the list, or rejects if empty
 */
private _openLastFiles(): Promise&lt;vscode.TextEditor&gt; {
    // Loop through context.workspaceState.&lt;something&gt; and check if they exist: open them
    const w_lastFiles: string[] = this._context.workspaceState.get(Constants.LAST_FILES_KEY) || [];
    if (w_lastFiles.length) {
        return this.sendAction(
            Constants.LEOBRIDGE.OPEN_FILES,
            JSON.stringify({ files: w_lastFiles })
        ).then(
            (p_openFileResult: LeoBridgePackage) =&gt; {
                this.leoStates.leoBridgeReady = true;
                this.leoStates.leoStartupFinished = true;
                return this.setupOpenedLeoDocument(p_openFileResult);
            },
            (p_errorOpen) =&gt; {
                this.leoStates.leoBridgeReady = true;
                this.leoStates.leoStartupFinished = true;
                console.log('in .then not opened or already opened');
                return Promise.reject(p_errorOpen);
            }
        );
    } else {
        return Promise.reject('Recent files list is empty');
    }
}

</t>
<t tx="felix.20200719025231.12">/**
 * * Adds to the context.workspaceState.&lt;xxx&gt;files if not already in there (no duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when all workspace storage modifications are done
 */
private _addRecentAndLastFile(p_file: string): Promise&lt;void&gt; {
    if (!p_file.length) {
        return Promise.resolve();
    }
    return Promise.all([
        utils.addFileToWorkspace(this._context, p_file, Constants.RECENT_FILES_KEY),
        utils.addFileToWorkspace(this._context, p_file, Constants.LAST_FILES_KEY),
    ]).then(() =&gt; {
        return Promise.resolve();
    });
}

</t>
<t tx="felix.20200719025231.13">/**
 * * Removes from context.workspaceState.leoRecentFiles if found (should not have duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when the workspace storage modification is done
 */
private _removeRecentFile(p_file: string): Thenable&lt;void&gt; {
    return utils.removeFileFromWorkspace(this._context, p_file, Constants.RECENT_FILES_KEY);
}

</t>
<t tx="felix.20200719025231.14">/**
 * * Removes from context.workspaceState.leoLastFiles if found (should not have duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when the workspace storage modification is done
 */
private _removeLastFile(p_file: string): Thenable&lt;void&gt; {
    return utils.removeFileFromWorkspace(this._context, p_file, Constants.LAST_FILES_KEY);
}

</t>
<t tx="felix.20200719025231.15">/**
 * * Shows the recent Leo files list, choosing one will open it
 * @returns A promise that resolves when the a file is finally opened, rejected otherwise
 */
public showRecentLeoFiles(): Thenable&lt;vscode.TextEditor | undefined&gt; {
    const w_recentFiles: string[] =
        this._context.workspaceState.get(Constants.RECENT_FILES_KEY) || [];
    let q_chooseFile: Thenable&lt;string | undefined&gt;;
    if (w_recentFiles.length) {
        q_chooseFile = vscode.window.showQuickPick(w_recentFiles, {
            placeHolder: Constants.USER_MESSAGES.OPEN_RECENT_FILE,
        });
    } else {
        // No file to list
        return Promise.resolve(undefined);
    }
    return q_chooseFile.then((p_result) =&gt; {
        if (p_result) {
            return this.openLeoFile(vscode.Uri.file(p_result));
        } else {
            // Canceled
            return Promise.resolve(undefined);
        }
    });
}

</t>
<t tx="felix.20200719025231.19">/**
 * * 'getStates' action for use in debounced method call
 */
private _triggerGetStates(): void {
    if (this._refreshType.documents) {
        this._refreshType.documents = false;
        this.refreshDocumentsPane();
    }
    if (this._refreshType.buttons) {
        this._refreshType.buttons = false;
        this.refreshButtonsPane();
    }
    if (this._refreshType.states) {
        this._refreshType.states = false;
        this.sendAction(Constants.LEOBRIDGE.GET_STATES)
            .then((p_package: LeoBridgePackage) =&gt; {
                if (p_package.states) {
                    this.leoStates.setLeoStateFlags(p_package.states);
                }
            });
    }
}

</t>
<t tx="felix.20200719025231.2">/**
 * * Orchestrates Leo integration into vscode
 */
export class LeoIntegration {
    // * Status Flags
    public activated: boolean = true; // Set to false when deactivating the extension
    private _leoBridgeReadyPromise: Promise&lt;LeoBridgePackage&gt; | undefined; // Is set when leoBridge has a leo controller ready
    private _currentOutlineTitle: string = Constants.GUI.TREEVIEW_TITLE_INTEGRATION; // Might need to be re-set when switching visibility
    private _hasShownContextOpenMessage: boolean = false; // Used to show this information only once

    // * State flags
    public leoStates: LeoStates;
    private _startingServer: boolean = false; // Used to prevent re-starting while starting until success of fail
    public verbose: boolean = false;
    public trace: boolean = false;
    public clipboardContent: string = "";

    // * Frontend command stack
    private _commandStack: CommandStack;

    // * Configuration Settings Service
    public config: Config; // Public configuration service singleton, used in leoSettingsWebview, leoBridge, and leoNode for inverted contrast

    // * Icon Paths
    public nodeIcons: Icon[] = []; // Singleton static array of all icon paths used in leoNodes for rendering in treeview
    public documentIcons: Icon[] = [];
    public buttonIcons: Icon[] = [];

    // * File Browser
    private _leoFilesBrowser: LeoFilesBrowser; // Browsing dialog service singleton used in the openLeoFile and save-as methods

    // * LeoBridge
    private _leoBridge: LeoBridge; // Singleton service to access leobridgeserver

    // * Outline Pane
    private _leoTreeProvider: LeoOutlineProvider; // TreeDataProvider single instance
    private _leoTreeView: vscode.TreeView&lt;LeoNode&gt;; // Outline tree view added to the Tree View Container with an Activity Bar icon
    private _leoTreeExView: vscode.TreeView&lt;LeoNode&gt;; // Outline tree view added to the Explorer Sidebar
    private _lastTreeView: vscode.TreeView&lt;LeoNode&gt;; // Last visible treeview
    private _retriedRefresh: boolean = false;
    private _treeId: number = 0; // Starting salt for tree node murmurhash generated Ids
    private _renamingHeadline: string = "";

    private _lastSelectedNode: LeoNode | undefined; // Last selected node we got a hold of; leoTreeView.selection maybe newer and unprocessed
    get lastSelectedNode(): LeoNode | undefined {
        return this._lastSelectedNode;
    }
    set lastSelectedNode(p_leoNode: LeoNode | undefined) {
        // Needs undefined type because it cannot be set in the constructor
        this._lastSelectedNode = p_leoNode;
        if (p_leoNode) {
            utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_leoNode.marked); // Global context to 'flag' the selected node's marked state
        }
    }

    // * Outline Pane redraw/refresh flags. Also set when calling refreshTreeRoot
    // If there's no reveal and its the selected node, the old id will be re-used for the node. (see _id property in LeoNode)
    private _revealType: RevealType = RevealType.NoReveal; // to be read/cleared in arrayToLeoNodesArray, to check if any should self-select
    private _preventShowBody = false; // Used when refreshing treeview from config: It requires not to open the body pane when refreshing
    private _needRefresh = false; // Used at the end of refresh process, when a setLanguage checks if gnx is same as lastSelectedNode

    // * Documents Pane
    private _leoDocumentsProvider: LeoDocumentsProvider;
    private _leoDocuments: vscode.TreeView&lt;LeoDocumentNode&gt;;
    private _leoDocumentsExplorer: vscode.TreeView&lt;LeoDocumentNode&gt;;
    private _currentDocumentChanged: boolean = false; // if clean and an edit is done: refresh opened documents view

    // * Goto nav panel
    private _leoGotoProvider: LeoGotoProvider;
    private _leoGoto: vscode.TreeView&lt;LeoGotoNode&gt;;
    private _leoGotoExplorer: vscode.TreeView&lt;LeoGotoNode&gt;;

    // * Commands stack finishing resolving "refresh flags", for type of refresh after finishing stack
    private _refreshType: ReqRefresh = {}; // Flags for commands to require parts of UI to refresh
    private _fromOutline: boolean = false; // Last command issued had focus on outline, as opposed to the body
    private _focusInterrupt: boolean = false; // Flag for preventing setting focus when interrupting (canceling) an 'insert node' text input dialog with another one

    // * Body Pane
    private _bodyFileSystemStarted: boolean = false;
    private _bodyEnablePreview: boolean = true;
    private _leoFileSystem: LeoBodyProvider; // as per https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api
    private _bodyTextDocument: vscode.TextDocument | undefined; // Set when selected in tree by user, or opening a Leo file in showBody. and by _locateOpenedBody.
    private _bodyMainSelectionColumn: vscode.ViewColumn | undefined; // Column of last body 'textEditor' found, set to 1

    private _languageFlagged: string[] = [];

    private _bodyPreviewMode: boolean = true;

    private _editorTouched: boolean = false; // Flag for applying editor changes to body when 'icon' state change and 'undo' back to untouched

    private _bodyStatesTimer: NodeJS.Timeout | undefined;

    // * Find panel
    private _findPanelWebviewView: vscode.WebviewView | undefined;
    private _findPanelWebviewExplorerView: vscode.WebviewView | undefined;
    private _lastSettingsUsed: LeoSearchSettings | undefined; // Last settings loaded / saved for current document

    // * Selection
    private _selectionDirty: boolean = false; // Flag set when cursor selection is changed
    private _selectionGnx: string = ''; // Packaged into 'BodySelectionInfo' structures, sent to Leo
    private _selection: vscode.Selection | undefined; // also packaged into 'BodySelectionInfo'
    private _scrollDirty: boolean = false; // Flag set when cursor selection is changed
    private _scrollGnx: string = '';
    private _scroll: vscode.Range | undefined;

    private _bodyUri: vscode.Uri = utils.strToLeoUri('');
    get bodyUri(): vscode.Uri {
        return this._bodyUri;
    }
    set bodyUri(p_uri: vscode.Uri) {
        this._leoFileSystem.setBodyTime(p_uri);
        this._bodyUri = p_uri;
    }

    // * '@button' pane
    private _leoButtonsProvider: LeoButtonsProvider;
    private _leoButtons: vscode.TreeView&lt;LeoButtonNode&gt;;
    private _leoButtonsExplorer: vscode.TreeView&lt;LeoButtonNode&gt;;
    private _rclickSelected: number[] = [];

    // * Leo Find Panel
    private _leoFindPanelProvider: vscode.WebviewViewProvider;

    // * Settings / Welcome webview
    public leoSettingsWebview: LeoSettingsProvider;

    // * Log and terminal Panes
    private _leoLogPane: vscode.OutputChannel = vscode.window.createOutputChannel(
        Constants.GUI.LOG_PANE_TITLE
    );
    // private _leoTerminalPane: vscode.OutputChannel | undefined; // ! local server output should be in log pane #

    // * Status Bar
    private _leoStatusBar: LeoStatusBar;

    // * Edit/Insert Headline Input Box options instance, setup so clicking outside cancels the headline change
    private _headlineInputOptions: vscode.InputBoxOptions = {
        ignoreFocusOut: false,
        value: '',
        valueSelection: undefined,
        prompt: '',
    };

    // * Automatic leobridgeserver startup management service
    private _serverService: ServerService;

    // * Timing
    private _needLastSelectedRefresh = false;
    private _bodyLastChangedDocument: vscode.TextDocument | undefined; // Only set in _onDocumentChanged
    private _bodyLastChangedDocumentSaved: boolean = true; // don't use 'isDirty' of the document!

    // * Debounced method used to get states for UI display flags (commands such as undo, redo, save, ...)
    public getStates: (() =&gt; void) &amp; {
        clear(): void;
    } &amp; {
        flush(): void;
    };

    // * Debounced method used to get opened Leo Files for the documents pane
    public refreshDocumentsPane: (() =&gt; void) &amp; {
        clear(): void;
    } &amp; {
        flush(): void;
    };

    // * Debounced method used to get content of the at-buttons pane
    public refreshButtonsPane: (() =&gt; void) &amp; {
        clear(): void;
    } &amp; {
        flush(): void;
    };

    // * Debounced method used to get content of the at-buttons pane
    public refreshGotoPane: (() =&gt; void) &amp; {
        clear(): void;
    } &amp; {
        flush(): void;
    };

    // * Debounced method used to refresh all
    public refreshAll: (() =&gt; void) &amp; {
        clear(): void;
    } &amp; {
        flush(): void;
    };

    @others
}
</t>
<t tx="felix.20200719025231.20">/**
 * * Returns the 'busy' state flag of the command stack, and leoBridge stack, while showing a message if it is.
 * Needed by special unstackable commands such as new, open,...
 * @param p_all Flag to also return true if either front command stack or bridge stack is busy
 * @returns true if command stack is busy, also returns true if p_all flag is set and bridge is busy
 */
private _isBusy(p_all?: boolean): boolean {
    if (this._commandStack.size() || (p_all &amp;&amp; this._leoBridge.isBusy())) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.TOO_FAST);
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20200719025231.21">/**
 * * Check if the current file is an already saved/named file
 * @returns true if the current opened Leo document's filename has some content. (not a new unnamed file)
 */
private _isCurrentFileNamed(): boolean {
    return !!this.leoStates.leoOpenedFileName.length; // checks if it's an empty string
}

</t>
<t tx="felix.20200719025231.22">/**
 * * Setup leoInteg's UI for having no opened Leo documents
 */
public setupNoOpenedLeoDocument(): void {
    this.leoStates.fileOpenedReady = false;
    this._bodyTextDocument = undefined;
    this.lastSelectedNode = undefined;
    this._refreshOutline(false, RevealType.NoReveal);
    this.refreshDocumentsPane();
    this.refreshButtonsPane();
    this.closeBody();
}

</t>
<t tx="felix.20200719025231.23">/**
 * * A Leo file was opened: setup leoInteg's UI accordingly.
 * @param p_openFileResult Returned info about currently opened and editing document
 * @param p_asClient specifies its not the originator of the opened file in multiple user context
 * @return a promise that resolves to an opened body pane text editor
 */
public setupOpenedLeoDocument(
    p_openFileResult: LeoBridgePackage,
    p_asClient?: boolean
): Promise&lt;vscode.TextEditor&gt; {
    this._needLastSelectedRefresh = true;
    const w_selectedLeoNode = this.apToLeoNode(p_openFileResult.node!, false); // Just to get gnx for the body's fist appearance
    this.leoStates.leoOpenedFileName = p_openFileResult.filename!;

    if (!p_asClient) {
        // * If not unnamed file add to recent list &amp; last opened list
        this._addRecentAndLastFile(p_openFileResult.filename!);
    }

    let q_switchTextEditor: Promise&lt;vscode.TextEditor&gt; | false = false;
    // * Could be already opened, so perform 'switch body' as if another node was selected
    if (this._bodyTextDocument &amp;&amp; this.bodyUri) {

        q_switchTextEditor = new Promise((p_resolve, p_reject) =&gt; {
            this._switchBody(w_selectedLeoNode.gnx, false, true).then((p_te) =&gt; {
                p_resolve(p_te);
            });
        });

    } else {
        this.bodyUri = utils.strToLeoUri(w_selectedLeoNode.gnx);
    }

    // * Start body pane system
    if (!this._bodyFileSystemStarted) {
        this._context.subscriptions.push(
            vscode.workspace.registerFileSystemProvider(
                Constants.URI_LEO_SCHEME,
                this._leoFileSystem,
                { isCaseSensitive: true }
            )
        );
        this._bodyFileSystemStarted = true;
    }

    // * Startup flag
    if (!this.leoStates.fileOpenedReady) {
        this.leoStates.fileOpenedReady = true;
    }

    // * Maybe first valid redraw of tree along with the selected node and its body
    this._refreshOutline(true, RevealType.RevealSelectFocus); // p_revealSelection flag set

    // * Maybe first StatusBar appearance
    this._leoStatusBar.update(true, 0, true);
    this._leoStatusBar.show(); // Just selected a node

    // * Show leo log pane
    // this.showLogPane(); // #203 No need to explicitly show the log pane upon opening files

    // * Send config to python's side (for settings such as defaultReloadIgnore and checkForChangeExternalFiles)
    this.sendConfigToServer(this.config.getConfig());
    // * Refresh Opened tree views
    this.refreshDocumentsPane();
    this.refreshButtonsPane();
    this.loadSearchSettings();
    // * Maybe first Body appearance
    // return this.showBody(false);
    if (q_switchTextEditor) {
        return q_switchTextEditor;
    } else {
        return this.showBody(false);
    }
}

</t>
<t tx="felix.20200719025231.24">/**
 * * Handles the change of vscode config: a onDidChangeConfiguration event triggered
 * @param p_event The configuration-change event passed by vscode
 */
private _onChangeConfiguration(p_event: vscode.ConfigurationChangeEvent): void {
    if (p_event.affectsConfiguration(Constants.CONFIG_NAME)) {
        this.config.buildFromSavedSettings();
    }

    // also check if workbench.editor.enablePreview
    this._bodyEnablePreview = !!vscode.workspace
        .getConfiguration('workbench.editor')
        .get('enablePreview');

    // Check For "workbench.editor.enablePreview" to be true.
    this.config.checkEnablePreview();
    this.config.checkCloseEmptyGroups();
    this.config.checkCloseOnFileDelete();
}

</t>
<t tx="felix.20200719025231.25">/**
 * * Handles the node expanding and collapsing interactions by the user in the treeview
 * @param p_event The event passed by vscode
 * @param p_expand True if it was an expand, false if it was a collapse event
 * @param p_treeView Pointer to the treeview itself, either the standalone treeview or the one under the explorer
 */
private _onChangeCollapsedState(
    p_event: vscode.TreeViewExpansionEvent&lt;LeoNode&gt;,
    p_expand: boolean,
    p_treeView: vscode.TreeView&lt;LeoNode&gt;
): void {
    // * Expanding or collapsing via the treeview interface selects the node to mimic Leo
    this.triggerBodySave(true);
    if (p_treeView.selection[0] &amp;&amp; p_treeView.selection[0] === p_event.element) {
        // * This happens if the tree selection is the same as the expanded/collapsed node: Just have Leo do the same
        // Pass
    } else {
        // * This part only happens if the user clicked on the arrow without trying to select the node
        this._revealTreeViewNode(p_event.element, { select: true, focus: false }); // No force focus : it breaks collapse/expand when direct parent
        this.selectTreeNode(p_event.element, true); // not waiting for a .then(...) so not to add any lag
    }
    this.sendAction(
        p_expand ? Constants.LEOBRIDGE.EXPAND_NODE : Constants.LEOBRIDGE.COLLAPSE_NODE,
        utils.buildNodeCommandJson(p_event.element.apJson)
    ).then(() =&gt; {
        if (this.config.leoTreeBrowse) {
            this._refreshOutline(true, RevealType.RevealSelect);
        }
    });
}

</t>
<t tx="felix.20200719025231.26">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flag to signify that the treeview who triggered this event is the one in the explorer view
 */
private _onTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {
    if (p_event.visible) {
        this._lastTreeView = p_explorerView ? this._leoTreeExView : this._leoTreeView;
        this.setTreeViewTitle();
        this._needLastSelectedRefresh = true; // Its a new node in a new tree so refresh lastSelectedNode too
        if (this.leoStates.fileOpenedReady) {
            this.loadSearchSettings();
        }
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="felix.20200719025231.27">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onDocTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {
    if (p_explorerView) {
    } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this.refreshDocumentsPane();
    }
}

</t>
<t tx="felix.20200719025231.29">/**
 * * Handles detection of the active editor having changed from one to another, or closed
 * TODO : Make sure the selection in tree if highlighted when a body pane is selected
 * @param p_editor The editor itself that is now active
 * @param p_internalCall Flag used to signify the it was called voluntarily by leoInteg itself
 */
private _onActiveEditorChanged(
    p_editor: vscode.TextEditor | undefined,
    p_internalCall?: boolean
): void {
    if (p_editor &amp;&amp; p_editor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        if (this.bodyUri.fsPath !== p_editor.document.uri.fsPath) {
            this._hideDeleteBody(p_editor);
        }
        this._checkPreviewMode(p_editor);
    }
    if (!p_internalCall) {
        this.triggerBodySave(true); // Save in case edits were pending
    }
    // * Status flag check
    if (!p_editor &amp;&amp; this._leoStatusBar.statusBarFlag) {
        return;
    }
    // * Status flag check
    setTimeout(() =&gt; {
        if (vscode.window.activeTextEditor) {
            this._leoStatusBar.update(
                vscode.window.activeTextEditor.document.uri.scheme === Constants.URI_LEO_SCHEME
            );
        }
    }, 0);
}

</t>
<t tx="felix.20200719025231.3">constructor(private _context: vscode.ExtensionContext) {
    // * Setup States
    this.leoStates = new LeoStates(_context, this);

    // * Get configuration settings
    this.config = new Config(_context, this);

    // * also check workbench.editor.enablePreview
    this.config.buildFromSavedSettings();
    this._bodyEnablePreview = !!vscode.workspace
        .getConfiguration('workbench.editor')
        .get('enablePreview');

    // * Build Icon filename paths
    this.nodeIcons = utils.buildNodeIconPaths(_context);
    this.documentIcons = utils.buildDocumentIconPaths(_context);
    this.buttonIcons = utils.buildButtonsIconPaths(_context);

    // * Create file browser instance
    this._leoFilesBrowser = new LeoFilesBrowser(_context);

    // * Setup leoBridge
    this._leoBridge = new LeoBridge(_context, this);

    // * Setup frontend command stack
    this._commandStack = new CommandStack(_context, this);

    // * Create a single data provider for both outline trees, Leo view and Explorer view
    this._leoTreeProvider = new LeoOutlineProvider(this);

    // * Create Leo stand-alone view and Explorer view outline panes
    // Uses 'select node' command, so 'onDidChangeSelection' is not used
    this._leoTreeView = vscode.window.createTreeView(Constants.TREEVIEW_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoTreeProvider,
    });
    this._leoTreeView.onDidExpandElement((p_event) =&gt;
        this._onChangeCollapsedState(p_event, true, this._leoTreeView)
    );
    this._leoTreeView.onDidCollapseElement((p_event) =&gt;
        this._onChangeCollapsedState(p_event, false, this._leoTreeView)
    );
    // * Trigger 'show tree in Leo's view'
    this._leoTreeView.onDidChangeVisibility((p_event) =&gt;
        this._onTreeViewVisibilityChanged(p_event, false)
    );
    this._leoTreeExView = vscode.window.createTreeView(Constants.TREEVIEW_EXPLORER_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoTreeProvider,
    });
    this._leoTreeExView.onDidExpandElement((p_event) =&gt;
        this._onChangeCollapsedState(p_event, true, this._leoTreeExView)
    );
    this._leoTreeExView.onDidCollapseElement((p_event) =&gt;
        this._onChangeCollapsedState(p_event, false, this._leoTreeExView)
    );
    // * Trigger 'show tree in explorer view'
    this._leoTreeExView.onDidChangeVisibility((p_event) =&gt;
        this._onTreeViewVisibilityChanged(p_event, true)
    );
    // * Init this._lastTreeView based on config only assuming explorer is default sidebar view
    this._lastTreeView = this.config.treeInExplorer ? this._leoTreeExView : this._leoTreeView;

    // * Create Leo Opened Documents Treeview Providers and tree views
    this._leoDocumentsProvider = new LeoDocumentsProvider(this);
    this._leoDocuments = vscode.window.createTreeView(Constants.DOCUMENTS_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoDocumentsProvider,
    });
    this._leoDocuments.onDidChangeVisibility((p_event) =&gt;
        this._onDocTreeViewVisibilityChanged(p_event, false)
    );
    this._leoDocumentsExplorer = vscode.window.createTreeView(Constants.DOCUMENTS_EXPLORER_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoDocumentsProvider,
    });
    this._leoDocumentsExplorer.onDidChangeVisibility((p_event) =&gt;
        this._onDocTreeViewVisibilityChanged(p_event, true)
    );

    // * Create '@buttons' Treeview Providers and tree views
    this._leoButtonsProvider = new LeoButtonsProvider(this);
    this._leoButtons = vscode.window.createTreeView(Constants.BUTTONS_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoButtonsProvider,
    });
    this._leoButtons.onDidChangeVisibility((p_event) =&gt;
        this._onButtonsTreeViewVisibilityChanged(p_event, false)
    );
    this._leoButtonsExplorer = vscode.window.createTreeView(Constants.BUTTONS_EXPLORER_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoButtonsProvider,
    });
    this._leoButtonsExplorer.onDidChangeVisibility((p_event) =&gt;
        this._onButtonsTreeViewVisibilityChanged(p_event, true)
    );

    // * Create goto Treeview Providers and tree views
    this._leoGotoProvider = new LeoGotoProvider(this);
    this._leoGoto = vscode.window.createTreeView(Constants.GOTO_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoGotoProvider,
    });
    this._leoGoto.onDidChangeVisibility((p_event) =&gt;
        this._onGotoTreeViewVisibilityChanged(p_event, false)
    );
    this._leoGotoExplorer = vscode.window.createTreeView(Constants.GOTO_EXPLORER_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoGotoProvider,
    });
    this._leoGotoExplorer.onDidChangeVisibility((p_event) =&gt;
        this._onGotoTreeViewVisibilityChanged(p_event, true)
    );
    // * Set 'last' goto tree view visible
    this._leoGotoProvider.setLastGotoView(this.config.treeInExplorer ? this._leoGotoExplorer : this._leoGoto);


    // * Create Body Pane
    this._leoFileSystem = new LeoBodyProvider(this);
    this._bodyMainSelectionColumn = 1;

    // * Create Status bar Entry
    this._leoStatusBar = new LeoStatusBar(_context, this);

    // * Automatic server start service
    this._serverService = new ServerService(_context, this);

    // * Leo Find Panel
    this._leoFindPanelProvider = new LeoFindPanelProvider(
        _context.extensionUri,
        _context,
        this
    );
    this._context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(
            Constants.FIND_ID,
            this._leoFindPanelProvider,
            { webviewOptions: { retainContextWhenHidden: true } }
        )
    );
    this._context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(
            Constants.FIND_EXPLORER_ID,
            this._leoFindPanelProvider,
            { webviewOptions: { retainContextWhenHidden: true } }
        )
    );

    // * Configuration / Welcome webview
    this.leoSettingsWebview = new LeoSettingsProvider(_context, this);

    // * React to change in active panel/text editor (window.activeTextEditor) - also fires when the active editor becomes undefined
    vscode.window.onDidChangeActiveTextEditor((p_editor) =&gt;
        this._onActiveEditorChanged(p_editor)
    );

    // * React to change in selection, cursor position and scroll position
    vscode.window.onDidChangeTextEditorSelection((p_event) =&gt;
        this._onChangeEditorSelection(p_event)
    );
    vscode.window.onDidChangeTextEditorVisibleRanges((p_event) =&gt;
        this._onChangeEditorScroll(p_event)
    );

    // * Triggers when a different text editor/vscode window changed focus or visibility, or dragged
    // This is also what triggers after drag and drop, see '_onChangeEditorViewColumn'
    vscode.window.onDidChangeTextEditorViewColumn((p_columnChangeEvent) =&gt;
        this._changedTextEditorViewColumn(p_columnChangeEvent)
    ); // Also triggers after drag and drop
    vscode.window.onDidChangeVisibleTextEditors((p_editors) =&gt;
        this._changedVisibleTextEditors(p_editors)
    ); // Window.visibleTextEditors changed
    vscode.window.onDidChangeWindowState((p_windowState) =&gt;
        this._changedWindowState(p_windowState)
    ); // Focus state of the current window changes

    // * React when typing and changing body pane
    vscode.workspace.onDidChangeTextDocument((p_textDocumentChange) =&gt;
        this._onDocumentChanged(p_textDocumentChange)
    );

    // * React to configuration settings events
    vscode.workspace.onDidChangeConfiguration((p_configChange) =&gt;
        this._onChangeConfiguration(p_configChange)
    );

    // * React to opening of any file in vscode
    vscode.workspace.onDidOpenTextDocument((p_document) =&gt;
        this._onDidOpenTextDocument(p_document)
    );

    // * Debounced refresh flags and UI parts, other than the tree and body
    this.getStates = debounce(
        () =&gt; { this._triggerGetStates(); },
        Constants.STATES_DEBOUNCE_DELAY
    );
    this.refreshDocumentsPane = debounce(
        () =&gt; { this._leoDocumentsProvider.refreshTreeRoot(); },
        Constants.DOCUMENTS_DEBOUNCE_DELAY
    );
    this.refreshButtonsPane = debounce(
        () =&gt; { this._leoButtonsProvider.refreshTreeRoot(); },
        Constants.BUTTONS_DEBOUNCE_DELAY
    );
    this.refreshGotoPane = debounce(
        () =&gt; { this._leoGotoProvider.refreshTreeRoot(); },
        Constants.GOTO_DEBOUNCE_DELAY
    );
    this.refreshAll = debounce(
        () =&gt; {
            this.launchRefresh({
                tree: true,
                body: true,
                buttons: true,
                states: true,
                documents: true
            }, false);
        },
        Constants.REFRESH_ALL_DEBOUNCE_DELAY
    );
}

</t>
<t tx="felix.20200719025231.31">/**
 * * Handle typing that was detected in a document
 * @param p_textDocumentChange Text changed event passed by vscode
 */
private _onDocumentChanged(p_textDocumentChange: vscode.TextDocumentChangeEvent): void {
    // ".length" check necessary, see https://github.com/microsoft/vscode/issues/50344
    if (
        this.lastSelectedNode &amp;&amp;
        p_textDocumentChange.contentChanges.length &amp;&amp;
        p_textDocumentChange.document.uri.scheme === Constants.URI_LEO_SCHEME
    ) {
        // * There was an actual change on a Leo Body by the user
        this._bodyLastChangedDocument = p_textDocumentChange.document;
        this._bodyLastChangedDocumentSaved = false;
        this._bodyPreviewMode = false;
        this._fromOutline = false; // Focus is on body pane
        this._editorTouched = true; // To make sure to transfer content to Leo even if all undone

        // * If icon should change then do it now (if there's no document edit pending)
        if (
            !this._currentDocumentChanged ||
            utils.leoUriToStr(p_textDocumentChange.document.uri) === this.lastSelectedNode.gnx
        ) {
            const w_hasBody = !!p_textDocumentChange.document.getText().length;
            if (utils.isIconChangedByEdit(this.lastSelectedNode, w_hasBody)) {
                this._bodySaveDocument(p_textDocumentChange.document).then(() =&gt; {
                    if (this.lastSelectedNode) {
                        this.lastSelectedNode.dirty = true;
                        this.lastSelectedNode.hasBody = w_hasBody;
                        // NOT incrementing this.treeID to keep ids intact
                    }
                    // NoReveal since we're keeping the same id.
                    this._refreshOutline(false, RevealType.NoReveal);
                });
                // also refresh document panel (icon may be dirty now)
                this.refreshDocumentsPane();
            }
        }

        // * If body changed a line with and '@' directive refresh body states
        let w_needsRefresh = false;
        p_textDocumentChange.contentChanges.forEach(p_contentChange =&gt; {
            if (p_contentChange.text.includes('@')) {
                // There may have been an @
                w_needsRefresh = true;
            }
        });

        const w_textEditor = vscode.window.activeTextEditor;

        if (w_textEditor &amp;&amp; p_textDocumentChange.document.uri.fsPath === w_textEditor.document.uri.fsPath) {
            w_textEditor.selections.forEach(p_selection =&gt; {
                // if line starts with @
                let w_line = w_textEditor.document.lineAt(p_selection.active.line).text;
                if (w_line.trim().startsWith('@')) {
                    w_needsRefresh = true;
                }
            });
        }
        if (w_needsRefresh) {
            this.debouncedRefreshBodyStates();
        }

    }
}

</t>
<t tx="felix.20200719025231.32">/**
 * * Save body to Leo if its dirty. That is, only if a change has been made to the body 'document' so far
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the possible saving process is finished
 */
public triggerBodySave(p_forcedVsCodeSave?: boolean): Promise&lt;boolean&gt; {
    // * Save body to Leo if a change has been made to the body 'document' so far
    let q_savePromise: Promise&lt;boolean&gt;;
    if (
        this._bodyLastChangedDocument &amp;&amp;
        (this._bodyLastChangedDocument.isDirty || this._editorTouched) &amp;&amp;
        !this._bodyLastChangedDocumentSaved
    ) {
        // * Is dirty and unsaved, so proper save is in order
        const w_document = this._bodyLastChangedDocument; // backup for bodySaveDocument before reset
        this._bodyLastChangedDocumentSaved = true;
        this._editorTouched = false;
        q_savePromise = this._bodySaveDocument(w_document, p_forcedVsCodeSave);
    } else if (
        p_forcedVsCodeSave &amp;&amp;
        this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty &amp;&amp;
        this._bodyLastChangedDocumentSaved
    ) {
        // * Had 'forcedVsCodeSave' and isDirty only, so just clean up dirty VSCODE document flag.
        this._bodyLastChangedDocument.save(); // ! USED INTENTIONALLY: This trims trailing spaces
        q_savePromise = this._bodySaveSelection(); // just save selection if it's changed
    } else {
        this._bodyLastChangedDocumentSaved = true;
        q_savePromise = this._bodySaveSelection();  // just save selection if it's changed
    }
    return q_savePromise.then((p_result) =&gt; {
        return p_result;
    }, (p_reason) =&gt; {
        console.log('BodySave rejected :', p_reason);
        return false;
    });
}

</t>
<t tx="felix.20200719025231.33">/**
 * * Sets new body text on leo's side, and may optionally save vsCode's body editor (which will trim spaces)
 * @param p_document Vscode's text document which content will be used to be the new node's body text in Leo
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the complete saving process is finished
 */
private _bodySaveDocument(
    p_document: vscode.TextDocument,
    p_forcedVsCodeSave?: boolean
): Promise&lt;boolean&gt; {
    if (p_document) {
        // * Fetch gnx and document's body text first, to be reused more than once in this method
        const w_param = {
            gnx: utils.leoUriToStr(p_document.uri),
            body: p_document.getText(),
        };
        this.sendAction(Constants.LEOBRIDGE.SET_BODY, JSON.stringify(w_param)); // Don't wait for promise
        // This bodySaveSelection is placed on the stack right after saving body, returns promise either way
        return this._bodySaveSelection().then(() =&gt; {
            this._refreshType.states = true;
            this.getStates();
            if (p_forcedVsCodeSave) {
                return p_document.save(); // ! USED INTENTIONALLY: This trims trailing spaces
            }
            return Promise.resolve(p_document.isDirty);
        });
    } else {
        return Promise.resolve(false);
    }
}

</t>
<t tx="felix.20200719025231.34">/**
 * * Places selection on the required node with a 'timeout'. Used after refreshing the opened Leo documents view.
 * @param p_documentNode Document node instance in the Leo document view to be the 'selected' one.
 */
public setDocumentSelection(p_documentNode: LeoDocumentNode): void {
    this._currentDocumentChanged = p_documentNode.documentEntry.changed;
    this.leoStates.leoOpenedFileName = p_documentNode.documentEntry.name;
    @others
    setTimeout(() =&gt; {
        if (!this._leoDocuments.visible &amp;&amp; !this._leoDocumentsExplorer.visible) {
            return;
        }
        let w_trigger = false;
        let w_docView: vscode.TreeView&lt;LeoDocumentNode&gt;;
        if (this._leoDocuments.visible) {
            w_docView = this._leoDocuments;
        } else {
            w_docView = this._leoDocumentsExplorer;
        }
        if (w_docView.selection.length &amp;&amp; w_docView.selection[0] === p_documentNode) {
            // console.log('already selected!');
        } else {
            w_trigger = true;
        }
        if (w_trigger) {
            w_docView.reveal(p_documentNode, { select: true, focus: false })
                .then(
                    (p_result) =&gt; {
                        // Shown document node
                    },
                    (p_reason) =&gt; {
                        if (this.trace || this.verbose) {
                            console.log('shown doc error on reveal: ');
                        }
                    }
                );
        }
    });
}

</t>
<t tx="felix.20200719025231.35">/**
 * * Show the outline, with Leo's selected node also selected, and optionally focussed
 * @param p_focusOutline Flag for focus to be placed in outline
 */
public showOutline(p_focusOutline?: boolean): void {
    if (this.lastSelectedNode) {
        try {
            this._lastTreeView.reveal(this.lastSelectedNode, {
                select: true,
                focus: p_focusOutline,
            }).then(
                () =&gt; {
                    // ok
                },
                (p_reason) =&gt; {
                    // showOutline failed: try refresh only once.
                    this._refreshOutline(true, RevealType.RevealSelect);
                }
            );

        } catch (p_error) {
            console.error("showOutline error: ", p_error);
            // showOutline failed: try refresh only once.
            this._refreshOutline(true, RevealType.RevealSelect);
        }

    }
}

</t>
<t tx="felix.20200719025231.38">/**
 * * Converts an archived position object to a LeoNode instance
 * @param p_ap The archived position to convert
 * @param p_revealSelected Flag that will trigger the node to reveal, select, and focus if its selected node in Leo
 * @param p_specificNode Other specific LeoNode to be used to override when revealing the the selected node is encountered
 * @returns The converted Leo Node (For tree provider usage)
 */
public apToLeoNode(
    p_ap: ArchivedPosition,
    p_revealSelected?: boolean,
    p_specificNode?: LeoNode
): LeoNode {
    let w_collapse: vscode.TreeItemCollapsibleState = vscode.TreeItemCollapsibleState.None;
    if (p_ap.hasChildren) {
        w_collapse = p_ap.expanded
            ? vscode.TreeItemCollapsibleState.Expanded
            : vscode.TreeItemCollapsibleState.Collapsed;
    }
    // * Unknown attributes are one-way read-only data, don't carry this in for string key for leo/python side of things
    let w_u = false;
    if (p_ap.u) {
        w_u = p_ap.u;
        delete p_ap.u;
    }
    const w_leoNode = new LeoNode(
        p_ap.headline, // label-headline
        p_ap.gnx, // gnx
        w_collapse, // collapsibleState
        JSON.stringify(p_ap), // string key for leo/python side of things
        p_ap.childIndex, // childIndex
        !!p_ap.cloned, // cloned
        !!p_ap.dirty, // dirty
        !!p_ap.marked, // marked
        !!p_ap.atFile, // atFile
        !!p_ap.hasBody, // hasBody
        !!p_ap.selected, // only used in LeoNode for setting isRoot
        w_u, // unknownAttributes
        this, // _leoIntegration pointer
        utils.hashNode(p_ap, this._treeId.toString(36))
    );
    if (p_revealSelected &amp;&amp; this._revealType &amp;&amp; p_ap.selected) {
        this._apToLeoNodeConvertReveal(p_specificNode ? p_specificNode : w_leoNode);
    }
    return w_leoNode;
}

</t>
<t tx="felix.20200719025231.39">/**
 * * Reveals the node that was detected as being the selected one while converting from archived positions
 * Also select it, or focus on it too depending on global this._revealType variable
 * @param p_leoNode The node that was detected as the selected node in Leo
 */
private _apToLeoNodeConvertReveal(p_leoNode: LeoNode): void {
    this.leoStates.setSelectedNodeFlags(p_leoNode);
    // First setup flags for selecting and focusing based on the current reveal type needed
    const w_selectFlag = this._revealType &gt;= RevealType.RevealSelect; // at least RevealSelect
    let w_focusFlag = this._revealType &gt;= RevealType.RevealSelectFocus; // at least RevealSelectFocus
    // Flags are setup so now reveal, select and / or focus as needed
    this._revealType = RevealType.NoReveal; // ok reset
    // If first time, or when treeview switched, lastSelectedNode will be undefined
    if (!this.lastSelectedNode || this._needLastSelectedRefresh) {
        this._needLastSelectedRefresh = false;
        this.lastSelectedNode = p_leoNode; // special case only: lastSelectedNode should be set in selectTreeNode
    }
    setTimeout(() =&gt; {
        this._revealTreeViewNode(p_leoNode, { select: w_selectFlag, focus: w_focusFlag })
            .then(() =&gt; {
                // console.log('did this ask for parent?', p_leoNode.id, p_leoNode.label); // ! debug
                if (w_selectFlag) {
                    this._gotSelection(p_leoNode);
                }
            }
            );
    });
}

</t>
<t tx="felix.20200719025231.4"></t>
<t tx="felix.20200719025231.40">/**
 * * Converts an array of 'ap' to an array of leoNodes.  This is used in 'getChildren' of leoOutline.ts
 * @param p_array Array of archived positions to be converted to leoNodes for the vscode treeview
 * @returns An array of converted Leo Nodes (For tree provider usage)
 */
public arrayToLeoNodesArray(p_array: ArchivedPosition[]): LeoNode[] {
    const w_leoNodesArray: LeoNode[] = [];
    for (let w_apData of p_array) {
        const w_leoNode = this.apToLeoNode(w_apData, true);
        w_leoNodesArray.push(w_leoNode);
    }
    return w_leoNodesArray;
}

</t>
<t tx="felix.20200719025231.47">/**
 * * Close body pane document and change the bodyUri
 * This blocks 'undos' from crossing over
 * @param p_newGnx New gnx body id to switch to
 */
private _switchBody(
    p_newGnx: string,
    p_aside: boolean,
    p_preserveFocus?: boolean
): Thenable&lt;vscode.TextEditor&gt; {
    const w_oldUri: vscode.Uri = this.bodyUri;

    // ? Set timestamps ?
    // this._leoFileSystem.setRenameTime(p_newGnx);

    let w_visibleCount = 0;
    vscode.window.visibleTextEditors.forEach((p_editor) =&gt; {
        if (p_editor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
            w_visibleCount++;
        }
    });

    if (this._bodyPreviewMode &amp;&amp; this._bodyEnablePreview &amp;&amp; w_visibleCount &lt; 2) {
        // just show in same column and delete after
        this.bodyUri = utils.strToLeoUri(p_newGnx);
        const q_showBody = this.showBody(p_aside, p_preserveFocus);
        vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_oldUri.path);
        return q_showBody;
    } else {
        // Gotta delete to close all and re-open, so:
        // Promise to Delete first, synchronously (as thenable),
        // tagged along with automatically removeFromRecentlyOpened in parallel
        const w_edit = new vscode.WorkspaceEdit();
        w_edit.deleteFile(w_oldUri, { ignoreIfNotExists: true });
        return vscode.workspace.applyEdit(w_edit).then(() =&gt; {
            // Set new uri and remove from 'Recently opened'
            this._bodyPreviewMode = true;
            this.bodyUri = utils.strToLeoUri(p_newGnx);
            // async, so don't wait for this to finish
            if (w_oldUri.fsPath !== this.bodyUri.fsPath) {
                vscode.commands.executeCommand(
                    'vscode.removeFromRecentlyOpened',
                    w_oldUri.path
                );
            }
            return this.showBody(p_aside, p_preserveFocus);
        });
    }
}

</t>
<t tx="felix.20200719025231.48">/**
 * * Sets globals if the current body is found opened in an editor panel for a particular gnx
 * @param p_gnx gnx to match
 * @returns true if located and found, false otherwise
 */
private _locateOpenedBody(p_gnx: string): boolean {
    let w_found = false;
    // * Only gets to visible editors, not every tab per editor
    vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
        if (utils.leoUriToStr(p_textEditor.document.uri) === p_gnx) {
            w_found = true;
            this._bodyTextDocument = p_textEditor.document;
            this._bodyMainSelectionColumn = p_textEditor.viewColumn;
        }
    });
    return w_found;
}

</t>
<t tx="felix.20200719025231.49">/**
 * * Closes any body pane opened in this vscode window instance
 * @returns a promise that resolves when the file is closed and removed from recently opened list
 */
public closeBody(): Thenable&lt;any&gt; {
    // TODO : CLEAR UNDO HISTORY AND FILE HISTORY for this.bodyUri !
    let q_closed;
    if (this.bodyUri) {
        q_closed = vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', this.bodyUri.path);
    } else {
        q_closed = Promise.resolve(true);
    }
    vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
        if (p_textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
            vscode.commands.executeCommand(
                'vscode.removeFromRecentlyOpened',
                p_textEditor.document.uri.path
            );
            if (p_textEditor.hide) {
                p_textEditor.hide();
            }
        }
    });
    return q_closed;
}

</t>
<t tx="felix.20200719025231.5">/**
 * * Core of the integration of Leo into vscode: Sends an action to leobridgeserver.py, to run in Leo.
 * @param p_action is the action string constant, from Constants.LEOBRIDGE
 * @param p_jsonParam (optional) JSON string to be given to the python script action call
 * @param p_deferredPayload (optional) a pre-made package that will be given back as the response, instead of package coming back from python
 * @param p_preventCall (optional) Flag for special case, only used at startup
 * @returns a Promise that will contain the JSON package answered back by leobridgeserver.py
 */
public sendAction(
    p_action: string,
    p_jsonParam = 'null',
    p_deferredPayload?: LeoBridgePackage,
    p_preventCall?: boolean
): Promise&lt;LeoBridgePackage&gt; {
    return this._leoBridge.action(p_action, p_jsonParam, p_deferredPayload, p_preventCall);
}

</t>
<t tx="felix.20200719025231.50">/**
 * * Opens an an editor for the currently selected node: "this.bodyUri". If already opened, this just 'reveals' it
 * @param p_aside Flag for opening the editor beside any currently opened and focused editor
 * @param p_preserveFocus flag that when true will stop the editor from taking focus once opened
 * @returns a promise for the editor that will show the body pane
 */
public showBody(p_aside: boolean, p_preserveFocus?: boolean): Promise&lt;vscode.TextEditor&gt; {
    // First setup timeout asking for gnx file refresh in case we were resolving a refresh of type 'RefreshTreeAndBody'
    if (this._refreshType.body) {
        this._refreshType.body = false;
        // TODO : CHECK IF TIMEOUT NECESSARY!
        setTimeout(() =&gt; {
            this._leoFileSystem.fireRefreshFile(utils.leoUriToStr(this.bodyUri));
        }, 0);
    }

    if (this._preventShowBody) {
        this._needRefresh = false;
        this._preventShowBody = false;
        return Promise.resolve(vscode.window.activeTextEditor!);
    }

    return Promise.resolve(vscode.workspace.openTextDocument(this.bodyUri)).then(
        (p_document) =&gt; {
            this._bodyTextDocument = p_document;

            // * Set document language along with the proper cursor position, selection range and scrolling position
            let q_bodyStates: Promise&lt;LeoBridgePackage&gt; | undefined;

            if (!this._needLastSelectedRefresh) {

                q_bodyStates = this.sendAction(
                    Constants.LEOBRIDGE.GET_BODY_STATES,
                    utils.buildNodeCommandJson(this.lastSelectedNode!.apJson)
                );

                q_bodyStates.then((p_bodyStates: LeoBridgePackage) =&gt; {
                    let w_language: string = p_bodyStates.language!;
                    let w_wrap: boolean = !!p_bodyStates.wrap;
                    let w_tabWidth: number | boolean = p_bodyStates.tabWidth || !!p_bodyStates.tabWidth;

                    // TODO : Apply tabwidth
                    // console.log('TABWIDTH: ', w_tabWidth);

                    // TODO : Apply Wrap
                    // console.log('WRAP: ', w_wrap);

                    // Replace language string if in 'exceptions' array
                    w_language = 'leobody.' + (Constants.LANGUAGE_CODES[w_language] || w_language);
                    // Apply language if the selected node is still the same after all those events
                    if (
                        !p_document.isClosed &amp;&amp;
                        this.lastSelectedNode &amp;&amp;
                        utils.leoUriToStr(p_document.uri) === this.lastSelectedNode.gnx
                    ) {
                        this._needRefresh = false;
                        this._setBodyLanguage(p_document, w_language);
                    } else if (!p_document.isClosed &amp;&amp;
                        this.lastSelectedNode &amp;&amp;
                        utils.leoUriToStr(p_document.uri) !== this.lastSelectedNode.gnx) {

                        // * check ONCE and retry.
                        // IF FLAG ALREADY SET ERROR MESSAGE &amp; RETURN
                        if (this._needRefresh) {
                            vscode.window.showInformationMessage("Leo Refresh Failed");
                            this._needRefresh = false; // reset flag
                        } else {
                            // SET FLAG AND LAUNCH FULL REFRESH
                            this._needRefresh = true;
                            this.sendAction(Constants.LEOBRIDGE.DO_NOTHING).then((p_package) =&gt; {
                                // refresh and reveal selection
                                this.launchRefresh(
                                    { tree: true, body: true, states: true, buttons: true, documents: true },
                                    false,
                                    p_package.node
                                );
                            });
                        }

                    }
                });
            }

            // Find body pane's position if already opened with same gnx (language still needs to be set per position)
            vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
                if (p_textEditor.document.uri.fsPath === p_document.uri.fsPath) {
                    this._bodyMainSelectionColumn = p_textEditor.viewColumn;
                    this._bodyTextDocument = p_textEditor.document;
                }
            });
            // Setup options for the preview state of the opened editor, and to choose which column it should appear
            const w_showOptions: vscode.TextDocumentShowOptions = p_aside
                ? {
                    viewColumn: vscode.ViewColumn.Beside,
                    preserveFocus: p_preserveFocus, // an optional flag that when true will stop the editor from taking focus
                    preview: true, // should text document be in preview only? set false for fully opened
                    // selection is instead set when the GET_BODY_STATES above resolves
                }
                : {
                    viewColumn: this._bodyMainSelectionColumn
                        ? this._bodyMainSelectionColumn
                        : 1, // view column in which the editor should be shown
                    preserveFocus: p_preserveFocus, // an optional flag that when true will stop the editor from taking focus
                    preview: true, // should text document be in preview only? set false for fully opened
                    // selection is instead set when the GET_BODY_STATES above resolves
                };

            // NOTE: textEditor.show() is deprecated — Use window.showTextDocument instead.
            const q_showTextDocument = vscode.window.showTextDocument(
                this._bodyTextDocument,
                w_showOptions
            ).then(
                (p_result) =&gt; { return p_result; },
                (p_reason) =&gt; {
                    if (this.trace || this.verbose) {
                        console.log('showTextDocument rejected');
                    }
                }
            );

            // else q_bodyStates will exist.
            if (q_bodyStates &amp;&amp; !this._needLastSelectedRefresh) {
                Promise.all([q_bodyStates, q_showTextDocument]).then(
                    (p_values: [LeoBridgePackage, vscode.TextEditor]) =&gt; {
                        const w_resultBodyStates = p_values[0];
                        const w_bodyTextEditor = p_values[1];
                        if (!w_resultBodyStates.selection) {
                            console.log("no selection in returned package from get_body_states");
                        }
                        const w_leoBodySel: BodySelectionInfo = w_resultBodyStates.selection!;

                        // Cursor position and selection range
                        const w_activeRow: number = w_leoBodySel.insert.line;
                        const w_activeCol: number = w_leoBodySel.insert.col;
                        let w_anchorLine: number = w_leoBodySel.start.line;
                        let w_anchorCharacter: number = w_leoBodySel.start.col;

                        if (w_activeRow === w_anchorLine &amp;&amp; w_activeCol === w_anchorCharacter) {
                            // Active insertion same as start selection, so use the other ones
                            w_anchorLine = w_leoBodySel.end.line;
                            w_anchorCharacter = w_leoBodySel.end.col;
                        }

                        const w_selection = new vscode.Selection(
                            w_anchorLine,
                            w_anchorCharacter,
                            w_activeRow,
                            w_activeCol
                        );

                        let w_scrollRange: vscode.Range | undefined;

                        // ! Test scroll position from selection range instead
                        // const w_scroll: number = w_leoBodySel.scroll;
                        // if (w_scroll) {
                        // w_scrollRange = new vscode.Range(w_scroll, 0, w_scroll, 0);
                        // }

                        // Build scroll position from selection range.
                        w_scrollRange = new vscode.Range(
                            w_activeRow,
                            w_activeCol,
                            w_activeRow,
                            w_activeCol
                        );

                        if (w_bodyTextEditor) {
                            w_bodyTextEditor.selection = w_selection; // set cursor insertion point &amp; selection range
                            if (!w_scrollRange) {
                                w_scrollRange = w_bodyTextEditor.document.lineAt(0).range;
                            }

                            if (this._refreshType.scroll) {
                                this._refreshType.scroll = false;
                                w_bodyTextEditor.revealRange(w_scrollRange); // set scroll approximation
                            }

                        } else {
                            if (this.trace || this.verbose) {
                                console.log("no selection in returned package from showTextDocument");
                            }
                        }

                    }
                );
            }
            return q_showTextDocument;
        }
    );
}

</t>
<t tx="felix.20200719025231.51"></t>
<t tx="felix.20200719025231.52">/**
 * * Select a tree node. Either called from user interaction, or used internally (p_internalCall flag)
 * @param p_node Node that was just selected
 * @param p_internalCall Flag used to indicate the selection is forced, and NOT originating from user interaction
 * @param p_aside Flag to force opening the body "Aside", i.e. when the selection was made from choosing "Open Aside"
 * @returns a promise with the package gotten back from Leo when asked to select the tree node
 */
public selectTreeNode(
    p_node: LeoNode,
    p_internalCall?: boolean,
    p_aside?: boolean
): Promise&lt;LeoBridgePackage | vscode.TextEditor&gt; {
    this.triggerBodySave(true);

    // * check if used via context menu's "open-aside" on an unselected node: check if p_node is currently selected, if not select it
    if (p_aside &amp;&amp; p_node !== this.lastSelectedNode) {
        this._revealTreeViewNode(p_node, { select: true, focus: false }); // no need to set focus: tree selection is set to right-click position
    }

    this.leoStates.setSelectedNodeFlags(p_node);
    this._leoStatusBar.update(true); // Just selected a node directly, or via expand/collapse
    const w_showBodyKeepFocus = p_aside
        ? this.config.treeKeepFocusWhenAside
        : this.config.treeKeepFocus;

    // * Check if having already this exact node position selected : Just show the body and exit
    // (other tree nodes with same gnx may have different syntax language coloring because of parents lineage)
    if (p_node === this.lastSelectedNode) {
        this._locateOpenedBody(p_node.gnx); // LOCATE NEW GNX
        return this.showBody(!!p_aside, w_showBodyKeepFocus); // Voluntary exit
    }

    // * Set selected node in Leo via leoBridge
    const q_setSelectedNode = this.sendAction(
        Constants.LEOBRIDGE.SET_SELECTED_NODE,
        utils.buildNodeCommandJson(p_node.apJson)
    ).then((p_setSelectedResult) =&gt; {
        if (!p_internalCall) {
            this._refreshType.states = true;
            this.getStates();
        }
        return p_setSelectedResult;
    });

    // * Apply the node to the body text without waiting for the selection promise to resolve
    this._tryApplyNodeToBody(p_node, !!p_aside, w_showBodyKeepFocus, true);
    return q_setSelectedNode;
}

</t>
<t tx="felix.20200719025231.54">/**
 * * Changes the marked state of a specified, or currently selected node
 * @param p_isMark Set 'True' to mark, otherwise unmarks the node
 * @param p_node Specifies which node use, or leave undefined to mark or unmark the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @returns Promise of LeoBridgePackage from execution on leoBridgeServer
 */
public changeMark(
    p_isMark: boolean,
    p_node?: LeoNode,
    p_fromOutline?: boolean
): Promise&lt;LeoBridgePackage&gt; {
    // No need to wait for body-save trigger for marking/un-marking a node
    const q_commandResult = this.nodeCommand({
        action: p_isMark ? Constants.LEOBRIDGE.MARK_PNODE : Constants.LEOBRIDGE.UNMARK_PNODE,
        node: p_node,
        refreshType: { tree: true, states: true },
        fromOutline: !!p_fromOutline,
    });
    if (q_commandResult) {
        if (!p_node || p_node === this.lastSelectedNode) {
            utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_isMark);
        }
        return q_commandResult;
    } else {
        return Promise.reject('Change mark on node not added on command stack');
    }
}

</t>
<t tx="felix.20200719025231.55">/**
 * * Asks for a new headline label, and replaces the current label with this new one one the specified, or currently selected node
 * @param p_node Specifies which node to rename, or leave undefined to rename the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @returns Promise of LeoBridgePackage from execution on leoBridgeServer
 */
public editHeadline(
    p_node?: LeoNode,
    p_fromOutline?: boolean
): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(false, true)
        .then(() =&gt; {
            if (!p_node &amp;&amp; this.lastSelectedNode) {
                p_node = this.lastSelectedNode; // Gets last selected node if called via keyboard shortcut or command palette (not set in command stack class)
            }
            if (p_node) {
                this._headlineInputOptions.prompt =
                    Constants.USER_MESSAGES.PROMPT_EDIT_HEADLINE;
                this._renamingHeadline = p_node.label;
                this._headlineInputOptions.value = p_node.label; // preset input pop up
                return vscode.window.showInputBox(this._headlineInputOptions);
            } else {
                return Promise.reject('No node selected');
            }
        })
        .then((p_newHeadline) =&gt; {
            if ((typeof p_newHeadline !== "undefined") &amp;&amp; p_newHeadline !== this._renamingHeadline) {
                // Is different!
                p_node!.label = p_newHeadline; // ! When labels change, ids will change and its selection and expansion states cannot be kept stable anymore.
                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.SET_HEADLINE,
                    node: p_node,
                    refreshType: { tree: true, states: true },
                    fromOutline: !!p_fromOutline,
                    name: p_newHeadline,
                });
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject('Edit Headline not added on command stack');
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20200719025231.56">/**
 * * Asks for a headline label to be entered and creates (inserts) a new node under the current, or specified, node
 * @param p_node specified under which node to insert, or leave undefined to use whichever is currently selected
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_interrupt Signifies the insert action is actually interrupting itself (e.g. rapid CTRL+I actions by the user)
 * @returns Promise of LeoBridgePackage from execution on leoBridgeServer
 */
public insertNode(
    p_node?: LeoNode,
    p_fromOutline?: boolean,
    p_asChild?: boolean,
    p_interrupt?: boolean
): Promise&lt;LeoBridgePackage&gt; {
    let w_fromOutline: boolean = !!p_fromOutline; // Use w_fromOutline for where we intend to leave focus when done with the insert
    if (p_interrupt) {
        this._focusInterrupt = true;
        w_fromOutline = this._fromOutline; // Going to use last state
    }
    // if no node parameter, the front command stack CAN be busy, but if a node is passed, stack must be free
    if (!p_node || !this._isBusy()) {
        this.triggerBodySave(true); // Don't wait for saving to resolve because we're waiting for user input anyways
        this._headlineInputOptions.prompt = Constants.USER_MESSAGES.PROMPT_INSERT_NODE;
        this._headlineInputOptions.value = Constants.USER_MESSAGES.DEFAULT_HEADLINE;
        return new Promise&lt;LeoBridgePackage&gt;((p_resolve, p_reject) =&gt; {
            vscode.window.showInputBox(this._headlineInputOptions).then((p_newHeadline) =&gt; {
                // * if node has child and is expanded: turn p_asChild to true!
                if (p_node &amp;&amp; p_node.collapsibleState === vscode.TreeItemCollapsibleState.Expanded) {
                    p_asChild = true;
                }
                if (!p_node &amp;&amp; this.lastSelectedNode &amp;&amp; this.lastSelectedNode.collapsibleState === vscode.TreeItemCollapsibleState.Expanded) {
                    p_asChild = true;
                }
                let w_action = p_newHeadline
                    ? (p_asChild ? Constants.LEOBRIDGE.INSERT_CHILD_NAMED_PNODE : Constants.LEOBRIDGE.INSERT_NAMED_PNODE)
                    : (p_asChild ? Constants.LEOBRIDGE.INSERT_CHILD_PNODE : Constants.LEOBRIDGE.INSERT_PNODE);
                const q_commandResult = this.nodeCommand({
                    action: w_action,
                    node: p_node,
                    refreshType: { tree: true, states: true },
                    fromOutline: w_fromOutline,
                    name: p_newHeadline,
                });
                if (q_commandResult) {
                    q_commandResult.then((p_package) =&gt; p_resolve(p_package));
                } else {
                    p_reject(w_action + ' not added on command stack');
                }
            });
        });
    } else {
        return Promise.reject('Insert node not added on command stack');
    }
}

</t>
<t tx="felix.20200719025231.57"></t>
<t tx="felix.20200719025231.58">/**
 * * Asks for file name and path, then saves the Leo file
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns a promise from saving the file results, or that will resolve to undefined if cancelled
 */
public saveAsLeoFile(p_fromOutline?: boolean): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
                return this._leoFilesBrowser.getLeoFileUrl(true);
            } else {
                // 'when-conditions' should prevent this
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            }
        })
        .then((p_chosenLeoFile) =&gt; {
            if (p_chosenLeoFile.trim()) {
                const w_hasDot = p_chosenLeoFile.indexOf('.') !== -1;
                if (
                    !w_hasDot ||
                    (p_chosenLeoFile.split('.').pop() !== Constants.FILE_EXTENSION &amp;&amp; w_hasDot)
                ) {
                    if (!p_chosenLeoFile.endsWith('.')) {
                        p_chosenLeoFile += '.'; // Add dot if needed
                    }
                    p_chosenLeoFile += Constants.FILE_EXTENSION; // Add extension
                }
                if (this.leoStates.leoOpenedFileName) {
                    this._removeLastFile(this.leoStates.leoOpenedFileName);
                    this._removeRecentFile(this.leoStates.leoOpenedFileName);
                }
                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.SAVE_FILE,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    fromOutline: !!p_fromOutline,
                    name: p_chosenLeoFile,
                });
                this.leoStates.leoOpenedFileName = p_chosenLeoFile.trim();
                this._leoStatusBar.update(true, 0, true);
                this._addRecentAndLastFile(p_chosenLeoFile.trim());
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject('Save file not added on command stack');
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20200719025231.59">/**
 * * Invokes the self.commander.save() Leo command
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns Promise that resolves when the save command is placed on the front-end command stack
 */
public saveLeoFile(p_fromOutline?: boolean): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(true, true).then((p_saveResult) =&gt; {
        if (this.leoStates.fileOpenedReady) {
            if (this.lastSelectedNode &amp;&amp; this._isCurrentFileNamed()) {
                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.SAVE_FILE,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    fromOutline: !!p_fromOutline,
                    name: '',
                });
                return q_commandResult
                    ? q_commandResult
                    : Promise.reject('Save file not added on command stack');
            } else {
                return this.saveAsLeoFile(p_fromOutline); // Override this command call if file is unnamed!
            }
        } else {
            // 'when-conditions' should prevent this
            vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
        }
    });
}

</t>
<t tx="felix.20200719025231.6">/**
 * * leoInteg starting entry point
 * Starts a leoBridge server, and/or establish a connection to a server, based on config settings.
 */
public startNetworkServices(): void {
    // * Check settings and start a server accordingly
    if (this.config.startServerAutomatically) {
        if (this.config.limitUsers &gt; 1) {
            utils.findSingleAvailablePort(this.config.connectionPort)
                .then((p_availablePort) =&gt; {
                    this.startServer();
                }, (p_reason) =&gt; {
                    // Rejected: Multi user port IN USE so skip start
                    if (this.config.connectToServerAutomatically) {
                        // Still try to connect if auto-connect is 'on'
                        this.connect();
                    }
                });
        } else {
            this.startServer();
        }
    } else if (this.config.connectToServerAutomatically) {
        // * (via settings) Connect to Leo Bridge server automatically without starting one first
        this.connect();
    } else {
        this.leoStates.leoStartupFinished = true;
    }
}

</t>
<t tx="felix.20200719025231.60">/**
 * * Show switch document 'QuickPick' dialog and switch file if selection is made, or just return if no files are opened.
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly selected document
 */
public switchLeoFile(): Promise&lt;vscode.TextEditor | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.GET_OPENED_FILES);
        })
        .then((p_package) =&gt; {
            const w_entries: ChooseDocumentItem[] = []; // Entries to offer as choices.
            const w_files: LeoDocument[] = p_package.files!;
            let w_index: number = 0;
            if (w_files &amp;&amp; w_files.length) {
                w_files.forEach(function (p_filePath: LeoDocument) {
                    w_entries.push({
                        label: w_index.toString(),
                        description: p_filePath.name
                            ? p_filePath.name
                            : Constants.UNTITLED_FILE_NAME,
                        value: w_index,
                        alwaysShow: true,
                    });
                    w_index++;
                });
                const w_pickOptions: vscode.QuickPickOptions = {
                    matchOnDescription: true,
                    placeHolder: Constants.USER_MESSAGES.CHOOSE_OPENED_FILE,
                };
                return vscode.window.showQuickPick(w_entries, w_pickOptions);
            } else {
                // "No opened documents"
                return Promise.resolve(undefined);
            }
        })
        .then((p_chosenDocument) =&gt; {
            if (p_chosenDocument) {
                return Promise.resolve(this.selectOpenedLeoDocument(p_chosenDocument.value));
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20200719025231.61">/**
 * * Switches Leo document directly by index number. Used by document treeview and switchLeoFile command.
 * @param p_index position of the opened Leo document in the document array
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly opened document
 */
public selectOpenedLeoDocument(p_index: number): Promise&lt;vscode.TextEditor&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(
                Constants.LEOBRIDGE.SET_OPENED_FILE,
                JSON.stringify({ index: p_index })
            );
        })
        .then((p_openFileResult: LeoBridgePackage) =&gt; {
            // Like we just opened or made a new file
            if (p_openFileResult.filename || p_openFileResult.filename === "") {
                return this.setupOpenedLeoDocument(p_openFileResult);
            } else {
                console.log('Select Opened Leo File Error');
                return Promise.reject('Select Opened Leo File Error');
            }
        });
}

</t>
<t tx="felix.20200719025231.64">/**
 * * Close an opened Leo file
 * @returns the launchRefresh promise started after it's done closing the Leo document
 */
public closeLeoFile(): Promise&lt;boolean&gt; {
    let w_removeLastFileName: string = '';
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (!this.leoStates.fileOpenedReady) {
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLOSE_ERROR);
                return Promise.reject(Constants.USER_MESSAGES.CLOSE_ERROR);
            }
            w_removeLastFileName = this.leoStates.leoOpenedFileName;
            return this.sendAction(
                Constants.LEOBRIDGE.CLOSE_FILE,
                JSON.stringify({ forced: false })
            );
        })
        .then((p_tryCloseResult) =&gt; {
            // Has a total member: closed file
            if (p_tryCloseResult.total || p_tryCloseResult.total === 0) {
                this._removeLastFile(w_removeLastFileName);
                if (p_tryCloseResult.total === 0) {
                    this.setupNoOpenedLeoDocument();
                } else {
                    this.loadSearchSettings();
                    this.launchRefresh(
                        {
                            tree: true,
                            body: true,
                            documents: true,
                            buttons: true,
                            states: true,
                        },
                        false
                    );
                }
                return Promise.resolve(true);
            } else {
                // No total member: did not close file
                const q_askSaveChangesInfoMessage: Thenable&lt;vscode.MessageItem | undefined&gt; =
                    vscode.window.showInformationMessage(
                        Constants.USER_MESSAGES.SAVE_CHANGES +
                        ' ' +
                        this.leoStates.leoOpenedFileName +
                        ' ' +
                        Constants.USER_MESSAGES.BEFORE_CLOSING,
                        { modal: true },
                        ...Constants.ASK_SAVE_CHANGES_BUTTONS
                    );
                return Promise.resolve(q_askSaveChangesInfoMessage)
                    .then((p_askSaveResult: vscode.MessageItem | undefined) =&gt; {
                        if (p_askSaveResult &amp;&amp; p_askSaveResult.title === Constants.USER_MESSAGES.YES) {
                            // save and then force-close
                            let w_savePromise: Promise&lt;LeoBridgePackage | undefined&gt;;
                            if (this._isCurrentFileNamed()) {
                                w_savePromise = this.sendAction(
                                    Constants.LEOBRIDGE.SAVE_FILE,
                                    JSON.stringify({ name: '' })
                                );
                            } else {
                                w_savePromise = this._leoFilesBrowser
                                    .getLeoFileUrl(true)
                                    .then((p_chosenLeoFile) =&gt; {
                                        if (p_chosenLeoFile.trim()) {
                                            return this.sendAction(
                                                Constants.LEOBRIDGE.SAVE_FILE,
                                                JSON.stringify({
                                                    name: p_chosenLeoFile.trim(),
                                                })
                                            );
                                        } else {
                                            // Canceled
                                            return Promise.resolve(undefined);
                                        }
                                    });
                            }
                            return w_savePromise.then(
                                (p_packageAfterSave) =&gt; {
                                    return this.sendAction(
                                        Constants.LEOBRIDGE.CLOSE_FILE,
                                        JSON.stringify({ forced: true })
                                    );
                                },
                                () =&gt; {
                                    return Promise.reject('Save failed');
                                }
                            );
                        } else if (p_askSaveResult &amp;&amp; p_askSaveResult.title === Constants.USER_MESSAGES.NO) {
                            // Don't want to save so just force-close directly
                            return this.sendAction(
                                Constants.LEOBRIDGE.CLOSE_FILE,
                                JSON.stringify({ forced: true })
                            );
                        } else {
                            // Canceled dialog
                            return Promise.resolve(undefined);
                        }
                    })
                    .then((p_closeResult: LeoBridgePackage | undefined) =&gt; {
                        if (p_closeResult) {
                            // * back from CLOSE_FILE action, the last that can be performed (after saving if dirty or not)
                            this._removeLastFile(w_removeLastFileName);
                            if (p_closeResult &amp;&amp; p_closeResult.total === 0) {
                                this.setupNoOpenedLeoDocument();
                            } else {
                                this.loadSearchSettings();
                                this.launchRefresh(
                                    {
                                        tree: true,
                                        body: true,
                                        documents: true,
                                        buttons: true,
                                        states: true,
                                    },
                                    false
                                );
                            }
                            return Promise.resolve(true);
                        }
                        // Canceled
                        return Promise.resolve(false);
                    });
            }
        });
}

</t>
<t tx="felix.20200719025231.65">/**
 * * Creates a new untitled Leo document
 * * If not shown already, it also shows the outline, body and log panes along with leaving focus in the outline
 * @returns A promise that resolves with a textEditor of the new file
 */
public newLeoFile(): Promise&lt;vscode.TextEditor&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.OPEN_FILE, JSON.stringify({ filename: "" }));
        })
        .then((p_openFileResult: LeoBridgePackage) =&gt; {
            if (p_openFileResult.filename || p_openFileResult.filename === "") {
                return this.setupOpenedLeoDocument(p_openFileResult);
            } else {
                return Promise.reject('New Leo File Error');
            }
        });
}

</t>
<t tx="felix.20200719025231.66">/**
 * * Shows an 'Open Leo File' dialog window and opens the chosen file
 * * If not shown already, it also shows the outline, body and log panes along with leaving focus in the outline
 * @param p_leoFileUri optional uri for specifying a file, if missing, a dialog will open
 * @returns A promise that resolves with a textEditor of the chosen file
 */
public openLeoFile(p_leoFileUri?: vscode.Uri): Promise&lt;vscode.TextEditor | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            let q_openedFile: Promise&lt;LeoBridgePackage | undefined&gt;; // Promise for opening a file
            if (p_leoFileUri &amp;&amp; p_leoFileUri.fsPath.trim()) {
                const w_fixedFilePath: string = p_leoFileUri.fsPath.replace(/\\/g, '/');
                q_openedFile = this.sendAction(
                    Constants.LEOBRIDGE.OPEN_FILE,
                    JSON.stringify({ filename: w_fixedFilePath })
                );
            } else {
                q_openedFile = this._leoFilesBrowser.getLeoFileUrl().then(
                    (p_chosenLeoFile) =&gt; {
                        if (p_chosenLeoFile.trim()) {
                            return this.sendAction(
                                Constants.LEOBRIDGE.OPEN_FILE,
                                JSON.stringify({ filename: p_chosenLeoFile })
                            );
                        } else {
                            return Promise.resolve(undefined);
                        }
                    },
                    (p_errorGetFile) =&gt; {
                        return Promise.reject(p_errorGetFile);
                    }
                );
            }
            return q_openedFile;
        })
        .then(
            (p_openFileResult: LeoBridgePackage | undefined) =&gt; {
                if (p_openFileResult) {
                    return this.setupOpenedLeoDocument(p_openFileResult);
                } else {
                    return Promise.resolve(undefined);
                }
            },
            (p_errorOpen) =&gt; {
                console.log('in .then not opened or already opened'); // TODO : IS REJECTION BEHAVIOR NECESSARY HERE TOO?
                return Promise.reject(p_errorOpen);
            }
        );
}

</t>
<t tx="felix.20200719025231.69">/**
 * * StatusBar click handler
 * @returns Thenable from the statusBar click customizable behavior
 */
public statusBarOnClick(): Thenable&lt;unknown&gt; {

    this.showLogPane();
    return Promise.resolve(true);

    /*
    if (this.leoStates.fileOpenedReady) {
        return this.minibuffer();
        // return this.switchLeoFile();
    } else {
        return vscode.commands.executeCommand(
            Constants.VSCODE_COMMANDS.QUICK_OPEN,
            Constants.GUI.QUICK_OPEN_LEO_COMMANDS
        );
    }
    */
}

</t>
<t tx="felix.20200719025231.7">/**
 * * Starts an instance of a leoBridge server, and may connect to it afterwards, based on configuration flags.
 */
public startServer(): void {
    if (this._startingServer) {
        return;
    }
    this._startingServer = true;
    this.leoStates.leoStartupFinished = false;
    this.showLogPane();
    this._serverService
        .startServer(
            this.config.leoPythonCommand,
            this.config.leoEditorPath,
            this.config.connectionPort
        )
        .then(
            (p_message) =&gt; {
                utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, true); // server started
                if (this.config.connectToServerAutomatically) {
                    setTimeout(() =&gt; {
                        // wait a few milliseconds
                        this.connect();
                        this._startingServer = false;
                    }, 1500);
                } else {
                    this._startingServer = false;
                    this.leoStates.leoStartupFinished = true;
                }
            },
            (p_reason) =&gt; {
                // This context flag will remove the 'connecting' welcome view
                this._startingServer = false;
                utils.setContext(Constants.CONTEXT_FLAGS.AUTO_START_SERVER, false);
                utils.setContext(Constants.CONTEXT_FLAGS.AUTO_CONNECT, false);
                if (
                    [Constants.USER_MESSAGES.LEO_PATH_MISSING,
                    Constants.USER_MESSAGES.CANNOT_FIND_SERVER_SCRIPT].includes(p_reason)
                ) {
                    vscode.window.showErrorMessage(Constants.USER_MESSAGES.START_SERVER_ERROR + p_reason, "Choose Folder")
                        .then(p_chosenButton =&gt; {
                            if (p_chosenButton === 'Choose Folder') {
                                vscode.commands.executeCommand(Constants.COMMANDS.CHOOSE_LEO_FOLDER);
                            }
                        });
                } else {
                    vscode.window.showErrorMessage(
                        Constants.USER_MESSAGES.START_SERVER_ERROR + p_reason,
                    );
                }
            }
        );
}

</t>
<t tx="felix.20200719025231.70">/**
 * * Test/Dummy command
 * @param p_fromOutline Flags if the call came with focus on the outline
 * @returns Thenable from the tested functionality
 */
public test(p_fromOutline?: boolean): Thenable&lt;unknown&gt; {
    // return this.statusBarOnClick();

    // this.sendAction(
    //     "!get_undos", JSON.stringify({ something: "not used" })
    // ).then((p_result: LeoBridgePackage) =&gt; {
    //     console.log('got back undos: ', p_result);
    // });

    // vscode.commands.executeCommand(Constants.COMMANDS.MARK_SELECTION)
    //     .then((p_result) =&gt; {
    //         console.log(
    //             'BACK FROM EXEC COMMAND ' +
    //             Constants.COMMANDS.MARK_SELECTION +
    //             ', p_result: ',
    //             JSON.stringify(p_result)
    //         );

    //     });

    // * test QuickSearchController
    //

    return Promise.resolve("");

    // * test ua's
    /*
    this.sendAction(
        // Constants.LEOBRIDGE.TEST, JSON.stringify({ testParam: "Some String" })
        Constants.LEOBRIDGE.SET_UA,
        JSON.stringify({
            ua: {
                kin: 'kin val',
                yoi: "toi test value string"
            }
        })
    ).then((p_result: LeoBridgePackage) =&gt; {
        console.log('get focus results: ', p_result);
    });
    // * test ua's
    return this.sendAction(
        Constants.LEOBRIDGE.SET_UA_MEMBER,
        JSON.stringify({
            name: 'uaTestName',
            value: "some test value string"
        })
    ).then((p_result: LeoBridgePackage) =&gt; {
        console.log('get focus results: ', p_result);
        this.launchRefresh(
            {
                tree: true
            },
            false
        );
    });
    */

    // Test setting scroll / selection range

    /*
    vscode.window.showQuickPick(["get", "set"]).then(p_results =&gt; {
        console.log('quick pick result:', p_results);
        let w_selection: vscode.Selection;
        let w_action = "";
        if (p_results === "get") {
           //  w_action = Constants.LEOBRIDGE.GET_SEARCH_SETTINGS;
            // w_selection = new vscode.Selection(1, 1, 1, 6);
            this.loadSearchSettings();
        } else {
            w_action = Constants.LEOBRIDGE.SET_SEARCH_SETTINGS;
            // w_selection = new vscode.Selection(2, 2, 3, 3);
        }
        console.log('w_action', w_action);
        const searchSettings: LeoGuiFindTabManagerSettings = {
            find_text: "new find text",
            change_text: "",
            ignore_case: false, // diff
            mark_changes: false,
            mark_finds: true, // diff
            node_only: false,
            pattern_match: false,
            search_body: true,
            search_headline: true,
            suboutline_only: false,
            whole_word: false
        };

        if (w_action) {
            this.sendAction(
                w_action, JSON.stringify({ searchSettings: searchSettings })
            ).then((p_result: LeoBridgePackage) =&gt; {
                console.log('got back settings: ', p_result);
            });
        }
    });
    */

    /*
    vscode.window.visibleTextEditors.forEach(p_textEditor =&gt; {
        console.log('p_textEditor.document.uri.scheme ', p_textEditor.document.uri.scheme);

        if (p_textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
            console.log('found');

            p_textEditor.selection = w_selection; // set cursor insertion point &amp; selection range
            // if (!w_scrollRange) {
            //     w_scrollRange = p_textEditor.document.lineAt(0).range;
            // }
            // p_textEditor.revealRange(w_scrollRange); // set
        }
    });
    */

    // GET_FOCUS AS A TEST
    // return this.sendAction(
    //     // Constants.LEOBRIDGE.TEST, JSON.stringify({ testParam: "Some String" })
    //     Constants.LEOBRIDGE.GET_FOCUS,
    //     JSON.stringify({ testParam: 'Some String' })
    // ).then((p_result: LeoBridgePackage) =&gt; {
    //     console.log('get focus results: ', p_result);

    //     // this.launchRefresh({ buttons: true }, false);
    //     // return vscode.window.showInformationMessage(
    //     //     ' back from test, called from ' +
    //     //     (p_fromOutline ? "outline" : "body") +
    //     //     ', with result: ' +
    //     //     JSON.stringify(p_result)
    //     // );
    // }).then(() =&gt; {
    //     return this.sendAction(Constants.LEOBRIDGE.GET_VERSION);
    // }).then((p_result: LeoBridgePackage) =&gt; {
    //     console.log('get version results: ', p_result);
    //     if (p_result.version) {
    //         vscode.window.showInformationMessage(p_result.version);
    //     }
    // });
}
</t>
<t tx="felix.20200719025231.8">/**
 * * Initiate a connection to the leoBridge server, then show view title, log pane, and set 'bridge ready' flags.
 */
public connect(): void {
    if (this.leoStates.leoBridgeReady || this.leoStates.leoConnecting) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.ALREADY_CONNECTED);
        return;
    }
    this.leoStates.leoConnecting = true;
    this.leoStates.leoStartupFinished = false;
    this._leoBridgeReadyPromise = this._leoBridge.initLeoProcess(
        this._serverService.usingPort // This will be zero if no port found
    );
    this._leoBridgeReadyPromise.then(
        (p_package) =&gt; {
            this.leoStates.leoConnecting = false;
            // Check if hard-coded first package signature
            if (p_package.id !== Constants.STARTING_PACKAGE_ID) {
                this.cancelConnect(Constants.USER_MESSAGES.CONNECT_ERROR);
            } else {
                const w_opened: boolean = !!p_package.commander;
                const w_lastFiles: string[] =
                    this._context.workspaceState.get(Constants.LAST_FILES_KEY) || [];
                if (w_lastFiles.length &amp;&amp; !w_opened) {
                    // This context flag will trigger 'Connecting...' placeholder
                    utils.setContext(Constants.CONTEXT_FLAGS.AUTO_CONNECT, true);

                    setTimeout(() =&gt; {
                        this._openLastFiles(); // Try to open last opened files, if any
                    }, 0);
                } else {
                    this.leoStates.leoBridgeReady = true;
                    this.leoStates.leoStartupFinished = true;
                }
                if (w_opened) {
                    p_package.filename = p_package.commander!.fileName;
                    this.setupOpenedLeoDocument(p_package, true);
                }

                // this.showLogPane(); // #203 Do not 'force' show the log pane

                if (!this.config.connectToServerAutomatically) {
                    vscode.window.showInformationMessage(Constants.USER_MESSAGES.CONNECTED);
                }
            }

            // TODO : Finish Closing and possibly SAME FOR OPENING AND CONNECTING
            // TODO : #14 @boltex COULD BE SOME FILES ALREADY OPENED OR NONE!
        },
        (p_reason) =&gt; {
            this.cancelConnect(Constants.USER_MESSAGES.CONNECT_FAILED + ': ' + p_reason);
        }
    );
}

</t>
<t tx="felix.20200719025231.9">/**
 * * Cancels websocket connection and reverts context flags.
 * Called from leoBridge.ts when its websocket reports disconnection.
 * @param p_message
 */
public cancelConnect(p_message?: string): void {
    // 'disconnect error' versus 'failed to connect'
    if (this.leoStates.leoBridgeReady) {
        vscode.window.showErrorMessage(
            p_message ? p_message : Constants.USER_MESSAGES.DISCONNECTED
        );
    } else {
        vscode.window.showInformationMessage(
            p_message ? p_message : Constants.USER_MESSAGES.DISCONNECTED
        );
    }

    // to change the 'viewsWelcome' content.
    // bring back to !leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
    utils.setContext(Constants.CONTEXT_FLAGS.AUTO_START_SERVER, false);
    // utils.setContext(Constants.CONTEXT_FLAGS.AUTO_CONNECT, false);
    this.leoStates.leoStartupFinished = true;
    this.leoStates.leoConnecting = false;
    this.leoStates.fileOpenedReady = false;
    this.leoStates.leoBridgeReady = false;
    this._leoBridgeReadyPromise = undefined;
    this._leoStatusBar.update(false);
    this._refreshOutline(false, RevealType.NoReveal);
}

</t>
<t tx="felix.20200719030811.1"></t>
<t tx="felix.20200719030842.1"></t>
<t tx="felix.20200719030902.1"></t>
<t tx="felix.20200719030909.1"></t>
<t tx="felix.20200719031115.1"></t>
<t tx="felix.20200719031346.1">/**
 * * Send user's configuration through leoBridge to the server script
 * @param p_config A config object containing all the configuration settings
 * @returns promise that will resolves with the package from "applyConfig" call in Leo bridge server
 */
public sendConfigToServer(p_config: ConfigMembers): Promise&lt;LeoBridgePackage&gt; {
    if (this.leoStates.leoBridgeReady) {
        return this.sendAction(Constants.LEOBRIDGE.APPLY_CONFIG, JSON.stringify(p_config));
    } else {
        return Promise.reject('Leo Bridge Not Ready');
    }
}

</t>
<t tx="felix.20200719031802.1"></t>
<t tx="felix.20200719033306.1"></t>
<t tx="felix.20200719033511.1"></t>
<t tx="felix.20200924205439.1">def _get_commander_method(self, p_command):
    """ Return the given method (p_command) in the Commands class or subcommanders."""
    # self.g.trace(p_command)
    #
    # First, try the commands class.
    w_func = getattr(self.commander, p_command, None)
    if w_func:
        return w_func
    #
    # Search all subcommanders for the method.
    table = (  # This table comes from c.initObjectIvars.
        'abbrevCommands',
        'bufferCommands',
        'chapterCommands',
        'controlCommands',
        'convertCommands',
        'debugCommands',
        'editCommands',
        'editFileCommands',
        'evalController',
        'gotoCommands',
        'helpCommands',
        'keyHandler',
        'keyHandlerCommands',
        'killBufferCommands',
        'leoCommands',
        'leoTestManager',
        'macroCommands',
        'miniBufferWidget',
        'printingController',
        'queryReplaceCommands',
        'rectangleCommands',
        'searchCommands',
        'spellCommands',
        'vimCommands',  # Not likely to be useful.
    )
    for ivar in table:
        subcommander = getattr(self.commander, ivar, None)
        if subcommander:
            w_func = getattr(subcommander, p_command, None)
            if w_func:
                ### self.g.trace(f"Found c.{ivar}.{p_command}")
                return w_func
        # else:
            # self.g.trace(f"Not Found: c.{ivar}") # Should never happen.
    return None

</t>
<t tx="felix.20200924205503.1">def leoCommand(self, p_command, param):
    '''
    Generic call to a method in Leo's Commands class or any subcommander class.

    The param["ap"] position is to be selected before having the command run,
    while the param["keep"] parameter specifies wether the original position
    should be re-selected afterward.

    The whole of those operations is to be undoable as one undo step.

    command: a method name (a string).
    param["ap"]: an archived position.
    param["keep"]: preserve the current selection, if possible.
    '''
    w_keepSelection = False  # Set default, optional component of param
    if "keep" in param:
        w_keepSelection = param["keep"]

    w_ap = param["ap"]  # At least node parameter is present
    if not w_ap:
        return self._outputError(f"Error in {p_command}: no param ap")

    w_p = self._ap_to_p(w_ap)
    if not w_p:
        return self._outputError(f"Error in {p_command}: no w_p position found")

    w_func = self._get_commander_method(p_command)
    if not w_func:
        return self._outputError(f"Error in {p_command}: no method found")

    if w_p == self.commander.p:
        w_func(event=None)
    else:
        w_oldPosition = self.commander.p
        self.commander.selectPosition(w_p)
        w_func(event=None)
        if w_keepSelection and self.commander.positionExists(w_oldPosition):
            self.commander.selectPosition(w_oldPosition)

    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924205915.1">def open_files(self, param):
    """
    Opens an array of leo files
    Returns an object that contains the last 'opened' member.
    """
    w_files = []
    if "files" in param:
        w_files = param["files"]

    for i_file in w_files:
        self.commander = None
        w_found = False
        # If not empty string (asking for New file) then check if already opened
        if i_file:
            for w_commander in self.g.app.commanders():
                if w_commander.fileName() == i_file:
                    w_found = True
                    self.commander = w_commander

        if not w_found:
            if os.path.isfile(i_file):
                # create self.commander by opening the file
                self.commander = self.bridge.openLeoFile(i_file)
                self.commander.findCommands.ftm = StringFindTabManager(
                    self.commander)
                self.commander.frame.body.wrapper = IntegTextWrapper(
                    self.commander, "integBody", self.g)
        if self.commander:
            self.commander.closed = False
            self.commander.selectPosition(self.commander.p)

    # Done with the last one, it's now the selected commander. Check again just in case.
    if self.commander:
        self._create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self._p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage(w_result)
    else:
        return self._outputError('Error in openFiles')

</t>
<t tx="felix.20200924210020.1">def get_buttons(self, param):
    '''Gets the currently opened file's @buttons list'''
    w_buttons = []
    if self.commander and self.commander.theScriptingController and self.commander.theScriptingController.buttonsDict:
        w_dict = self.commander.theScriptingController.buttonsDict
        for w_key in w_dict:
            w_entry = {"name": w_dict[w_key], "index": str(w_key)}
            w_buttons.append(w_entry)
    return self.sendLeoBridgePackage({"buttons": w_buttons})

</t>
<t tx="felix.20200924210024.1">def remove_button(self, param):
    '''Removes an entry from the buttonsDict by index string'''
    w_index = param['index']
    w_dict = self.commander.theScriptingController.buttonsDict
    w_key = None
    for i_key in w_dict:
        if(str(i_key) == w_index):
            w_key = i_key
    if w_key:
        del(w_dict[w_key])  # delete object member
    # return selected node when done
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924210029.1">def click_button(self, param):
    '''Handles buttons clicked in client from the '@button' panel'''
    w_index = param['index']
    w_dict = self.commander.theScriptingController.buttonsDict
    w_button = None
    for i_key in w_dict:
        if(str(i_key) == w_index):
            w_button = i_key
    if w_button:
        w_button.command()  # run clicked button command
    # return selected node when done
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924210036.1">def get_all_leo_commands(self, param):
    """Return a list of all Leo commands that make sense in leoInteg."""
    c = self.commander
    d = c.commandsDict  # keys are command names, values are functions.
    bad_names = self._bad_commands()  # #92.
    good_names = self._good_commands()
    duplicates = set(bad_names).intersection(set(good_names))
    if duplicates:
        print('duplicate command names...', flush=True)
        for z in sorted(duplicates):
            print(z)
    result = []
    for command_name in sorted(d):
        func = d.get(command_name)
        if not func:
            print('no func:', command_name, flush=True)
            continue
        if command_name in bad_names:  # #92.
            continue
        # Prefer func.__func_name__ to func.__name__: Leo's decorators change func.__name__!
        func_name = getattr(func, '__func_name__', func.__name__)
        if not func_name:
            print('no name', command_name, flush=True)
            continue
        doc = func.__doc__ or ''
        result.append({
            "label": command_name,
            "func":  func_name,
            "detail": doc,
        })
        # This shows up in the bridge log.
        # print(f"__doc__: {len(doc):4} {command_name:40} {func_name} ", flush=True)
        # print(f"{func_name} ", flush=True)

    return self.sendLeoBridgePackage({"commands": result})

</t>
<t tx="felix.20200924210058.1">def _bad_commands(self):
    """Return the list of Leo's command names that leoInteg should ignore."""
    c = self.commander
    bad = []
    d = c.commandsDict  # keys are command names, values are functions.
    #
    # First, remove @button, @command and vim commands.
    for command_name in sorted(d):
        if command_name.startswith((':', '@')):
            # print('ignore', command_name)
            bad.append(command_name)
    # Second, remove other commands.
    # This is a hand-curated list.
    bad_list = [

        # Abbreviations...
        'abbrev-kill-all',
        'abbrev-list',
        'dabbrev-completion',
        'dabbrev-expands',

        # Autocompletion...
        'auto-complete',
        'auto-complete-force',
        'disable-autocompleter',
        'disable-calltips',
        'enable-autocompleter',
        'enable-calltips',

        # Debugger...
        'debug',
        'db-again',
        'db-b',
        'db-c',
        'db-h',
        'db-input',
        'db-l',
        'db-n',
        'db-q',
        'db-r',
        'db-s',
        'db-status',
        'db-w',

        # File operations...
        'directory-make',
        'directory-remove',
        'file-delete',
        'file-diff-files',
        'file-insert',
        'file-new',
        'file-open-by-name',

        # All others...
        'shell-command',
        'shell-command-on-region',
        'cheat-sheet',
        'dehoist',  # Duplicates of de-hoist.
        'find-clone-all',
        'find-clone-all-flattened',
        'find-clone-tag',
        'find-all',
        'find-all-unique-regex',
        'find-character',
        'find-character-extend-selection',
        'find-next',
        'find-prev',
        'find-word',
        'find-word-in-line',

        'global-search',

        'isearch-backward',
        'isearch-backward-regexp',
        'isearch-forward',
        'isearch-forward-regexp',
        'isearch-with-present-options',

        'replace',
        'replace-all',
        'replace-current-character',
        'replace-then-find',

        're-search-backward',
        're-search-forward',

        'search-backward',
        'search-forward',
        'search-return-to-origin',

        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
        'set-replace-string',
        'set-search-string',

        'show-find-options',

        'start-search',

        'toggle-find-collapses-nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',

        'word-search-backward',
        'word-search-forward',

        # Buttons...
        'delete-script-button-button',

        # Clicks...
        'click-click-box',
        'click-icon-box',
        'ctrl-click-at-cursor',
        'ctrl-click-icon',
        'double-click-icon-box',
        'right-click-icon',

        # Editors...
        'add-editor', 'editor-add',
        'delete-editor', 'editor-delete',
        'detach-editor-toggle',
        'detach-editor-toggle-max',

        # Focus...
        'cycle-editor-focus', 'editor-cycle-focus',
        'focus-to-body',
        'focus-to-find',
        'focus-to-log',
        'focus-to-minibuffer',
        'focus-to-nav',
        'focus-to-spell-tab',
        'focus-to-tree',

        'tab-cycle-next',
        'tab-cycle-previous',
        'tab-detach',

        # Headlines..
        'abort-edit-headline',
        'edit-headline',
        'end-edit-headline',

        # Layout and panes...
        'adoc',
        'adoc-with-preview',

        'contract-body-pane',
        'contract-log-pane',
        'contract-outline-pane',

        'edit-pane-csv',
        'edit-pane-test-open',
        'equal-sized-panes',
        'expand-log-pane',
        'expand-body-pane',
        'expand-outline-pane',

        'free-layout-context-menu',
        'free-layout-load',
        'free-layout-restore',
        'free-layout-zoom',

        'zoom-in',
        'zoom-out'

        # Log
        'clear-log',

        # Menus...
        'activate-cmds-menu',
        'activate-edit-menu',
        'activate-file-menu',
        'activate-help-menu',
        'activate-outline-menu',
        'activate-plugins-menu',
        'activate-window-menu',
        'context-menu-open',
        'menu-shortcut',

        # Modes...
        'clear-extend-mode',

        # Outline...
        'contract-or-go-left',
        'contract-node',
        'contract-parent',

        # Scrolling...
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-outline-down-line',
        'scroll-outline-down-page',
        'scroll-outline-left',
        'scroll-outline-right',
        'scroll-outline-up-line',
        'scroll-outline-up-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',

        # Windows...
        'about-leo',

        'cascade-windows',
        'close-others',
        'close-window',

        'iconify-frame',

        'find-tab-hide',
        'find-tab-open',

        'hide-body-dock',
        'hide-body-pane',
        'hide-invisibles',
        'hide-log-pane',
        'hide-outline-dock',
        'hide-outline-pane',
        'hide-tabs-dock',

        'minimize-all',

        'resize-to-screen',

        'show-body-dock',
        'show-hide-body-dock',
        'show-hide-outline-dock',
        'show-hide-render-dock',
        'show-hide-tabs-dock',
        'show-tabs-dock',
        'clean-diff',
        'cm-external-editor',

        'delete-@button-parse-json-button',
        'delete-trace-statements',

        'disable-idle-time-events',
        'do-nothing',

        'enable-idle-time-events',
        'enter-quick-command-mode',
        'exit-named-mode',

        'F6-open-console',

        'flush-lines',
        'full-command',

        'get-child-headlines',

        'history',

        'insert-file-name',

        'justify-toggle-auto',

        'keep-lines',
        'keyboard-quit',

        'line-number',
        'line-numbering-toggle',
        'line-to-headline',

        'marked-list',

        'mode-help',

        'open-python-window',

        'open-with-idle',
        'open-with-open-office',
        'open-with-scite',
        'open-with-word',

        'recolor',
        'redraw',

        'repeat-complex-command',

        'session-clear',
        'session-create',
        'session-refresh',
        'session-restore',
        'session-snapshot-load',
        'session-snapshot-save',

        'set-colors',
        'set-command-state',
        'set-comment-column',
        'set-extend-mode',
        'set-fill-column',
        'set-fill-prefix',
        'set-font',
        'set-insert-state',
        'set-overwrite-state',
        'set-silent-mode',

        'show-buttons',
        'show-calltips',
        'show-calltips-force',
        'show-color-names',
        'show-color-wheel',
        'show-commands',
        'show-file-line',

        'show-focus',
        'show-fonts',

        'show-invisibles',
        'show-next-tip',
        'show-node-uas',
        'show-outline-dock',
        'show-plugin-handlers',
        'show-plugins-info',
        'show-settings',
        'show-settings-outline',
        'show-spell-info',
        'show-stats',

        'style-set-selected',

        'suspend',

        'toggle-abbrev-mode',
        'toggle-active-pane',
        'toggle-angle-brackets',
        'toggle-at-auto-at-edit',
        'toggle-autocompleter',
        'toggle-calltips',
        'toggle-case-region',
        'toggle-extend-mode',
        'toggle-idle-time-events',
        'toggle-input-state',
        'toggle-invisibles',
        'toggle-line-numbering-root',
        'toggle-sparse-move',
        'toggle-split-direction',

        'what-line',
        'eval',
        'eval-block',
        'eval-last',
        'eval-last-pretty',
        'eval-replace',

        'find-quick',
        'find-quick-changed',
        'find-quick-selected',
        'find-quick-test-failures',
        'find-quick-timeline',

        'goto-next-history-node',
        'goto-prev-history-node',

        'preview',
        'preview-body',
        'preview-expanded-body',
        'preview-expanded-html',
        'preview-html',
        'preview-marked-bodies',
        'preview-marked-html',
        'preview-marked-nodes',
        'preview-node',
        'preview-tree-bodies',
        'preview-tree-html',
        'preview-tree-nodes',

        'spell-add',
        'spell-as-you-type-next',
        'spell-as-you-type-toggle',
        'spell-as-you-type-undo',
        'spell-as-you-type-wrap',
        'spell-change',
        'spell-change-then-find',
        'spell-find',
        'spell-ignore',
        'spell-tab-hide',
        'spell-tab-open',

        'tag-children',

        'todo-children-todo',
        'todo-dec-pri',
        'todo-find-todo',
        'todo-fix-datetime',
        'todo-inc-pri',

        'vr',
        'vr-contract',
        'vr-expand',
        'vr-hide',
        'vr-lock',
        'vr-pause-play-movie',
        'vr-show',
        'vr-toggle',
        'vr-unlock',
        'vr-update',
        'vr-zoom',

        'vs-create-tree',
        'vs-dump',
        'vs-reset',
        'vs-update',
        # vs code's text editing commands should cover all of these...
        'add-comments',
        'add-space-to-lines',
        'add-tab-to-lines',
        'align-eq-signs',

        'back-char',
        'back-char-extend-selection',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'back-to-home',
        'back-to-home-extend-selection',
        'back-to-indentation',
        'back-word',
        'back-word-extend-selection',
        'back-word-smart',
        'back-word-smart-extend-selection',
        'backward-delete-char',
        'backward-delete-word',
        'backward-delete-word-smart',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'backward-kill-paragraph',
        'backward-kill-sentence',
        'backward-kill-word',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',

        'capitalize-word',
        'center-line',
        'center-region',
        'clean-all-blank-lines',
        'clean-all-lines',
        'clean-body',
        'clean-lines',
        'clear-kill-ring',
        'clear-selected-text',
        'convert-blanks',
        'convert-tabs',
        'copy-text',
        'cut-text',

        'delete-char',
        'delete-comments',
        'delete-indentation',
        'delete-spaces',
        'delete-word',
        'delete-word-smart',
        'downcase-region',
        'downcase-word',

        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'end-of-line',
        'end-of-line-extend-selection',

        'exchange-point-mark',

        'extend-to-line',
        'extend-to-paragraph',
        'extend-to-sentence',
        'extend-to-word',

        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',

        'finish-of-line',
        'finish-of-line-extend-selection',

        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'forward-word-smart',
        'forward-word-smart-extend-selection',

        'go-anywhere',
        'go-back',
        'go-forward',
        'goto-char',

        'indent-region',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',

        'insert-hard-tab',
        'insert-newline',
        'insert-parentheses',
        'insert-soft-tab',

        'kill-line',
        'kill-paragraph',
        'kill-pylint',
        'kill-region',
        'kill-region-save',
        'kill-sentence',
        'kill-to-end-of-line',
        'kill-word',
        'kill-ws',

        'match-brackets',

        'move-lines-down',
        'move-lines-up',
        'move-past-close',
        'move-past-close-extend-selection',

        'newline-and-indent',
        'next-line',
        'next-line-extend-selection',
        'next-or-end-of-line',
        'next-or-end-of-line-extend-selection',

        'previous-line',
        'previous-line-extend-selection',
        'previous-or-beginning-of-line',
        'previous-or-beginning-of-line-extend-selection',

        'rectangle-clear',
        'rectangle-close',
        'rectangle-delete',
        'rectangle-kill',
        'rectangle-open',
        'rectangle-string',
        'rectangle-yank',

        'remove-blank-lines',
        'remove-newlines',
        'remove-space-from-lines',
        'remove-tab-from-lines',

        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',

        'paste-text',
        'pop-cursor',
        'push-cursor',

        'select-all',
        'select-next-trace-statement',
        'select-to-matching-bracket',

        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',

        'split-defs',
        'split-line',

        'start-of-line',
        'start-of-line-extend-selection',

        'tabify',
        'transpose-chars',
        'transpose-lines',
        'transpose-words',

        'unformat-paragraph',
        'unindent-region',

        'untabify',

        'upcase-region',
        'upcase-word',
        'update-ref-file',

        'yank',
        'yank-pop',

        'zap-to-character',

    ]
    bad.extend(bad_list)
    result = list(sorted(bad))
    return result

</t>
<t tx="felix.20200924210112.1">def _good_commands(self):
    """Defined commands that definitely should be included in leoInteg."""
    good_list = [

        'contract-all',
        'contract-all-other-nodes',
        'clone-node',
        'copy-node',
        'copy-marked-nodes',
        'cut-node',

        'de-hoist',
        'delete-marked-nodes',
        'delete-node',
        'demangle-recent-files',
        'demote',

        'expand-and-go-right',
        'expand-next-level',
        'expand-node',
        'expand-or-go-right',
        'expand-prev-level',
        'expand-to-level-1',
        'expand-to-level-2',
        'expand-to-level-3',
        'expand-to-level-4',
        'expand-to-level-5',
        'expand-to-level-6',
        'expand-to-level-7',
        'expand-to-level-8',
        'expand-to-level-9',
        'expand-all',
        'expand-all-subheads',
        'expand-ancestors-only',

        'find-next-clone',

        'goto-first-node',
        'goto-first-sibling',
        'goto-first-visible-node',
        'goto-last-node',
        'goto-last-sibling',
        'goto-last-visible-node',
        'goto-next-changed',
        'goto-next-clone',
        'goto-next-marked',
        'goto-next-node',
        'goto-next-sibling',
        'goto-next-visible',
        'goto-parent',
        'goto-prev-marked',
        'goto-prev-node',
        'goto-prev-sibling',
        'goto-prev-visible',

        'hoist',

        'insert-node',
        'insert-node-before',
        'insert-as-first-child',
        'insert-as-last-child',
        'insert-child',

        'mark',
        'mark-changed-items',
        'mark-first-parents',
        'mark-subheads',

        'move-marked-nodes',
        'move-outline-down',
        'move-outline-left',
        'move-outline-right',
        'move-outline-up',

        'paste-node',
        'paste-retaining-clones',
        'promote',
        'promote-bodies',
        'promote-headlines',

        'sort-children',
        'sort-siblings',

        'tangle',
        'tangle-all',
        'tangle-marked',

        'unmark-all',
        'unmark-first-parents',
        'clean-main-spell-dict',
        'clean-persistence',
        'clean-recent-files',
        'clean-spellpyx',
        'clean-user-spell-dict',

        'clear-all-caches',
        'clear-all-hoists',
        'clear-all-uas',
        'clear-cache',
        'clear-node-uas',
        'clear-recent-files',

        'delete-first-icon',
        'delete-last-icon',
        'delete-node-icons',

        'dump-caches',
        'dump-clone-parents',
        'dump-expanded',
        'dump-node',
        'dump-outline',

        'insert-icon',

        'set-ua',

        'show-all-uas',
        'show-bindings',
        'show-clone-ancestors',
        'show-clone-parents',
        # Export files...
        'export-headlines',
        'export-jupyter-notebook',
        'outline-to-cweb',
        'outline-to-noweb',
        'remove-sentinels',
        'typescript-to-py',

        # Import files...
        'import-MORE-files',
        'import-file',
        'import-free-mind-files',
        'import-jupyter-notebook',
        'import-legacy-external-files',
        'import-mind-jet-files',
        'import-tabbed-files',
        'import-todo-text-files',
        'import-zim-folder',

        # Open specific files...
        # 'ekr-projects',
        'leo-cheat-sheet',  # These duplicates are useful.
        'leo-dist-leo',
        'leo-docs-leo',
        'leo-plugins-leo',
        'leo-py-leo',
        'leo-quickstart-leo',
        'leo-scripts-leo',
        'leo-settings',
        'leo-unittest-leo',
        'my-leo-settings',
        # 'scripts',
        'settings',

        'open-cheat-sheet-leo',
        'open-desktop-integration-leo',
        'open-leo-dist-leo',
        'open-leo-docs-leo',
        'open-leo-plugins-leo',
        'open-leo-py-leo',
        'open-leo-settings',
        'open-leo-settings-leo',
        'open-local-settings',
        'open-my-leo-settings',
        'open-my-leo-settings-leo',
        'open-quickstart-leo',
        'open-scripts-leo',
        'open-unittest-leo',

        # Open other places...
        'open-offline-tutorial',
        'open-online-home',
        'open-online-toc',
        'open-online-tutorials',
        'open-online-videos',
        'open-recent-file',
        'open-theme-file',
        'open-url',
        'open-url-under-cursor',
        'open-users-guide',

        # Read outlines...
        'read-at-auto-nodes',
        'read-at-file-nodes',
        'read-at-shadow-nodes',
        'read-file-into-node',
        'read-outline-only',
        'read-ref-file',

        # Save Files.
        'file-save',
        'file-save-as',
        'file-save-as-unzipped',
        'file-save-by-name',
        'file-save-to',
        'save',  # Some may not be needed.
        'save-all',
        'save-as',
        'save-file',
        'save-file-as',
        'save-file-as-unzipped',
        'save-file-as-zipped',
        'save-file-by-name',
        'save-file-to',
        'save-to',

        # Write parts of outlines...
        'write-at-auto-nodes',
        'write-at-file-nodes',
        'write-at-shadow-nodes',
        'write-dirty-at-auto-nodes',
        'write-dirty-at-file-nodes',
        'write-dirty-at-shadow-nodes',
        'write-edited-recent-files',
        'write-file-from-node',
        'write-missing-at-file-nodes',
        'write-outline-only',

        'clone-find-all',  # Should be overridden by leointeg
        'clone-find-all-flattened',   # Should be overridden by leointeg
        'clone-find-all-flattened-marked',
        'clone-find-all-marked',
        'clone-find-parents',
        'clone-find-tag',
        'clone-marked-nodes',
        'clone-node-to-last-node',
        'clone-to-at-spot',

        'edit-setting',
        'edit-shortcut',

        'execute-pytest',
        'execute-script',
        'extract',
        'extract-names',

        'goto-any-clone',
        'goto-global-line',
        'goto-line',
        'git-diff', 'gd',

        'log-kill-listener', 'kill-log-listener',
        'log-listen', 'listen-to-log',

        'make-stub-files',

        'pdb',

        'redo',  # Should be overridden by leointeg
        'rst3',
        'run-all-unit-tests-externally',
        'run-all-unit-tests-locally',
        'run-marked-unit-tests-externally',
        'run-marked-unit-tests-locally',
        'run-selected-unit-tests-externally',
        'run-selected-unit-tests-locally',
        'run-tests',

        'undo',  # Should be overridden by leointeg

        'xdb',
        # Beautify, blacken, fstringify...
        'beautify-files',
        'beautify-files-diff',
        'blacken-files',
        'blacken-files-diff',
        'diff-and-open-leo-files',
        'diff-beautify-files',
        'diff-fstringify-files',
        'diff-leo-files',
        'diff-marked-nodes',
        'fstringify-files',
        'fstringify-files-diff',
        'fstringify-files-silent',
        'pretty-print-c',
        'silent-fstringify-files',

        # All other commands...
        'at-file-to-at-auto',

        'beautify-c',

        'cls',
        'c-to-python',
        'c-to-python-clean-docs',
        'check-derived-file',
        'check-outline',
        'code-to-rst',
        'compare-two-leo-files',
        'convert-all-blanks',
        'convert-all-tabs',
        'count-children',
        'count-pages',
        'count-region',

        'desktop-integration-leo',

        'edit-recent-files',
        'exit-leo',

        'file-compare-two-leo-files',
        'find-def',
        'find-long-lines',
        'find-missing-docstrings',
        'flake8',
        'flatten-outline',
        'flatten-outline-to-node',
        'flatten-script',

        'gc-collect-garbage',
        'gc-dump-all-objects',
        'gc-dump-new-objects',
        'gc-dump-objects-verbose',
        'gc-show-summary',

        'help',  # To do.
        'help-for-abbreviations',
        'help-for-autocompletion',
        'help-for-bindings',
        'help-for-command',
        'help-for-creating-external-files',
        'help-for-debugging-commands',
        'help-for-drag-and-drop',
        'help-for-dynamic-abbreviations',
        'help-for-find-commands',
        'help-for-keystroke',
        'help-for-minibuffer',
        'help-for-python',
        'help-for-regular-expressions',
        'help-for-scripting',
        'help-for-settings',

        'insert-body-time',  # ?
        'insert-headline-time',
        'insert-jupyter-toc',
        'insert-markdown-toc',

        'find-var',

        'join-leo-irc',
        'join-node-above',
        'join-node-below',
        'join-selection-to-node-below',

        'move-lines-to-next-node',

        'new',

        'open-outline',

        'parse-body',
        'parse-json',
        'pandoc',
        'pandoc-with-preview',
        'paste-as-template',

        'print-body',
        'print-cmd-docstrings',
        'print-expanded-body',
        'print-expanded-html',
        'print-html',
        'print-marked-bodies',
        'print-marked-html',
        'print-marked-nodes',
        'print-node',
        'print-sep',
        'print-tree-bodies',
        'print-tree-html',
        'print-tree-nodes',
        'print-window-state',

        'pyflakes',
        'pylint',
        'pylint-kill',
        'python-to-coffeescript',

        'quit-leo',

        'reformat-body',
        'reformat-paragraph',
        'refresh-from-disk',
        'reload-all-settings',
        'reload-settings',
        'reload-style-sheets',
        'revert',

        'save-buffers-kill-leo',
        'screen-capture-5sec',
        'screen-capture-now',
        'script-button',  # ?
        'set-reference-file',
        'show-style-sheet',
        'sort-recent-files',
        'sphinx',
        'sphinx-with-preview',
        'style-reload',  # ?

        'untangle',
        'untangle-all',
        'untangle-marked',

        'view-lossage',  # ?

        'weave',

        # Dubious commands (to do)...
        'act-on-node',

        'cfa',  # Do we need abbreviations?
        'cfam',
        'cff',
        'cffm',
        'cft',

        'buffer-append-to',
        'buffer-copy',
        'buffer-insert',
        'buffer-kill',
        'buffer-prepend-to',
        'buffer-switch-to',
        'buffers-list',
        'buffers-list-alphabetically',

        'chapter-back',
        'chapter-next',
        'chapter-select',
        'chapter-select-main',
        'create-def-list',  # ?
    ]
    return good_list

</t>
<t tx="felix.20200924210952.1">def _getDocstringForCommand(self, command_name):
    """get docstring for the given command."""
    func = self._get_commander_method(command_name)
    docstring = func.__doc__ if func else ''
    return docstring

</t>
<t tx="felix.20200924211032.1">def setActionId(self, p_id):
    self.currentActionId = p_id

</t>
<t tx="felix.20200924211034.1">async def asyncOutput(self, p_json):
    '''Output json string to the websocket'''
    if self.webSocket:
        await self.webSocket.send(p_json)
    else:
        print("websocket not ready yet", flush=True)

</t>
<t tx="felix.20200924211037.1">def sendLeoBridgePackage(self, p_package={}):
    p_package["id"] = self.currentActionId
    return(json.dumps(p_package, separators=(',', ':')))  # send as json

</t>
<t tx="felix.20200924211041.1">def _outputError(self, p_message="Unknown Error"):
    # Output to this server's running console
    print("ERROR: " + p_message, flush=True)
    w_package = {"id": self.currentActionId}
    w_package["error"] = p_message
    return p_message

</t>
<t tx="felix.20200924211048.1">def _outputBodyData(self, p_bodyText=""):
    return self.sendLeoBridgePackage({"body": p_bodyText})

</t>
<t tx="felix.20200924211051.1">def _outputPNode(self, p_node=False):
    if p_node:
        # Single node, singular
        return self.sendLeoBridgePackage({"node": self._p_to_ap(p_node)})
    else:
        return self.sendLeoBridgePackage({"node": None})

</t>
<t tx="felix.20200924211054.1">def _outputPNodes(self, p_pList):
    w_apList = []
    for p in p_pList:
        w_apList.append(self._p_to_ap(p))
    # Multiple nodes, plural
    return self.sendLeoBridgePackage({"children": w_apList})

</t>
<t tx="felix.20200924211057.1">def mark_node(self, param):
    '''Mark a node, don't select it'''
    w_ap = param["ap"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            w_p.setMarked()
            # return selected node when done (not w_p)
            return self._outputPNode(self.commander.p)
        else:
            return self._outputError("Error in markPNode no w_p node found")
    else:
        return self._outputError("Error in markPNode no param node")

</t>
<t tx="felix.20200924211100.1">def unmark_node(self, param):
    '''Unmark a node, don't select it'''
    w_ap = param["ap"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            w_p.clearMarked()
            # return selected node when done (not w_p)
            return self._outputPNode(self.commander.p)
        else:
            return self._outputError("Error in unmarkPNode no w_p node found")
    else:
        return self._outputError("Error in unmarkPNode no param node")

</t>
<t tx="felix.20200924211104.1">def clone_node(self, param):
    '''Clone a node, return it, if it was also the current selection, otherwise try not to select it'''
    w_ap = param["ap"]
    if not w_ap:
        return self._outputError("Error in clonePNode function, no param ap")
    w_p = self._ap_to_p(w_ap)
    if not w_p:
        # default empty
        return self._outputError("Error in clonePNode function, no w_p node found")
    if w_p == self.commander.p:
        self.commander.clone()
    else:
        oldPosition = self.commander.p
        self.commander.selectPosition(w_p)
        self.commander.clone()
        if self.commander.positionExists(oldPosition):
            self.commander.selectPosition(oldPosition)
    # return selected node either ways
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924211121.1">def cut_node(self, param):
    '''Cut a node, don't select it. Try to keep selection, then return the selected node that remains'''
    w_ap = param["ap"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            if w_p == self.commander.p:
                self.commander.cutOutline()  # already on this node, so cut it
            else:
                oldPosition = self.commander.p  # not same node, save position to possibly return to
                self.commander.selectPosition(w_p)
                self.commander.cutOutline()
                if self.commander.positionExists(oldPosition):
                    # select if old position still valid
                    self.commander.selectPosition(oldPosition)
                else:
                    oldPosition._childIndex = oldPosition._childIndex-1
                    # Try again with childIndex decremented
                    if self.commander.positionExists(oldPosition):
                        # additional try with lowered childIndex
                        self.commander.selectPosition(oldPosition)
            # in both cases, return selected node
            return self._outputPNode(self.commander.p)
        else:
            # default empty
            return self._outputError("Error in cutPNode no w_p node found")
    else:
        return self._outputError("Error in cutPNode no param node")

</t>
<t tx="felix.20200924211125.1">def delete_node(self, param):
    '''Delete a node, don't select it. Try to keep selection, then return the selected node that remains'''
    w_ap = param["ap"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            if w_p == self.commander.p:
                self.commander.deleteOutline()  # already on this node, so delete it
            else:
                oldPosition = self.commander.p  # not same node, save position to possibly return to
                self.commander.selectPosition(w_p)
                self.commander.deleteOutline()
                if self.commander.positionExists(oldPosition):
                    # select if old position still valid
                    self.commander.selectPosition(oldPosition)
                else:
                    oldPosition._childIndex = oldPosition._childIndex-1
                    # Try again with childIndex decremented
                    if self.commander.positionExists(oldPosition):
                        # additional try with lowered childIndex
                        self.commander.selectPosition(oldPosition)
            # in both cases, return selected node
            return self._outputPNode(self.commander.p)
        else:
            # default empty
            return self._outputError("Error in deletePNode no w_p node found")
    else:
        return self._outputError("Error in deletePNode no param node")

</t>
<t tx="felix.20200924211127.1">def insert_node(self, param):
    '''Insert a node at given node, then select it once created, and finally return it'''
    w_ap = param["ap"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            w_bunch = self.commander.undoer.beforeInsertNode(w_p)
            w_newNode = w_p.insertAfter()
            w_newNode.setDirty()
            self.commander.undoer.afterInsertNode(
                w_newNode, 'Insert Node', w_bunch)
            self.commander.selectPosition(w_newNode)
            # in both cases, return selected node
            return self._outputPNode(self.commander.p)
        else:
            # default empty
            return self._outputError("Error in insertPNode no w_p node found")
    else:
        return self._outputError("Error in insertPNode no param node")

</t>
<t tx="felix.20200924211132.1">def insert_named_node(self, param):
    '''Insert a node at given node, set its headline, select it and finally return it'''
    w_newHeadline = param['name']
    w_ap = param["ap"]
    if w_ap:
        w_p = self._ap_to_p(w_ap)
        if w_p:
            w_bunch = self.commander.undoer.beforeInsertNode(w_p)
            w_newNode = w_p.insertAfter()
            # set this node's new headline
            w_newNode.h = w_newHeadline
            w_newNode.setDirty()
            self.commander.undoer.afterInsertNode(
                w_newNode, 'Insert Node', w_bunch)
            self.commander.selectPosition(w_newNode)
            # in any case, return selected node
            return self._outputPNode(self.commander.p)
        else:
            # default empty
            return self._outputError("Error in insertNamedPNode no w_p node found")
    else:
        return self._outputError("Error in insertNamedPNode no param node")

</t>
<t tx="felix.20200924211135.1">def undo(self, param):
    '''Undo last un-doable operation'''
    if self.commander.undoer.canUndo():
        self.commander.undoer.undo()
    # return selected node when done
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924211138.1">def redo(self, param):
    '''Undo last un-doable operation'''
    if self.commander.undoer.canRedo():
        self.commander.undoer.redo()
    # return selected node when done
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200924223845.1"></t>
<t tx="felix.20200924223910.1"></t>
<t tx="felix.20200924223945.1"></t>
<t tx="felix.20200924224017.1"></t>
<t tx="felix.20200924224100.1"></t>
<t tx="felix.20200927213534.1">def _getScript(self, c, p,
               useSelectedText=True,
               forcePythonSentinels=True,
               useSentinels=True,
               ):
    """
    Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if
    p is not the current node or if there is no text selection.
    """
    w = c.frame.body.wrapper
    if not p:
        p = c.p
    try:
        if w and p == c.p and useSelectedText and w.hasSelection():
            s = w.getSelectedText()
        else:
            s = p.b
        # Remove extra leading whitespace so the user may execute indented code.
        s = self.g.removeExtraLws(s, c.tab_width)
        s = self.g.extractExecutableString(c, p, s)
        script = self.g.composeScript(c, p, s,
                                      forcePythonSentinels=forcePythonSentinels,
                                      useSentinels=useSentinels)
    except Exception:
        self.g.es_print("unexpected exception in g.getScript")
        self.g.es_exception()
        script = ''
    return script

</t>
<t tx="felix.20200927224639.1">def _outputSelectionData(self, p_bodySelection):
    return self.sendLeoBridgePackage({"bodySelection": p_bodySelection})

</t>
<t tx="felix.20200928004727.1">/**
 * * Handles detection of the active editor's selection change or cursor position
 * @param p_event a change event containing the active editor's selection, if any.
 */
private _onChangeEditorSelection(p_event: vscode.TextEditorSelectionChangeEvent): void {
    if (p_event.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        if (p_event.selections.length) {
            this._selectionDirty = true;
            this._selection = p_event.selections[0];
            this._selectionGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20200928133238.1">/**
 * * Saves the cursor position along with the text selection range and scroll position
 * @returns Promise that resolves when the "setSelection" action returns from Leo's side
 */
private _bodySaveSelection(): Promise&lt;boolean&gt; {
    if (this._selectionDirty &amp;&amp; this._selection) {
        // Prepare scroll data separately
        // ! TEST NEW SCROLL WITH SINGLE LINE NUMBER
        let w_scroll: number;
        if (this._selectionGnx === this._scrollGnx &amp;&amp; this._scrollDirty) {
            w_scroll = this._scroll?.start.line || 0;
        } else {
            w_scroll = 0;
        }
        // let w_scroll: { start: BodyPosition; end: BodyPosition; };
        // if (this._selectionGnx === this._scrollGnx &amp;&amp; this._scrollDirty) {
        //     w_scroll = {
        //         start: {
        //             line: this._scroll?.start.line || 0,
        //             col: this._scroll?.start.character || 0
        //         },
        //         end: {
        //             line: this._scroll?.end.line || 0,
        //             col: this._scroll?.end.character || 0
        //         }
        //     };
        // } else {
        //     w_scroll = {
        //         start: {
        //             line: 0, col: 0
        //         },
        //         end: {
        //             line: 0, col: 0
        //         }
        //     };
        // }
        // Send whole
        const w_param: BodySelectionInfo = {
            gnx: this._selectionGnx,
            scroll: w_scroll,
            insert: {
                line: this._selection.active.line || 0,
                col: this._selection.active.character || 0,
            },
            start: {
                line: this._selection.start.line || 0,
                col: this._selection.start.character || 0,
            },
            end: {
                line: this._selection.end.line || 0,
                col: this._selection.end.character || 0,
            },
        };
        // console.log("set scroll to leo: " + w_scroll + " start:" + this._selection.start.line);

        this._scrollDirty = false;
        this._selectionDirty = false; // don't wait for return of this call
        return this.sendAction(Constants.LEOBRIDGE.SET_SELECTION, JSON.stringify(w_param)).then(
            (p_result) =&gt; {
                return Promise.resolve(true);
            }
        );
    } else {
        return Promise.resolve(true);
    }
}

</t>
<t tx="felix.20200928174406.1">class IntegTextWrapper:
    """
    A class that represents text as a Python string.
    Modified from Leo's StringTextWrapper class source
    """

    @others

</t>
<t tx="felix.20200928174406.10">def getAllText(self):
    """IntegTextWrapper getAllText"""
    s = self.s
    # print("WRAPPER getAllText  " + s)
    return self.g.checkUnicode(s)

</t>
<t tx="felix.20200928174406.11">def getInsertPoint(self):
    """IntegTextWrapper getInsertPoint"""
    i = self.ins
    if i is None:
        if self.virtualInsertPoint is None:
            i = 0
        else:
            i = self.virtualInsertPoint
    self.virtualInsertPoint = i
    return i

</t>
<t tx="felix.20200928174406.12">def getSelectedText(self):
    """IntegTextWrapper getSelectedText"""
    i, j = self.sel
    s = self.s[i:j]
    # print("WRAPPER getSelectedText with self.s[i:j]: " + s)
    return self.g.checkUnicode(s)

</t>
<t tx="felix.20200928174406.13">def getSelectionRange(self, sort=True):
    """Return the selected range of the widget."""
    sel = self.sel
    if len(sel) == 2 and sel[0] &gt;= 0 and sel[1] &gt;= 0:
        i, j = sel
        if sort and i &gt; j:
            sel = j, i  # Bug fix: 10/5/07
        return sel
    i = self.ins
    return i, i

</t>
<t tx="felix.20200928174406.14">def hasSelection(self):
    """IntegTextWrapper hasSelection"""
    i, j = self.getSelectionRange()
    return i != j

</t>
<t tx="felix.20200928174406.15">def insert(self, i, s):
    """IntegTextWrapper insert"""
    i = self.toPythonIndex(i)
    s1 = s
    self.s = self.s[:i] + s1 + self.s[i:]
    i += len(s1)
    self.ins = i
    self.sel = i, i

</t>
<t tx="felix.20200928174406.16">def selectAllText(self, insert=None):
    """IntegTextWrapper selectAllText"""
    self.setSelectionRange(0, 'end', insert=insert)

</t>
<t tx="felix.20200928174406.17">def setAllText(self, s):
    """IntegTextWrapper setAllText"""
    # print("WRAPPER setAllText: " + s)
    self.s = s
    i = len(self.s)
    self.ins = i
    self.sel = i, i

</t>
<t tx="felix.20200928174406.18">def setInsertPoint(self, pos, s=None):
    """IntegTextWrapper setInsertPoint"""
    self.virtualInsertPoint = i = self.toPythonIndex(pos)
    self.ins = i
    self.sel = i, i

</t>
<t tx="felix.20200928174406.19">def setSelectionRange(self, i, j, insert=None):
    """IntegTextWrapper setSelectionRange"""
    i, j = self.toPythonIndex(i), self.toPythonIndex(j)
    self.sel = i, j
    self.ins = j if insert is None else self.toPythonIndex(insert)

</t>
<t tx="felix.20200928174406.2">def __init__(self, c, name, g):
    """Ctor for the IntegTextWrapper class."""
    self.c = c
    self.name = name
    self.g = g  # Should g be totally global across all leoIntegration classes?
    self.ins = 0
    self.sel = 0, 0
    self.s = ''
    self.yScroll = 0
    self.supportsHighLevelInterface = True
    self.widget = None  # This ivar must exist, and be None.

def __repr__(self):
    return f"&lt;IntegTextWrapper: {id(self)} {self.name}&gt;"

def getName(self):
    """IntegTextWrapper."""
    return self.name  # Essential.

</t>
<t tx="felix.20200928174406.20">def toPythonIndex(self, index):
    """IntegTextWrapper toPythonIndex"""
    return self.g.toPythonIndex(self.s, index)

</t>
<t tx="felix.20200928174406.21">def toPythonIndexRowCol(self, index):
    """IntegTextWrapper toPythonIndexRowCol"""
    s = self.getAllText()
    i = self.toPythonIndex(index)
    row, col = self.g.convertPythonIndexToRowCol(s, i)
    return i, row, col

</t>
<t tx="felix.20200928174406.3">def clipboard_clear(self):
    self.g.app.gui.replaceClipboardWith('')

def clipboard_append(self, s):
    s1 = self.g.app.gui.getTextFromClipboard()
    self.g.app.gui.replaceClipboardWith(s1 + s)

</t>
<t tx="felix.20200928174406.4">def flashCharacter(self, i, bg='white', fg='red',
                   flashes=3, delay=75): pass

def see(self, i): pass

def seeInsertPoint(self): pass

def setFocus(self): pass

def setStyleClass(self, name): pass

def tag_configure(self, colorName, **keys): pass

</t>
<t tx="felix.20200928174406.5"></t>
<t tx="felix.20200928174406.6">def appendText(self, s):
    """IntegTextWrapper appendText"""
    self.s = self.s + self.g.toUnicode(s)
    # defensive
    self.ins = len(self.s)
    self.sel = self.ins, self.ins

</t>
<t tx="felix.20200928174406.7">def delete(self, i, j=None):
    """IntegTextWrapper delete"""
    i = self.toPythonIndex(i)
    if j is None:
        j = i + 1
    j = self.toPythonIndex(j)
    # This allows subclasses to use this base class method.
    if i &gt; j:
        i, j = j, i
    s = self.getAllText()
    self.setAllText(s[:i] + s[j:])
    # Bug fix: 2011/11/13: Significant in external tests.
    self.setSelectionRange(i, i, insert=i)

</t>
<t tx="felix.20200928174406.8">def deleteTextSelection(self):
    """IntegTextWrapper."""
    i, j = self.getSelectionRange()
    self.delete(i, j)

</t>
<t tx="felix.20200928174406.9">def get(self, i, j=None):
    """IntegTextWrapper get"""
    i = self.toPythonIndex(i)
    if j is None:
        j = i + 1
    j = self.toPythonIndex(j)
    s = self.s[i:j]
    # print("WRAPPER GET with self.s[i:j]: " + s)
    return self.g.toUnicode(s)

</t>
<t tx="felix.20200929215102.3">def page_up(self, param):
    """Selects a node a couple of steps up in the tree to simulate page up"""
    n = param.get("n", 3)
    for z in range(n):
        self.commander.selectVisBack()
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200929215102.4">def page_down(self, param):
    """Selects a node a couple of steps down in the tree to simulate page down"""
    n = param.get("n", 3)
    for z in range(n):
        self.commander.selectVisNext()
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20200929215102.5">def get_body_states(self, param):
    """
    Finds the language in effect at top of body for position p,
    return type is lowercase 'language' non-empty string.
    Also returns the saved cursor position from last time node was accessed.

    The cursor positions are given as {"line": line, "col": col, "index": i}
    with line and col along with a redundant index for convenience and flexibility.
    """
    w_ap = param.get("ap")  # At least node parameter is present
    if not w_ap:
        return self._outputError("Error in getLanguage, no param ap")

    w_p = self._ap_to_p(w_ap)
    if not w_p:
        print(
            "in GBS -&gt; P NOT FOUND gnx:" + w_ap['gnx'] + " using self.commander.p gnx: " + self.commander.p.v.gnx)
        w_p = self.commander.p

    w_wrapper = self.commander.frame.body.wrapper

    defaultPosition = {"line": 0, "col": 0, "index": 0}
    states = {
        'language': 'plain',
        # See BodySelectionInfo interface in types.d.ts
        'selection': {
            "gnx": w_p.v.gnx,
            "scroll": 0,
            # "scroll": {
            #     "start": defaultPosition,
            #     "end": defaultPosition
            # },
            "insert": defaultPosition,
            "start": defaultPosition,
            "end": defaultPosition
        }
    }

    if w_p:
        c, g = self.commander, self.g
        aList = g.get_directives_dict_list(w_p)
        d = g.scanAtCommentAndAtLanguageDirectives(aList)

        language = (
            d and d.get('language') or
            g.getLanguageFromAncestorAtFileNode(w_p) or
            c.config.getString('target-language') or
            'plain'
        )

        if w_p.v.scrollBarSpot is None:
            w_scroll = 0
        else:
            w_scroll = w_p.v.scrollBarSpot

        if w_p.v.insertSpot is None:
            w_active = 0
        else:
            w_active = w_p.v.insertSpot
        if w_p.v.selectionStart is None:
            w_start = 0
        else:
            w_start = w_p.v.selectionStart

        if w_p.v.selectionLength is None:
            w_length = 0
        else:
            w_length = w_p.v.selectionLength

        w_end = w_start + w_length

        # get selection from wrapper instead if its the selected node
        if self.commander.p.v.gnx == w_p.v.gnx:
            # print("in GBS -&gt; SAME AS self.commander.p SO USING FROM WRAPPER")
            w_active = w_wrapper.getInsertPoint()
            w_start, w_end = w_wrapper.getSelectionRange(True)
            w_scroll = w_wrapper.getYScrollPosition()

            w_activeI, w_activeRow, w_activeCol = c.frame.body.wrapper.toPythonIndexRowCol(
                w_active)
            w_startI, w_startRow, w_startCol = c.frame.body.wrapper.toPythonIndexRowCol(
                w_start)
            w_endI, w_endRow, w_endCol = c.frame.body.wrapper.toPythonIndexRowCol(
                w_end)
        else:
            print("NOT SAME AS self.commander.p SO USING FROM w_p.v")
            w_activeI, w_startI, w_endI = w_active, w_start, w_end
            w_activeRow, w_activeCol = g.convertPythonIndexToRowCol(
                w_p.v.b, w_active)
            w_startRow, w_startCol = g.convertPythonIndexToRowCol(
                w_p.v.b, w_start)
            w_endRow, w_endCol = g.convertPythonIndexToRowCol(
                w_p.v.b, w_end)

        states = {
            'language': language.lower(),
            'selection': {
                "gnx": w_p.v.gnx,
                "scroll": w_scroll,  # w_scroll was kept as-is ?
                "insert": {"line": w_activeRow, "col": w_activeCol, "index": w_activeI},
                "start": {"line": w_startRow, "col": w_startCol, "index": w_startI},
                "end": {"line": w_endRow, "col": w_endCol, "index": w_endI}
            }
        }
    return self.sendLeoBridgePackage(states)

</t>
<t tx="felix.20200929230231.1">def set_selection(self, param):
    '''
    Set cursor position and scroll position along with selection start and end.

    Positions can be sent as {"col":int, "line" int} dict
    or as numbers directly for convenience.

    (For the currently selected node's body, if gnx matches only)
    Save those values on the commander's body "wrapper"
    See BodySelectionInfo interface in types.d.ts
    '''
    w_same = False  # Flag for actually setting values in the wrapper, if same gnx.
    w_wrapper = self.commander.frame.body.wrapper
    w_gnx = param['gnx']
    w_body = ""
    w_v = None
    if self.commander.p.v.gnx == w_gnx:
        # print('Set Selection! OK SAME GNX: ' + self.commander.p.v.gnx)
        w_same = True
        w_v = self.commander.p.v
    else:
        # ? When navigating rapidly - Check if this is a bug - how to improve
        print('Set Selection! NOT SAME GNX: selected:' +
              self.commander.p.v.gnx + ', package:' + w_gnx)
        w_v = self.commander.fileCommands.gnxDict.get(w_gnx)

    if not w_v:
        print('ERROR : Set Selection! NOT SAME Leo Document')
        # ! FAILED (but return as normal)
        return self._outputPNode(self.commander.p)

    w_body = w_v.b
    f_convert = self.g.convertRowColToPythonIndex
    w_active = param['insert']
    w_start = param['start']
    w_end = param['end']

    # no convertion necessary, its given back later
    w_scroll = param['scroll']

    # IF sent as number use as is - no conversion needed
    if type(w_active) == int:
        w_insert = w_active
        w_startSel = w_start
        w_endSel = w_end
    else:
        w_insert = f_convert(
            w_body, w_active['line'], w_active['col'])
        w_startSel = f_convert(
            w_body, w_start['line'], w_start['col'])
        w_endSel = f_convert(
            w_body, w_end['line'], w_end['col'])

    # print("setSelection (same as selected): " + str(w_same) + " w_insert " + str(w_insert) +
    #       " w_startSel " + str(w_startSel) + " w_endSel " + str(w_endSel))

    # If it's the currently selected node set the wrapper's states too

    if w_same:
        w_wrapper.setSelectionRange(w_startSel, w_endSel, w_insert)
        w_wrapper.setYScrollPosition(w_scroll)
    else:
        pass

    # Set for v node no matter what
    w_v.scrollBarSpot = w_scroll
    w_v.insertSpot = w_insert
    w_v.selectionStart = w_startSel
    w_v.selectionLength = (
        w_endSel - w_startSel) if w_endSel &gt; w_startSel else 0

    # When switching nodes, Leo's core saves the insert point, selection,
    # and vertical scroll position in the old (unselected) vnode. From v.init:

    # self.insertSpot = None
    #     # Location of previous insert point.
    # self.scrollBarSpot = None
    #     # Previous value of scrollbar position.
    # self.selectionLength = 0
    #     # The length of the selected body text.
    # self.selectionStart = 0
    #         # The start of the selected body text.

    # output selected node as 'ok'
    return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20201006195046.1">/**
 * * LeoBody cursor active position and text selection state, along with gnx
 */
export interface BodySelectionInfo {
    gnx: string;
    // scroll is stored as-is as the 'scrollBarSpot' in Leo
    // ! TEST scroll as single number only (for Leo vertical scroll value)
    scroll: number;
    // scroll: {
    //     start: BodyPosition;
    //     end: BodyPosition;
    // }
    insert: BodyPosition;
    start: BodyPosition;
    end: BodyPosition;
}

</t>
<t tx="felix.20201014020145.1">/**
 * * Handles detection of the active editor's scroll position changes
 * @param p_event a change event containing the active editor's visible range, if any.
 */
private _onChangeEditorScroll(p_event: vscode.TextEditorVisibleRangesChangeEvent): void {
    if (p_event.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        if (p_event.visibleRanges.length) {
            this._scrollDirty = true;
            this._scroll = p_event.visibleRanges[0];
            this._scrollGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20201017224340.1">/**
 * * Structure for configuration settings changes used along with welcome/settings webview.
 */
export interface ConfigSetting {
    code: string;
    value: any;
}

</t>
<t tx="felix.20201018163510.1">/**
 * * Returns the milliseconds between a given starting process.hrtime tuple and the current call to process.hrtime
 * @param p_start starting process.hrtime to subtract from current immediate time
 * @returns number of milliseconds passed since the given start hrtime
 */
export function getDurationMs(p_start: [number, number]): number {
    const [w_secs, w_nanosecs] = process.hrtime(p_start);
    return w_secs * 1000 + Math.floor(w_nanosecs / 1000000);
}

</t>
<t tx="felix.20201025144113.1">def test(self, param):
    '''Utility test function for debugging'''
    print("Called test")
    return self.sendLeoBridgePackage({'testReturnedKey': 'testReturnedValue'})
    # return self._outputPNode(self.commander.p)

</t>
<t tx="felix.20201028223434.1">def setXScrollPosition(self, i):
    pass
    # X axis ignored

</t>
<t tx="felix.20201028223533.1">def getXScrollPosition(self):
    return 0
    # X axis ignored

</t>
<t tx="felix.20201102223046.1">def setYScrollPosition(self, i):
    self.yScroll = i
    # print("wrapper set y scroll" + str(self.yScroll))

</t>
<t tx="felix.20201102223052.1">def getYScrollPosition(self):
    # print("wrapper get y scroll" + str(self.yScroll))
    return self.yScroll

</t>
<t tx="felix.20201103000337.1">/**
 * * Table for converting Leo languages names for the currently opened body pane
 * Used in showBody method of leoIntegration.ts
 */
public static LANGUAGE_CODES: { [key: string]: string | undefined } = {
    cplusplus: 'cpp',
    md: 'markdown',
    rest: 'restructuredtext',
    rst: 'restructuredtext'
};

</t>
<t tx="felix.20201105010253.1">{
  "command": "leointeg.extract",
  "key": "ctrl+shift+d",
  "mac": "cmd+shift+d",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.extractNames",
  "key": "ctrl+shift+n",
  "mac": "cmd+shift+n",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leo"
},
</t>
<t tx="felix.20201105010614.1">{
  "command": "leointeg.extract",
  "category": "Leo",
  "title": "Extract",
  "icon": {
    "light": "resources/light/extract.svg",
    "dark": "resources/dark/extract.svg"
  }
},
{
  "command": "leointeg.extractNames",
  "category": "Leo",
  "title": "Extract Names",
  "icon": {
    "light": "resources/light/extract-name.svg",
    "dark": "resources/dark/extract-name.svg"
  }
},
</t>
<t tx="felix.20201106200100.1">/**
 * * Performs the actual addition into workspaceState context
 * @param p_context Needed to get to vscode workspace storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the workspace storage modification is done
 */
export function addFileToWorkspace(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Just push that string into the context.workspaceState.&lt;something&gt; array
    const w_contextEntry: string[] = p_context.workspaceState.get(p_key) || [];
    if (w_contextEntry) {
        if (!w_contextEntry.includes(p_file)) {
            w_contextEntry.push(p_file);
            if (w_contextEntry.length &gt; 10) {
                w_contextEntry.shift();
            }
        }
        return p_context.workspaceState.update(p_key, w_contextEntry); // Added file
    } else {
        // First so create key entry with an array of single file
        return p_context.workspaceState.update(p_key, [p_file]);
    }
}

</t>
<t tx="felix.20201106200109.1">/**
 * * Removes file entry from workspaceState context
 * @param p_context Needed to get to vscode workspace storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the workspace storage modification is done
  */
export function removeFileFromWorkspace(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Check if exist in context.workspaceState.&lt;something&gt; and remove if found
    const w_files: string[] = p_context.workspaceState.get(p_key) || [];
    if (w_files &amp;&amp; w_files.includes(p_file)) {
        w_files.splice(w_files.indexOf(p_file), 1); // Splice and update
        return p_context.workspaceState.update(p_key, w_files);
    }
    return Promise.resolve(); // not even in list so just resolve
}

</t>
<t tx="felix.20201107224112.1">/**
 * * Promise that triggers body save (rejects if busy), and resolves when done
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the possible saving process is finished
 */
private _isBusyTriggerSave(p_all: boolean, p_forcedVsCodeSave?: boolean): Promise&lt;boolean&gt; {
    if (this._isBusy(p_all)) {
        return Promise.reject('Command stack busy'); // Warn user to wait for end of busy state
    }
    return this.triggerBodySave(p_forcedVsCodeSave);
}

</t>
<t tx="felix.20201114185218.1">/**
 * * Sets the outline pane top bar string message or refreshes with existing title if no title passed
 * @param p_title new string to replace the current title
 */
public setTreeViewTitle(p_title?: string): void {
    if (p_title) {
        this._currentOutlineTitle = p_title;
    }
    // * Set/Change outline pane title e.g. "INTEGRATION", "OUTLINE"
    if (this._leoTreeView) {
        this._leoTreeView.title = this._currentOutlineTitle;
    }
    if (this._leoTreeExView) {
        this._leoTreeExView.title =
            Constants.GUI.EXPLORER_TREEVIEW_PREFIX + this._currentOutlineTitle;
    }
}

</t>
<t tx="felix.20201114185813.1">/**
 * * Opens quickPick minibuffer pallette to choose from all commands in this file's commander
 * @returns Promise that resolves when the chosen command is placed on the front-end command stack
 */
public minibuffer(): Thenable&lt;LeoBridgePackage | undefined&gt; {
    // Wait for _isBusyTriggerSave resolve because the full body save may change available commands
    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {
            const q_commandList: Thenable&lt;vscode.QuickPickItem[]&gt; = this.sendAction(
                Constants.LEOBRIDGE.GET_COMMANDS
            ).then((p_result: LeoBridgePackage) =&gt; {
                if (p_result.commands &amp;&amp; p_result.commands.length) {
                    const w_regexp = new RegExp('\\s+', 'g');
                    p_result.commands.forEach(p_command =&gt; {
                        if (p_command.detail) {
                            p_command.detail = p_command.detail.trim().replace(w_regexp, ' ');
                        }
                    });
                    return p_result.commands;
                } else {
                    return [];
                }
            });
            const w_options: vscode.QuickPickOptions = {
                placeHolder: Constants.USER_MESSAGES.MINIBUFFER_PROMPT,
                matchOnDetail: true,
            };
            return vscode.window.showQuickPick(q_commandList, w_options);
        })
        .then((p_picked) =&gt; {
            if (
                p_picked &amp;&amp;
                p_picked.label &amp;&amp;
                Constants.MINIBUFFER_OVERRIDDEN_COMMANDS[p_picked.label]
            ) {
                return vscode.commands.executeCommand(
                    Constants.MINIBUFFER_OVERRIDDEN_COMMANDS[p_picked.label]
                );
            }
            if (p_picked &amp;&amp; p_picked.label) {
                const w_commandResult = this.nodeCommand({
                    action: "-" + p_picked.label, // Adding HYPHEN prefix to specify a command-name
                    node: undefined,
                    refreshType: {
                        tree: true,
                        body: true,
                        documents: true,
                        buttons: true,
                        states: true,
                    },
                    fromOutline: false, // true // TODO : Differentiate from outline?
                });
                return w_commandResult ? w_commandResult : Promise.reject('Command not added');
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20201119002510.1">/**
 * * Body position
 * Used in BodySelectionInfo interface
 */
export interface BodyPosition {
    line: number;
    col: number;
}

</t>
<t tx="felix.20201126235315.1">/**
 * * Strings used in 'at-button' panel display in LeoButtonNode
 */
public static BUTTON_STRINGS = {
    NULL_WIDGET: "nullButtonWidget",
    SCRIPT_BUTTON: "script-button",
    ADD_BUTTON: "leoButtonAdd",
    NORMAL_BUTTON: "leoButtonNode"
};

</t>
<t tx="felix.20201129184357.1">def printAction(param):
    '''Debugging tool that prints out called action if not in 'common-action' array'''
    w_action = param["action"]
    # print action if not getChild or getChildren or some other very common action
    if w_action in commonActions:
        pass
    else:
        print(f"*ACTION* {w_action}, id {param['id']}", flush=True)


</t>
<t tx="felix.20201208235246.1">/**
 * * Command strings to be used with vscode.commands.executeCommand
 * See https://code.visualstudio.com/api/extension-guides/command#programmatically-executing-a-command
 */
public static VSCODE_COMMANDS = {
    SET_CONTEXT: "setContext",
    CLOSE_ACTIVE_EDITOR: "workbench.action.closeActiveEditor",
    QUICK_OPEN: "workbench.action.quickOpen"
};

</t>
<t tx="felix.20201215210439.1">"view/title": [
  {
    "command": "leointeg.openLeoFile",
    "when": "view =~ /^leoIntegration|^leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "view =~ /^leoIntegration|^leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.showSettingsPage",
    "when": "view =~ /^leoFindPanel|^leoDocuments|^leoButtons/ &amp;&amp; leoBridgeReady",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.showLogPane",
    "when": "view =~ /^leoFindPanel|^leoDocuments|^leoButtons/ &amp;&amp; leoBridgeReady",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.findQuickSelected",
    "when": "view =~ /^leoGotoPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.findQuickTimeline",
    "when": "view =~ /^leoGotoPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.findQuickChanged",
    "when": "view =~ /^leoGotoPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.history",
    "when": "view =~ /^leoGotoPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.markedList",
    "when": "view =~ /^leoGotoPanel/ &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.showSettingsPage",
    "when": "view =~ /^leoIntegration/ &amp;&amp; !leoTreeOpened",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.clearRecentFiles",
    "when": "view =~ /^leoIntegration/ &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.connectToServer",
    "when": "view =~ /^leoIntegration/ &amp;&amp; !leoBridgeReady &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.startServer",
    "when": "view =~ /^leoIntegration/ &amp;&amp; !leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; !leoServerStarted",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.stopServer",
    "when": "view =~ /^leoIntegration/ &amp;&amp; !leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; leoServerStarted",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.saveAsLeoJsFile",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.undoFromOutline",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanUndo",
    "group": "navigation@3"
  },
  {
    "command": "leointeg.undoDisabled",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoCanUndo",
    "group": "navigation@3"
  },
  {
    "command": "leointeg.redoFromOutline",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanRedo",
    "group": "navigation@4"
  },
  {
    "command": "leointeg.redoDisabled",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoCanRedo",
    "group": "navigation@4"
  },
  {
    "command": "leointeg.deHoistFromOutline",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanDehoist",
    "group": "navigation@5"
  },
  {
    "command": "leointeg.contractAllFromOutline",
    "when": "view =~ /^leoIntegration/ &amp;&amp; leoTreeOpened",
    "group": "navigation@6"
  }
],
</t>
<t tx="felix.20201215210510.1">"view/item/context": [
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "viewItem =~ /^leoDocumentSelectedTitled/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "viewItem =~ /^leoDocumentSelectedUntitled/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.saveAsLeoJsFile",
    "when": "viewItem =~ /^leoDocumentSelectedUntitled/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.closeLeoFile",
    "when": "viewItem =~ /^leoDocumentSelected/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.editHeadline",
    "when": "showEditOnNodes &amp;&amp; viewItem =~ /^leoNode/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.insertNode",
    "when": "showAddOnNodes &amp;&amp; viewItem =~ /^leoNode/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.moveOutlineDown",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /^leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineLeft",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /^leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineRight",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /^leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineUp",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /^leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.copyNode",
    "when": "showCopyOnNodes &amp;&amp; viewItem =~ /^leoNode/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "showCloneOnNodes &amp;&amp; viewItem =~ /^leoNode/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.mark",
    "when": "showMarkOnNodes &amp;&amp; viewItem =~ /^leoNodeUnmarked/",
    "group": "inline@5"
  },
  {
    "command": "leointeg.unmark",
    "when": "showMarkOnNodes &amp;&amp; viewItem =~ /^leoNodeMarked/",
    "group": "inline@5"
  },
  {
    "command": "leointeg.openAside",
    "when": "showOpenAside &amp;&amp; viewItem =~ /^leoNode/",
    "group": "leoNodeContext1@1"
  },
  {
    "command": "leointeg.hoistNode",
    "when": "viewItem =~ /leoNodeNotRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.deHoist",
    "when": "leoCanDehoist &amp;&amp; viewItem =~ /leoNodeRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.refreshFromDisk",
    "when": "viewItem =~ /leoNodeAtFile/",
    "group": "leoNodeContext1@3"
  },
  {
    "command": "leointeg.mark",
    "when": "viewItem =~ /^leoNodeUnmarked/",
    "group": "leoNodeContext2@1"
  },
  {
    "command": "leointeg.unmark",
    "when": "viewItem =~ /^leoNodeMarked/",
    "group": "leoNodeContext2@2"
  },
  {
    "command": "leointeg.copyNode",
    "when": "viewItem =~ /^leoNode/",
    "group": "leoNodeContext2@3"
  },
  {
    "command": "leointeg.cutNode",
    "when": "viewItem =~ /^leoNode/",
    "group": "leoNodeContext2@4"
  },
  {
    "command": "leointeg.pasteNode",
    "when": "viewItem =~ /^leoNode/",
    "group": "leoNodeContext2@5"
  },
  {
    "command": "leointeg.pasteNodeAsClone",
    "when": "viewItem =~ /^leoNode/",
    "group": "leoNodeContext2@6"
  },
  {
    "command": "leointeg.delete",
    "when": "viewItem =~ /^leoNode/",
    "group": "leoNodeContext2@7"
  },
  {
    "command": "leointeg.insertNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /^leoNode/",
    "group": "leoNodeContext3@1"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /^leoNode/",
    "group": "leoNodeContext3@2"
  },
  {
    "command": "leointeg.gotoNextClone",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNodeCloned/",
    "group": "leoNodeContext3@3"
  },
  {
    "command": "leointeg.removeButton",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /^leoButtonNode/",
    "group": "leoButtonContext1@1"
  },
  {
    "command": "leointeg.gotoScript",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /^leoButtonNode/",
    "group": "leoButtonContext1@2"
  }
],
</t>
<t tx="felix.20210418013332.1">/**
 * * Closes non-existing body by deleting the file and calling 'hide'
 * @param p_textEditor the editor to close
 */
private _hideDeleteBody(p_textEditor: vscode.TextEditor): void {
    const w_edit = new vscode.WorkspaceEdit();
    w_edit.deleteFile(p_textEditor.document.uri, { ignoreIfNotExists: true });
    vscode.workspace.applyEdit(w_edit);
    if (p_textEditor.hide) {
        p_textEditor.hide();
    }
    vscode.commands.executeCommand(
        'vscode.removeFromRecentlyOpened',
        p_textEditor.document.uri.path
    );
}

</t>
<t tx="felix.20210418014039.1">/**
 * * Moved a document to another column
 * @param p_columnChangeEvent  event describing the change of a text editor's view column
 */
public _changedTextEditorViewColumn(
    p_columnChangeEvent: vscode.TextEditorViewColumnChangeEvent
): void {
    if (p_columnChangeEvent &amp;&amp; p_columnChangeEvent.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        this._checkPreviewMode(p_columnChangeEvent.textEditor);
    }
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20210418014040.1">/**
 * * Tabbed on another editor
 * @param p_editors text editor array (to be checked for changes in this method)
 */
public _changedVisibleTextEditors(p_editors: readonly vscode.TextEditor[]): void {
    if (p_editors &amp;&amp; p_editors.length) {
        // May be no changes - so check length
        p_editors.forEach((p_textEditor) =&gt; {
            if (p_textEditor &amp;&amp; p_textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
                if (this.bodyUri.fsPath !== p_textEditor.document.uri.fsPath) {
                    this._hideDeleteBody(p_textEditor);
                }
                this._checkPreviewMode(p_textEditor);
            }
        });
    }
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20210418014040.2">/**
 * * Whole window has been minimized/restored
 * @param p_windowState the state of the window that changed
 */
public _changedWindowState(p_windowState: vscode.WindowState): void {
    // no other action
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20210418220343.1">
/**
 * * Clears the global 'Preview Mode' flag if the given editor is not in the main body column
 * @param p_editor is the editor to check for is in the same column as the main one
 */
private _checkPreviewMode(p_editor: vscode.TextEditor): void {
    // if selected gnx but in another column
    if (
        p_editor.document.uri.fsPath === this.bodyUri.fsPath &amp;&amp;
        p_editor.viewColumn !== this._bodyMainSelectionColumn
    ) {
        this._bodyPreviewMode = false;
        this._bodyMainSelectionColumn = p_editor.viewColumn;
    }
}

</t>
<t tx="felix.20210418230204.1">
/**
 * * Find editor column based on uri
 * @returns View Column if found, undefined otherwise
 */
private _findUriColumn(p_uri: vscode.Uri): vscode.ViewColumn | undefined {
    let w_column: vscode.ViewColumn | undefined;
    vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
        if (p_textEditor.document.uri.fsPath === p_uri.fsPath) {
            w_column = p_textEditor.viewColumn;
        }
    });
    return w_column;
}

</t>
<t tx="felix.20210418230204.2">/**
 * * Find editor column based on gnx string
 * @returns View Column if found, undefined otherwise
 */
private _findGnxColumn(p_gnx: string): vscode.ViewColumn | undefined {
    let w_column: vscode.ViewColumn | undefined;
    vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
        if (p_textEditor.document.uri.fsPath.substr(1) === p_gnx) {
            w_column = p_textEditor.viewColumn;
        }
    });
    return w_column;
}

</t>
<t tx="felix.20210509210502.1">## 0.1.13

- Added support for precise focus placement, focus switch between tree/body.
- Made the extension more aware of the current selection state, to have strictly relevant buttons visible shown only.
- Made the 'edit headline' hover icon removable, in order to enable 'Tab' keybinding to go from tree to body directly.
- Added commands and keybindings for 'goto' operations 'hoist/dehoist' [#25](https://github.com/boltex/leointeg/issues/25) and other commands. [#30](https://github.com/boltex/leointeg/issues/30)
- Added support for Leo-Style outline navigation. [#43](https://github.com/boltex/leointeg/issues/43) Has to be enabled with an option in the config settings: "Use Leo Tree Browsing" which makes the arrow keys, pgUp/pgDn, home/end move the selection instead of a cursor when focus is on Leo's outline.
- Implemented @buttons in it's own panel, visible where the already existing 'outline' and 'opened leo documents' panels reside.
- Added (basic) unknown attributes support as hover tooltip and small description on node headlines.
- Added a 'leoBridge Server Terminal Panel' to gather output of the leoBridge stdOut pipe. It's displayed among the 'output panels', along with the standard 'leo log window', when the server is started by leoInteg. (either with the auto-start config setting, or by calling the 'start server' command via buttons or the command-palette.)
- Syntax coloring and Snippets are now enabled for those languages : C, C++, CSS, HTML, Java, Javascript, json, Markdown, PHP, Python, Rust and Typescript. They are taken from the default extension for that language, or if non-existent, from the most popular extension for that language
- Recent files are now remembered and restored upon re-opening vscode.
- Leo files can be opened from the explorer pane directly.
- Added 'minibuffer' feature with the usual alt-x command from Leo.
- Added cursor position, selected range and scrolling position to be captured and restored when navigating the outline. [#39](https://github.com/boltex/leointeg/issues/39) This allows for commands that use the currently selected text, [#61](https://github.com/boltex/leointeg/issues/61) such as run script and extract/extract name, etc.
- Redid the body display and switching logic to support new vscode API features. (vscode now does not block 'undo' operations between file-rename operations, which were used to switch body pane content.)

</t>
<t tx="felix.20210512000301.1">def get_focus(self, param):
    """
    Return a representation of the focused widget,
    one of ("body", "tree", "headline", repr(the_widget)).
    """
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    return self.sendLeoBridgePackage({"focus": focus})

</t>
<t tx="felix.20210516233931.1">/**
 * * Opens the find panel and selects all &amp; focuses on the find field.
 */
public startSearch(): void {
    let w_panelID = '';
    let w_panel: vscode.WebviewView | undefined;
    if (this._lastTreeView === this._leoTreeExView) {
        w_panelID = Constants.FIND_EXPLORER_ID;
        w_panel = this._findPanelWebviewExplorerView;
    } else {
        w_panelID = Constants.FIND_ID;
        w_panel = this._findPanelWebviewView;
    }
    vscode.commands.executeCommand(w_panelID + '.focus').then((p_result) =&gt; {
        if (w_panel &amp;&amp; w_panel.show &amp;&amp; !w_panel.visible) {
            w_panel.show(false);
        }
        w_panel?.webview.postMessage({ type: 'selectFind' });
    });
}

</t>
<t tx="felix.20210516234059.1">/**
 * * Find next / previous commands
 * @param p_fromOutline
 * @param p_reverse
 * @returns Promise that resolves when the "launch refresh" is started
 */
public find(p_fromOutline: boolean, p_reverse: boolean): Promise&lt;any&gt; {
    const w_action: string = p_reverse
        ? Constants.LEOBRIDGE.FIND_PREVIOUS
        : Constants.LEOBRIDGE.FIND_NEXT;
    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(w_action, JSON.stringify({ fromOutline: !!p_fromOutline }));
        })
        .then((p_findResult: LeoBridgePackage) =&gt; {
            if (!p_findResult.found || !p_findResult.focus) {
                vscode.window.showInformationMessage('Not found');
            } else {
                let w_focusOnOutline = false;
                const w_focus = p_findResult.focus.toLowerCase();
                if (w_focus.includes('tree') || w_focus.includes('head')) {
                    // tree
                    w_focusOnOutline = true;
                }
                this.launchRefresh(
                    {
                        tree: true,
                        body: true,
                        scroll: p_findResult.found &amp;&amp; !w_focusOnOutline,
                        documents: false,
                        buttons: false,
                        states: true,
                    },
                    w_focusOnOutline
                );
            }
        });
}

</t>
<t tx="felix.20210517001143.1">{
  "command": "leointeg.startSearch",
  "category": "Leo",
  "title": "Start Search"
},
{
  "command": "leointeg.findAll",
  "category": "Leo",
  "title": "Find All"
},
{
  "command": "leointeg.findNext",
  "category": "Leo",
  "title": "Find Next"
},
{
  "command": "leointeg.findNextFromOutline",
  "category": "Leo",
  "title": "Find Next"
},
{
  "command": "leointeg.findPrevious",
  "category": "Leo",
  "title": "Find Previous"
},
{
  "command": "leointeg.findPreviousFromOutline",
  "category": "Leo",
  "title": "Find Previous"
},
{
  "command": "leointeg.findVar",
  "category": "Leo",
  "title": "Find the var under the cursor"
},
{
  "command": "leointeg.findDef",
  "category": "Leo",
  "shortTitle": "Find Definition",
  "title": "Find the def or class under the cursor"
},
{
  "command": "leointeg.replace",
  "category": "Leo",
  "title": "Replace"
},
{
  "command": "leointeg.replaceFromOutline",
  "category": "Leo",
  "title": "Replace"
},
{
  "command": "leointeg.replaceThenFind",
  "category": "Leo",
  "title": "Replace Then Find"
},
{
  "command": "leointeg.replaceThenFindFromOutline",
  "category": "Leo",
  "title": "Replace Then Find"
},
{
  "command": "leointeg.replaceAll",
  "category": "Leo",
  "title": "Replace All"
},
{
  "command": "leointeg.gotoGlobalLine",
  "category": "Leo",
  "title": "Goto Global Line"
},
{
  "command": "leointeg.cloneFindAll",
  "category": "Leo",
  "title": "Clone Find All"
},
{
  "command": "leointeg.cloneFindAllFlattened",
  "category": "Leo",
  "title": "Clone Find All Flattened"
},
{
  "command": "leointeg.cloneFindMarked",
  "category": "Leo",
  "shortTitle": "cfam",
  "title": "cfam - Clone Find All Marked Nodes"
},
{
  "command": "leointeg.cloneFindFlattenedMarked",
  "category": "Leo",
  "shortTitle": "cffm",
  "title": "cffm - Clone Find All Flattened Marked"
},
{
  "command": "leointeg.cloneFindTag",
  "category": "Leo",
  "shortTitle": "cft",
  "title": "cft - Clone Find Tag"
},
{
  "command": "leointeg.tagChildren",
  "category": "Leo",
  "title": "Tag Children"
},
{
  "command": "leointeg.tagNode",
  "category": "Leo",
  "title": "Tag Node"
},
{
  "command": "leointeg.removeTags",
  "category": "Leo",
  "title": "Remove Tags"
},
{
  "command": "leointeg.setFindEverywhereOption",
  "category": "Leo",
  "shortTitle": "Find Everywhere",
  "title": "Set Find Everywhere Option"
},
{
  "command": "leointeg.setFindNodeOnlyOption",
  "category": "Leo",
  "shortTitle": "Find in Node",
  "title": "Set Find in Node Only Option"
},
{
  "command": "leointeg.setFindSuboutlineOnlyOption",
  "category": "Leo",
  "shortTitle": "Find in SubOutline",
  "title": "Set Find in SubOutline Only Option"
},
{
  "command": "leointeg.toggleFindIgnoreCaseOption",
  "category": "Leo",
  "shortTitle": "Find Ignore Case",
  "title": "Toggle Find Ignore Case Option"
},
{
  "command": "leointeg.toggleFindMarkChangesOption",
  "category": "Leo",
  "shortTitle": "Find Mark Changes",
  "title": "Toggle Find Mark Changes Option"
},
{
  "command": "leointeg.toggleFindMarkFindsOption",
  "category": "Leo",
  "shortTitle": "Find Mark Finds",
  "title": "Toggle Find Mark Finds Option"
},
{
  "command": "leointeg.toggleFindRegexpOption",
  "category": "Leo",
  "shortTitle": "Find RegExp",
  "title": "Toggle Find RegExp Option"
},
{
  "command": "leointeg.toggleFindWordOption",
  "category": "Leo",
  "shortTitle": "Find Whole Word",
  "title": "Toggle Find Whole Word Option"
},
{
  "command": "leointeg.toggleFindSearchBodyOption",
  "category": "Leo",
  "shortTitle": "Find Search Body",
  "title": "Toggle Find Search Body Option"
},
{
  "command": "leointeg.toggleFindSearchHeadlineOption",
  "category": "Leo",
  "shortTitle": "Find Search Headline",
  "title": "Toggle Find Search Headline Option"
},
</t>
<t tx="felix.20210517001459.1">{
  "command": "leointeg.mark",
  "category": "Leo",
  "title": "Mark",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leointeg.markSelection",
  "category": "Leo",
  "title": "Mark",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leointeg.markSelectionFromOutline",
  "category": "Leo",
  "title": "Mark",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leointeg.unmark",
  "category": "Leo",
  "title": "Unmark",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leointeg.unmarkSelection",
  "category": "Leo",
  "title": "Unmark",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "category": "Leo",
  "title": "Unmark",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leointeg.unmarkAll",
  "category": "Leo",
  "title": "Unmark All"
},
{
  "command": "leointeg.markSubheads",
  "category": "Leo",
  "title": "Mark Subheads"
},
{
  "command": "leointeg.markChangedItems",
  "category": "Leo",
  "title": "Mark Changed Items"
},
{
  "command": "leointeg.copyMarked",
  "category": "Leo",
  "title": "Copy Marked"
},
{
  "command": "leointeg.cloneMarkedNodes",
  "category": "Leo",
  "title": "Clone Marked Nodes"
},
{
  "command": "leointeg.diffMarkedNodes",
  "category": "Leo",
  "title": "Diff Marked Nodes"
},
{
  "command": "leointeg.deleteMarkedNodes",
  "category": "Leo",
  "title": "Delete Marked Nodes"
},
{
  "command": "leointeg.moveMarkedNodes",
  "category": "Leo",
  "title": "Move Marked Nodes"
}
</t>
<t tx="felix.20210517004335.1">{
  "command": "leointeg.startSearch",
  "key": "ctrl+f",
  "mac": "cmd+f",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !editorFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.findNextFromOutline",
  "key": "f3",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.findNext",
  "key": "f3",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.findPreviousFromOutline",
  "key": "f2",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.findPrevious",
  "key": "f2",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.replace",
  "key": "ctrl+=",
  "mac": "cmd+=",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.replaceFromOutline",
  "key": "ctrl+=",
  "mac": "cmd+=",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.replaceThenFind",
  "key": "ctrl+-",
  "mac": "cmd+-",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.replaceThenFindFromOutline",
  "key": "ctrl+-",
  "mac": "cmd+-",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.gotoGlobalLine",
  "key": "alt+g",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.setFindEverywhereOption",
  "key": "ctrl+alt+e",
  "mac": "cmd+alt+e",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.setFindNodeOnlyOption",
  "key": "ctrl+alt+n",
  "mac": "cmd+alt+n",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.setFindSuboutlineOnlyOption",
  "key": "ctrl+alt+s",
  "mac": "cmd+alt+s",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindIgnoreCaseOption",
  "key": "ctrl+alt+i",
  "mac": "cmd+alt+i",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindMarkChangesOption",
  "key": "ctrl+alt+c",
  "mac": "cmd+alt+c",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindMarkFindsOption",
  "key": "ctrl+alt+f",
  "mac": "cmd+alt+f",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindRegexpOption",
  "key": "ctrl+alt+x",
  "mac": "cmd+alt+x",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindWordOption",
  "key": "ctrl+alt+w",
  "mac": "cmd+alt+w",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindSearchBodyOption",
  "key": "ctrl+alt+b",
  "mac": "cmd+alt+b",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindSearchHeadlineOption",
  "key": "ctrl+alt+h",
  "mac": "cmd+alt+h",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/ || leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
</t>
<t tx="felix.20210522001751.1">import * as vscode from 'vscode';
import { Constants } from '../constants';
import { LeoIntegration } from '../leoIntegration';
import * as utils from '../utils';

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20210522001814.1">/**
 * Leo Find Panel provider
 */
export class LeoFindPanelProvider implements vscode.WebviewViewProvider {
    private _view?: vscode.WebviewView;

    constructor(
        private readonly _extensionUri: vscode.Uri,
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20210522152739.1">/**
 * * LeoInteg search settings structure for use with the 'find' webview
 */
export interface LeoSearchSettings {
    // Nav options
    navText: string;
    isTag: boolean;
    showParents: boolean;
    searchOptions: number;
    // Find/change strings...
    findText: string;
    replaceText: string;
    // Find options...
    wholeWord: boolean;
    ignoreCase: boolean;
    regExp: boolean;
    markFinds: boolean;
    markChanges: boolean;
    searchHeadline: boolean;
    searchBody: boolean;
    searchScope: LeoSearchScope; // 0, 1 or 2 for outline, sub-outline, or node.
}

</t>
<t tx="felix.20210522152922.1">/**
 * * LeoInteg's Enum type for the search scope radio buttons of the find panel.
 */
export const enum LeoSearchScope {
    entireOutline = 0,
    subOutlineOnly,
    nodeOnly
}

</t>
<t tx="felix.20210522233604.1"></t>
<t tx="felix.20210522233744.1">{
  "view": "leoGotoPanel",
  "contents": "Not connected",
  "when": "!leoTreeOpened"
},
{
  "view": "leoGotoPanelExplorer",
  "contents": "Not connected",
  "when": "!leoTreeOpened"
},
{
  "view": "leoGotoPanel",
  "contents": "No Results",
  "when": "leoTreeOpened"
},
{
  "view": "leoGotoPanelExplorer",
  "contents": "No Results",
  "when": "leoTreeOpened"
},
{
  "view": "leoFindPanel",
  "contents": "Not connected",
  "when": "!leoTreeOpened"
},
{
  "view": "leoFindPanelExplorer",
  "contents": "Not connected",
  "when": "!leoTreeOpened"
}
</t>
<t tx="felix.20210523154200.1">def get_ui_states(self, param):
    """
    Gets the currently opened file's general states for UI enabled/disabled states
    such as undo available, file changed/unchanged
    """
    w_states = {}
    if self.commander:
        try:
            # 'dirty/changed' member
            w_states["changed"] = self.commander.changed
            w_states["canUndo"] = self.commander.canUndo()
            w_states["canRedo"] = self.commander.canRedo()
            w_states["canDemote"] = self.commander.canDemote()
            w_states["canPromote"] = self.commander.canPromote()
            w_states["canDehoist"] = self.commander.canDehoist()

        except Exception as e:
            self.g.trace('Error while getting states')
            print("Error while getting states", flush=True)
            print(str(e), flush=True)
    else:
        w_states["changed"] = False
        w_states["canUndo"] = False
        w_states["canRedo"] = False
        w_states["canDemote"] = False
        w_states["canPromote"] = False
        w_states["canDehoist"] = False

    return self.sendLeoBridgePackage({"states": w_states})

</t>
<t tx="felix.20210523154320.1"></t>
<t tx="felix.20210523154326.1">def get_search_settings(self, param):
    """
    Gets search options
    """
    w_result = self.commander.findCommands.ftm.get_settings()
    return self.sendLeoBridgePackage({"searchSettings": w_result.__dict__})

</t>
<t tx="felix.20210523154352.1">def set_search_settings(self, param):
    """
    Sets search options. Init widgets and ivars from param.searchSettings
    """
    c = self.commander
    find = c.findCommands
    ftm = c.findCommands.ftm
    searchSettings = param['searchSettings']
    # Find/change text boxes.
    table = (
        ('find_findbox', 'find_text', ''),
        ('find_replacebox', 'change_text', ''),
    )
    for widget_ivar, setting_name, default in table:
        w = getattr(ftm, widget_ivar)
        s = searchSettings.get(setting_name) or default
        w.clear()
        w.insert(s)
    # Check boxes.
    table = (
        ('ignore_case', 'check_box_ignore_case'),
        ('mark_changes', 'check_box_mark_changes'),
        ('mark_finds', 'check_box_mark_finds'),
        ('pattern_match', 'check_box_regexp'),
        ('search_body', 'check_box_search_body'),
        ('search_headline', 'check_box_search_headline'),
        ('whole_word', 'check_box_whole_word'),
    )
    for setting_name, widget_ivar in table:
        w = getattr(ftm, widget_ivar)
        val = searchSettings.get(setting_name)
        setattr(find, setting_name, val)
        if val != w.isChecked():
            w.toggle()
    # Radio buttons
    table = (
        ('node_only', 'node_only', 'radio_button_node_only'),
        ('entire_outline', None, 'radio_button_entire_outline'),
        ('suboutline_only', 'suboutline_only', 'radio_button_suboutline_only'),
    )
    for setting_name, ivar, widget_ivar in table:
        w = getattr(ftm, widget_ivar)
        val = searchSettings.get(setting_name, False)
        if ivar is not None:
            assert hasattr(find, setting_name), setting_name
            setattr(find, setting_name, val)
            if val != w.isChecked():
                w.toggle()
    # Ensure one radio button is set.
    w = ftm.radio_button_entire_outline
    if not searchSettings.get('node_only', False) and not searchSettings.get('suboutline_only', False):
        setattr(find, 'entire_outline', True)
        if not w.isChecked():
            w.toggle()
    else:
        setattr(find, 'entire_outline', False)
        if w.isChecked():
            w.toggle()

    # Confirm by sending back the settings to leointeg
    w_result = ftm.get_settings()
    return self.sendLeoBridgePackage({"searchSettings": w_result.__dict__})

</t>
<t tx="felix.20210523162125.1">/**
 * * Leo's GUI search settings internal structure
 */
export interface LeoGuiFindTabManagerSettings {
    // Nav options
    nav_text: string;
    is_tag: boolean;
    show_parents: boolean;
    search_options: number;
    //Find/change strings...
    find_text: string,
    change_text: string,
    // Find options...
    ignore_case: boolean,
    mark_changes: boolean,
    mark_finds: boolean,
    node_only: boolean,
    pattern_match: boolean,
    search_body: boolean,
    search_headline: boolean,
    suboutline_only: boolean,
    whole_word: boolean
}

</t>
<t tx="felix.20210524215215.1">/**
 * * Send the settings to the Leo Bridge Server
 * @param p_settings the search settings to be set server side to affect next results
 * @returns the promise from the server call
 */
public saveSearchSettings(p_settings: LeoSearchSettings): Promise&lt;LeoBridgePackage&gt; {
    this._lastSettingsUsed = p_settings;
    // convert to LeoGuiFindTabManagerSettings
    const w_settings: LeoGuiFindTabManagerSettings = {
        // Nav settings
        is_tag: p_settings.isTag,
        nav_text: p_settings.navText,
        show_parents: p_settings.showParents,
        search_options: p_settings.searchOptions,
        // Find/change strings...
        find_text: p_settings.findText,
        change_text: p_settings.replaceText,
        // Find options...
        ignore_case: p_settings.ignoreCase,
        mark_changes: p_settings.markChanges,
        mark_finds: p_settings.markFinds,
        node_only: !!(p_settings.searchScope === 2),
        pattern_match: p_settings.regExp,
        search_body: p_settings.searchBody,
        search_headline: p_settings.searchHeadline,
        suboutline_only: !!(p_settings.searchScope === 1),
        whole_word: p_settings.wholeWord,
    };
    return this.sendAction(
        Constants.LEOBRIDGE.SET_SEARCH_SETTINGS,
        JSON.stringify({ searchSettings: w_settings })
    );
}

</t>
<t tx="felix.20210524231157.1">/**
 * * Capture instance for further calls on find panel webview
 * @param p_panel The panel (usually that got the latest onDidReceiveMessage)
 */
public setFindPanel(p_panel: vscode.WebviewView): void {
    if (this._lastTreeView === this._leoTreeExView) {
        this._findPanelWebviewExplorerView = p_panel;
    } else {
        this._findPanelWebviewView = p_panel;
    }
}

</t>
<t tx="felix.20210525232728.1">/**
 * * Gets the search settings from Leo, and applies them to the find panel webviews
 */
public loadSearchSettings(): void {
    this.sendAction(Constants.LEOBRIDGE.GET_SEARCH_SETTINGS).then(
        (p_result: LeoBridgePackage) =&gt; {
            const w_searchSettings: LeoGuiFindTabManagerSettings = p_result.searchSettings!;
            const w_settings: LeoSearchSettings = {
                isTag: w_searchSettings.is_tag,
                navText: w_searchSettings.nav_text,
                showParents: w_searchSettings.show_parents,
                searchOptions: w_searchSettings.search_options,
                //Find/change strings...
                findText: w_searchSettings.find_text,
                replaceText: w_searchSettings.change_text,
                // Find options...
                wholeWord: w_searchSettings.whole_word,
                ignoreCase: w_searchSettings.ignore_case,
                regExp: w_searchSettings.pattern_match,
                markFinds: w_searchSettings.mark_finds,
                markChanges: w_searchSettings.mark_changes,
                searchHeadline: w_searchSettings.search_headline,
                searchBody: w_searchSettings.search_body,
                // 0, 1 or 2 for outline, sub-outline, or node.
                searchScope:
                    0 +
                    (w_searchSettings.suboutline_only ? 1 : 0) +
                    (w_searchSettings.node_only ? 2 : 0),
            };
            if (w_settings.searchScope &gt; 2) {
                console.error('searchScope SHOULD BE 0, 1, 2 only: ', w_settings.searchScope);
            }
            this._lastSettingsUsed = w_settings;
            if (this._findPanelWebviewExplorerView) {
                this._findPanelWebviewExplorerView.webview.postMessage({
                    type: 'setSettings',
                    value: w_settings,
                });
            }
            if (this._findPanelWebviewView) {
                this._findPanelWebviewView.webview.postMessage({
                    type: 'setSettings',
                    value: w_settings,
                });
            }
        }
    );
}

</t>
<t tx="felix.20210527225925.1">def find_next(self, param):
    """Run Leo's find-next command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    p, pos, newpos = fc.do_find_next(settings)
    found = True
    if not p:
        found = False
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": found, "pos": pos, "newpos": newpos,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210527225930.1">def find_previous(self, param):
    """Run Leo's find-previous command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    p, pos, newpos = fc.do_find_prev(settings)
    found = True
    if not p:
        found = False
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": found, "pos": pos, "newpos": newpos,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210528000603.1">def _show_find_success(self, c, in_headline, insert, p):
    '''Handle a successful find match.'''
    if in_headline:
        self.g.app.gui.set_focus(c, self.headlineWidget)
    # no return

</t>
<t tx="felix.20210528012836.1">/**
 * * Check if Leo should be focused on outline
 */
public getBridgeFocus(): void {
    this.sendAction(Constants.LEOBRIDGE.GET_FOCUS).then((p_resultFocus: LeoBridgePackage) =&gt; {
        if (p_resultFocus.focus) {
            const w_focus = p_resultFocus.focus.toLowerCase();
            if (w_focus.includes('tree') || w_focus.includes('head')) {
                this._fromOutline = true;
            }
        }
    });
}

</t>
<t tx="felix.20210530153353.1">{
  "command": "leointeg.startSearch",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findNext",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findPrevious",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findVar",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findDef",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.replace",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.replaceThenFind",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.replaceAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.setFindEverywhereOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.setFindNodeOnlyOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.setFindSuboutlineOnlyOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindIgnoreCaseOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindMarkChangesOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindMarkFindsOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindRegexpOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindWordOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindSearchBodyOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindSearchHeadlineOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.gotoGlobalLine",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindAllFlattened",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindFlattenedMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindTag",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.tagChildren",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20210530153359.1">{
  "command": "leointeg.copyMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.diffMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markChangedItems",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markSubheads",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.unmarkAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.deleteMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveMarkedNodes",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20210530160638.1">{
  "command": "leointeg.extract",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.extractNames",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20210530161800.1">{
  "command": "leointeg.findNextFromOutline",
  "when": "false"
},
{
  "command": "leointeg.findPreviousFromOutline",
  "when": "false"
},
{
  "command": "leointeg.replaceFromOutline",
  "when": "false"
},
{
  "command": "leointeg.replaceThenFindFromOutline",
  "when": "false"
}
</t>
<t tx="felix.20210530223726.1">/**
 * * Replace / Replace-Then-Find commands
 * @param p_fromOutline
 * @param p_thenFind
 * @returns Promise that resolves when the "launch refresh" is started
 */
public replace(p_fromOutline: boolean, p_thenFind: boolean): Promise&lt;any&gt; {
    const w_action: string = p_thenFind
        ? Constants.LEOBRIDGE.REPLACE_THEN_FIND
        : Constants.LEOBRIDGE.REPLACE;
    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(w_action, JSON.stringify({ fromOutline: !!p_fromOutline }));
        })
        .then((p_replaceResult: LeoBridgePackage) =&gt; {
            if (!p_replaceResult.found || !p_replaceResult.focus) {
                vscode.window.showInformationMessage('Not found');
            } else {
                let w_focusOnOutline = false;
                const w_focus = p_replaceResult.focus.toLowerCase();
                if (w_focus.includes('tree') || w_focus.includes('head')) {
                    // tree
                    w_focusOnOutline = true;
                }
                this.launchRefresh(
                    {
                        tree: true,
                        body: true,
                        scroll: true,
                        documents: false,
                        buttons: false,
                        states: true,
                    },
                    w_focusOnOutline
                );
            }
        });
}

</t>
<t tx="felix.20210530225306.1">/**
 * * Set search setting in the search webview
 * @param p_id string id of the setting name
 */
public setSearchSetting(p_id: string): void {
    let w_panel: vscode.WebviewView | undefined;
    if (this._lastTreeView === this._leoTreeExView) {
        w_panel = this._findPanelWebviewExplorerView;
    } else {
        w_panel = this._findPanelWebviewView;
    }
    w_panel!.webview.postMessage({ type: 'setSearchSetting', id: p_id });
}

</t>
<t tx="felix.20210530225640.1"></t>
<t tx="felix.20210530230354.1">/**
 * * Find / Replace All
 * @returns Promise of LeoBridgePackage from execution or undefined if cancelled
 */
public findAll(p_replace: boolean): Promise&lt;any&gt; {
    const w_action: string = p_replace
        ? Constants.LEOBRIDGE.REPLACE_ALL
        : Constants.LEOBRIDGE.FIND_ALL;

    let w_searchString: string = this._lastSettingsUsed!.findText;
    let w_replaceString: string = this._lastSettingsUsed!.replaceText;

    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            return this._inputFindPattern()
                .then((p_findString) =&gt; {
                    if (!p_findString) {
                        return true; // Cancelled with escape or empty string.
                    }
                    w_searchString = p_findString;
                    if (p_replace) {
                        return this._inputFindPattern(true).then((p_replaceString) =&gt; {
                            if (p_replaceString === undefined) {
                                return true;
                            }
                            w_replaceString = p_replaceString;
                            return false;
                        });
                    }
                    return false;
                });
        })
        .then((p_cancelled: boolean) =&gt; {
            if (this._lastSettingsUsed &amp;&amp; !p_cancelled) {
                this._lastSettingsUsed.findText = w_searchString;
                this._lastSettingsUsed.replaceText = w_replaceString;
                this.saveSearchSettings(this._lastSettingsUsed); // No need to wait, will be stacked.
                return this.sendAction(w_action)
                    .then((p_findResult: LeoBridgePackage) =&gt; {
                        let w_focusOnOutline = false;
                        const w_focus = p_findResult.focus!.toLowerCase();
                        if (w_focus.includes('tree') || w_focus.includes('head')) {
                            // tree
                            w_focusOnOutline = true;
                        }
                        this.loadSearchSettings();
                        this.launchRefresh(
                            { tree: true, body: true, documents: false, buttons: false, states: true },
                            w_focusOnOutline
                        );
                    });
            }
        });
}

</t>
<t tx="felix.20210530230400.1">/**
 * * Clone Find All / Marked / Flattened
 * @param p_marked flag for finding marked nodes
 * @param p_flat flag to get flattened results
 * @returns Promise of LeoBridgePackage from execution or undefined if cancelled
 */
public cloneFind(p_marked: boolean, p_flat: boolean): Promise&lt;any&gt; {
    let w_searchString: string = this._lastSettingsUsed!.findText;
    let w_action: string;
    if (p_marked) {
        w_action = p_flat
            ? Constants.LEOBRIDGE.CLONE_FIND_FLATTENED_MARKED
            : Constants.LEOBRIDGE.CLONE_FIND_MARKED;
    } else {
        w_action = p_flat
            ? Constants.LEOBRIDGE.CLONE_FIND_ALL_FLATTENED
            : Constants.LEOBRIDGE.CLONE_FIND_ALL;
    }

    if (p_marked) {
        // don't use find methods.
        return this.nodeCommand({
            action: w_action,
            node: undefined,
            refreshType: { tree: true, body: true, states: true },
            fromOutline: false,
        }) || Promise.resolve();
    }

    return this._isBusyTriggerSave(false, true)
        .then(() =&gt; {
            return this._inputFindPattern()
                .then((p_findString) =&gt; {
                    if (!p_findString) {
                        return true; // Cancelled with escape or empty string.
                    }
                    w_searchString = p_findString;
                    return false;
                });
        })
        .then((p_cancelled: boolean) =&gt; {
            if (this._lastSettingsUsed &amp;&amp; !p_cancelled) {
                this._lastSettingsUsed.findText = w_searchString;
                this.saveSearchSettings(this._lastSettingsUsed); // No need to wait, will be stacked.
                return this.sendAction(w_action)
                    .then((p_cloneFindResult: LeoBridgePackage) =&gt; {
                        let w_focusOnOutline = false;
                        const w_focus = p_cloneFindResult.focus!.toLowerCase();
                        if (w_focus.includes('tree') || w_focus.includes('head')) {
                            // tree
                            w_focusOnOutline = true;
                        }
                        this.loadSearchSettings();
                        this.launchRefresh(
                            { tree: true, body: true, documents: false, buttons: false, states: true },
                            w_focusOnOutline
                        );
                    });
            }
        });
}

</t>
<t tx="felix.20210530233134.1">/**
 * * Find panel controls ids
 */
public static FIND_INPUTS_IDS = {
    FIND_TEXT: "findText",
    REPLACE_TEXT: "replaceText",
    ENTIRE_OUTLINE: "entireOutline",
    NODE_ONLY: "nodeOnly",
    SUBOUTLINE_ONLY: "subOutlineOnly",
    IGNORE_CASE: "ignoreCase",
    MARK_CHANGES: "markChanges",
    MARK_FINDS: "markFinds",
    REG_EXP: "regExp",
    WHOLE_WORD: "wholeWord",
    SEARCH_BODY: "searchBody",
    SEARCH_HEADLINE: "searchHeadline"
};

</t>
<t tx="felix.20210531011702.1">def replace(self, param):
    """Run Leo's replace command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    fc.change(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": True,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210531011713.1">def replace_then_find(self, param):
    """Run Leo's replace then find next command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    result = fc.do_change_then_find(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": result,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210531011822.1">def replace_all(self, param):
    """Run Leo's replace all command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    result = fc.do_change_all(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": result,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210531214057.1">def clone_find_all(self, param):
    """Run Leo's clone-find-all command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    result = fc.do_clone_find_all(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": result,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210531214103.1">def clone_find_all_flattened(self, param):
    """Run Leo's clone-find-all-flattened command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    result = fc.do_clone_find_all_flattened(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": result,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)
</t>
<t tx="felix.20210601005209.1">def find_all(self, param):
    """Run Leo's find all command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    result = fc.do_find_all(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"found": result,
                "focus": focus, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210601151758.1">def find_var(self, param):
    """Run Leo's find-var command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    # todo : find var implementation
    print("todo : find var implementation")
    # result = fc.do_clone_find_all_flattened(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210601151804.1">def find_def(self, param):
    """Run Leo's find-def command and return results."""
    c = self.commander
    fc = c.findCommands
    settings = fc.ftm.get_settings()
    # todo : find def implementation
    print("todo : find def implementation")
    # result = fc.do_clone_find_all_flattened(settings)
    w = self.g.app.gui.get_focus()
    focus = self.g.app.gui.widget_name(w)
    w_result = {"node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210601152841.1">def goto_global_line(self, param):
    """Run Leo's goto-global-line command and return results."""
    c = self.commander
    junk_p, junk_offset, found = c.gotoCommands.find_file_line(
        n=int(param['line']))
    w_result = {"found": found, "node": self._p_to_ap(c.p)}
    return self.sendLeoBridgePackage(w_result)

</t>
<t tx="felix.20210601164915.1">/**
 * * Goto Global Line
 */
public gotoGlobalLine(): void {
    this.triggerBodySave(false)
        .then((p_saveResult: boolean) =&gt; {
            return vscode.window.showInputBox({
                title: Constants.USER_MESSAGES.TITLE_GOTO_GLOBAL_LINE,
                placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_GOTO_GLOBAL_LINE,
                prompt: Constants.USER_MESSAGES.PROMPT_GOTO_GLOBAL_LINE,
            });
        })
        .then((p_inputResult?: string) =&gt; {
            if (p_inputResult) {
                const w_line = parseInt(p_inputResult);
                if (!isNaN(w_line)) {
                    this.sendAction(
                        Constants.LEOBRIDGE.GOTO_GLOBAL_LINE,
                        JSON.stringify({ line: w_line })
                    ).then((p_resultGoto: LeoBridgePackage) =&gt; {
                        if (!p_resultGoto.found) {
                            // Not found
                        }
                        this.launchRefresh(
                            {
                                tree: true,
                                body: true,
                                documents: false,
                                buttons: false,
                                states: true,
                            },
                            false
                        );
                    });
                }
            }
        });
}

</t>
<t tx="felix.20210602151654.1">/**
 * * Overridden 'good' minibuffer commands
 */
public static MINIBUFFER_OVERRIDDEN_COMMANDS: { [key: string]: string } = {
    "tag-children": Constants.COMMANDS.TAG_CHILDREN,
    "clone-find-tag": Constants.COMMANDS.CLONE_FIND_TAG,
    "import-file": Constants.COMMANDS.IMPORT_ANY_FILE,
    "redo": Constants.COMMANDS.REDO,
    "undo": Constants.COMMANDS.UNDO,
    "clone-find-all": Constants.COMMANDS.CLONE_FIND_ALL,
    "clone-find-all-flattened": Constants.COMMANDS.CLONE_FIND_ALL_FLATTENED,

    'import-MORE-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-free-mind-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-jupyter-notebook': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-legacy-external-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-mind-jet-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-tabbed-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-todo-text-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-zim-folder': Constants.COMMANDS.IMPORT_ANY_FILE,

    'file-new': Constants.COMMANDS.NEW_FILE,
    'file-open-by-name': Constants.COMMANDS.OPEN_FILE,
    'new': Constants.COMMANDS.NEW_FILE,
    'open-outline': Constants.COMMANDS.OPEN_FILE,
    'file-save': Constants.COMMANDS.SAVE_FILE,
    'file-save-as': Constants.COMMANDS.SAVE_AS_FILE,
    'file-save-as-leojs': Constants.COMMANDS.SAVE_AS_LEOJS,
    'file-save-as-unzipped': Constants.COMMANDS.SAVE_AS_FILE,
    'file-save-by-name': Constants.COMMANDS.SAVE_AS_FILE,
    'file-save-to': Constants.COMMANDS.SAVE_AS_FILE,
    'save': Constants.COMMANDS.SAVE_FILE,
    'save-as': Constants.COMMANDS.SAVE_AS_FILE,
    'save-file': Constants.COMMANDS.SAVE_FILE,
    'save-file-as': Constants.COMMANDS.SAVE_AS_FILE,
    'save-file-as-leojs': Constants.COMMANDS.SAVE_AS_LEOJS,
    'save-file-as-unzipped': Constants.COMMANDS.SAVE_AS_FILE,
    'save-file-by-name': Constants.COMMANDS.SAVE_AS_FILE,
    'save-file-to': Constants.COMMANDS.SAVE_AS_FILE,
    'save-to': Constants.COMMANDS.SAVE_AS_FILE,

    'clone-find-all-flattened-marked': Constants.COMMANDS.CLONE_FIND_FLATTENED_MARKED,
    'clone-find-all-marked': Constants.COMMANDS.CLONE_FIND_MARKED,

    'clone-marked-nodes': Constants.COMMANDS.CLONE_MARKED_NODES,

    'cfa': Constants.COMMANDS.CLONE_FIND_ALL,
    'cfam': Constants.COMMANDS.CLONE_FIND_MARKED,
    'cff': Constants.COMMANDS.CLONE_FIND_ALL_FLATTENED,
    'cffm': Constants.COMMANDS.CLONE_FIND_FLATTENED_MARKED,
    'cft': Constants.COMMANDS.CLONE_FIND_TAG,

    'git-diff': Constants.COMMANDS.GIT_DIFF,
    'gd': Constants.COMMANDS.GIT_DIFF,

    'find-tab-open': Constants.COMMANDS.START_SEARCH,
    'find-clone-all': Constants.COMMANDS.CLONE_FIND_ALL,
    'find-clone-all-flattened': Constants.COMMANDS.CLONE_FIND_ALL_FLATTENED,
    'find-clone-tag': Constants.COMMANDS.CLONE_FIND_TAG,
    'find-all': Constants.COMMANDS.FIND_ALL,
    'start-search': Constants.COMMANDS.START_SEARCH,
    'find-next': Constants.COMMANDS.FIND_NEXT,
    'find-prev': Constants.COMMANDS.FIND_PREVIOUS,
    'search-backward': Constants.COMMANDS.FIND_NEXT,
    'search-forward': Constants.COMMANDS.FIND_PREVIOUS,
    'find-var': Constants.COMMANDS.FIND_VAR,
    'find-def': Constants.COMMANDS.FIND_DEF,
    'replace': Constants.COMMANDS.REPLACE,
    'replace-all': Constants.COMMANDS.REPLACE_ALL,
    'change-all': Constants.COMMANDS.REPLACE_ALL,
    'change-then-find': Constants.COMMANDS.REPLACE_THEN_FIND,
    'replace-then-find': Constants.COMMANDS.REPLACE_THEN_FIND,
    'show-find-options': Constants.COMMANDS.START_SEARCH,
    'toggle-find-ignore-case-option': Constants.COMMANDS.TOGGLE_FIND_IGNORE_CASE_OPTION,
    'toggle-find-in-body-option': Constants.COMMANDS.TOGGLE_FIND_SEARCH_BODY_OPTION,
    'toggle-find-in-headline-option': Constants.COMMANDS.TOGGLE_FIND_SEARCH_HEADLINE_OPTION,
    'toggle-find-mark-changes-option': Constants.COMMANDS.TOGGLE_FIND_MARK_CHANGES_OPTION,
    'toggle-find-mark-finds-option': Constants.COMMANDS.TOGGLE_FIND_MARK_FINDS_OPTION,
    'toggle-find-regex-option': Constants.COMMANDS.TOGGLE_FIND_REGEXP_OPTION,
    'toggle-find-word-option': Constants.COMMANDS.TOGGLE_FIND_WORD_OPTION,

    'goto-next-history-node': Constants.COMMANDS.PREV_NODE,
    'goto-prev-history-node': Constants.COMMANDS.NEXT_NODE,


};

</t>
<t tx="felix.20210602155312.1">/**
 * * Import any File(s)
 * No URL passed from the command definition.
 * @param p_leoFileUri is offered for internal use only
 */
public importAnyFile(p_leoFileUri?: vscode.Uri): Thenable&lt;unknown&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            let q_importFile: Promise&lt;LeoBridgePackage | undefined&gt;; // Promise for opening a file
            if (p_leoFileUri &amp;&amp; p_leoFileUri.fsPath.trim()) {
                const w_fixedFilePath: string = p_leoFileUri.fsPath.replace(/\\/g, '/');
                q_importFile = this.sendAction(
                    Constants.LEOBRIDGE.IMPORT_ANY_FILE,
                    JSON.stringify({ filenames: w_fixedFilePath })
                );
            } else {
                q_importFile = this._leoFilesBrowser.getImportFileUrls().then(
                    (p_chosenLeoFiles) =&gt; {
                        if (p_chosenLeoFiles.length) {
                            return this.sendAction(
                                Constants.LEOBRIDGE.IMPORT_ANY_FILE,
                                JSON.stringify({ filenames: p_chosenLeoFiles })
                            );
                        } else {
                            return Promise.resolve(undefined);
                        }
                    },
                    (p_errorGetFile) =&gt; {
                        return Promise.reject(p_errorGetFile);
                    }
                );
            }
            return q_importFile;
        })
        .then(
            (p_importFileResult: LeoBridgePackage | undefined) =&gt; {
                if (p_importFileResult) {
                    return this.launchRefresh(
                        {
                            tree: true,
                            body: true,
                            documents: true,
                            buttons: false,
                            states: true,
                        },
                        false
                    );
                } else {
                    return Promise.resolve(undefined);
                }
            },
            (p_errorImport) =&gt; {
                console.log('in .then not imported'); // TODO : IS REJECTION BEHAVIOR NECESSARY HERE TOO?
                return Promise.reject(p_errorImport);
            }
        );
}

</t>
<t tx="felix.20210602160216.1">/**
 * * Open a file browser to let user choose file(s) to import
 * @param p_fileType can be used to restrict to a particular file type
 * @returns a promise of an array of filepath+name strings
 */
public getImportFileUrls(p_fileType?: string): Promise&lt;string[]&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve([]);
    }
    this._fileBrowserActive = true;
    let w_types: { [name: string]: string[]; };
    if (p_fileType &amp;&amp; Constants.IMPORT_FILE_TYPES[p_fileType]) {
        w_types = {};
        w_types[p_fileType] = Constants.IMPORT_FILE_TYPES[p_fileType];
    } else {
        w_types = Constants.IMPORT_FILE_TYPES;
    }
    return new Promise((p_resolve, p_reject) =&gt; {
        vscode.window
            .showOpenDialog({
                canSelectMany: true,
                openLabel: "Import File",
                canSelectFolders: false,
                filters: w_types,
                defaultUri: this._getBestOpenFolderUri()
            })
            .then(p_chosenLeoFiles =&gt; {
                this._fileBrowserActive = false;
                if (p_chosenLeoFiles) {
                    // array instead of single string
                    const w_result = p_chosenLeoFiles.map(function (e) {
                        return e.fsPath.replace(/\\/g, "/").trim();
                    });
                    p_resolve(w_result); // Replace backslashes for windows support
                } else {
                    p_resolve([]);
                }
            });
    });
}
</t>
<t tx="felix.20210602203830.1">def import_any_file(self, param):
    """
    Import file(s) from array of file names
    """
    c = self.commander
    g = self.g
    ic = c.importCommands
    names = param.get('filenames')
    if names:
        g.chdir(names[0])
    if not names:
        return self._outputError("Error in import_any_file no filenames found")

    # New in Leo 4.9: choose the type of import based on the extension.
    derived = [z for z in names if c.looksLikeDerivedFile(z)]
    others = [z for z in names if z not in derived]
    if derived:
        ic.importDerivedFiles(parent=c.p, paths=derived)
    for fn in others:
        junk, ext = g.os_path_splitext(fn)
        ext = ext.lower()  # #1522
        if ext.startswith('.'):
            ext = ext[1:]
        if ext == 'csv':
            ic.importMindMap([fn])
        elif ext in ('cw', 'cweb'):
            ic.importWebCommand([fn], "cweb")
        # Not useful. Use @auto x.json instead.
        # elif ext == 'json':
            # ic.importJSON([fn])
        elif fn.endswith('mm.html'):
            ic.importFreeMind([fn])
        elif ext in ('nw', 'noweb'):
            ic.importWebCommand([fn], "noweb")
        elif ext == 'more':
            # (Félix) leoImport Should be on c?
            c.leoImport.MORE_Importer(c).import_file(fn)  # #1522.
        elif ext == 'txt':
            # (Félix) import_txt_file Should be on c?
            # #1522: Create an @edit node.
            c.import_txt_file(c, fn)
        else:
            # Make *sure* that parent.b is empty.
            last = c.lastTopLevel()
            parent = last.insertAfter()
            parent.v.h = 'Imported Files'
            ic.importFilesCommand(
                files=[fn],
                parent=parent,
                treeType='@auto',  # was '@clean'
                # Experimental: attempt to use permissive section ref logic.
            )
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20210602213308.1">/**
 * * Possible import file types
 */
public static IMPORT_FILE_TYPES: { [name: string]: string[]; } = {
    "All files": ["*"],
    "C/C++ files": ["c", "cpp", "h", "hpp"],
    "FreeMind files": ["mm.html"],
    "Java files": ["java"],
    "JavaScript files": ["js"],
    // "JSON files": ["json"],
    "Mindjet files": ["csv"],
    "MORE files": ["MORE"],
    "Lua files": ["lua"],
    "Pascal files": ["pas"],
    "Python files": ["py"],
    "Text files": ["txt"],
};

</t>
<t tx="felix.20210610022645.1">"editor/title": [
  {
    "command": "leointeg.showSettingsPage",
    "when": "resourceScheme == leo",
    "group": "2_custom"
  },
  {
    "command": "leointeg.prev",
    "when": "resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.next",
    "when": "resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.hoistSelection",
    "when": "showHoistOnBody &amp;&amp; !leoRoot &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@3"
  },
  {
    "command": "leointeg.deHoist",
    "when": "showHoistOnBody &amp;&amp; leoCanDehoist &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@4"
  },
  {
    "command": "leointeg.promoteSelection",
    "when": "showPromoteOnBody &amp;&amp; leoCanPromote &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leointeg.demoteSelection",
    "when": "showPromoteOnBody &amp;&amp; leoCanDemote &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@6"
  },
  {
    "command": "leointeg.executeScript",
    "when": "showExecuteOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@7"
  },
  {
    "command": "leointeg.extract",
    "when": "showExtractOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@8"
  },
  {
    "command": "leointeg.extractNames",
    "when": "showExtractOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@9"
  },
  {
    "command": "leointeg.cloneNodeSelection",
    "when": "showEditionOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@10"
  },
  {
    "command": "leointeg.insertNodeSelection",
    "when": "showEditionOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@11"
  },
  {
    "command": "leointeg.insertChildNodeSelection",
    "when": "showEditionOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@12"
  },
  {
    "command": "leointeg.deleteSelection",
    "when": "showEditionOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@13"
  },
  {
    "command": "leointeg.cutNodeSelection",
    "when": "showClipboardOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@14"
  },
  {
    "command": "leointeg.copyNodeSelection",
    "when": "showClipboardOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@15"
  },
  {
    "command": "leointeg.pasteNodeAtSelection",
    "when": "showClipboardOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@16"
  },
  {
    "command": "leointeg.pasteNodeAsCloneAtSelection",
    "when": "showClipboardOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@17"
  },
  {
    "command": "leointeg.markSelection",
    "when": "showMarkOnBody &amp;&amp; !leoMarked  &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@18"
  },
  {
    "command": "leointeg.unmarkSelection",
    "when": "showMarkOnBody &amp;&amp; leoMarked  &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@19"
  },
  {
    "command": "leointeg.sortSiblingsSelection",
    "when": "showSortOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@20"
  },
  {
    "command": "leointeg.importAnyFile",
    "when": "showImportOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@21"
  },
  {
    "command": "leointeg.refreshFromDiskSelection",
    "when": "showRefreshOnBody &amp;&amp; leoAtFile &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@22"
  }
],
</t>
<t tx="felix.20210610022836.1">/**
 * * Previous / Next Node Buttons
 * @param p_next Flag to mean 'next' instead of default 'previous'
 * @returns the promise from the command sent to the leo bridge
 */
public prevNextNode(p_next: boolean, p_fromOutline?: boolean): Promise&lt;any&gt; {
    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            let w_command: string;
            if (p_next) {
                w_command = Constants.LEOBRIDGE.GOTO_NEXT_HISTORY;
            } else {
                w_command = Constants.LEOBRIDGE.GOTO_PREV_HISTORY;
            }
            return this.nodeCommand({
                action: w_command,
                node: undefined,
                refreshType: { tree: true, states: true, body: true },
                fromOutline: !!p_fromOutline,
            });
        });
}

</t>
<t tx="felix.20210612000127.1">## 0.1.14

- Rewrite of the leobridgeserver script to be made compatible with the standards in leoserver script from Leo.
- Added option for specifying server file and path. Defaults to the internal leobridgeserver server script.
- Fixed cursor position and selection bugs.
- Fixed automatic server startup and connection bugs.
- Added Search functionality along with a 'find' panel.
- Added goto global line and other clone-find related commands from Leo's 'Search' menu.
- Added import-file(s) command - an alias of the import-any-file command form Leo.
- Temporary fix for some minibuffer commands to override the widgets interactions (ex. clone-find-all, etc.)
- Undo and redo icons are now faded out instead of disappearing when unavailable - to help with button shifting when clicking rapidly.
- Many other small bugfixes.

</t>
<t tx="felix.20210612214028.1">/**
 * * Find next available port starting with p_startingPort inclusively,
 * * check next (max 5) additional ports and return port number, or 0 if none.
 * @param p_startingPort the port number at which to start looking for a free port
 * @returns a promise of an opened port number
 */
export function findNextAvailablePort(p_startingPort: number): Promise&lt;number&gt; {
    return portfinder.getPortPromise({
        port: p_startingPort,
        startPort: p_startingPort,
        stopPort: p_startingPort + 5
    });
}

</t>
<t tx="felix.20210613205741.1">/**
 * * Get a find pattern string input from the user
 * @param p_replace flag for doing a 'replace' instead of a 'find'
 * @returns Promise of string or undefined if cancelled
 */
private _inputFindPattern(p_replace?: boolean): Thenable&lt;string | undefined&gt; {
    return vscode.window.showInputBox({
        title: p_replace ? "Replace with" : "Search for",
        prompt: p_replace ? "Type text to replace with and press enter." : "Type text to search for and press enter.",
        placeHolder: p_replace ? "Replace pattern here" : "Find pattern here",
    });
}

</t>
<t tx="felix.20210613210351.1">/**
 * * Popup browser to choose Leo-Editor installation folder path
 */
public chooseLeoFolder(): void {
    utils.chooseLeoFolderDialog().then(p_chosenPath =&gt; {
        if (p_chosenPath &amp;&amp; p_chosenPath.length) {
            this.config.setLeoIntegSettings(
                [{
                    code: Constants.CONFIG_NAMES.LEO_EDITOR_PATH,
                    value: p_chosenPath[0].fsPath
                }]
            ).then(() =&gt; {
                this.leoSettingsWebview.changedConfiguration();
                vscode.window.showInformationMessage("Leo-Editor installation folder chosen as " + p_chosenPath[0].fsPath);
                if (!this.leoStates.leoStartupFinished &amp;&amp; this.config.startServerAutomatically) {
                    this.startServer();
                }
            });
        }
    });
}

</t>
<t tx="felix.20210613212439.1"></t>
<t tx="felix.20210614235023.1">/**
 * * Shows dialog for choosing the Leo Editor installation folder path
 * @returns A promise that resolves to the selected resources or undefined
 */
export function chooseLeoFolderDialog(): Thenable&lt;vscode.Uri[] | undefined&gt; {
    return vscode.window.showOpenDialog(
        {
            title: "Locate Leo-Editor Installation Folder",
            canSelectMany: false,
            openLabel: "Choose Folder",
            canSelectFiles: false,
            canSelectFolders: true
        }
    );
}

</t>
<t tx="felix.20210620213815.1">def clone_find_tag(self, param):
    """Run Leo's clone-find-tag command and return results."""
    tag = 'clone_find_tag'
    c = self.commander
    fc = c.findCommands
    the_tag = param.get("tag")
    if the_tag:
        settings = fc.ftm.get_settings()
        n, p = fc.do_clone_find_tag(settings)
    return self.sendLeoBridgePackage({"n": n})

</t>
<t tx="felix.20210620213822.1">def tag_children(self, param):
    """Run Leo's tag-children command"""
    # This is not a find command!
    c = self.commander
    fc = c.findCommands
    the_tag = param.get("tag")
    if the_tag:
        fc.do_tag_children(c.p, the_tag)
    return self.sendLeoBridgePackage()

</t>
<t tx="felix.20210620220655.1">/**
 * * Tag Children
 */
public tagChildren(): void {
    this.triggerBodySave(false)
        .then((p_saveResult: boolean) =&gt; {
            return vscode.window.showInputBox({
                title: Constants.USER_MESSAGES.TITLE_TAG_CHILDREN,
                placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_TAG_CHILDREN,
                prompt: Constants.USER_MESSAGES.PROMPT_TAG_CHILDREN,
            });
        })
        .then((p_inputResult?: string) =&gt; {
            if (p_inputResult &amp;&amp; p_inputResult.trim()) {
                this.sendAction(
                    Constants.LEOBRIDGE.TAG_CHILDREN,
                    JSON.stringify({ tag: p_inputResult.trim() })
                ).then((p_resultFind: LeoBridgePackage) =&gt; {
                    if (!p_resultFind.found) {
                        // Not found
                    }
                    this.launchRefresh(
                        {
                            tree: true,
                            body: true,
                            documents: false,
                            buttons: false,
                            states: true,
                        },
                        false
                    );
                });
            }
        });
}

</t>
<t tx="felix.20210620220702.1">/**
 * * Clone Find Tag
 */
public cloneFindTag(): void {
    this.triggerBodySave(false)
        .then((p_saveResult: boolean) =&gt; {
            return vscode.window.showInputBox({
                title: Constants.USER_MESSAGES.TITLE_FIND_TAG,
                placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_CLONE_FIND_TAG,
                prompt: Constants.USER_MESSAGES.PROMPT_CLONE_FIND_TAG,
            });
        })
        .then((p_inputResult?: string) =&gt; {
            if (p_inputResult &amp;&amp; p_inputResult.trim()) {
                this.sendAction(
                    Constants.LEOBRIDGE.CLONE_FIND_TAG,
                    JSON.stringify({ tag: p_inputResult.trim() })
                ).then((p_resultFind: LeoBridgePackage) =&gt; {
                    if (!p_resultFind.found) {
                        // Not found
                    }
                    this.launchRefresh(
                        {
                            tree: true,
                            body: true,
                            documents: false,
                            buttons: false,
                            states: true,
                        },
                        false
                    );
                });
            }
        });
}

</t>
<t tx="felix.20210703013251.1">"leoIntegration.showEditionOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows clone, delete and insert nodes above the body pane"
},
"leoIntegration.showClipboardOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows cut, copy &amp; paste nodes above the body pane"
},
"leoIntegration.showPromoteOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows promote and demote above the body pane"
},
"leoIntegration.showExecuteOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Execute Script' above the body pane"
},
"leoIntegration.showExtractOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows extract commands above the body pane"
},
"leoIntegration.showImportOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Import File' above the body pane"
},
"leoIntegration.showRefreshOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Refresh from disk' above the body pane"
},
"leoIntegration.showHoistOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows Hoist commands above the body pane"
},
"leoIntegration.showMarkOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows Mark commands above the body pane"
},
"leoIntegration.showSortOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Sort Siblings' above the body pane"
},
</t>
<t tx="felix.20210706233101.1">/**
 * * Unique numeric Id
 */
var uniqueId: number = 0;

</t>
<t tx="felix.20210706233106.1">/**
 * * Get new uniqueID
 */
export function getUniqueId(): string {
    const id = uniqueId++;
    return id.toString();
}

</t>
<t tx="felix.20210709004123.1">{
  "command": "leointeg.statusBar",
  "when": "false"
},
</t>
<t tx="felix.20210713000442.1">/**
 * * find-var or find-def commands
 * @param p_def find-def instead of find-var
 * @returns Promise that resolves when the "launch refresh" is started
 */
public findSymbol(p_def: boolean): Promise&lt;any&gt; {
    const w_action: string = p_def
        ? Constants.LEOBRIDGE.FIND_DEF
        : Constants.LEOBRIDGE.FIND_VAR;
    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(w_action, JSON.stringify({ fromOutline: false }));
        })
        .then((p_findResult: LeoBridgePackage) =&gt; {
            if (!p_findResult.found || !p_findResult.focus) {
                vscode.window.showInformationMessage('Not found');
            } else {
                let w_focusOnOutline = false;
                const w_focus = p_findResult.focus.toLowerCase();
                if (w_focus.includes('tree') || w_focus.includes('head')) {
                    // tree
                    w_focusOnOutline = true;
                }
                this.loadSearchSettings();
                this.launchRefresh(
                    {
                        tree: true,
                        body: true,
                        scroll: p_findResult.found &amp;&amp; !w_focusOnOutline,
                        documents: false,
                        buttons: false,
                        states: true,
                    },
                    w_focusOnOutline
                );
            }
        });
}

</t>
<t tx="felix.20210713005825.1">"editor/context": [
  {
    "command": "leointeg.findVar",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.findDef",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.extract",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.extractNames",
    "when": "editorHasSelection &amp;&amp; !editorHasMultipleSelections &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  }
],
</t>
<t tx="felix.20210717192921.1">/**
 * * Kills the server if it was started by this instance of leoInteg
 */
public killServer(): void {
    if (this._serverProcess) {
        // this._serverProcess.kill(); // Replaced by the tree-kill lib
        kill(this._serverProcess.pid);
        this._isStarted = false;
        if (!this._leoIntegration.activated) {
            return;
        }
        utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);
        this._serverProcess = undefined;
    } else {
        console.error("No Server");
    }
}

</t>
<t tx="felix.20210717204048.1">/**
 * * Kills the server process if it was started by this instance of the extension
 */
public killServer(): void {
    this._serverService.killServer();
}

</t>
<t tx="felix.20210718155134.1">/**
 * * cleanupBody closes all remaining body pane to shut down this vscode window
 * @returns a promise that resolves when done saving and closing
 */
public cleanupBody(): Thenable&lt;any&gt; {
    let q_save: Thenable&lt;any&gt;;
    //
    if (this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty &amp;&amp;
        utils.leoUriToStr(this.bodyUri) === utils.leoUriToStr(this._bodyLastChangedDocument.uri)
    ) {
        q_save = this._bodySaveDeactivate(this._bodyLastChangedDocument);
    } else {
        q_save = Promise.resolve(true);
    }

    // Adding log in the chain of events
    let q_edit: Thenable&lt;boolean&gt;;
    if (this.bodyUri) {
        const w_edit = new vscode.WorkspaceEdit();
        w_edit.deleteFile(this.bodyUri, { ignoreIfNotExists: true });
        q_edit = vscode.workspace.applyEdit(w_edit).then(() =&gt; {
            // console.log('applyEdit done');
            return true;
        }, () =&gt; {
            // console.log('applyEdit failed');
            return false;
        });
    } else {
        q_edit = Promise.resolve(true);
    }
    Promise.all([q_save, q_edit])
        .then(() =&gt; {
            // console.log('cleaned both');
            return this.closeBody();
        }, () =&gt; {
            // console.log('cleaned both failed');
            return true;
        });

    return q_save;
}

</t>
<t tx="felix.20210718163005.1">## 0.1.15

- Modified server location logic
- Fixed find-prev, next, find all / clone-find commands
- Fixed extract name command.
- Fixed body being re-written to same string and being marked dirty when 'safety-saving' before switching docs.
- Detection of .Leo documents themselves now works by closing and re-opening the .leo file if reloading is chosen by the user. (or automatic via options)
- Added icons and commands for top of body pane menu.
- Added new commands such as insert-child along with their keybindings.
- Also added more keybindings to the 'insert-node' command such as 'insert' and 'shift-insert'.
- Added find-var and find-def commands.
- Made some text-related commands available through the right-click context menu in the body pane. (extract, find-var, find-def, etc.)

</t>
<t tx="felix.20210725153617.1">## 0.1.16

- Added procedures to cleanup when closing a vscode window. (closes server and body panes)

</t>
<t tx="felix.20210725221438.1">function onVscodeInputChanged(element: HTMLInputElement) {
    if (element.id === "zoomLevel") {
        frontFontConfig.zoomLevel = element.valueAsNumber;
    }
    if (element.id === "editorFontSize") {
        frontFontConfig.fontSize = element.valueAsNumber;
    }
    applyFontChanges();
}

</t>
<t tx="felix.20210725221447.1">function setFontControls(): void {
    if (frontFontConfig.zoomLevel || frontFontConfig.zoomLevel === 0) {
        const w_element = document.getElementById("zoomLevel");
        (w_element as HTMLInputElement).valueAsNumber = Number(frontFontConfig.zoomLevel);
    } else {
        console.log('Error : vscode font setting "zoomLevel" is missing');
    }
    if (frontFontConfig.fontSize) {
        const w_element = document.getElementById("editorFontSize");
        (w_element as HTMLInputElement).valueAsNumber = Number(frontFontConfig.fontSize);
    } else {
        console.log('Error : vscode font setting "fontSize" is missing');
    }
}

</t>
<t tx="felix.20210727224122.1">/**
 * * Get config from vscode for the UI font sizes
 * @returns the font settings object (zoom level and editor font size)
 */
public getFontConfig(): FontSettings {
    let w_zoomLevel = vscode.workspace.getConfiguration(
        "window"
    ).get("zoomLevel");
    let w_fontSize = vscode.workspace.getConfiguration(
        "editor"
    ).get("fontSize");

    const w_config: FontSettings = {
        zoomLevel: Number(w_zoomLevel),
        fontSize: Number(w_fontSize)
    };
    return w_config;
}

</t>
<t tx="felix.20210727224135.1">/**
 * * Apply changes in font size settings and save them in user settings.
 */
public setFontConfig(p_settings: FontSettings): void {
    if (p_settings.zoomLevel || p_settings.zoomLevel === 0) {
        if (!isNaN(p_settings.zoomLevel) &amp;&amp; p_settings.zoomLevel &lt;= 12 &amp;&amp; p_settings.zoomLevel &gt;= -12) {
            vscode.workspace.getConfiguration("window")
                .update("zoomLevel", p_settings.zoomLevel, true);
        } else {
            vscode.window.showInformationMessage(
                "Value for zoom level should be between -12 and 12"
            );
        }
    }
    if (p_settings.fontSize) {
        if (!isNaN(p_settings.fontSize) &amp;&amp; p_settings.fontSize &lt;= 30 &amp;&amp; p_settings.fontSize &gt;= 6) {
            vscode.workspace.getConfiguration("editor")
                .update("fontSize", p_settings.fontSize, true);
        } else {
            vscode.window.showInformationMessage(
                "Value for font size should be between 6 and 30"
            );
        }
    }
}

</t>
<t tx="felix.20210727224655.1">export interface FontSettings {
    zoomLevel: number;
    fontSize: number;
}

</t>
<t tx="felix.20210727225050.1">/**
 * * For simple interactions in webviews into vscode API
 */
export interface IVsCodeApi {
    postMessage(msg: {}): void;
    setState(state: {}): void;
    getState(): { [key: string]: any };
}

</t>
<t tx="felix.20210802162424.1">/**
 * * Disconnects from the server
 */
public stopConnection(): void {
    this._leoBridge.closeLeoProcess();
}

</t>
<t tx="felix.20210802163703.1">/**
 * * Closes the websocket connection
 */
public closeLeoProcess(): void {
    if (this._websocket) {
        this._websocket.close(1001, "Quitting LeoInteg");
        // console.log('websocket closed');
    } else {
        // console.warn('LeoInteg websocket close called without websocket active');
    }
}

</t>
<t tx="felix.20210804175113.1">/**
 * * Server announced the multi-user content changed: Debounce a refresh cycle.
 * The 'action' string can be checked to determine what kind, if any, is required.
 * Note: 'Getters' and the 'do_nothing' actions are NOT shared by the server.
 * @param p_serverPackage the package sent along by the server
 */
public refresh(p_serverPackage: any): void {
    if (p_serverPackage.opened &amp;&amp; this._leoIntegration.leoStates.fileOpenedReady) {
        this._leoIntegration.refreshAll();
    } else if (p_serverPackage.opened &amp;&amp; !this._leoIntegration.leoStates.fileOpenedReady) {
        this._leoIntegration.sendAction(Constants.LEOBRIDGE.DO_NOTHING)
            .then((p_doNothingPackage) =&gt; {
                p_doNothingPackage.filename = p_doNothingPackage.commander!.fileName;
                this._leoIntegration.setupOpenedLeoDocument(p_doNothingPackage, true);
            });
    } else {
        this._leoIntegration.setupNoOpenedLeoDocument();
    }
}

</t>
<t tx="felix.20210806175431.1">/**
 * * Sets new body text on leo's side before vscode closes itself if body is dirty
 * @param p_document Vscode's text document which content will be used to be the new node's body text in Leo
 * @returns a promise that resolves when the complete saving process is finished
 */
private _bodySaveDeactivate(
    p_document: vscode.TextDocument
): Promise&lt;LeoBridgePackage&gt; {
    const w_param = {
        gnx: utils.leoUriToStr(p_document.uri),
        body: p_document.getText(),
    };
    return this.sendAction(Constants.LEOBRIDGE.SET_BODY, JSON.stringify(w_param));
}

</t>
<t tx="felix.20210812004050.1">{
  "command": "workbench.files.action.collapseExplorerFolders",
  "key": "alt+-",
  "when": "!inSearchEditor &amp;&amp; !sideBarFocus &amp;&amp; resourceScheme == untitled || !inSearchEditor &amp;&amp; !sideBarFocus &amp;&amp; resourceScheme == file || !inSearchEditor &amp;&amp; explorerViewletFocus"
}
</t>
<t tx="felix.20210816230003.1">## 0.1.17

- Saves recently opened Leo files list per workspace, instead of globally.
- Changed the default visible command icons above the body pane. Also makes sure 'settings' is visible.
- Added global zoom level and editor font-size in the LeoInteg settings panel to help change the body &amp; outline font sizes.
- Server now opens modal dialogs for saving dirty documents on exit.
- Added experimental server option settings (cwd, shell, detach) to help with various python setups.
- Server now started with a CWD of the current workspace by default (fixes git-diff).

</t>
<t tx="felix.20210818223534.1">/**
 * * Set the workbench.editor.enablePreview vscode setting
 */
public setEnablePreview(): Thenable&lt;void&gt; {
    return vscode.workspace.getConfiguration("workbench.editor")
        .update("enablePreview", true, true);
}

</t>
<t tx="felix.20210818225820.1">/**
 * * Check if the workbench.editor.enablePreview flag is set
 * @param p_forced Forces the setting instead of just suggesting with a message
 */
public checkEnablePreview(p_forced?: boolean): void {
    let w_result: any = true;
    const w_setting = vscode.workspace.getConfiguration("workbench.editor");
    if (w_setting.inspect("enablePreview")!.globalValue === undefined) {
        w_result = w_setting.inspect("enablePreview")!.defaultValue;
    } else {
        w_result = w_setting.inspect("enablePreview")!.globalValue;
    }
    if (w_result === false) {
        if (p_forced) {
            this.setEnablePreview();
            vscode.window.showInformationMessage("'Enable Preview' setting was set");
        } else {
            if (!this._leoIntegration.leoStates.leoStartupFinished) {
                return;
            }
            vscode.window.showWarningMessage("'Enable Preview' setting is recommended (currently disabled)", "Fix it")
                .then(p_chosenButton =&gt; {
                    if (p_chosenButton === "Fix it") {
                        vscode.commands.executeCommand(Constants.COMMANDS.SET_ENABLE_PREVIEW);
                    }
                });
        }
    }
}

</t>
<t tx="felix.20210820231649.1">/**
 * * Check for unique port #
 * @param p_port the port number at which to look for
 * @returns a promise of an opened port number - or rejection if busy port
 */
export function findSingleAvailablePort(p_port: number): Promise&lt;number&gt; {
    return portfinder.getPortPromise({
        port: p_port,
        startPort: p_port,
        stopPort: p_port
    });
}

</t>
<t tx="felix.20210821202347.1">/**
 * * Check if the 'workbench.editor.closeEmptyGroups' setting is false
 * @param p_forced Forces the setting instead of just suggesting with a message
 */
public checkCloseEmptyGroups(p_forced?: boolean): void {
    let w_result: any = false;
    const w_setting = vscode.workspace.getConfiguration("workbench.editor");
    if (w_setting.inspect("closeEmptyGroups")!.globalValue === undefined) {
        w_result = w_setting.inspect("closeEmptyGroups")!.defaultValue;
    } else {
        w_result = w_setting.inspect("closeEmptyGroups")!.globalValue;
    }
    if (w_result === true) {
        if (p_forced) {
            this.clearCloseEmptyGroups();
            vscode.window.showInformationMessage("'Close Empty Groups' setting was cleared");
        } else {
            if (!this._leoIntegration.leoStates.leoStartupFinished) {
                return;
            }
            vscode.window.showWarningMessage("'Close Empty Groups' setting is NOT recommended!", "Fix it")
                .then(p_chosenButton =&gt; {
                    if (p_chosenButton === "Fix it") {
                        vscode.commands.executeCommand(Constants.COMMANDS.CLEAR_CLOSE_EMPTY_GROUPS);
                    }
                });
        }
    }
}

</t>
<t tx="felix.20210821203119.1">/**
 * * Clears the workbench.editor.closeEmptyGroups vscode setting
 */
public clearCloseEmptyGroups(): Thenable&lt;void&gt; {
    return vscode.workspace.getConfiguration("workbench.editor")
        .update("closeEmptyGroups", false, true);
}

</t>
<t tx="felix.20210821212114.1">"extension/context": [
  {
    "command": "leointeg.showSettingsPage",
    "when": "extension =~ /^boltex.leointeg/ &amp;&amp; extensionStatus == installed",
    "group": "3_leointeg@1"
  }
]
</t>
<t tx="felix.20210829192609.1">## Server Settings

Although the Leo integration has one instance of the leoserver script per vscode 'project'
window by default, the server settings also has features that allows you to use the same instance
of Leo in multiple client (vscode) windows simultaneously, with real-time updates and interaction.

(See [Multiple concurrent connections](https://leoeditor.com/leoserver.html#multiple-concurrent-connections))

### Auto Start

**When auto-start is set, a vscode window will start a new instance of Leo server for itself on the next available network port.**
If the connection limit is set to anything above the default of one (1),
then the auto-start logic will consider a port being in use as
being already started and will not start another one.
_(Letting you connect, or auto-connect to it from any additional opened vscode window.)_

The server, located in your Leo-Editor installation folder, also has other options unrelated to
LeoInteg that allows you to create a stand-alone internet server for other uses such as
multi-user interaction over a network/internet, and more.

Run the server directly with the '--help' argument like so for more details:\
**`...leo-editor/leo/core/leoserver.py --help`**

For more information about the Leo server see [Using leoserver.py](https://leoeditor.com/leoserver.html) from Leo's official documentation.

</t>
<t tx="felix.20210829223822.1">Old Server Scripts
==================

Kept as @@file nodes: Remove an @ to uncomment, then save to generate files.

Ignored in Git
--------------

leobridgeserver.py and leoserver.py file names are now part of the .gitignore file.

For normal usage, use the leoserver.py file from your leo-editor installation folder instead.

(Located in ...leo-editor/leo/core/)

To make sure leointeg is using the latest server version, make sure you update your Leo-Editor installation to the latest version.

</t>
<t tx="felix.20210901215735.1">## 0.1.19

- Fixed 'tab' press from the sidebar: if pressing from the outline it tabs to possible icons on the node, then goes to the body pane. If pressed from the search panel, it cycles through the fields of the search panel.
- Made the server output channel and the Leo Log Window not show up and open automatically anymore unless the text in the Log Window is 'red' (For Errors to be shown).
- Added icon for the 'show Log Pane' command and made it available, along with the 'Show Leointeg Settings', on title bar of documents and buttons views.
- Automatic detection of VSCode's workbench.editor.closeOnFileDelete if its missing/disabled.
- Fixed pressing shift+insert while in terminal, which triggered the 'insert node' command instead of letting the usual vscode 'paste in terminal' command take effect.

</t>
<t tx="felix.20210904235646.1">/**
 * * Check if the workbench.editor.closeOnFileDelete flag is set
 * @param p_forced Forces the setting instead of just suggesting with a message
 */
public checkCloseOnFileDelete(p_forced?: boolean): void {
    let w_result: any = true;
    const w_setting = vscode.workspace.getConfiguration("workbench.editor");
    if (w_setting.inspect("closeOnFileDelete")!.globalValue === undefined) {
        w_result = w_setting.inspect("closeOnFileDelete")!.defaultValue;
    } else {
        w_result = w_setting.inspect("closeOnFileDelete")!.globalValue;
    }
    if (w_result === false) {
        if (p_forced) {
            this.setCloseOnFileDelete();
            vscode.window.showInformationMessage("'Close on File Delete' setting was set");

        } else {
            if (!this._leoIntegration.leoStates.leoStartupFinished) {
                return;
            }
            vscode.window.showWarningMessage("'Close on File Delete' setting is recommended (currently disabled)", "Fix it")
                .then(p_chosenButton =&gt; {
                    if (p_chosenButton === "Fix it") {
                        vscode.commands.executeCommand(Constants.COMMANDS.SET_CLOSE_ON_FILE_DELETE);
                    }
                });
        }
    }
}

</t>
<t tx="felix.20210904235707.1">/**
 * * Set the "workbench.editor.closeOnFileDelete" vscode setting
 */
public setCloseOnFileDelete(): Thenable&lt;void&gt; {
    return vscode.workspace.getConfiguration("workbench.editor")
        .update("closeOnFileDelete", true, true);
}

</t>
<t tx="felix.20210915233602.1">/**
 * * Asks for .leojs file name and path, then saves the JSON Leo file
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns a promise from saving the file results, or that will resolve to undefined if cancelled
 */
public saveAsLeoJsFile(p_fromOutline?: boolean): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
                return this._leoFilesBrowser.getLeoJsFileUrl();
            } else {
                // 'when-conditions' should prevent this
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            }
        })
        .then((p_chosenLeoFile) =&gt; {
            if (p_chosenLeoFile.trim()) {
                const w_hasDot = p_chosenLeoFile.indexOf('.') !== -1;
                if (
                    !w_hasDot ||
                    (p_chosenLeoFile.split('.').pop() !== Constants.JS_FILE_EXTENSION &amp;&amp; w_hasDot)
                ) {
                    if (!p_chosenLeoFile.endsWith('.')) {
                        p_chosenLeoFile += '.'; // Add dot if needed
                    }
                    p_chosenLeoFile += Constants.JS_FILE_EXTENSION; // Add extension
                }
                if (this.leoStates.leoOpenedFileName) {
                    this._removeLastFile(this.leoStates.leoOpenedFileName);
                    this._removeRecentFile(this.leoStates.leoOpenedFileName);
                }
                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.SAVE_FILE,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    fromOutline: !!p_fromOutline,
                    name: p_chosenLeoFile,
                });
                this.leoStates.leoOpenedFileName = p_chosenLeoFile.trim();
                this._leoStatusBar.update(true, 0, true);
                this._addRecentAndLastFile(p_chosenLeoFile.trim());
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject('Save file not added on command stack');
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20210915234252.1">/**
 * * Open a file browser and let the user choose a JSON leojs file name to save as.
 * @returns A promise resolving to a chosen path string, or rejected with an empty string if cancelled
 */
public getLeoJsFileUrl(): Promise&lt;string&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve("");
    }
    this._fileBrowserActive = true;
    return new Promise((p_resolve, p_reject) =&gt; {
        // Choose file
        vscode.window.showSaveDialog({
            saveLabel: "Save as leojs File",
            defaultUri: this._getBestOpenFolderUri(),
            filters: { 'JSON Leo File': ['leojs'] }
        })
            .then(p_chosenLeoFile =&gt; {
                this._fileBrowserActive = false;
                if (p_chosenLeoFile) {
                    // single string
                    p_resolve(p_chosenLeoFile.fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                } else {
                    p_resolve(""); // not rejection - resolve empty string
                }
            });

    });
}

</t>
<t tx="felix.20210916004954.1">## 0.1.18

- Git-diff is now fixed in Leo so the experimental option 'Set CWD' has been removed
- The somewhat unnecessary experimental option 'Shell' has been removed.
- Automatic detection of VSCode's workbench.editor.enablePreview if its missing/disabled.
- Automatic detection of VSCode's workbench.editor.closeEmptyGroups if its missing/enabled.
- Easier access to the leo settings through the extension config title strings and the extension view menu.

</t>
<t tx="felix.20210917225004.1">/**
 * * Closes all visible text editors that have Leo filesystem scheme
 */
function closeLeoTextEditors() {
    vscode.window.visibleTextEditors.forEach(p_textEditor =&gt; {
        if (p_textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
            if (p_textEditor.hide) {
                p_textEditor.hide();
            }
        }
    });
}

</t>
<t tx="felix.20210919194259.1">## 0.1.20

- Added .leojs JSON file format support.
- Fixed various smaller/invisible bugs.

</t>
<t tx="felix.20210919194446.1">## 1.0.1

- Fixed double check for vscode settings recommendations at startup.

</t>
<t tx="felix.20210923233342.1">## 1.0.0

- Fixed 'body-undo-modification-bug' when triggering outline icon change before undoing.
- Version 1.0, First Official Release!

</t>
<t tx="felix.20210928231455.1">## 1.0.2

- Cleaned up command palette's insert 'child' choices.
- Fixed 'insert node' command to insert as child if the targeted (or current) node is expanded.

</t>
<t tx="felix.20211007215423.1">## 1.0.3

- Fixed 'F3' bug: findNext didn't trigger because the context was not (re)set properly on focus-out from the 'find panel'.
- Changed all context 'when' clauses to be more 'precise &amp; unique' in relation to other extensions, such as leojs.
- Added the reStructuredText (rest) .rst language support. (syntax coloring and snippets)
- Fixed at-button panel to refresh after adding a button
- Added 'Goto Script' command to the context menu of at-buttons, to 'find and goto' the source node of the button script.

</t>
<t tx="felix.20211017002435.1">/**
 * * Finds and goes to the script of an at-button. Used by '@buttons' treeview.
 * @param p_node the node of the at-buttons panel that was right-clicked
 * @returns the launchRefresh promise started after it's done finding the node
 */
public gotoScript(p_node: LeoButtonNode): Promise&lt;boolean&gt; {
    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {
            return this.sendAction(
                Constants.LEOBRIDGE.GOTO_SCRIPT,
                JSON.stringify({ index: p_node.button.index })
            );
        })
        .then((p_gotoScriptResult: LeoBridgePackage) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.DO_NOTHING);
        })
        .then((p_package) =&gt; {
            // refresh and reveal selection
            this.launchRefresh({ tree: true, body: true, states: true, buttons: false, documents: false }, false, p_package.node);
            return Promise.resolve(true); // TODO launchRefresh should be a returned promise
        });
}

</t>
<t tx="felix.20211018004333.1">## 1.0.4

- Fixed typos and small bugs.
- Fixed refresh type for mark/unmark node.
- Fixed bug that prevented context some menu items on \@\&lt;files\&gt; nodes and other special nodes.
- Added Write (dirty) \@\&lt;file\&gt; commands and keybindings.
- Fixed flags and icons shown above the body pane for hoist/dehoist commands.
- Fixed 'clean/dirty' state of leo body documents with the 'triggerBodySave' method which makes sure the body text is sent to the leo server before anything would close or destroy the body pane. (when focusing on another document or outside of vscode, etc.)
- Fixed "view welcome-content" of outline for contexts before the bridge is connected, and settings were changed. (e.g. when auto start and/or auto-connect were off at startup)
- Fixed Leo's comment/code blocks directives "@doc"/"@code" and their shorthand versions "@"/"@c".
- Fixed color syntax to match Leo's PR #2303 which removes @raw and @end_raw and adds @section-delims.

</t>
<t tx="felix.20211111214657.1">/**
 * * Refreshes body pane's statuses such as applied language file type, word-wrap state, etc.
 */
public refreshBodyStates(): void {
    if (!this._bodyTextDocument || !this.lastSelectedNode) {
        return;
    }

    // * Set document language along with the proper cursor position, selection range and scrolling position
    let q_bodyStates: Promise&lt;LeoBridgePackage&gt; | undefined;
    q_bodyStates = this.sendAction(
        Constants.LEOBRIDGE.GET_BODY_STATES,
        utils.buildNodeCommandJson(this.lastSelectedNode!.apJson)
    );
    q_bodyStates.then((p_bodyStates: LeoBridgePackage) =&gt; {
        let w_language: string = p_bodyStates.language!;
        let w_wrap: boolean = !!p_bodyStates.wrap;

        // TODO : Apply Wrap
        // console.log('WRAP: ', w_wrap);

        // Replace language string if in 'exceptions' array
        w_language = Constants.LEO_LANGUAGE_PREFIX + (Constants.LANGUAGE_CODES[w_language] || w_language);
        // Apply language if the selected node is still the same after all those events
        if (this._bodyTextDocument &amp;&amp;
            !this._bodyTextDocument.isClosed &amp;&amp;
            this.lastSelectedNode &amp;&amp;
            w_language !== this._bodyTextDocument.languageId &amp;&amp;
            utils.leoUriToStr(this._bodyTextDocument.uri) === this.lastSelectedNode.gnx
        ) {
            this._setBodyLanguage(this._bodyTextDocument, w_language);
        }
    });
}

</t>
<t tx="felix.20211111233213.1">/**
 * * Refresh body states after a small debounced delay.
 */
public debouncedRefreshBodyStates() {
    if (this._bodyStatesTimer) {
        clearTimeout(this._bodyStatesTimer);
    }
    this._bodyStatesTimer = setTimeout(() =&gt; {
        // this.triggerBodySave(true);
        this._bodySaveDocument(this._bodyLastChangedDocument!);
        this.refreshBodyStates();
    }, Constants.BODY_STATES_DEBOUNCE_DELAY);
}

</t>
<t tx="felix.20211114150842.1">{
  "command": "leointeg.undoFromOutline",
  "key": "ctrl+z",
  "mac": "cmd+z",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !inputFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
{
  "command": "leointeg.redoFromOutline",
  "key": "ctrl+shift+z",
  "mac": "cmd+shift+z",
  "when": "leoFindFocus || leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; !inputFocus &amp;&amp; !editorTextFocus &amp;&amp; focusedView =~ /^leoIntegration|^leoFindPanel|^leoDocuments|^leoButtons/"
},
</t>
<t tx="felix.20211129222933.1">private _tryFullRefresh(): void {
    this._errorRefreshFlag = true;
    this._leoIntegration.sendAction(Constants.LEOBRIDGE.DO_NOTHING)
        .then((p_package) =&gt; {
            // refresh and reveal selection
            const w_node = this._leoIntegration.apToLeoNode(p_package.node!);
            this._leoIntegration.lastSelectedNode = w_node;
            this._leoIntegration.showOutline();
            // ! maybe overkill
            this._leoIntegration.launchRefresh(
                { tree: true, body: true, states: true, buttons: true, documents: true },
                false,
                p_package.node
            );
        });
}

</t>
<t tx="felix.20211210001626.1">## 1.0.5

- Fixed bug where the selection could not change (visual update in outline) when hoisted on a node deeper than top-level of tree (sibling of root node).

</t>
<t tx="felix.20220215235325.1">/**
 * * Sets vscode's body-pane editor's language
 */
private _setBodyLanguage(p_document: vscode.TextDocument, p_language: string): Thenable&lt;vscode.TextDocument&gt; {
    return vscode.languages.setTextDocumentLanguage(p_document, p_language).then(
        (p_mewDocument) =&gt; { return p_mewDocument; }, // ok - language found
        (p_error) =&gt; {
            let w_langName: string = p_error.toString().split('\n')[0];
            if (w_langName.length &gt; 36 &amp;&amp; w_langName.includes(Constants.LEO_LANGUAGE_PREFIX)) {
                w_langName = w_langName.substring(36);
            } else {
                w_langName = "";
            }
            if (w_langName &amp;&amp; !this._languageFlagged.includes(w_langName)) {
                this._languageFlagged.push(w_langName);
                vscode.window.showInformationMessage(w_langName + Constants.USER_MESSAGES.LANGUAGE_NOT_SUPPORTED);
            } else if (!w_langName) {
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.UNKNOWN_LANGUAGE_NOT_SUPPORTED);
            }
            return p_document;
        }
    );
}

</t>
<t tx="felix.20220216005511.1">## 1.0.6

- Prevent reappearance of unknown-language warnings in a session, for a given language.
- Added Fortran and Fortran90 syntax-coloring and snippets support.
- Clicking on LeoInteg's status bar indicator now shows the log pane.
- Added support for "@rclick" nodes along "@button" nodes, by presenting a menu if they are present when clicking one.
- Copy paste from/to anywhere! Clipboard operations are now using the system's clipboard instead of Leo's internal clipboard. (Requires Leo minimal version of at least 6.6-b2)
- Removed LeoBridge server output pane: The server and 'Print' terminal outputs from leo now appears in the log pane.
- Headlines can now be changed to an empty string, as per Leo's standards.

</t>
<t tx="felix.20220220191549.1">/**
 * * Used to select a button's rclick by index
 */
export interface ChooseRClickItem extends vscode.QuickPickItem {
    index: number;
    rclick?: RClick;
}

</t>
<t tx="felix.20220221001803.1">/**
 * * Returned from Leo with buttons data
 */
export interface RClick {
    name: string;
    children: RClick[];
}

</t>
<t tx="felix.20220221003719.1">/**
 * * Show input window to select
 */
private _handleRClicks(p_rclicks: RClick[], topLevelName?: string): Thenable&lt;ChooseRClickItem&gt; {
    const w_choices: ChooseRClickItem[] = [];
    let w_index = 0;
    if (topLevelName) {
        w_choices.push(
            { label: topLevelName, picked: true, alwaysShow: true, index: w_index++ }
        );
    }
    w_choices.push(
        ...p_rclicks.map((p_rclick): ChooseRClickItem =&gt; { return { label: p_rclick.name, index: w_index++, rclick: p_rclick }; })
    );

    const w_options: vscode.QuickPickOptions = {
        placeHolder: Constants.USER_MESSAGES.CHOOSE_BUTTON
    };
    return vscode.window.showQuickPick(w_choices, w_options).then((p_picked) =&gt; {
        if (p_picked) {
            this._rclickSelected.push(p_picked.index);
            if (topLevelName &amp;&amp; p_picked.index === 0) {
                return Promise.resolve(p_picked);
            }
            if (p_picked.rclick &amp;&amp; p_picked.rclick.children &amp;&amp; p_picked.rclick.children.length) {
                return this._handleRClicks(p_picked.rclick.children);
            } else {
                return Promise.resolve(p_picked);
            }
        }
        // Escaped
        return Promise.reject();
    });
}

</t>
<t tx="felix.20220222012528.1">public cutNode(
    p_node?: LeoNode,
    p_fromOutline?: boolean
): Promise&lt;LeoBridgePackage&gt; {
    return this._isBusyTriggerSave(false, true)
        .then(() =&gt; {

            const q_commandResult = this.nodeCommand({
                action: Constants.LEOBRIDGE.CUT_PNODE,
                node: p_node,
                refreshType: { tree: true, body: true, states: true },
                fromOutline: !!p_fromOutline,
            });
            if (q_commandResult) {
                return q_commandResult.then(p_package =&gt; {
                    if (p_package.string) {
                        this.replaceClipboardWith(p_package.string);
                    } else {
                    }
                    return p_package;
                });

            } else {
                return Promise.reject('Cut Node not added on command stack');
            }
        });
}

</t>
<t tx="felix.20220222012540.1">public copyNode(
    p_node?: LeoNode,
    p_fromOutline?: boolean
): Promise&lt;LeoBridgePackage&gt; {
    return this._isBusyTriggerSave(false, true)
        .then(() =&gt; {

            const q_commandResult = this.nodeCommand({
                action: Constants.LEOBRIDGE.COPY_PNODE,
                node: p_node,
                refreshType: {}, // none
                fromOutline: !!p_fromOutline,
            });
            if (q_commandResult) {
                return q_commandResult.then(p_package =&gt; {
                    if (p_package.string) {
                        this.replaceClipboardWith(p_package.string);
                    } else {
                    }
                    return p_package;
                });

            } else {
                return Promise.reject('Copy Node not added on command stack');
            }

        });

}

</t>
<t tx="felix.20220222012552.1">public pasteNode(
    p_node?: LeoNode,
    p_fromOutline?: boolean
): Thenable&lt;LeoBridgePackage&gt; {
    return this._isBusyTriggerSave(false, true).then(() =&gt; {

        return this.asyncGetTextFromClipboard().then((p_text) =&gt; {

            const q_commandResult = this.nodeCommand({
                action: Constants.LEOBRIDGE.PASTE_PNODE,
                node: p_node,
                refreshType: { tree: true, body: true, states: true },
                name: p_text,
                fromOutline: !!p_fromOutline,
            });
            if (q_commandResult) {
                return q_commandResult;
            } else {
                return Promise.reject('Cut Node not added on command stack');
            }

        });
    });

}

</t>
<t tx="felix.20220222012602.1">public pasteAsCloneNode(
    p_node?: LeoNode,
    p_fromOutline?: boolean
): Thenable&lt;LeoBridgePackage&gt; {
    return this._isBusyTriggerSave(false, true).then(() =&gt; {

        return this.asyncGetTextFromClipboard().then((p_text) =&gt; {

            const q_commandResult = this.nodeCommand({
                action: Constants.LEOBRIDGE.PASTE_CLONE_PNODE,
                node: p_node,
                refreshType: { tree: true, body: true, states: true },
                name: p_text,
                fromOutline: !!p_fromOutline,
            });
            if (q_commandResult) {
                return q_commandResult;
            } else {
                return Promise.reject('Cut Node not added on command stack');
            }

        });
    });
}

</t>
<t tx="felix.20220222014050.1"></t>
<t tx="felix.20220222014050.2">public replaceClipboardWith(s: string): Thenable&lt;void&gt; {
    this.clipboardContent = s; // also set immediate clipboard string
    return vscode.env.clipboard.writeText(s);
}

</t>
<t tx="felix.20220222014050.3">public asyncGetTextFromClipboard(): Thenable&lt;string&gt; {
    return vscode.env.clipboard.readText().then((s) =&gt; {
        // also set immediate clipboard string for possible future read
        this.clipboardContent = s;
        return this.getTextFromClipboard();
    });
}

</t>
<t tx="felix.20220222014050.4">/**
 * Returns clipboard content
*/
public getTextFromClipboard(): string {
    return this.clipboardContent;
}

</t>
<t tx="felix.20220228223901.1">{
  "command": "leointeg.test",
  "category": "Leo",
  "title": "test"
},
</t>
<t tx="felix.20220301224252.1">// @ts-check

// This script will be run within the webview itself
// It cannot access the main VS Code APIs directly.
// Send message to leoInteg with vscode.postMessage({ keyNameEx1: someValue, ... });
// Receive messages from leoInteg with window.addEventListener('message', event =&gt; { ... });
(function () {
    // @ts-expect-error
    const vscode = acquireVsCodeApi();

    let timer; // for debouncing sending the settings from this webview to leointeg
    let dirty = false; // all but nav input
    let navTextDirty = false;

    let firstTabEl = 'searchOptions'; // used to be 'findText' before nav inputs
    let lastTabEl = 'searchBody';

    // * LeoSearchSettings Type
    let searchSettings = {
        // Nav settings
        navText: '',
        showParents: true,
        isTag: false,
        searchOptions: 0,
        // Find/replace
        findText: '',
        replaceText: '',
        wholeWord: false,
        ignoreCase: true,
        regExp: false,
        markFinds: false,
        markChanges: false,
        searchHeadline: true,
        searchBody: true,
        searchScope: 0, // 0 is entire outline (1: sub-outline, 2: node only)
    };

    let inputIds = ['findText', 'replaceText'];
    let checkboxIds = [
        'wholeWord',
        'ignoreCase',
        'regExp',
        'markFinds',
        'markChanges',
        'searchHeadline',
        'searchBody',
    ];
    let radioIds = ['entireOutline', 'subOutlineOnly', 'nodeOnly'];

    function navTextChange() {
        // User changed text in nav text input

        // DEBOUNCE .25 seconds

        // ALSO set navTextDirty = false if sent to leoserver!

        console.log('! navTextChange ! navText is --&gt; ', searchSettings.navText);
    }

    /**
     * @param {string} p_id
     */
    function setSearchSetting(p_id) {
        if (checkboxIds.includes(p_id)) {
            toggleCheckbox(p_id);
        } else if (radioIds.includes(p_id)) {
            setRadio(p_id);
        }
    }

    /**
     * @param {any} p_settings
     */
    function setSettings(p_settings) {
        // Nav controls
        // @ts-expect-error
        document.getElementById("navText").value = p_settings["navText"];
        searchSettings["navText"] = p_settings["navText"];

        // showParents
        // @ts-expect-error
        document.getElementById("showParents").checked = p_settings["showParents"];
        searchSettings["showParents"] = p_settings["showParents"];

        // isTag
        // @ts-expect-error
        document.getElementById("isTag").checked = p_settings["isTag"];
        searchSettings["isTag"] = p_settings["isTag"];
        // searchOptions
        // @ts-expect-error
        document.getElementById("searchOptions").value = p_settings["searchOptions"];
        searchSettings["searchOptions"] = p_settings["searchOptions"];

        // When opening a Leo document, set default values of fields
        inputIds.forEach((p_inputId) =&gt; {
            // @ts-expect-error
            document.getElementById(p_inputId).value = p_settings[p_inputId];
            searchSettings[p_inputId] = p_settings[p_inputId];
        });
        checkboxIds.forEach((p_inputId) =&gt; {
            // @ts-expect-error
            document.getElementById(p_inputId).checked = p_settings[p_inputId];
            searchSettings[p_inputId] = p_settings[p_inputId];
        });
        // @ts-expect-error
        document.getElementById(radioIds[p_settings['searchScope']]).checked = true;
        searchSettings.searchScope = p_settings['searchScope'];
    }

    function sendSearchConfig() {
        dirty = false; // clear dirty flag
        vscode.postMessage({ type: 'searchConfig', value: searchSettings });
    }

    function processChange() {
        clearTimeout(timer);
        dirty = true;
        timer = setTimeout(() =&gt; {
            sendSearchConfig();
        }, 300);
    }

    /**
     * @param {string} p_inputId
     */
    function toggleCheckbox(p_inputId) {
        let w_checkbox = document.getElementById(p_inputId);
        let w_setTo = true;
        // @ts-expect-error
        if (w_checkbox.checked) {
            w_setTo = false;
        }
        // @ts-expect-error
        w_checkbox.checked = w_setTo;
        searchSettings[p_inputId] = w_setTo;
        if (timer) {
            clearTimeout(timer);
        }
        sendSearchConfig();
    }

    /**
     * @param {string} p_inputId
     */
    function setRadio(p_inputId) {
        // @ts-expect-error
        document.getElementById(p_inputId).checked = true;
        searchSettings['searchScope'] = parseInt(
            // @ts-expect-error
            document.querySelector('input[name="searchScope"]:checked').value
        );
        if (timer) {
            clearTimeout(timer);
        }
        sendSearchConfig();
    }

    /**
     *
     * @param {KeyboardEvent} p_event
     */
    function checkKeyDown(p_event) {
        // @ts-expect-error
        if (!p_event) p_event = window.event;
        var keyCode = p_event.code || p_event.key;

        if (keyCode === 'Tab') {
            var actEl = document.activeElement;
            if (p_event.shiftKey) {
                // shift + tab so if first got last
                var firstEl = document.getElementById(firstTabEl);
                if (actEl === firstEl) {
                    p_event.preventDefault();
                    p_event.stopPropagation();
                    p_event.stopImmediatePropagation();
                    document.getElementById(lastTabEl).focus();
                    return;
                }
            } else {
                // tab, so if last goto first
                var lastEl = document.getElementById(lastTabEl);
                if (actEl === lastEl) {
                    p_event.preventDefault();
                    p_event.stopPropagation();
                    p_event.stopImmediatePropagation();
                    focusOnField(firstTabEl);
                    return;
                }
            }
        }
        // checkOtherKeys(p_event);
    }

    /**
     * @param {string} p_id
     */
    function focusOnField(p_id) {
        const inputField = document.querySelector('#' + p_id);
        // @ts-expect-error
        inputField.select();
        // TODO : TEST IF NEEDED TO PREVENT FLICKER ON FIRST TRY?
        setTimeout(() =&gt; {
            // @ts-expect-error
            inputField.select();
        }, 0);
    }

    function getSettings() {
        // clear dirty, clear timer,
        if (dirty) {
            dirty = false;
            clearTimeout(timer);
            sendSearchConfig(); // just trigger send settings
        }
    }

    document.getElementById('navText').onkeypress = function (p_event) {
        // @ts-expect-error
        if (!p_event) p_event = window.event;
        var keyCode = p_event.code || p_event.key;
        if (keyCode == 'Enter') {
            if (navTextDirty) {
                navTextDirty = false;
                if (timer) {
                    clearTimeout(timer);
                }
                sendSearchConfig();
            }
            vscode.postMessage({ type: 'leoNavEnter' });
            return false;
        }
        document.getElementById('navText').addEventListener('input', function (p_event) {
            // @ts-expect-error
            searchSettings.navText = this.value;
            navTextDirty = true;
            navTextChange(); // DEBOUNCE THIS Dont process change too fast!
        });
    };
    document.getElementById('showParents').addEventListener('change', function (p_event) {
        // @ts-expect-error
        searchSettings.showParents = this.checked;
        processChange();
    });
    document.getElementById('isTag').addEventListener('change', function (p_event) {
        // @ts-expect-error
        searchSettings.isTag = this.checked;
        processChange();
    });
    document.getElementById('searchOptions').addEventListener('change', function (p_event) {
        // @ts-expect-error
        searchSettings.searchOptions = Number(this.value);
        processChange();
    });

    inputIds.forEach((p_inputId) =&gt; {
        document.getElementById(p_inputId).onkeypress = function (p_event) {
            // @ts-expect-error
            if (!p_event) p_event = window.event;
            var keyCode = p_event.code || p_event.key;
            if (keyCode == 'Enter') {
                if (timer) {
                    clearTimeout(timer);
                    sendSearchConfig();
                }
                vscode.postMessage({ type: 'leoFindNext' });
                return false;
            }
        };
        document.getElementById(p_inputId).addEventListener('input', function (p_event) {
            // @ts-expect-error
            searchSettings[p_inputId] = this.value;
            processChange();
        });
    });

    checkboxIds.forEach((p_inputId) =&gt; {
        document.getElementById(p_inputId).addEventListener('change', function (p_event) {
            // @ts-expect-error
            searchSettings[p_inputId] = this.checked;
            processChange();
        });
    });

    radioIds.forEach((p_inputId) =&gt; {
        document.getElementById(p_inputId).addEventListener('change', function (p_event) {
            searchSettings['searchScope'] = parseInt(
                // @ts-expect-error
                document.querySelector('input[name="searchScope"]:checked').value
            );
            processChange();
        });
    });

    document.onkeydown = checkKeyDown;

    document.addEventListener('focusin', (event) =&gt; {
        vscode.postMessage({ type: 'gotFocus' });
    });
    document.addEventListener('focusout', (event) =&gt; {
        vscode.postMessage({ type: 'lostFocus' });
    });

    // Handle messages sent from the extension to the webview
    window.addEventListener('message', (event) =&gt; {
        const message = event.data; // The json data that the extension sent
        switch (message.type) {
            // * Nav Tab Controls
            // Focus and select all text in 'nav' field
            case 'selectNav': {
                focusOnField('navText');
                if (message.text || message.text === "") {
                    // @ts-expect-error
                    document.getElementById("navText").value = message.text;
                    searchSettings["navText"] = message.text;
                    if (timer) {
                        clearTimeout(timer);
                    }
                    sendSearchConfig();
                }
                break;
            }
            // * Find Tab Controls
            // Focus and select all text in 'find' field
            case 'selectFind': {
                focusOnField('findText');
                break;
            }
            // Focus and select all text in 'replace' field
            case 'selectReplace': {
                focusOnField('replaceText');
                break;
            }
            case 'getSettings': {
                getSettings();
                break;
            }
            case 'setSettings': {
                setSettings(message.value);
                break;
            }
            case 'setSearchSetting': {
                setSearchSetting(message.id);
                break;
            }
        }
    });

    vscode.postMessage({ type: 'refreshSearchConfig' });
})();
</t>
<t tx="felix.20220305225942.1">public navEnter(): Thenable&lt;LeoBridgePackage&gt; {
    return this._isBusyTriggerSave(false, true).then(() =&gt; {

        return this.sendAction(
            Constants.LEOBRIDGE.NAV_SEARCH
        ).then((p_package) =&gt; {
            this._leoGotoProvider.refreshTreeRoot();
            this.findQuickGoAnywhere({ preserveFocus: true }); // show but dont change focus
            return p_package;
        });

    });

}

</t>
<t tx="felix.20220305231404.1">public navTextChange(): Thenable&lt;LeoBridgePackage&gt; {
    return this._isBusyTriggerSave(false, true).then(() =&gt; {

        return this.sendAction(
            Constants.LEOBRIDGE.NAV_HEADLINE_SEARCH
        ).then((p_package) =&gt; {
            this._leoGotoProvider.refreshTreeRoot();
            this.findQuickGoAnywhere({ preserveFocus: true }); // show but dont change focus
            return p_package;
        });

    });


}

</t>
<t tx="felix.20220307233825.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { ProviderResult } from "vscode";
import { LeoGotoNode } from "./leoGotoNode";
import { Constants } from "./constants";
import { LeoGoto } from "./types";

/**
 * * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
export class LeoGotoProvider implements vscode.TreeDataProvider&lt;LeoGotoNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoGotoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoGotoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoGotoNode | undefined&gt; = this._onDidChangeTreeData.event;


    private _lastGotoView: vscode.TreeView&lt;LeoGotoNode&gt; | undefined;

    private _topNode: LeoGotoNode | undefined;

    constructor(private _leoIntegration: LeoIntegration) { }

    public showGotoPanel(): Thenable&lt;void&gt; {
        if (this._lastGotoView &amp;&amp; this._topNode) {
            return this._lastGotoView.reveal(this._topNode, { select: false, focus: false });
        }
        return Promise.resolve();
    }

    public setLastGotoView(p_view: vscode.TreeView&lt;LeoGotoNode&gt;): void {
        this._lastGotoView = p_view;
    }

    /**
     * * Refresh the whole outline
     */
    public refreshTreeRoot(): void {
        console.log('refresh treeRoot goto nav CALLED!! ');
        this._onDidChangeTreeData.fire(undefined);
    }

    public getTreeItem(element: LeoGotoNode): Thenable&lt;LeoGotoNode&gt; | LeoGotoNode {
        return element;
    }

    public getChildren(element?: LeoGotoNode): Thenable&lt;LeoGotoNode[]&gt; {

        console.log('----------------------- getChildren GOTO NAV !! ');

        // if called with element, or not ready, give back empty array as there won't be any children
        if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {


            // call action to get get list, and convert to LeoButtonNode(s) array
            return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_GOTO_PANEL).then(p_package =&gt; {
                if (p_package &amp;&amp; p_package.navList) {

                    console.log('----------------------- GOT children from nav', p_package);

                    const w_list: LeoGotoNode[] = [];
                    this._topNode = undefined;
                    const w_navList: LeoGoto[] = p_package.navList;
                    if (w_navList &amp;&amp; w_navList.length) {
                        w_navList.forEach((p_goto: LeoGoto) =&gt; {
                            const w_newNode = new LeoGotoNode(p_goto, p_package.navOptions!);
                            if (!this._topNode) {
                                this._topNode = w_newNode;
                            }
                            w_list.push(w_newNode);
                        });
                    }
                    return w_list;
                } else {
                    return [];
                }
            });


        } else {
            return Promise.resolve([]); // Defaults to an empty list of children
        }
    }

    public getParent(element: LeoGotoNode): ProviderResult&lt;LeoGotoNode&gt; | null {
        // Leo documents are just a list, as such, entries are always child of root, so return null
        return null;
    }

}
</t>
<t tx="felix.20220307233828.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoGoto } from "./types";
import * as utils from "./utils";

/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoGotoNode extends vscode.TreeItem {

    // Context string is checked in package.json with 'when' clauses
    private _id: string;
    private _description: string | boolean;
    private _type: string;
    private _headline: string;

    constructor(
        gotoEntry: LeoGoto,
        navOptions: { isTag: boolean, showParents: boolean }
    ) {
        let w_spacing = "";
        if (navOptions.showParents &amp;&amp; !navOptions.isTag) {
            w_spacing = "  ";
        }
        super(gotoEntry.t === "headline" ? (w_spacing + gotoEntry.h) : "");

        // Setup this instance
        this._id = utils.getUniqueId();
        this._type = gotoEntry.t;
        this._headline = gotoEntry.h.trim();

        this._description = false;
        if (this._type === 'body') {
            if (navOptions.showParents) {
                this._description = "    " + this._headline;
            } else {
                this._description = "  " + this._headline;
            }
        } else if (this._type === 'parent') {
            this._description = this._headline.trim();
        } else if (this._type === 'generic') {
            this._description = "&lt; " + this._headline + " &gt;";
        }

        this.command = {
            command: Constants.COMMANDS.GOTO_NAV_ENTRY,
            title: '',
            arguments: [this]
        };
        this.iconPath = undefined;
    }

    // @ts-ignore
    public get tooltip(): string {
        if (this._type !== "generic") {
            return this._type.charAt(0).toUpperCase() + this._type.slice(1);
        }
        return this._headline;
    }

    // @ts-ignore
    public get description(): string | boolean {
        return this._description;
    }

    // @ts-ignore
    // public get iconPath(): Icon| vscode.ThemeIcon|string {
    //     return false;
    // }

    // @ts-ignore
    public get id(): string {
        // Add prefix and suffix salt to numeric index to prevent accidental duplicates
        // Should be unique when refreshed
        return "g" + this._id + "o";
    }

}
</t>
<t tx="felix.20220307235733.1">{
  "command": "leointeg.findQuick",
  "category": "Leo",
  "title": "Focus on Nav tab"
},
{
  "command": "leointeg.goAnywhere",
  "category": "Leo",
  "title": "Go Anywhere"
},
{
  "command": "leointeg.findQuickSelected",
  "category": "Leo",
  "title": "Nav search with current selection",
  "icon": {
    "light": "resources/light/find-quick-selected.svg",
    "dark": "resources/dark/find-quick-selected.svg"
  }
},
{
  "command": "leointeg.findQuickTimeline",
  "category": "Leo",
  "title": "List nodes in reverse gnx order",
  "icon": {
    "light": "resources/light/find-quick-timeline.svg",
    "dark": "resources/dark/find-quick-timeline.svg"
  }
},
{
  "command": "leointeg.findQuickChanged",
  "category": "Leo",
  "title": "List all dirty nodes",
  "icon": {
    "light": "resources/light/find-quick-changed.svg",
    "dark": "resources/dark/find-quick-changed.svg"
  }
},
{
  "command": "leointeg.history",
  "category": "Leo",
  "title": "List nodes from history",
  "icon": {
    "light": "resources/light/find-quick-history.svg",
    "dark": "resources/dark/find-quick-history.svg"
  }
},
{
  "command": "leointeg.markedList",
  "category": "Leo",
  "title": "List all marked nodes",
  "icon": {
    "light": "resources/light/find-quick-marked.svg",
    "dark": "resources/dark/find-quick-marked.svg"
  }
},
</t>
<t tx="felix.20220308203528.1">export interface LeoGoto {
    key: string; // or number??
    h: string;
    t: "body" | "headline" | "parent" | "generic";
}

</t>
<t tx="felix.20220308213523.1"></t>
<t tx="felix.20220308213538.1">/**
 * Opens the Nav tab and focus on nav text input
*/
public findQuick(p_string?: string): Thenable&lt;unknown&gt; {
    let w_panelID = '';
    let w_panel: vscode.WebviewView | undefined;
    if (this._lastTreeView === this._leoTreeExView) {
        w_panelID = Constants.FIND_EXPLORER_ID;
        w_panel = this._findPanelWebviewExplorerView;
    } else {
        w_panelID = Constants.FIND_ID;
        w_panel = this._findPanelWebviewView;
    }
    vscode.commands.executeCommand(w_panelID + '.focus').then((p_result) =&gt; {
        if (w_panel &amp;&amp; w_panel.show &amp;&amp; !w_panel.visible) {
            w_panel.show(false);
        }
        const w_message: { [key: string]: string } = { type: 'selectNav' };
        if (p_string &amp;&amp; p_string?.trim()) {
            w_message["text"] = p_string.trim();
        }
        w_panel?.webview.postMessage(w_message);
    });
    return Promise.resolve();
}

</t>
<t tx="felix.20220308213547.1">/**
 * Opens the Nav tab with the selected text as the search string
*/
public findQuickSelected(): Thenable&lt;unknown&gt; {
    if (vscode.window.activeTextEditor) {
        const editor = vscode.window.activeTextEditor;
        const selection = editor.selection;
        if (!selection.isEmpty) {
            const text = editor.document.getText(selection);
            console.log('findQuickSelected with text: ', text);
            return this.findQuick(text);
        }
    }
    console.log('findQuickSelected without text! ');
    return this.findQuick();
}

</t>
<t tx="felix.20220308213552.1">/**
 * Lists all nodes in reversed gnx order, newest to oldest
*/
public findQuickTimeline(): Thenable&lt;unknown&gt; {
    console.log('findQuickTimeline');
    return this.sendAction(Constants.LEOBRIDGE.FIND_QUICK_TIMELINE)
        .then((p_result: LeoBridgePackage) =&gt; {
            this._leoGotoProvider.refreshTreeRoot();
            return this.findQuickGoAnywhere(); // Finish by opening and focussing nav pane
        });
}

</t>
<t tx="felix.20220308213557.1">/**
 * Lists all nodes that are changed (aka "dirty") since last save.
*/
public findQuickChanged(): Thenable&lt;unknown&gt; {
    console.log('findQuickChanged');

    return this.sendAction(Constants.LEOBRIDGE.FIND_QUICK_CHANGED)
        .then((p_result: LeoBridgePackage) =&gt; {
            this._leoGotoProvider.refreshTreeRoot();
            return this.findQuickGoAnywhere(); // Finish by opening and focussing nav pane
        });
}

</t>
<t tx="felix.20220308213600.1">/**
 * Lists nodes from c.nodeHistory.
*/
public findQuickHistory(): Thenable&lt;unknown&gt; {
    console.log('findQuickHistory');

    return this.sendAction(Constants.LEOBRIDGE.FIND_QUICK_HISTORY)
        .then((p_result: LeoBridgePackage) =&gt; {
            this._leoGotoProvider.refreshTreeRoot();
            return this.findQuickGoAnywhere(); // Finish by opening and focussing nav pane
        });
}

</t>
<t tx="felix.20220308213605.1">/**
 * List all marked nodes.
*/
public findQuickMarked(): Thenable&lt;unknown&gt; {
    console.log('findQuickMarked');

    return this.sendAction(Constants.LEOBRIDGE.FIND_QUICK_MARKED)
        .then((p_result: LeoBridgePackage) =&gt; {
            this._leoGotoProvider.refreshTreeRoot();
            return this.findQuickGoAnywhere(); // Finish by opening and focussing nav pane
        });
}

</t>
<t tx="felix.20220308213619.1">/**
 * Opens goto and focus in panel
*/
public findQuickGoAnywhere(p_options?: { preserveFocus?: boolean }): Thenable&lt;unknown&gt; {
    console.log('findQuickGoAnywhere');
    // open and optionally focus nav panel
    let w_panel = "";
    if (this._lastTreeView === this._leoTreeExView) {
        w_panel = Constants.GOTO_EXPLORER_ID;
    } else {
        w_panel = Constants.GOTO_ID;
    }
    vscode.commands.executeCommand(w_panel + '.focus', p_options);

    return Promise.resolve();
}

</t>
<t tx="felix.20220308220651.1">{
  "command": "leointeg.findQuick",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findQuickSelected",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findQuickTimeline",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findQuickChanged",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.goAnywhere",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.history",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markedList",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20220309215616.1">public gotoNavEntry(p_node: LeoGotoNode): Thenable&lt;unknown&gt; {
    console.log('Clicked NAV ENTRY! ', p_node);

    return Promise.resolve();
}

</t>
<t tx="felix.20220310224330.1">/**
 * * Handle the change of visibility of either goto treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onGotoTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {

    if (p_explorerView) {
    } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this._leoGotoProvider.setLastGotoView(p_explorerView ? this._leoGotoExplorer : this._leoGoto);
        this.refreshGotoPane();
    }
}

</t>
<t tx="felix.20220313211902.1">/**
 * * Tag Children
 */
public tagNode(): void {

}

</t>
<t tx="felix.20220313211907.1">/**
 * * Tag Children
 */
public removeTags(): void {

}

</t>
<t tx="felix.20220313212109.1">def tag_node(self, param):
    """Tag selected node with given string"""
    # This is not a find command!
    c = self.commander
    fc = c.findCommands
    the_tag = param.get("tag")
    if the_tag:
        # fc.do_tag_children(c.p, the_tag)
        pass
    return self.sendLeoBridgePackage()

</t>
<t tx="felix.20220313212118.1">def remove_tags(self, param):
    """Remove tags on selected node"""
    # This is not a find command!
    c = self.commander

    return self.sendLeoBridgePackage()

</t>
<t tx="fil.20210603195218.1">import * as vscode from "vscode";
import * as path from 'path';
import { LeoIntegration } from "../leoIntegration";
import * as utils from "../utils";

@language typescript
@tabwidth -4
@others
</t>
<t tx="fil.20210603195319.1">export class LeoSettingsProvider {

    private _panel: vscode.WebviewPanel | undefined;
    private readonly _extensionPath: string;
    private _html: string | undefined;
    private _waitingForUpdate: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._extensionPath = _context.extensionPath;
        vscode.workspace.onDidChangeConfiguration(p_event =&gt; this.changedConfiguration(p_event));
    }

    @others
}
</t>
<t tx="fil.20210603195319.2">public changedConfiguration(p_event?: vscode.ConfigurationChangeEvent): void {
    if (this._panel &amp;&amp; !this._waitingForUpdate) {
        this._panel.webview.postMessage({ command: 'newConfig', config: this._leoIntegration.config.getConfig() });
        this._panel.webview.postMessage({ command: 'newFontConfig', config: this._leoIntegration.config.getFontConfig() });
    }
}

</t>
<t tx="fil.20210603195319.3">public openWebview(): void {
    if (this._panel) {
        this._panel.reveal();
    } else {
        this._getBaseHtml().then(p_baseHtml =&gt; {
            this._panel = vscode.window.createWebviewPanel(
                'leoSettings', // Identifies the type of the webview. Used internally
                'Leo Integration Settings', // Title of the panel displayed to the user
                { viewColumn: vscode.ViewColumn.Beside, preserveFocus: false }, // Editor column to show the new webview panel in.
                {
                    retainContextWhenHidden: false,
                    enableFindWidget: true,
                    enableCommandUris: true,
                    enableScripts: true
                }
            );
            let w_baseUri = this._panel.webview.asWebviewUri(vscode.Uri.file(
                path.join(this._extensionPath)
            ));
            this._panel.iconPath = vscode.Uri.file(this._context.asAbsolutePath('resources/leoapp128px.png'));
            this._panel.webview.html = p_baseHtml.replace(
                /#{root}/g,
                w_baseUri.toString()
            ).replace(
                /#{endOfBody}/g,
                `&lt;script type="text/javascript" nonce="Z2l0bGV1cy1ib290c3RyYXA="&gt;window.leoConfig = ${JSON.stringify(
                    this._leoIntegration.config.getConfig()
                )};window.fontConfig = ${JSON.stringify(
                    this._leoIntegration.config.getFontConfig()
                )};&lt;/script&gt;`
            );
            this._panel.webview.onDidReceiveMessage(
                message =&gt; {
                    switch (message.command) {
                        case 'alert':
                            vscode.window.showErrorMessage(message.text);
                            break;
                        case 'chooseLeoEditorPath':
                            utils.chooseLeoFolderDialog().then(p_chosenPath =&gt; {
                                if (p_chosenPath &amp;&amp; p_chosenPath.length) {
                                    this._panel!.webview.postMessage(
                                        {
                                            command: 'newEditorPath',
                                            editorPath: p_chosenPath[0].fsPath
                                        }
                                    );
                                }
                            });
                            break;
                        case 'getNewConfig':
                            if (this._panel &amp;&amp; !this._waitingForUpdate) {
                                this._panel.webview.postMessage(
                                    {
                                        command: 'newConfig',
                                        config: this._leoIntegration.config.getConfig()
                                    }
                                );
                            }
                            break;
                        case 'config':
                            this._waitingForUpdate = true;
                            this._leoIntegration.config.setLeoIntegSettings(message.changes).then(() =&gt; {
                                this._panel!.webview.postMessage(
                                    {
                                        command: 'vscodeConfig',
                                        config: this._leoIntegration.config.getConfig()
                                    }
                                );
                                this._waitingForUpdate = false;
                            });
                            break;
                        case 'getNewFontConfig':
                            if (this._panel &amp;&amp; !this._waitingForUpdate) {
                                this._panel.webview.postMessage(
                                    {
                                        command: 'newFontConfig',
                                        config: this._leoIntegration.config.getFontConfig()
                                    }
                                );
                            }
                            break;
                        case 'fontConfig':
                            this._leoIntegration.config.setFontConfig(message.changes);
                            break;
                    }
                },
                null,
                this._context.subscriptions
            );
            this._panel.onDidDispose(() =&gt; {
                // console.log('disposed');
                this._panel = undefined;
            },
                null,
                this._context.subscriptions);
        });
    }
}

</t>
<t tx="fil.20210603195319.4">private async _getBaseHtml(): Promise&lt;string&gt; {
    if (this._html !== undefined) {
        return this._html;
    } else {
        const w_filename = this._context.asAbsolutePath(path.join('dist/webviews/', 'settings.html'));
        const w_doc = await vscode.workspace.openTextDocument(w_filename);

        this._html = w_doc.getText();

        return this._html;
    }
}
</t>
<t tx="fil.20210603195851.1">public resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken
) {
    this._view = webviewView;

    webviewView.webview.options = {
        // Allow scripts in the webview
        enableScripts: true,

        localResourceRoots: [this._extensionUri],
    };

    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    webviewView.webview.onDidReceiveMessage((data) =&gt; {
        switch (data.type) {
            case 'leoNavEnter': {
                this._leoIntegration.navEnter();
                break;
            }
            case 'leoNavTextChange': {
                this._leoIntegration.navTextChange();
                break;
            }
            case 'gotFocus': {
                // utils.setContext("sideBarFocus", true);
                // utils.setContext("focusedView", "leoFindPanel");
                utils.setContext("leoFindFocus", true);
                break;
            }
            case 'lostFocus': {
                // utils.setContext("sideBarFocus", false);
                // utils.setContext("focusedView", "");
                utils.setContext("leoFindFocus", false);
                break;
            }
            case 'leoFindNext': {
                vscode.commands.executeCommand(Constants.COMMANDS.FIND_NEXT);
                break;
            }
            case 'leoFindPrevious': {
                vscode.commands.executeCommand(Constants.COMMANDS.FIND_PREVIOUS);
                break;
            }
            case 'searchConfig': {
                this._leoIntegration.saveSearchSettings(data.value);
                break;
            }
            case 'replace': {
                this._leoIntegration.replace(true, false);
                break;
            }
            case 'replaceThenFind': {
                this._leoIntegration.replace(true, true);
                break;
            }
            case 'refreshSearchConfig': {
                // Leave a cycle before getting settings
                setTimeout(() =&gt; {
                    this._leoIntegration.loadSearchSettings();
                }, 0);
                break;
            }
        }
    });
    this._leoIntegration.setFindPanel(this._view);
}

</t>
<t tx="fil.20210603195902.1">private _getHtmlForWebview(webview: vscode.Webview) {
    // Get the local path to main script run in the webview, then convert it to a uri we can use in the webview.
    const scriptUri = webview.asWebviewUri(
        vscode.Uri.joinPath(this._extensionUri, 'find-panel', 'main.js')
    );
    // Do the same for the stylesheet.
    const styleResetUri = webview.asWebviewUri(
        vscode.Uri.joinPath(this._extensionUri, 'find-panel', 'reset.css')
    );
    const styleVSCodeUri = webview.asWebviewUri(
        vscode.Uri.joinPath(this._extensionUri, 'find-panel', 'vscode.css')
    );
    const styleMainUri = webview.asWebviewUri(
        vscode.Uri.joinPath(this._extensionUri, 'find-panel', 'main.css')
    );

    // Use a nonce to only allow a specific script to be run.
    const nonce = this.getNonce();

    return `&lt;!DOCTYPE html&gt;
        &lt;html lang="en" tabindex="-1"&gt;
        &lt;head&gt;
            &lt;meta charset="UTF-8"&gt;
            &lt;meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource}; script-src 'nonce-${nonce}';"&gt;
            &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
            &lt;link href="${styleResetUri}" rel="stylesheet"&gt;
            &lt;link href="${styleVSCodeUri}" rel="stylesheet"&gt;
            &lt;link href="${styleMainUri}" rel="stylesheet"&gt;

            &lt;title&gt;Leo Find Panel&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;div class="row mb-0"&gt;
                &lt;div class="col no-overflow"&gt;
                    &lt;label class="first" for="navText"&gt;Nav:&lt;/label&gt;
                    &lt;select name="searchOptions" id="searchOptions"&gt;
                        &lt;option value="0"&gt;All&lt;/option&gt;
                        &lt;option value="1"&gt;Subtree&lt;/option&gt;
                        &lt;option value="2"&gt;File&lt;/option&gt;
                        &lt;option value="3"&gt;Chapter&lt;/option&gt;
                        &lt;option value="4"&gt;Node&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
                &lt;div class="col-nav"&gt;
                    &lt;input type="checkbox" id="isTag" name="isTag" &gt;
                    &lt;label for="isTag"&gt;Tag&lt;/label&gt;

                    &lt;input type="checkbox" id="showParents" name="showParents" &gt;
                    &lt;label for="showParents"&gt;Show parents&lt;/label&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;input class="mt-0" type="text" id="navText" name="navText" placeholder="&lt;nav pattern here&gt;"&gt;

            &lt;label class="mb-0" for="findText"&gt;Find/Replace:&lt;/label&gt;
            &lt;input type="text" id="findText" name="findText" placeholder="&lt;find pattern here&gt;" &gt;
            &lt;!-- &lt;label for="replaceText"&gt;Replace:&lt;/label&gt; --&gt;
            &lt;input type="text" id="replaceText" name="replaceText" placeholder="&lt;replace pattern here&gt;" &gt;
            &lt;div class="row"&gt;
                &lt;div class="col"&gt;
                    &lt;input type="checkbox" id="wholeWord" name="wholeWord" &gt;
                    &lt;label for="wholeWord"&gt;Whole &lt;u&gt;w&lt;/u&gt;ord&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="ignoreCase" name="ignoreCase" &gt;
                    &lt;label for="ignoreCase"&gt;&lt;u&gt;I&lt;/u&gt;gnore case&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="regExp" name="regExp" &gt;
                    &lt;label for="regExp"&gt;Rege&lt;u&gt;x&lt;/u&gt;p&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="markFinds" name="markFinds" &gt;
                    &lt;label for="markFinds"&gt;Mark &lt;u&gt;f&lt;/u&gt;inds&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="markChanges" name="markChanges" &gt;
                    &lt;label for="markChanges"&gt;Mark &lt;u&gt;c&lt;/u&gt;hanges&lt;/label&gt;
                &lt;/div&gt;
                &lt;div class="col"&gt;
                    &lt;!-- RADIOS --&gt;
                    &lt;input type="radio" id="entireOutline" name="searchScope" value="0"&gt;
                    &lt;label for="entireOutline"&gt;&lt;u&gt;E&lt;/u&gt;ntire outline&lt;/label&gt;&lt;br&gt;
                    &lt;input type="radio" id="subOutlineOnly" name="searchScope" value="1"&gt;
                    &lt;label for="subOutlineOnly"&gt;&lt;u&gt;S&lt;/u&gt;uboutline Only&lt;/label&gt;&lt;br&gt;
                    &lt;input type="radio" id="nodeOnly" name="searchScope" value="2"&gt;
                    &lt;label for="nodeOnly"&gt;&lt;u&gt;N&lt;/u&gt;ode only&lt;/label&gt;&lt;br&gt;
                    &lt;!-- CHECKBOXES --&gt;
                    &lt;input type="checkbox" id="searchHeadline" name="searchHeadline" &gt;
                    &lt;label for="searchHeadline"&gt;Search &lt;u&gt;h&lt;/u&gt;eadline&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="searchBody" name="searchBody" &gt;
                    &lt;label for="searchBody"&gt;Search &lt;u&gt;b&lt;/u&gt;ody&lt;/label&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;script nonce="${nonce}" src="${scriptUri}"&gt;&lt;/script&gt;
        &lt;/body&gt;
        &lt;/html&gt;`;
}

</t>
<t tx="fil.20210603195909.1">private getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i &lt; 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}
</t>
<t tx="fil.20210603223013.1"></t>
<t tx="fil.20210603223013.2">@language css
div.row {
  overflow-x: hidden;
  white-space: nowrap;
}

div.col {
  width: 50%;
  max-width: 9.5em;
  display: inline-block;
  text-overflow: ellipsis;
  overflow: hidden;
}
div.col-nav {
  width: 50%;
  display: inline-block;
  text-overflow: ellipsis;
  overflow: hidden;
}
</t>
<t tx="fil.20210603223013.4">@others
@language javascript
@tabwidth -4
</t>
<t tx="fil.20210603223014.2">@language css
html {
	box-sizing: border-box;
	font-size: 13px;
}

*,
*:before,
*:after {
	box-sizing: inherit;
}

body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
ol,
ul {
	margin: 0;
	padding: 0;
	font-weight: normal;
}

img {
	max-width: 100%;
	height: auto;
}
</t>
<t tx="fil.20210603223014.4">@language css
:root {
  --input-padding-vertical: 6px;
  --input-padding-horizontal: 4px;
  --input-margin-vertical: 4px;
  --input-margin-horizontal: 0;
  height: 100%;
  padding-right: 20px;
}

comment {
  --container-padding: 20px;
}

html:focus {
  outline: 1px solid;
  outline-width: 1px;
  outline-style: solid;
  outline-offset: -1px;
  outline-color: var(--vscode-focusBorder);
}

body {
  margin-left: 20px;
  background-color: transparent;
  padding: 0 var(--container-padding);
  color: var(--vscode-foreground);
  font-size: var(--vscode-font-size);
  font-weight: var(--vscode-font-weight);
  font-family: var(--vscode-font-family);
}

.first {
  margin-top: 2px;
  margin-bottom: 0;
  display: inline-block;
}

.mt-8 {
  margin-top: 8px;
  display: inline-block;
}

.mb-0 {
  margin-bottom: 0;
}

.mt-0 {
  margin-top: 0;
}

.align-right {
  text-align: right;
}

.float-left {
  float: left;
}

.float-right {
  float: right;
}

.no-overflow {
  text-overflow: unset !important;
}

ol,
ul {
  padding-left: var(--container-padding);
}

body &gt; *,
form &gt; * {
  margin-block-start: var(--input-margin-vertical);
  margin-block-end: var(--input-margin-vertical);
}

*:focus {
  outline-color: var(--vscode-focusBorder);
}

a {
  color: var(--vscode-textLink-foreground);
}

a:hover,
a:active {
  color: var(--vscode-textLink-activeForeground);
}

code {
  font-size: var(--vscode-editor-font-size);
  font-family: var(--vscode-editor-font-family);
}

button {
  border: none;
  padding: var(--input-padding-vertical) var(--input-padding-horizontal);
  width: 100%;
  text-align: center;
  outline: 1px solid transparent;
  outline-offset: 2px !important;
  color: var(--vscode-button-foreground);
  background: var(--vscode-button-background);
}

button:hover {
  cursor: pointer;
  background: var(--vscode-button-hoverBackground);
}

button:focus {
  outline-color: var(--vscode-focusBorder);
}

button.secondary {
  color: var(--vscode-button-secondaryForeground);
  background: var(--vscode-button-secondaryBackground);
}

button.secondary:hover {
  background: var(--vscode-button-secondaryHoverBackground);
}

select {
  background: var(--vscode-dropdown-background);
  color: var(--vscode-input-foreground);
  border-color: var(--vscode-dropdown-border);
  cursor: pointer;
  width: 50px;
  left: 15%;
  position: relative;
  border-radius: 2px;
}
select option {
  background-color: var(--vscode-dropdown-listBackground);
}
select option:focus {
  background-color: var(--vscode-input-background);
  outline-color: var(--vscode-input-border);
}

input:not([type="radio"]):not([type="checkbox"]),
textarea {
  display: block;
  margin-right: 20px;
  width: 100%;
  border: none;
  font-family: var(--vscode-font-family);
  padding: var(--input-padding-vertical) var(--input-padding-horizontal);
  padding: 3px var(--input-padding-horizontal);
  border-radius: 2px;
  color: var(--vscode-input-foreground);
  outline-color: var(--vscode-input-border);
  background-color: var(--vscode-input-background);
}

input[type="checkbox"]:focus + label {
  border: 1px solid var(--vscode-button-background);
}
input[type="radio"]:focus + label {
  border: 1px solid var(--vscode-button-background);
}

input::placeholder,
textarea::placeholder {
  color: var(--vscode-input-placeholderForeground);
}

u {
  color: var(--vscode-editor-foreground);
  text-decoration-color: var(--vscode-foreground);
  text-underline-offset: 0.04em;
}

body &gt; div &gt; div &gt; label:focus,
body &gt; div &gt; div &gt; label:active {
  outline-color: none !important;
  border: none !important;
}
</t>
<t tx="fil.20210603223933.1"></t>
<t tx="fil.20210603223933.10">&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
&lt;/head&gt;

&lt;body class="preload"&gt;
  &lt;div class="container"&gt;

    &lt;header&gt;
      &lt;a class="header__link"
         title="Learn more about Leo Integration"
         href="https://github.com/boltex/leointeg#-leo-for-vs-code"&gt;
        &lt;div class="header__logo"&gt;
          &lt;img class="image__logo"
               src="#{root}/resources/leoapp128px.png" /&gt;
          &lt;div&gt;
            &lt;h1&gt;Leo&lt;span class="header__logo--highlight"&gt;Integ&lt;/span&gt;&lt;/h1&gt;
            &lt;p class="header__subtitle"&gt;Leo for VS Code&lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/a&gt;
      &lt;p class="header__blurb"&gt;
        Use &lt;b&gt;Leo&lt;/b&gt;, the Literate Editor with Outlines, to program with &lt;b&gt;directed acyclic graphs&lt;/b&gt;,
        along with section-references, '@others', and clones.
      &lt;/p&gt;
    &lt;/header&gt;

    &lt;div class="hero__area"&gt;
      &lt;p&gt;
        &lt;a class="bold"
           title="Learn more about LeoInteg"
           href="https://github.com/boltex/leointeg#-leo-editor-integration-with-visual-studio-code"&gt;LeoInteg&lt;/a&gt;
        is an open-source extension created by
        &lt;a class="bold"
           title="My github user page"
           href="https://boltex.github.io/"&gt;Félix&lt;/a&gt; that integrates &lt;a class="bold"
           title="Learn more about Leo"
           href="https://leoeditor.com/"&gt;Leo&lt;/a&gt; into VS Code.
      &lt;/p&gt;
    &lt;/div&gt;

    &lt;div class="content__area"&gt;
      &lt;section id="welcome"
               class="section--full mb-0"&gt;
        &lt;h2 class="section__title section__title--primary"&gt;
          Welcome to &lt;span class="highlight"&gt;LeoInteg 1.0.7&lt;/span&gt;
        &lt;/h2&gt;
        &lt;div class="center mt-1"&gt;
          &lt;a class="button button--flat is-sidebar-hidden "
             title="LeoInteg is built by the support of generous users like you!"
             href="https://boltex.github.io/"&gt;Sponsor LeoInteg
            &lt;span class="heart"&gt;&amp;#x2764;&lt;/span&gt;
          &lt;/a&gt;
          &lt;a class="button button--flat"
             title="LeoInteg's Features"
             href="https://github.com/boltex/leointeg#features"&gt;
            See What's New in LeoInteg 1.0.7
          &lt;/a&gt;
        &lt;/div&gt;
        &lt;p class="blurb center ml-0 mr-0"&gt;
          LeoInteg is designed to &lt;b&gt;provide Leo's functionality&lt;/b&gt;
          and can be &lt;b&gt;customized&lt;/b&gt; to meet your needs.
        &lt;/p&gt;
        &lt;h2 class="section__title section__title--break"&gt;&lt;/h2&gt;
        &lt;p class="section__hint mt-0 center"&gt;
          Automate the &lt;a href="#leobridge-options"
             title="Setup server options"&gt;Leo server startup&lt;/a&gt;,
          auto-refresh when &lt;a href="#external-files"
             title="Setup file-change detection"&gt;external files change&lt;/a&gt;,
          or choose which &lt;a href="#node-commands"
             title="Fine-tune interface"&gt;node icons&lt;/a&gt;
          are shown and more with the options below.
        &lt;/p&gt;
      &lt;/section&gt;

      &lt;section id="leobridge-options"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Leo Server Options
            &lt;/h2&gt;
          &lt;/div&gt;
          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="startServerAutomatically"
                       name="startServerAutomatically"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="startServerAutomatically"&gt;Start&amp;nbsp;Server&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Run the leoserver.py server script at startup&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="connectToServerAutomatically"
                       name="connectToServerAutomatically"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="connectToServerAutomatically"&gt;Connect&amp;nbsp;to&amp;nbsp;Server&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Connects automatically to a Leo server&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="leoEditorPath"&gt;Leo&amp;#8209;Editor&amp;nbsp;Path&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/label&gt;
                &lt;input id="leoEditorPath"
                       name="leoEditorPath"
                       type="text"
                       maxlength="256"
                       placeholder="C:/leo-editor"
                       data-setting /&gt;
                &lt;button type="button"
                        id="chooseLeoEditorPath"
                        name="chooseLeoEditorPath"
                        class="button btn button--flat button--flat-primary button--choose-path"&gt;
                  Browse For Folder...
                &lt;/button&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Location of your Leo-Editor installation&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="leoPythonCommand"&gt;Python&amp;nbsp;Command&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/label&gt;
                &lt;input id="leoPythonCommand"
                       name="leoPythonCommand"
                       type="text"
                       maxlength="256"
                       placeholder="Empty for default"
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Command for starting python (Defaults to 'py' on windows, or
                'python3' otherwise)&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="connectionAddress"&gt;Connection&amp;nbsp;Address&lt;/label&gt;
                &lt;input id="connectionAddress"
                       name="connectionAddress"
                       type="text"
                       maxlength="256"
                       placeholder="Host Name, IP Address or localhost"
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Connection host&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="connectionPort"&gt;Connection&amp;nbsp;Port&lt;/label&gt;
                &lt;input id="connectionPort"
                       name="connectionPort"
                       type="number"
                       min="0"
                       max="65535"
                       max-length="5"
                       placeholder="Port Number"
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Connection host port number&lt;/span&gt;
            &lt;/div&gt;

            &lt;fieldset&gt;
              &lt;legend&gt;Experimental Features&lt;/legend&gt;
              &lt;div class="setting"&gt;
                &lt;div class="setting__input"&gt;
                  &lt;input id="setDetached"
                         name="setDetached"
                         type="checkbox"
                         data-setting /&gt;
                  &lt;label for="setDetached"&gt;Spawn&amp;nbsp;Detached&lt;/label&gt;
                &lt;/div&gt;
                &lt;span class="setting__hint"&gt;Server spawned with 'detached' option&lt;br&gt;
                  (Shows dialog when quitting with unsaved files)&lt;/span&gt;
              &lt;/div&gt;
              &lt;div class="setting"&gt;
                &lt;div class="setting__input"&gt;
                  &lt;label for="limitUsers"&gt;User&amp;nbsp;Limit&lt;/label&gt;
                  &lt;input id="limitUsers"
                         name="limitUsers"
                         type="number"
                         min="0"
                         max="255"
                         max-length="3"
                         placeholder="1 to 255"
                         data-setting /&gt;
                &lt;/div&gt;
                &lt;span class="setting__hint"&gt;Server's max simultaneous connections&lt;/span&gt;
              &lt;/div&gt;
              &lt;br&gt;
              &lt;p&gt;For a standalone, persistent, or multi-user server
                see &lt;a href="https://leoeditor.com/leoserver.html"
                   title="Leo server documentation"&gt;Using leoserver.py&lt;/a&gt;
                from Leo's documentation.
              &lt;/p&gt;
            &lt;/fieldset&gt;

          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="external-files"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              External Files Change Detection
            &lt;/h2&gt;
          &lt;/div&gt;
          &lt;div class="settings"&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="checkForChangeExternalFiles"&gt;Check changes to external files&lt;/label&gt;
                &lt;select id="checkForChangeExternalFiles"
                        name="checkForChangeExternalFiles"
                        data-setting&gt;
                  &lt;option value="none"&gt;Default from Leo's config&lt;/option&gt;
                  &lt;option value="force-check"&gt;Check for changes&lt;/option&gt;
                  &lt;option value="force-ignore"&gt;Ignore all changes&lt;/option&gt;
                &lt;/select&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Use Leo's defaults, or force either to check changes or not&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="defaultReloadIgnore"&gt;Force reload or ignore changes&lt;/label&gt;
                &lt;select id="defaultReloadIgnore"
                        name="defaultReloadIgnore"
                        data-setting&gt;
                  &lt;option value="none"&gt;Choose each time&lt;/option&gt;
                  &lt;option value="yes-all"&gt;Reload All&lt;/option&gt;
                  &lt;option value="no-all"&gt;Ignore All&lt;/option&gt;
                &lt;/select&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Choose yourself, or set default to reload or ignore changes&lt;/span&gt;
            &lt;/div&gt;

          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="interface-behavior"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Interface Behavior
            &lt;/h2&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="leoTreeBrowse"
                       name="leoTreeBrowse"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="leoTreeBrowse"&gt;Use Leo Tree Browsing&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Navigate Leo's outline with Leo's shortcuts and behavior instead of the
                default vscode
                method&lt;br&gt;(Arrow keys move selection instead of moving a cursor when focus is on Leo's outline)&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="treeKeepFocus"
                       name="treeKeepFocus"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="treeKeepFocus"&gt;Keep focus on Outline&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Keep focus in the outline when selecting a node - overridden by "&lt;strong&gt;Leo
                  Tree
                  Browsing"&lt;/strong&gt;&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="treeKeepFocusWhenAside"
                       name="treeKeepFocusWhenAside"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="treeKeepFocusWhenAside"&gt;Keep focus when opening on the side&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Keep focus in the outline when opening a body pane on the side&lt;/span&gt;
            &lt;/div&gt;

          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="tree-in-explorer"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;div class="setting__input setting__input--big"&gt;
              &lt;input id="treeInExplorer"
                     name="treeInExplorer"
                     type="checkbox"
                     data-setting /&gt;
              &lt;label for="treeInExplorer"&gt;Show&amp;nbsp;Leo&amp;nbsp;Outline&amp;nbsp;in&amp;nbsp;Explorer&lt;/label&gt;
            &lt;/div&gt;
            &lt;p class="section__header-hint"&gt;
              Adds an instance of the outline pane in the explorer view
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="section__preview"&gt;
          &lt;img class="image__preview"
               src="#{root}/resources/treeInExplorerDisabled.png" /&gt;
          &lt;img class="image__preview--overlay hidden"
               src="#{root}/resources/treeInExplorerEnabled.png"
               data-visibility="treeInExplorer" /&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="show-open-aside"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;div class="setting__input setting__input--big"&gt;
              &lt;input id="showOpenAside"
                     name="showOpenAside"
                     type="checkbox"
                     data-setting /&gt;
              &lt;label for="showOpenAside"&gt;Show&amp;nbsp;'Open&amp;nbsp;to&amp;nbsp;the&amp;nbsp;Side'&lt;/label&gt;
            &lt;/div&gt;
            &lt;p class="section__header-hint"&gt;
              Adds the command in the node's context menu
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="section__preview"&gt;
          &lt;img class="image__preview"
               src="#{root}/resources/showOpenAsideDisabled.png" /&gt;
          &lt;img class="image__preview--overlay hidden"
               src="#{root}/resources/showOpenAsideEnabled.png"
               data-visibility="showOpenAside" /&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="invert-contrast"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;div class="setting__input setting__input--big"&gt;
              &lt;input id="invertNodeContrast"
                     name="invertNodeContrast"
                     type="checkbox"
                     data-setting /&gt;
              &lt;label for="invertNodeContrast"&gt;Invert Node Contrast&lt;/label&gt;
            &lt;/div&gt;
            &lt;p class="section__header-hint"&gt;
              Inverts the dirty/clean border of tree nodes
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="section__preview"&gt;
          &lt;img class="image__preview"
               src="#{root}/resources/invertedDisabled.png" /&gt;
          &lt;img class="image__preview--overlay hidden"
               src="#{root}/resources/invertedEnabled.png"
               data-visibility="invertNodeContrast" /&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="node-commands"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Node Commands
            &lt;/h2&gt;
            &lt;p class="section__header-hint"&gt;
              Hovering tree nodes displays an edit icon - Choose more commands to display when hovering
            &lt;/p&gt;
          &lt;/div&gt;
          &lt;div class="section__preview"&gt;

            &lt;img class="image__preview"
                 src="#{root}/resources/allIconsDisabled.png" /&gt;

            &lt;div class="image__preview--float-container"&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/bookmark.png"
                   data-visibility="showMarkOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/copy.png"
                   data-visibility="showCopyOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/clone.png"
                   data-visibility="showCloneOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/arrows.png"
                   data-visibility="showArrowsOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/add.png"
                   data-visibility="showAddOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/editHeadline.png"
                   data-visibility="showEditOnNodes" /&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showEditOnNodes"
                       name="showEditOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showEditOnNodes"&gt;Edit&amp;nbsp;Headline&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Edit Headline' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showMarkOnNodes"
                       name="showMarkOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showMarkOnNodes"&gt;Mark&amp;nbsp;/&amp;nbsp;Unmark&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Mark/Unmark' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showCopyOnNodes"
                       name="showCopyOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showCopyOnNodes"&gt;Copy&amp;nbsp;Node&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Copy' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showCloneOnNodes"
                       name="showCloneOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showCloneOnNodes"&gt;Clone&amp;nbsp;Node&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Clone' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showArrowsOnNodes"
                       name="showArrowsOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showArrowsOnNodes"&gt;Move&amp;nbsp;arrow&amp;nbsp;commands&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Move' arrows on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showAddOnNodes"
                       name="showAddOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showAddOnNodes"&gt;Add&amp;nbsp;Node&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Insert' on hover&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;

        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="editor-commands"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Body Editor Icons
            &lt;/h2&gt;
            &lt;p class="section__header-hint"&gt;
              Command Icons to display atop the Body Pane: &lt;em&gt;Limited to the first leftmost 9 icons&lt;/em&gt;
            &lt;/p&gt;
          &lt;/div&gt;
          &lt;div class="section__preview"&gt;

            &lt;img class="image__preview__body"
                 src="#{root}/resources/body-menu.png" /&gt;

            &lt;div class="image__preview__body--float-container"&gt;

              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-refresh.png"
                   data-visibility="showRefreshOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-import.png"
                   data-visibility="showImportOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-sort.png"
                   data-visibility="showSortOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-mark.png"
                   data-visibility="showMarkOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-clipboard.png"
                   data-visibility="showClipboardOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-edition.png"
                   data-visibility="showEditionOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-extract.png"
                   data-visibility="showExtractOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-execute.png"
                   data-visibility="showExecuteOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-promote.png"
                   data-visibility="showPromoteOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-hoist.png"
                   data-visibility="showHoistOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-prev-next.png" /&gt;

            &lt;/div&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showEditionOnBody"
                       name="showEditionOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showEditionOnBody"&gt;Outline&amp;nbsp;Edition&amp;nbsp;Commands&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Clone, Delete and Insert nodes&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showClipboardOnBody"
                       name="showClipboardOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showClipboardOnBody"&gt;Clipboard&amp;nbsp;Operations&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Cut, Copy and Paste nodes&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showPromoteOnBody"
                       name="showPromoteOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showPromoteOnBody"&gt;Promote&amp;nbsp;&amp;amp;&amp;nbsp;Demote&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Promote children, demote siblings&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showExecuteOnBody"
                       name="showExecuteOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showExecuteOnBody"&gt;Execute&amp;nbsp;Script&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Executes node or selected text&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showExtractOnBody"
                       name="showExtractOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showExtractOnBody"&gt;Extract&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Extract Text and Names&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showImportOnBody"
                       name="showImportOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showImportOnBody"&gt;Import&amp;nbsp;File&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Import any file into a node&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showRefreshOnBody"
                       name="showRefreshOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showRefreshOnBody"&gt;Refresh&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Refresh an external file from disk&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showHoistOnBody"
                       name="showHoistOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showHoistOnBody"&gt;Hoist&amp;nbsp;&amp;amp;&amp;nbsp;Dehoist&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Isolate part of the outline&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showMarkOnBody"
                       name="showMarkOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showMarkOnBody"&gt;Mark&amp;nbsp;&amp;amp;&amp;nbsp;Unmark&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Mark or unmark tree nodes&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showSortOnBody"
                       name="showSortOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showSortOnBody"&gt;Sort&amp;nbsp;Siblings&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Sort siblings of a node alphabetically&lt;/span&gt;
            &lt;/div&gt;

          &lt;/div&gt;

        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="font-sizes"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Outline and Body Font Sizes
            &lt;/h2&gt;
            &lt;p class="section__header-hint"&gt;
              &lt;em&gt;Start by adjusting the Outline pane&lt;/em&gt;, by changing the global &lt;em&gt;Zoom Level&lt;/em&gt;.&lt;br&gt;
              Then, resize the the &lt;em&gt;Body Pane font size&lt;/em&gt; by changing the &lt;em&gt;Editor Font Size&lt;/em&gt;.
            &lt;/p&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="zoomLevel"&gt;Zoom Level&lt;/label&gt;
                &lt;input id="zoomLevel"
                       name="zoomLevel"
                       type="number"
                       min="-12"
                       max="12"
                       maxlength="2"
                       placeholder="Number"
                       data-vscode /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;
                Adjust the zoom level&lt;br&gt;
                of the window.&lt;br&gt;
                (Original size is 0 and each&lt;br&gt;
                increment above 1 or below -1&lt;br&gt;
                represents zooming 20%.&lt;br&gt;
                You can also use decimals.)
              &lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="editorFontSize"&gt;Editor Font Size&lt;/label&gt;
                &lt;input id="editorFontSize"
                       name="editorFontSize"
                       type="number"
                       min="6"
                       max="30"
                       maxlength="2"
                       placeholder="Number"
                       data-vscode /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;
                Controls the Text-Editor&lt;br&gt;
                pane font size in pixels.&lt;br&gt;
                Set this after having set the&lt;br&gt;
                Zoom Level for the outline, as&lt;br&gt;
                it's affected by the Zoom Level.
              &lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="statusbar-indicator"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Statusbar Indicator
            &lt;/h2&gt;
            &lt;p class="section__header-hint"&gt;
              Keyboard icon can also include a label and be displayed in a specific color
            &lt;/p&gt;
          &lt;/div&gt;

          &lt;div class="section__preview"&gt;
            &lt;img class="image__preview"
                 src="#{root}/resources/statusbar.png" /&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="statusBarString"&gt;Status Bar Keyboard indicator&lt;/label&gt;
                &lt;input id="statusBarString"
                       name="statusBarString"
                       type="text"
                       maxlength="8"
                       placeholder="Status bar indicator text "
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Leo's keybindings 'on/off' indicator text message&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="statusBarColor"&gt;Status Bar Color&lt;/label&gt;
                &lt;input id="statusBarColor"
                       name="statusBarColor"
                       type="text"
                       maxlength="6"
                       placeholder="RrGgBb"
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Leo's keybindings 'on' indicator 6 hex digits color code&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;
    &lt;/div&gt;

    &lt;div class="sidebar"&gt;
      &lt;div class="sidebar__group"&gt;
        &lt;a class="button button--flat-primary"
           title="Support LeoInteg Development"
           href="https://boltex.github.io/"&gt;Sponsor
          LeoInteg &amp;#x2764;&lt;/a&gt;
        &lt;p&gt;
          LeoInteg is built by the support of generous users like &lt;b&gt;you&lt;/b&gt;!
        &lt;/p&gt;
      &lt;/div&gt;

      &lt;div class="sidebar__group"&gt;
        &lt;h2&gt;Configuration&lt;/h2&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href="#leobridge-options"
               title="Server settings"&gt;Leo server Options&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#external-files"
               title="File change detection settings"&gt;External Files&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#interface-behavior"
               title="Outline behavior settings"&gt;Interface Behavior&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#tree-in-explorer"
               title="Outline visibility settings"&gt;Outline in Explorer&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#show-open-aside"
               title="Outline context menu settings"&gt;Open to the Side&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#invert-contrast"
               title="UI contrast settings"&gt;Invert Contrast&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#node-commands"
               title="Outline nodes settings"&gt;Node Hover Commands&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#editor-commands"
               title="Body editor menu settings"&gt;Body Editor Icons&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#font-sizes"
               title="Font size settings"&gt;Font Sizes&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#statusbar-indicator"
               title="Statusbar settings"&gt;Statusbar Indicator&lt;/a&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;

      &lt;!-- &lt;div class="sidebar__group"&gt;
        &lt;h2&gt;Help&lt;/h2&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href="https://github.com/boltex/leointeg#requirements"&gt;Documentation&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://github.com/boltex/leointeg/blob/master/CHANGELOG.md#change-log"&gt;Changelog&lt;/a&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt; --&gt;

      &lt;div class="sidebar__group"&gt;
        &lt;h2&gt;About Leo&lt;/h2&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href="https://leoeditor.com/"
               title="Leo’s Home Page"&gt;Home Page&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://leoeditor.com/leo_toc.html"
               title="Leo’s Documentation Page"&gt;Documentation&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://groups.google.com/forum/#!forum/leo-editor"
               title="Leo Editor Forum"&gt;Forum&lt;/a&gt;
            &lt;small&gt; &amp;nbsp;&amp;nbsp;&amp;mdash;&amp;nbsp; #Google Group&lt;/small&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://github.com/leo-editor/leo-editor"
               title="Leo Editor on GitHub"&gt;Source&lt;/a&gt;
            &lt;small&gt; &amp;nbsp;&amp;nbsp;&amp;mdash;&amp;nbsp; #GitHub&lt;/small&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;

  &lt;/div&gt;
  &lt;div id="dirty-config-toast"&gt;Saving...&lt;/div&gt;
  &lt;div id="saved-config-toast"&gt;Settings Saved&lt;/div&gt;
  #{endOfBody}
&lt;/body&gt;

&lt;/html&gt;
</t>
<t tx="fil.20210603223933.165">import { initializeAndWatchThemeColors } from './theme';
import { debounce } from "debounce";
import { ConfigSetting, IVsCodeApi } from '../../types';

declare function acquireVsCodeApi(): IVsCodeApi;

@others
@language typescript
@tabwidth -4
</t>
<t tx="fil.20210603223933.166">(function () {
    const vscode = acquireVsCodeApi();
    initializeAndWatchThemeColors();

    const toast = document.getElementById("saved-config-toast");
    const dirty = document.getElementById("dirty-config-toast");

    // * TEST
    const oldState = vscode.getState();
    let currentCount: number = (oldState &amp;&amp; oldState.count) || 0;
    if (currentCount) {
        // Already opened! Get fresh and recent config!
        vscode.postMessage({
            command: "getNewConfig"
        });
    }
    currentCount = currentCount + 1;
    vscode.setState({ count: currentCount });

    // * SETUP
    // Global variable config
    let frontConfig: { [key: string]: any } = {};
    let vscodeConfig: { [key: string]: any } = {};
    let vscodeFontConfig: { [key: string]: any } = {};
    let frontFontConfig: { [key: string]: any } = {};

    vscodeConfig = (window as any).leoConfig; // ! PRE SET BY leoSettingsWebview
    frontConfig = JSON.parse(JSON.stringify(vscodeConfig));
    vscodeFontConfig = (window as any).fontConfig; // ! PRE SET BY leoSettingsWebview
    frontFontConfig = JSON.parse(JSON.stringify(vscodeFontConfig));

    // Handle messages sent from the extension to the webview
    window.addEventListener("message", event =&gt; {
        const message = event.data; // The json data that the extension sent
        if (message.command) {
            switch (message.command) {
                case "test":
                    console.log("got test message");
                    break;
                case "newConfig":
                    vscodeConfig = message.config;
                    frontConfig = JSON.parse(JSON.stringify(message.config));
                    setControls();
                    break;
                case "vscodeConfig":
                    dirty!.className = dirty!.className.replace("show", "");
                    toast!.className = "show";
                    setTimeout(function () { toast!.className = toast!.className.replace("show", ""); }, 1500);
                    vscodeConfig = message.config; // next changes will be confronted to those settings
                    break;
                case "newFontConfig":
                    vscodeFontConfig = message.config;
                    frontFontConfig = JSON.parse(JSON.stringify(message.config));
                    setFontControls();
                    break;
                case "vscodeFontConfig":
                    vscodeFontConfig = message.config; // next changes will be confronted to those settings
                    break;
                case "newEditorPath":
                    const w_element: HTMLElement | null = document.getElementById("leoEditorPath");
                    if (w_element) {
                        (w_element as HTMLInputElement).value = message.editorPath;
                        onInputChanged(w_element as HTMLInputElement);
                    }
                    break;
                default:
                    console.log("got message: ", message.command);
                    break;
            }
        } else {
            console.log('got object without command:', message);
        }
    });

    @others

    var applyChanges = debounce(function () {
        var w_changes: ConfigSetting[] = [];
        if (frontConfig) {
            for (var prop in frontConfig) {
                if (Object.prototype.hasOwnProperty.call(frontConfig, prop)) {
                    // console.log(prop);
                    if (frontConfig[prop] !== vscodeConfig[prop]) {
                        w_changes.push({ code: prop, value: frontConfig[prop] });
                    }
                }
            }
        }
        if (w_changes.length) {
            // ok replace!
            vscodeConfig = frontConfig;
            frontConfig = JSON.parse(JSON.stringify(frontConfig));
            vscode.postMessage({
                command: "config",
                changes: w_changes
            });
        } else {
            // Still have to remove 'modified' popup
            dirty!.className = dirty!.className.replace("show", "");
        }
    }, 1500);

    var applyFontChanges = debounce(function () {
        vscode.postMessage({
            command: "fontConfig",
            changes: frontFontConfig
        });
    }, 800);


    // * START
    const w_button: HTMLElement | null = document.getElementById('chooseLeoEditorPath');
    if (w_button) {
        w_button.onclick = chooseLeoEditorPath;
    }
    setControls();
    setFontControls();
    setVisibility(frontConfig);
    onBind();

})();
</t>
<t tx="fil.20210603223933.2">const cssColorRegex = /^(?:(#?)([0-9a-f]{3}|[0-9a-f]{6})|((?:rgb|hsl)a?)\((-?\d+%?)[,\s]+(-?\d+%?)[,\s]+(-?\d+%?)[,\s]*(-?[\d.]+%?)?\))$/i;

@others
@language typescript
@tabwidth -4
</t>
<t tx="fil.20210603223933.3">function adjustLight(color: number, amount: number) {
    const cc = color + amount;
    const c = amount &lt; 0 ? (cc &lt; 0 ? 0 : cc) : cc &gt; 255 ? 255 : cc;

    return Math.round(c);
}

</t>
<t tx="fil.20210603223933.4">export function darken(color: string, percentage: number) {
    return lighten(color, -percentage);
}

</t>
<t tx="fil.20210603223933.5">export function lighten(color: string, percentage: number) {
    const rgba = toRgba(color);
    // tslint:disable-next-line: triple-equals
    if (rgba == null) { return color; }

    const [r, g, b, a] = rgba;
    const amount = (255 * percentage) / 100;
    return `rgba(${adjustLight(r, amount)}, ${adjustLight(g, amount)}, ${adjustLight(b, amount)}, ${a})`;
}

</t>
<t tx="fil.20210603223933.6">export function opacity(color: string, percentage: number) {
    const rgba = toRgba(color);
    // tslint:disable-next-line: triple-equals
    if (rgba == null) { return color; }

    const [r, g, b, a] = rgba;
    return `rgba(${r}, ${g}, ${b}, ${a * (percentage / 100)})`;
}

</t>
<t tx="fil.20210603223933.7">export function toRgba(color: string) {
    color = color.trim();

    const result = cssColorRegex.exec(color);
    // tslint:disable-next-line: triple-equals
    if (result == null) { return null; }

    if (result[1] === '#') {
        const hex = result[2];
        switch (hex.length) {
            case 3:
                return [parseInt(hex[0] + hex[0], 16), parseInt(hex[1] + hex[1], 16), parseInt(hex[2] + hex[2], 16), 1];
            case 6:
                return [
                    parseInt(hex.substring(0, 2), 16),
                    parseInt(hex.substring(2, 4), 16),
                    parseInt(hex.substring(4, 6), 16),
                    1
                ];
        }

        return null;
    }

    switch (result[3]) {
        case 'rgb':
            return [parseInt(result[4], 10), parseInt(result[5], 10), parseInt(result[6], 10), 1];
        case 'rgba':
            return [parseInt(result[4], 10), parseInt(result[5], 10), parseInt(result[6], 10), parseFloat(result[7])];
        default:
            return null;
    }
}
</t>
<t tx="fil.20210603223933.9">&lt;!DOCTYPE html&gt;
@others
@language html
@tabwidth -2
</t>
<t tx="fil.20210603223934.1">function listenAll(selector: string, name: string, listener: EventListener) {
    const els = (document.querySelectorAll(selector) as unknown) as Element[];
    for (const el of els) {
        el.addEventListener(name, listener, false);
    }
}

</t>
<t tx="fil.20210603223934.10">function setVisibility(state: { [key: string]: string | boolean }) {
    for (const el of document.querySelectorAll&lt;HTMLElement&gt;('[data-visibility]')) {
        el.classList.toggle('hidden', !evaluateStateExpression(el.dataset.visibility!, state));
    }
}
</t>
<t tx="fil.20210603223934.11">function parseStateExpression(expression: string): [string, string, string | boolean | undefined] {
    const [lhs, op, rhs] = expression.trim().split(/([=+!])/);
    return [lhs.trim(), op !== undefined ? op.trim() : '=', rhs !== undefined ? rhs.trim() : rhs];
}

</t>
<t tx="fil.20210603223934.12">function evaluateStateExpression(expression: string, changes: { [key: string]: string | boolean }): boolean {
    let state = false;

    for (const expr of expression.trim().split('&amp;')) {
        const [lhs, op, rhs] = parseStateExpression(expr);

        switch (op) {
            case '=': {
                // Equals
                let value = changes[lhs];
                if (value === undefined) {
                    value = getSettingValue(lhs) || false;
                }
                state = rhs !== undefined ? rhs === String(value) : Boolean(value);
                break;
            }
            case '!': {
                // Not equals
                let value = changes[lhs];
                if (value === undefined) {
                    value = getSettingValue(lhs) || false;
                }
                state = rhs !== undefined ? rhs !== String(value) : !value;
                break;
            }
            case '+': {
                // Contains
                if (rhs !== undefined) {
                    const setting = getSettingValue(lhs);
                    state = setting !== undefined ? setting.includes(rhs.toString()) : false;
                }
                break;
            }
        }

        if (!state) { break; }
    }
    return state;
}

</t>
<t tx="fil.20210603223934.13">function getSettingValue(p_setting: string): any {
    return frontConfig[p_setting];
}
</t>
<t tx="fil.20210603223934.15">import { darken, lighten, opacity } from './colors';

@others
@language typescript
@tabwidth -4
</t>
<t tx="fil.20210603223934.16">export function initializeAndWatchThemeColors() {
    const onColorThemeChanged = () =&gt; {
        const body = document.body;
        const computedStyle = window.getComputedStyle(body);

        const bodyStyle = body.style;

        const font = computedStyle.getPropertyValue('--vscode-font-family').trim();
        if (font) {
            bodyStyle.setProperty('--font-family', font);
            bodyStyle.setProperty('--font-size', computedStyle.getPropertyValue('--vscode-font-size').trim());
            bodyStyle.setProperty('--font-weight', computedStyle.getPropertyValue('--vscode-font-weight').trim());
        } else {
            bodyStyle.setProperty(
                '--font-family',
                computedStyle.getPropertyValue('--vscode-editor-font-family').trim()
            );
            bodyStyle.setProperty('--font-size', computedStyle.getPropertyValue('--vscode-editor-font-size').trim());
            bodyStyle.setProperty(
                '--font-weight',
                computedStyle.getPropertyValue('--vscode-editor-font-weight').trim()
            );
        }

        let color = computedStyle.getPropertyValue('--vscode-editor-background').trim();
        bodyStyle.setProperty('--color-background', color);
        bodyStyle.setProperty('--color-background--lighten-05', lighten(color, 5));
        bodyStyle.setProperty('--color-background--darken-05', darken(color, 5));
        bodyStyle.setProperty('--color-background--lighten-075', lighten(color, 7.5));
        bodyStyle.setProperty('--color-background--darken-075', darken(color, 7.5));
        bodyStyle.setProperty('--color-background--lighten-15', lighten(color, 15));
        bodyStyle.setProperty('--color-background--darken-15', darken(color, 15));
        bodyStyle.setProperty('--color-background--lighten-30', lighten(color, 30));
        bodyStyle.setProperty('--color-background--darken-30', darken(color, 30));
        bodyStyle.setProperty('--color-background--lighten-50', lighten(color, 50));
        bodyStyle.setProperty('--color-background--darken-50', darken(color, 50));

        color = computedStyle.getPropertyValue('--vscode-button-background').trim();
        bodyStyle.setProperty('--color-button-background', color);
        bodyStyle.setProperty('--color-button-background--darken-30', darken(color, 30));

        color = computedStyle.getPropertyValue('--vscode-button-foreground').trim();
        bodyStyle.setProperty('--color-button-foreground', color);

        color = computedStyle.getPropertyValue('--vscode-editor-foreground').trim();
        if (!color) {
            color = computedStyle.getPropertyValue('--vscode-foreground').trim();
        }
        bodyStyle.setProperty('--color-foreground', color);
        bodyStyle.setProperty('--color-foreground--85', opacity(color, 85));
        bodyStyle.setProperty('--color-foreground--75', opacity(color, 75));
        bodyStyle.setProperty('--color-foreground--65', opacity(color, 65));
        bodyStyle.setProperty('--color-foreground--50', opacity(color, 50));

        color = computedStyle.getPropertyValue('--vscode-focusBorder').trim();
        bodyStyle.setProperty('--color-focus-border', color);

        color = computedStyle.getPropertyValue('--vscode-textLink-foreground').trim();
        bodyStyle.setProperty('--color-link-foreground', color);
        bodyStyle.setProperty('--color-link-foreground--darken-20', darken(color, 20));
        bodyStyle.setProperty('--color-link-foreground--lighten-20', lighten(color, 20));
    };

    const observer = new MutationObserver(onColorThemeChanged);
    observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });

    onColorThemeChanged();
    return observer;
}
</t>
<t tx="fil.20210603223934.2">function chooseLeoEditorPath() {
    vscode.postMessage({
        command: "chooseLeoEditorPath"
    });
}

</t>
<t tx="fil.20210603223934.3">function onBind() {
    listenAll('input[type=checkbox][data-setting]', 'change', function (this: HTMLInputElement) {
        return onInputChecked(this);
    });
    listenAll('input[type=text][data-setting], input:not([type])[data-setting]', 'blur', function (
        this: HTMLInputElement
    ) {
        return onInputBlurred(this);
    });
    listenAll('input[type=text][data-setting], input:not([type])[data-setting]', 'focus', function (
        this: HTMLInputElement
    ) {
        return onInputFocused(this);
    });
    listenAll('input[type=text][data-setting], input[type=number][data-setting]', 'input', function (
        this: HTMLInputElement
    ) {
        return onInputChanged(this);
    });
    listenAll('select[data-setting]', 'change', function (this: HTMLSelectElement) {
        return onDropdownChanged(this);
    });
    listenAll('input[type=number][data-vscode]', 'input', function (
        this: HTMLInputElement
    ) {
        return onVscodeInputChanged(this);
    });
}

</t>
<t tx="fil.20210603223934.4">function onDropdownChanged(element: HTMLSelectElement) {
    if (element) {
        const w_value = element.options[element.selectedIndex].value;
        frontConfig[element.id] = w_value;
    }
    dirty!.className = "show";
    applyChanges();
}

</t>
<t tx="fil.20210603223934.5">function onInputChecked(element: HTMLInputElement) {
    frontConfig[element.id] = element.checked;
    setVisibility(frontConfig);
    dirty!.className = "show";
    applyChanges();
}
</t>
<t tx="fil.20210603223934.6">function onInputBlurred(element: HTMLInputElement) {
    // console.log('onInputBlurred', element);
}
</t>
<t tx="fil.20210603223934.7">function onInputFocused(element: HTMLInputElement) {
    // console.log('onInputFocused', element);
}
</t>
<t tx="fil.20210603223934.8">function onInputChanged(element: HTMLInputElement) {
    if (element.type === 'number' &amp;&amp; Number(element.value) &lt; Number(element.max) &amp;&amp; Number(element.value) &gt; Number(element.min)) {
        frontConfig[element.id] = Number(element.value);
        element.classList.remove("is-invalid");
    } else if (element.type === 'number' &amp;&amp; (Number(element.value) &gt; Number(element.max) || Number(element.value) &lt; Number(element.min))) {
        // make red
        element.classList.add("is-invalid");
    } else if (element.type === 'text' &amp;&amp; element.value.length &lt;= element.maxLength) {
        frontConfig[element.id] = element.value;
    }
    dirty!.className = "show";
    applyChanges();
}

</t>
<t tx="fil.20210603223934.9">function setControls(): void {
    // 1- Set leointeg's own configuration settings
    for (const key in frontConfig) {
        if (frontConfig.hasOwnProperty(key)) {
            const w_element = document.getElementById(key);
            if (w_element &amp;&amp; w_element.getAttribute('type') === 'checkbox') {
                (w_element as HTMLInputElement).checked = frontConfig[key];
            } else if (w_element) {
                (w_element as HTMLInputElement).value = frontConfig[key];
            } else {
                console.log('ERROR : w_element', key, ' is ', w_element);
            }
        }
    }
}

</t>
<t tx="fil.20210603223956.2">@language css
html {
  height: 100%;
  font-size: 62.5%;
  box-sizing: border-box;
  scroll-behavior: smooth;
}

body {
  background-color: var(--color-background);
  color: var(--color-foreground);
  font-family: var(--font-family);
  height: 100%;
  line-height: 1.4;
  font-size: 100% !important;

  &amp;.vscode-light {
    background-color: var(--color-background--darken-075);
  }
}

a {
  border: 0;
  color: var(--color-link-foreground);
  font-weight: 400;
  outline: none;
  text-decoration: none;

  &amp;:not([href]):not([tabindex]):focus,
  &amp;:not([href]):not([tabindex]):hover {
    color: inherit;
    text-decoration: none;
  }

  &amp;:focus {
    outline-color: var(--color-focus-border);
  }
  &amp;:hover {
    color: var(--color-link-foreground--lighten-20);
  }
}

a,
a:active,
a:focus {
  outline: none;
}

b {
  font-weight: 600;
}

span.heart {
  color: rgb(139, 49, 119);
}

code,
.shortcut-key {
  border-radius: 4px;
  color: var(--color-foreground);
  padding: 2px 6px 0 6px;
  vertical-align: baseline;

  .vscode-dark &amp; {
    background-color: var(--color-background--lighten-15);
    border-bottom: 2px solid var(--color-background--lighten-15);
  }

  .vscode-light &amp; {
    background-color: var(--color-background--darken-15);
    border-bottom: 2px solid var(--color-background--darken-15);
  }
}

h1 {
  border: none;
  font-size: 4rem;
  font-weight: 400;
  margin: 0;
  padding: 0;
  white-space: nowrap;
}

h2 {
  font-size: 2.2rem;
  font-weight: 200;
  line-height: normal;
  margin: 1em 0 0.3em 0;
  white-space: nowrap;
}

h3 {
  font-size: 1.8rem;
  font-weight: 200;
  line-height: normal;
  margin: 1em 0 0.3em 0;
  white-space: nowrap;
}

h4 {
  font-size: 1rem;
  font-weight: 200;
  line-height: normal;
  margin: 1em 0 0.3em 0;
  white-space: nowrap;
}

header {
  grid-area: header;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(265px, 1fr));
  grid-gap: 1em 3em;
  align-items: center;
  justify-items: center;
  margin: 0 3em;
}

input,
select,
button {
  font-family: var(--font-family);
  font-size: inherit;
  margin: 0;
}

input[type="checkbox"] {
  background: none;
  border: none;
  cursor: pointer;
  margin: 0;
  padding: 0 10px;

  &amp;:focus {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 5px;
    outline: none;
  }

  &amp;[disabled] {
    color: var(--color-foreground--75);
    cursor: default;
  }
}

input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  margin: 0;
}

input[type="number"],
input[type="text"],
input:not([type]) {
  background: none;
  color: var(--color-foreground);
  margin: 0 10px;
  max-width: 300px;
  padding: 4px;
  // width: 100%;

  .vscode-dark &amp; {
    border: 1px solid rgba(255, 255, 255, 0.3);
  }

  .vscode-light &amp; {
    border: 1px solid rgba(0, 0, 0, 0.3);
  }

  &amp;:focus {
    outline-color: var(--color-focus-border);

    .vscode-light &amp; {
      background-color: rgba(255, 255, 255, 0.4);
    }

    .vscode-dark &amp; {
      background-color: rgba(0, 0, 0, 0.2);
    }
  }

  &amp;.is-invalid {
    outline-color: red !important;
    border-color: red !important;
  }

  &amp;[disabled] {
    color: var(--color-foreground--75);
    cursor: default;
  }

  &amp;::placeholder {
    color: var(--vscode-input-placeholderForeground);
  }
}

label {
  cursor: pointer;
}

select {
  background: none;
  color: var(--color-foreground);
  cursor: pointer;
  margin: 0 0.75em;
  padding: 2px;
  min-width: 14em;

  .vscode-light &amp; {
    border: 1px solid rgba(0, 0, 0, 0.3);
  }

  .vscode-dark &amp; {
    border: 1px solid rgba(255, 255, 255, 0.3);
  }

  &amp;:focus {
    outline-color: var(--color-focus-border);
    .vscode-light &amp; {
      background-color: rgba(255, 255, 255, 0.4);
    }

    .vscode-dark &amp; {
      background-color: rgba(0, 0, 0, 0.2);
    }
  }

  &amp;[disabled] {
    color: var(--color-foreground--75);
    cursor: default;
  }
}

select option {
  .vscode-light &amp; {
    background-color: var(--color-background--darken-05);
  }

  .vscode-dark &amp; {
    background-color: var(--color-background--lighten-05);
  }

  &amp;:focus {
    outline-color: var(--color-focus-border);
    .vscode-light &amp; {
      background-color: rgba(255, 255, 255, 0.4);
    }

    .vscode-dark &amp; {
      background-color: rgba(0, 0, 0, 0.2);
    }
  }
}

ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

.button {
  background: none;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  display: inline-block;
  font-size: 1.1rem;
  letter-spacing: 0.25em;
  margin: 1em 0.5em;
  padding: 1em 1.75em;
  text-decoration: none;
  text-transform: uppercase;
  user-select: none;
  white-space: nowrap;

  &amp;:focus {
    outline: none;
  }
}

.button--big {
  font-size: 1.5rem;
}

.button--flat {
  .vscode-light &amp; {
    border: 1px solid rgba(0, 0, 0, 0.6);
    color: black;
  }
  .vscode-dark &amp; {
    border: 1px solid rgba(255, 255, 255, 0.6);
    color: white !important;
  }
  transition: background-color 250ms, border-color 250ms, color 250ms;

  &amp;:hover {
    .vscode-light &amp; {
      background-color: var(--color-button-background--darken-30);
      border-color: var(--color-button-background--darken-30);
      color: white !important;
    }
    .vscode-dark &amp; {
      background-color: white;
      border-color: white;
      color: black !important;
    }
  }

  .preload &amp; {
    transition-duration: 0s !important;
  }
}

.button--flat-inverse {
  background-color: white;
  border: 1px solid white;
  color: black !important;
  font-weight: 600;
  transition: background-color 250ms, border-color 250ms, color 250ms;

  &amp;:hover {
    background: rgba(0, 0, 0, 0.2);
    border-color: rgba(255, 255, 255, 0.6);
    color: white !important;
  }

  .preload &amp; {
    transition-duration: 0s !important;
  }
}

.button--flat-primary {
  background-color: var(--color-button-background);
  border: 1px solid var(--color-button-background);
  color: var(--color-button-foreground) !important;
  font-weight: 600;
  transition: background-color 250ms, border-color 250ms, color 250ms;

  &amp;:hover {
    .vscode-dark &amp; {
      background-color: white;
      border-color: white;
      color: black !important;
    }

    .vscode-light &amp; {
      background-color: var(--color-button-background--darken-30);
      border-color: var(--color-button-background--darken-30);
      color: white !important;
    }
  }

  .preload &amp; {
    transition-duration: 0s !important;
  }
}

.button--choose-path {
  padding: 0.6em 0.7em;
  margin-left: 0.2rem;
  margin-bottom: 0;
}

.blurb {
  font-size: 1.5rem;
  font-weight: 200;
  color: var(--color-foreground--65);
  margin: 1em;

  b {
    color: var(--color-foreground--85);
  }

  .vscode-light &amp; {
    color: var(--color-foreground--75);
  }
}

.command {
  font-weight: 600;
  padding: 1px 3px;
}

.container {
  display: grid;
  grid-template-areas: "header header" "hero hero" "content sidebar";
  grid-template-columns: repeat(1, 1fr min-content);
  margin: 1em auto;
  grid-gap: 1em 3em;
  max-width: 1200px;
  min-width: 450px;

  @media all and (max-width: 768px) {
    grid-gap: 1em 0;
  }
}

.content__area {
  grid-area: content;
  font-size: 1.4rem;
  // border-radius: 8x;

  .vscode-dark &amp; {
    background-color: var(--color-background--lighten-05);
  }

  .vscode-light &amp; {
    background-color: var(--color-background);
  }

  @media all and (max-width: 768px) {
    grid-column: span 1;
  }
}

.content__area--full-scroll {
  background-color: unset !important;
  margin-bottom: 90vh;

  .section--settings {
    margin: 0 0 1em 0;
  }
}

.cta {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  font-size: 1.3rem;
  margin: 0;

  &amp; p {
    margin-left: 10%;
    margin-right: 10%;
    margin-top: -0.5em;
    opacity: 0.6;
  }
}

.cta--primary {
  margin: 0 1em;
}

.cta--secondary {
  margin: 0 1em;
}

.header__blurb {
  color: var(--color-foreground--75);
  flex: 2 1 55%;
  font-size: 1.5rem;
  font-weight: 200;
  margin: 0;
  min-width: 345px;

  @media all and (max-width: 880px) {
    margin: 0 2em;
  }
}

.header__link {
  color: var(--color-foreground);
  outline: none;

  &amp;:hover,
  &amp;:active,
  &amp;:focus {
    color: var(--color-foreground);
    outline: none;
  }
}

.header__logo {
  display: flex;
  flex-wrap: nowrap;
}

.header__logo--highlight {
  color: #8d3d17;
}

.header__subtitle {
  color: var(--color-foreground--65);
  font-size: 2rem;
  font-weight: 100;
  margin: -0.2em 0 0 0;
  white-space: nowrap;
}

.hero__area {
  grid-area: hero;
  color: var(--color-foreground--75);
  font-size: 1.5rem;
  font-weight: 200;
  margin: 0 1em;

  b {
    color: var(--color-foreground--85);
  }
}

.hero__area--sticky {
  background: var(--color-background);
  margin: 0;
  padding: 1em 0;
  position: sticky;
  top: -1px;
  z-index: 1;
  grid-column: span 1;

  .vscode-light &amp; {
    background: var(--color-background--darken-075);
  }
}

.hero__row {
  display: flex;
  flex-wrap: nowrap;
  align-items: baseline;
  justify-content: space-between;
}

.hero__subtitle {
  color: var(--color-foreground--75);
  font-size: 1.4rem;
  margin: 0.25em 0 0 0;
}

.hero__title {
  font-size: 4rem;
  margin: 0;
}

.hero__title-actions {
  margin: 0 1em;
}

.hero__toolbar {
  flex: 1 1 auto;

  display: flex;
  justify-content: flex-end;
  white-space: nowrap;

  select,
  option {
    background-color: var(--color-background) !important;
    margin-right: 0;

    @media all and (max-width: 768px) {
      margin-right: unset;
    }
  }
}

.hero__toolbar-scope {
  flex: 0 0 auto;
}

.icon {
  background-color: var(--color-foreground);
  display: inline-block;
  height: 24px;
  margin-right: 3px;
  position: relative;
  width: 19px;
  top: 9px;

  h2 &amp; {
    top: 7px;
  }
}

// .icon__bulb {
//   -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path fill-rule="evenodd" d="M11.67 8.658c-.338.334-.598.705-.781 1.114-.178.407-.268.85-.268 1.329v1.6a1.304 1.304 0 0 1-.794 1.197c-.159.068-.329.102-.509.102H7.712a1.285 1.285 0 0 1-.922-.379 1.303 1.303 0 0 1-.38-.92v-1.6c0-.479-.092-.921-.274-1.329a3.556 3.556 0 0 0-.776-1.114 4.689 4.689 0 0 1-1.006-1.437A4.187 4.187 0 0 1 4 5.5a4.432 4.432 0 0 1 .616-2.27c.197-.336.432-.64.705-.914.274-.272.578-.506.911-.702.338-.196.7-.348 1.084-.454C7.7 1.053 8.1 1 8.516 1a4.476 4.476 0 0 1 2.276.614 4.475 4.475 0 0 1 1.622 1.616 4.438 4.438 0 0 1 .616 2.27c0 .617-.117 1.191-.353 1.721a4.69 4.69 0 0 1-1.006 1.437zM9.623 10.5H7.409v2.201c0 .081.028.15.09.212.062.061.131.09.213.09h1.606a.289.289 0 0 0 .213-.09.286.286 0 0 0 .09-.212V10.5z" clip-rule="evenodd"/&gt;&lt;/svg&gt;');
//   mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path fill-rule="evenodd" d="M11.67 8.658c-.338.334-.598.705-.781 1.114-.178.407-.268.85-.268 1.329v1.6a1.304 1.304 0 0 1-.794 1.197c-.159.068-.329.102-.509.102H7.712a1.285 1.285 0 0 1-.922-.379 1.303 1.303 0 0 1-.38-.92v-1.6c0-.479-.092-.921-.274-1.329a3.556 3.556 0 0 0-.776-1.114 4.689 4.689 0 0 1-1.006-1.437A4.187 4.187 0 0 1 4 5.5a4.432 4.432 0 0 1 .616-2.27c.197-.336.432-.64.705-.914.274-.272.578-.506.911-.702.338-.196.7-.348 1.084-.454C7.7 1.053 8.1 1 8.516 1a4.476 4.476 0 0 1 2.276.614 4.475 4.475 0 0 1 1.622 1.616 4.438 4.438 0 0 1 .616 2.27c0 .617-.117 1.191-.353 1.721a4.69 4.69 0 0 1-1.006 1.437zM9.623 10.5H7.409v2.201c0 .081.028.15.09.212.062.061.131.09.213.09h1.606a.289.289 0 0 0 .213-.09.286.286 0 0 0 .09-.212V10.5z" clip-rule="evenodd"/&gt;&lt;/svg&gt;');
//   -webkit-mask-repeat: no-repeat;
//   mask-repeat: no-repeat;
//   opacity: 0.8;
// }

// .icon__chevron-down {
//   -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path fill-rule="evenodd" clip-rule="evenodd" d="M7.97602 10.0719L12.3333 5.7146L12.952 6.33332L8.28538 11L7.66666 11L3 6.33332L3.61872 5.7146L7.97602 10.0719Z" /&gt;&lt;/svg&gt;');
//   mask-image: url('data:image/svg+xml;utf8,&lt;svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path fill-rule="evenodd" clip-rule="evenodd" d="M7.97602 10.0719L12.3333 5.7146L12.952 6.33332L8.28538 11L7.66666 11L3 6.33332L3.61872 5.7146L7.97602 10.0719Z" /&gt;&lt;/svg&gt;');
//   -webkit-mask-repeat: no-repeat;
//   mask-repeat: no-repeat;
// }

// .icon__gear {
//   -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path d="M9.1 4.4L8.6 2H7.4l-.5 2.4-.7.3-2-1.3-.9.8 1.3 2-.2.7-2.4.5v1.2l2.4.5.3.8-1.3 2 .8.8 2-1.3.8.3.4 2.3h1.2l.5-2.4.8-.3 2 1.3.8-.8-1.3-2 .3-.8 2.3-.4V7.4l-2.4-.5-.3-.8 1.3-2-.8-.8-2 1.3-.7-.2zM9.4 1l.5 2.4L12 2.1l2 2-1.4 2.1 2.4.4v2.8l-2.4.5L14 12l-2 2-2.1-1.4-.5 2.4H6.6l-.5-2.4L4 13.9l-2-2 1.4-2.1L1 9.4V6.6l2.4-.5L2.1 4l2-2 2.1 1.4.4-2.4h2.8zm.6 7c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zM8 9c.6 0 1-.4 1-1s-.4-1-1-1-1 .4-1 1 .4 1 1 1z"/&gt;&lt;/svg&gt;');
//   mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path d="M9.1 4.4L8.6 2H7.4l-.5 2.4-.7.3-2-1.3-.9.8 1.3 2-.2.7-2.4.5v1.2l2.4.5.3.8-1.3 2 .8.8 2-1.3.8.3.4 2.3h1.2l.5-2.4.8-.3 2 1.3.8-.8-1.3-2 .3-.8 2.3-.4V7.4l-2.4-.5-.3-.8 1.3-2-.8-.8-2 1.3-.7-.2zM9.4 1l.5 2.4L12 2.1l2 2-1.4 2.1 2.4.4v2.8l-2.4.5L14 12l-2 2-2.1-1.4-.5 2.4H6.6l-.5-2.4L4 13.9l-2-2 1.4-2.1L1 9.4V6.6l2.4-.5L2.1 4l2-2 2.1 1.4.4-2.4h2.8zm.6 7c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zM8 9c.6 0 1-.4 1-1s-.4-1-1-1-1 .4-1 1 .4 1 1 1z"/&gt;&lt;/svg&gt;');
//   -webkit-mask-repeat: no-repeat;
//   mask-repeat: no-repeat;
// }

// .icon__info {
//   -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path fill-rule="evenodd" d="M8.568 1.031A6.8 6.8 0 0 1 12.76 3.05a7.06 7.06 0 0 1 .46 9.39 6.85 6.85 0 0 1-8.58 1.74 7 7 0 0 1-3.12-3.5 7.12 7.12 0 0 1-.23-4.71 7 7 0 0 1 2.77-3.79 6.8 6.8 0 0 1 4.508-1.149zM9.04 13.88a5.89 5.89 0 0 0 3.41-2.07 6.07 6.07 0 0 0-.4-8.06 5.82 5.82 0 0 0-7.43-.74 6.06 6.06 0 0 0 .5 10.29 5.81 5.81 0 0 0 3.92.58zM8.51 7h-1v4h1V7zm0-2h-1v1h1V5z" clip-rule="evenodd"/&gt;&lt;/svg&gt;');
//   mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path fill-rule="evenodd" d="M8.568 1.031A6.8 6.8 0 0 1 12.76 3.05a7.06 7.06 0 0 1 .46 9.39 6.85 6.85 0 0 1-8.58 1.74 7 7 0 0 1-3.12-3.5 7.12 7.12 0 0 1-.23-4.71 7 7 0 0 1 2.77-3.79 6.8 6.8 0 0 1 4.508-1.149zM9.04 13.88a5.89 5.89 0 0 0 3.41-2.07 6.07 6.07 0 0 0-.4-8.06 5.82 5.82 0 0 0-7.43-.74 6.06 6.06 0 0 0 .5 10.29 5.81 5.81 0 0 0 3.92.58zM8.51 7h-1v4h1V7zm0-2h-1v1h1V5z" clip-rule="evenodd"/&gt;&lt;/svg&gt;');
//   -webkit-mask-repeat: no-repeat;
//   mask-repeat: no-repeat;
// }

.icon--md {
  height: 30px;
  width: 24px;
  top: 12px;
}

.icon--lg {
  height: 36px;
  width: 30px;
  top: 15px;
}

.image__logo {
  margin: 9px 1em 0 0;
  max-height: 64px;
  max-width: 64px;
}

.image__preview {
  display: block;
  border-radius: 8px;
  box-shadow: 0px 0px 1px 0px rgba(0, 0, 0, 0.8), 0px 0px 12px 1px rgba(0, 0, 0, 0.5);
  width: 600px;
}
.image__preview__body {
  display: block;
  border-radius: 8px;
  box-shadow: 0px 0px 1px 0px rgba(0, 0, 0, 0.8), 0px 0px 12px 1px rgba(0, 0, 0, 0.5);
  width: 680px;
}

.image__preview--overlay {
  left: 0;
  position: absolute;
  top: 0;
}

.image__preview--float-container {
  left: 0;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  padding-right: 17%;
}

.image__preview__body--float-container {
  left: 0;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  padding-right: 7px;
  padding-left: 7px;
  overflow: hidden;
}

.image__preview--float {
  float: right;
}

.link__configure,
.link__learn-more {
  margin-left: 10px;
}

.presets {
  align-items: baseline;
  justify-content: center;
  display: flex;
  width: 100%;
  flex-wrap: wrap;
}

section {
  display: flex;
  flex-wrap: wrap;

  margin-bottom: 1em;
  padding: 1em;

  h2 {
    flex: 1 0 auto;

    display: flex;
    margin-top: 0;
    margin-bottom: 1em;
  }
}

.section--full {
  flex-flow: column;
}

.section--settings {
  flex: 0 1 auto;

  display: flex;
  flex-wrap: wrap;

  border-radius: 8px;
  margin: 1em;
  padding: 1em 0 0.5em 1em;
  // box-shadow: 0px 0px 6px 1px rgba(0, 0, 0, 0.15);

  .vscode-dark &amp; {
    background: var(--color-background--lighten-075);
  }

  .vscode-light &amp; {
    background: var(--color-background--darken-05);
  }
}

.section--collapsible {
  .vscode-light &amp; {
    background: var(--color-background);
  }

  .section__header {
    cursor: pointer;
    flex: 1 0 100%;
    margin-right: 0;

    &amp;:after {
      background-color: var(--color-foreground--75);
      content: "";
      height: 40px;
      -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125"&gt;&lt;path d="M50 62a3 3 0 0 1-2-1L26 44a3 3 0 0 1 3-5l21 16 21-16a3 3 0 1 1 3 5L52 61a3 3 0 0 1-2 1z"/&gt;&lt;/svg&gt;');
      mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125"&gt;&lt;path d="M50 62a3 3 0 0 1-2-1L26 44a3 3 0 0 1 3-5l21 16 21-16a3 3 0 1 1 3 5L52 61a3 3 0 0 1-2 1z"/&gt;&lt;/svg&gt;');
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-size: 32px 40px;
      mask-size: 32px 40px;
      position: absolute;
      right: 0;
      top: 0;
      transition: transform 250ms ease-in-out;
      width: 32px;
    }
  }

  &amp;.collapsed {
    .section__header {
      margin-bottom: 0;

      &amp;:after {
        transform: translateY(-9px) rotate(-180deg);
      }

      h2 {
        margin-bottom: 0;
      }
    }

    .section__collapsible {
      display: none;
    }
  }
}

.section__collapsible {
  display: flex;
  flex-wrap: wrap;
}

.section__content {
  flex: 1 1 auto;

  display: flex;
  flex-flow: column wrap;
}

.section__group {
  flex: 1 0 100%;

  display: flex;
  flex-flow: wrap-reverse;

  &amp; + .section__group {
    margin-top: 1em;
  }
}

.section__header {
  display: flex;
  align-items: baseline;
  flex: 0 1 auto;
  flex-flow: column;
  margin-bottom: 1em;
  margin-right: 1em;
  position: relative;

  h2 {
    margin-bottom: 0;
  }

  .link__configure,
  .link__learn-more {
    visibility: hidden;
  }

  &amp;:hover {
    .link__configure,
    .link__learn-more {
      visibility: visible;
    }
  }
}

.section__header-hint {
  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0.25em 0;
}

.section__header-info {
  display: grid;
  grid-template-columns: auto auto;
  grid-gap: 1em;
  align-items: center;

  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0.25em 0.5em;

  p {
    margin: 0;
    line-height: 2rem;
  }

  .icon {
    top: 3px;
  }
}

.section__hint {
  flex: 0 0 auto;

  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0;
}

.section__preview {
  flex: 0 1 auto;
  position: relative;
  margin-left: auto;
  margin-right: auto;
  margin-bottom: 0.65rem;

  .section__collapsible &amp; {
    margin-bottom: 1em;
  }
}

.section__preview-hint {
  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0.5em 0.5em 0 0.5em;
  text-align: center;
}

// .section__preview-spacer {
// 	flex-grow: 10;
// 	flex-shrink: 10;
// }

.section__title {
  flex: 1 0 auto;
  margin: 0;
}

.section__title--primary {
  font-size: 3rem;
  margin: 0.3em 0;
  justify-content: center;
}

.section__title--break {
  margin: 0.3em 15% 0 15%;
  padding-top: 1em;
  justify-content: center;

  .vscode-dark &amp; {
    border-top: 1px solid var(--color-background--lighten-30);
  }

  .vscode-light &amp; {
    border-top: 1px solid var(--color-background--darken-30);
  }
}

.setting {
  flex: 0 1 auto;
  position: relative;
  margin-right: 1em;
  min-width: 15.5em;

  &amp; input[type="checkbox"] {
    flex: 0 0 16px;
    height: 16px;
    margin: 0 10px 0 0;
    position: relative;
    top: 3px;
    width: 16px;
  }

  &amp;[disabled] {
    label {
      color: var(--color-foreground--75);
      cursor: default;
    }
  }
}

#interface-behavior {
  .setting {
    min-width: 29em;
  }
}

fieldset {
  display: flex;
  flex-wrap: wrap;
  margin-right: 1em;
  padding-right: 0;
  border-style: solid;
  border-width: 1px;
  background-color: #80000010;
  border-color: #92473e;
  p {
    margin: 0;
    padding-right: 1em;
    width: 100%;
    color: var(--color-foreground--65);
    span {
      color: var(--color-foreground);
    }
  }
}

// .setting--expandable {
//   .setting__expander {
//     background-color: var(--color-foreground--75);
//     cursor: pointer;
//     height: 16px;
//     -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125"&gt;&lt;path d="M50 62a3 3 0 0 1-2-1L26 44a3 3 0 0 1 3-5l21 16 21-16a3 3 0 1 1 3 5L52 61a3 3 0 0 1-2 1z"/&gt;&lt;/svg&gt;');
//     mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125"&gt;&lt;path d="M50 62a3 3 0 0 1-2-1L26 44a3 3 0 0 1 3-5l21 16 21-16a3 3 0 1 1 3 5L52 61a3 3 0 0 1-2 1z"/&gt;&lt;/svg&gt;');
//     -webkit-mask-repeat: no-repeat;
//     mask-repeat: no-repeat;
//     -webkit-mask-size: 32px 28px;
//     mask-size: 32px 28px;
//     position: relative;
//     margin: 0;
//     transform: translate(-9px, 4px) rotate(-90deg);
//     transition: transform 250ms ease-in-out;
//     width: 32px;
//   }

//   &amp; + .settings {
//     display: none;
//   }

//   &amp;.expanded {
//     .setting__expander {
//       transform: translate(-4px, 0);
//     }

//     &amp; + .settings {
//       display: unset;
//     }
//   }
// }

.setting__input {
  display: inline-flex;
  flex-wrap: nowrap;
  align-items: baseline;
  line-height: normal;
  margin: 0.5em 0;

  input,
  select {
    flex-grow: 1;

    &amp; + .link__configure,
    &amp; + .link__learn-more {
      margin-left: 0;
    }
  }

  input[type="text"],
  input:not([type]) {
    min-width: 150px;
  }

  label {
    flex-grow: 0;

    &gt; select {
      margin-top: 0.25em;
    }
  }

  .link__learn-more,
  .link__configure {
    visibility: hidden;
    max-height: 15px;

    .icon {
      display: block;
      top: unset;
    }
  }

  &amp;:hover {
    .link__learn-more,
    .link__configure {
      visibility: visible;
    }
  }
}

.setting__input--big {
  font-size: 2.2rem;
  font-weight: 200;
  margin: 0;

  &amp; input[type="checkbox"] {
    flex: 0 0 1.5em;
    height: 1em;
    margin: 0;
    position: relative;
    top: 3px;
    left: -5px;
    width: 1em;
  }

  &amp; label {
    white-space: nowrap;
  }

  .link__learn-more,
  .link__configure {
    max-height: 17px;
  }
}

.setting__input--format {
  display: flex;

  input[type="text"],
  input:not([type]) {
    max-width: unset;
  }
}

.setting__hint {
  color: var(--color-foreground--75);
  display: block;
  font-weight: 200;
  font-size: 1.3rem;
  margin: 0 1em 0.5em 1em;
}

.settings {
  flex: 1 0 auto;

  display: flex;
  flex-wrap: wrap;
  // align-items: baseline;
  // justify-content: space-between;
}

.settings--fixed {
  display: block;
}

.sidebar {
  grid-area: sidebar;
  align-self: flex-start;
  font-size: 1.3rem;
  position: sticky;
  top: 0;
  z-index: 2;

  @media all and (max-width: 768px) {
    display: none;
  }

  li {
    white-space: nowrap;
  }

  .button {
    margin: 0;
  }
}

.sidebar__group {
  margin-top: 1em;

  h2 {
    font-size: 2rem;
  }

  p {
    font-weight: 400;
    opacity: 0.5;
    text-align: center;
  }
}

.sidebar__jump-link {
  &amp;.active {
    font-weight: 700;

    &amp;:before {
      content: " ";
      border-left: 4px solid var(--color-link-foreground--darken-20);
      position: absolute;
      left: -1em;
      height: 1em;
      padding-bottom: 4px;

      .vscode-light &amp; {
        border-left-color: var(--color-link-foreground--lighten-20);
      }
    }
  }
}

.sponsor__image {
  opacity: 0.8;
  transition: opacity 250ms;
  transform: scale(0.6);
  margin: -2.5em 0;

  &amp;:hover {
    opacity: 1;
  }
}

.sponsor__tag {
  font-size: 1.1rem;
  margin: -1em 0.5em 0 0.5em;
  opacity: 0.5;
  text-align: center;
}

.bold {
  font-weight: 600;
}

.center {
  text-align: center;
}

.hidden {
  display: none !important;
}

.highlight {
  background-color: #cc5d1a;
  border-bottom: 2px solid #cc5d1a;
  // background-color: #7e3919;
  // border-bottom: 2px solid #85422a;
  border-radius: 3px;
  color: #f2f2f2;
  margin: 0 0.25em;
  padding: 2px 10px;
  text-align: center;
  vertical-align: bottom;
}

.is-sidebar-hidden {
  display: none;

  @media all and (max-width: 768px) {
    display: initial;
  }
}

.mb-0 {
  margin-bottom: 0 !important;
}

.mb-05 {
  margin-bottom: 0.5em !important;
}

.mb-1 {
  margin-bottom: 1em !important;
}

.mb-2 {
  margin-bottom: 2em !important;
}

.ml-0 {
  margin-left: 0 !important;
}

.ml-1 {
  margin-left: 1em !important;
}

.ml-2 {
  margin-left: 2em !important;
}

.ml-3 {
  margin-left: 3em !important;
}

.ml-4 {
  margin-left: 4em !important;
}

.mr-0 {
  margin-right: 0 !important;
}

.mr-1 {
  margin-right: 1em !important;
}

.mr-2 {
  margin-right: 2em !important;
}

.mt-n1 {
  margin-top: -1em !important;
}

.mt-0 {
  margin-top: 0 !important;
}

.mt-05 {
  margin-top: 0.5em !important;
}

.mt-1 {
  margin-top: 1em !important;
}

.mt-2 {
  margin-top: 2em !important;
}

.non-interactive {
  cursor: default !important;
}

.nowrap {
  white-space: nowrap !important;
}

.light {
  .vscode-dark &amp; {
    display: none;
  }
}

.dark {
  .vscode-light &amp; {
    display: none;
  }
}

::-webkit-scrollbar-corner {
  background-color: transparent !important;
}

@import "popup";
</t>
<t tx="fil.20210603223956.4">@language css
#saved-config-toast {
  box-shadow: 0px 0px 28px 0 rgba(0, 0, 0, 0.5);
  // background-color: #000 !important;

  cursor: default;
  display: block;
  padding: 1em 0.5rem;
  position: fixed;
  text-align: center;
  width: 60%;
  // height: 200px;
  top: 50px;
  left: 50%;
  border-radius: 12px;
  // margin-top: -100px; /* Negative half of height. */
  margin-left: -30%; /* Negative half of width. */
  visibility: hidden;
  font-size: 2rem;
  z-index: 100;

  &amp;.show {
    visibility: visible; /* Show the snackbar */
    /* Add animation: Take 0.5 seconds to fade in and out the snackbar.
    However, delay the fade out process for 2.5 seconds */
    // -webkit-animation: fadein 0.3s, fadeout 0.3s 0.5s;
    // animation: fadein 0.3s, fadeout 0.3s 0.4s;
    animation: fadein 0.5s, fadeout 0.5s 1s;
  }

  &amp;:before {
    // background: transparent;
    // border: 12px solid transparent;
    // content: '';
    // left: 50%;
    // position: absolute;
    // pointer-events: none;
    // top: -24px;
    // z-index: 1001;

    .vscode-light &amp; {
      border-bottom-color: var(--color-background--darken-075);
    }

    .vscode-dark &amp; {
      border-bottom-color: var(--color-background--lighten-075);
    }
  }

  .vscode-light &amp; {
    background: var(--color-background--darken-075);
  }

  .vscode-dark &amp; {
    background: var(--color-background--lighten-075);
  }
}

#dirty-config-toast {
  box-shadow: 0px 0px 28px 0 rgba(0, 0, 0, 0.5);
  // background-color: #000 !important;

  cursor: default;
  display: block;
  padding: 1em 0.5rem;
  position: fixed;
  text-align: center;
  width: 60%;
  // height: 200px;
  top: 50px;
  left: 50%;
  border-radius: 12px;
  // margin-top: -100px; /* Negative half of height. */
  margin-left: -30%; /* Negative half of width. */
  visibility: hidden;
  font-size: 2rem;
  z-index: 100;

  &amp;.show {
    visibility: visible; /* Show the snackbar */
  }

  &amp;:before {
    // background: transparent;
    // border: 12px solid transparent;
    // content: '';
    // left: 50%;
    // position: absolute;
    // pointer-events: none;
    // top: -24px;
    // z-index: 1001;

    .vscode-light &amp; {
      border-bottom-color: var(--color-background--darken-075);
    }

    .vscode-dark &amp; {
      border-bottom-color: var(--color-background--lighten-075);
    }
  }
  .vscode-light &amp; {
    background-color: #cc5d1a;
    color: #f2f2f2;
  }

  .vscode-dark &amp; {
    background-color: #cc5d1a;
    color: #f2f2f2;
  }
}

/* Animations to fade the snackbar in and out */
@keyframes fadein {
  from {
    // top: 0;
    opacity: 0.8;
  }
  to {
    // top: 30px;
    opacity: 1;
  }
}

@keyframes fadeout {
  from {
    // top: 30px;
    opacity: 1;
  }
  to {
    // top: 0;
    opacity: 0;
  }
}

.token-popup__scroller {
  margin-right: -0.4em;
  max-height: 35vh;
  overflow-y: scroll;
  padding-right: 0.4em;
}

.token-popup__hint {
  color: var(--color-foreground--75);
  display: inline-block;
  font-weight: 200;
  margin: 1.25em 0.5em 0 0.25em;
}

.token-popup__title {
  color: var(--color-foreground);
  font-weight: 400;
  margin: 0.25em 0 1em 0;
  text-align: center;
}

.token-popup__table {
  border-collapse: collapse;
  color: var(--color-foreground--75);
  table-layout: fixed;

  &amp; tr:nth-child(even) {
    .vscode-light &amp; {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .vscode-dark &amp; {
      background-color: rgba(255, 255, 255, 0.04);
    }
  }

  &amp; td {
    padding: 6px;

    i {
      opacity: 0.6;
    }
  }

  &amp; td:first-child {
    padding: 6px 12px;
  }

  &amp; td:last-child {
    padding-right: 12px;
    text-align: end;
  }
}

.token {
  background: var(--color-link-foreground--darken-20);
  border-bottom: 2px solid var(--color-link-foreground--darken-20);
  border-radius: 3px;
  color: white;
  cursor: pointer;
  display: inline-block;
  padding: 1px 8px !important;

  &amp;:before {
    content: "${";
  }

  &amp;:after {
    content: "}";
  }

  .vscode-light &amp; {
    background: var(--color-link-foreground--lighten-20);
    border-bottom-color: var(--color-link-foreground--lighten-20);
  }
}
</t>
<t tx="fil.20210609233100.1">/**
 * * Clear leointeg's last-opened &amp; recently opened Leo files list
 */
public clearRecentLeoFiles(): void {
    this._context.workspaceState.update(Constants.LAST_FILES_KEY, undefined);
    this._context.workspaceState.update(Constants.RECENT_FILES_KEY, undefined);
    vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLEARED_RECENT);
}

</t>
</tnodes>
</leo_file>
