<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20200722190504.1"><vh>Startup</vh>
<v t="ekr.20200724052304.1"><vh>@button backup</vh></v>
<v t="ekr.20200808100711.1"><vh>@settings</vh>
<v t="ekr.20200808100717.1"><vh>@string target-language = plain</vh></v>
</v>
<v t="ekr.20200722125546.1"><vh>script: Print all command names</vh></v>
<v t="ekr.20200815113508.1"><vh>script: Find empty nodes that have no children</vh></v>
</v>
<v t="felix.20200718220811.1"><vh>Documentation</vh>
<v t="felix.20200718220818.1"><vh>@clean README.md</vh>
<v t="felix.20200718221645.1"><vh>Requirements</vh></v>
<v t="felix.20200718222026.1"><vh>BETA version installation</vh></v>
<v t="felix.20200718222035.1"><vh>Features</vh></v>
<v t="felix.20200718222043.1"><vh>Keybindings</vh></v>
<v t="felix.20200718222048.1"><vh>Derive External Files</vh></v>
<v t="felix.20200718222053.1"><vh>Automate Synchronization</vh></v>
<v t="felix.20200718222058.1"><vh>Status Bar Indicator</vh></v>
<v t="felix.20200718222102.1"><vh>Extension Settings</vh></v>
<v t="felix.20200718222108.1"><vh>Issues</vh></v>
<v t="felix.20200718222113.1"><vh>How it works</vh></v>
<v t="felix.20200718222118.1"><vh>Acknowledgments</vh></v>
</v>
<v t="felix.20200718220833.1"><vh>@clean CHANGELOG.md</vh>
<v t="felix.20210725153617.1"><vh>0.1.16</vh></v>
<v t="felix.20210718163005.1"><vh>0.1.15</vh></v>
<v t="felix.20210612000127.1"><vh>0.1.14</vh></v>
<v t="felix.20210509210502.1"><vh>0.1.13</vh></v>
<v t="felix.20200718222417.1"><vh>0.1.12</vh></v>
<v t="felix.20200718222419.1"><vh>0.1.11</vh></v>
<v t="felix.20200718222422.1"><vh>0.1.10</vh></v>
<v t="felix.20200718222425.1"><vh>0.1.9</vh></v>
<v t="felix.20200718222427.1"><vh>0.1.8</vh></v>
<v t="felix.20200718222429.1"><vh>0.1.7</vh></v>
<v t="felix.20200718222433.1"><vh>0.1.6</vh></v>
<v t="felix.20200718222435.1"><vh>0.1.5</vh></v>
<v t="felix.20200718222437.1"><vh>0.1.4</vh></v>
<v t="felix.20200718222439.1"><vh>0.1.3</vh></v>
<v t="felix.20200718222440.1"><vh>0.1.2</vh></v>
<v t="felix.20200718222442.1"><vh>0.1.1</vh></v>
<v t="felix.20200718222445.1"><vh>0.0.1</vh></v>
</v>
<v t="felix.20200718220833.2"><vh>@clean CONTRIBUTING.md</vh>
<v t="felix.20200718222731.1"><vh>Introduction</vh></v>
<v t="felix.20200718222739.1"><vh>Development requirements</vh></v>
<v t="felix.20200718222741.1"><vh>Getting the source</vh></v>
<v t="felix.20200718222745.1"><vh>Choosing a debug profile</vh></v>
<v t="felix.20200718222748.1"><vh>Starting the extension</vh></v>
<v t="felix.20200718222754.1"><vh>The python server script</vh></v>
<v t="felix.20200718222757.1"><vh>Issues</vh></v>
</v>
</v>
<v t="ekr.20200722190517.1"><vh>Files: Other</vh>
<v t="felix.20191126232434.2"><vh>@file leobridgeserver.py</vh></v>
<v t="felix.20210621233316.1"><vh>@file leoserver.py</vh></v>
<v t="ekr.20200815123601.1"><vh>@clean package.json</vh>
<v t="ekr.20200815123601.2"><vh>configuration</vh>
<v t="ekr.20200815123601.3"><vh>External Files Change Detection</vh></v>
<v t="ekr.20200815123601.4"><vh>Interface Behavior</vh></v>
<v t="ekr.20200815123601.5"><vh>Statusbar Indicator</vh></v>
<v t="ekr.20200815123601.6"><vh>Interface Appearance</vh></v>
<v t="felix.20210703013251.1"><vh>Body Pane Icons</vh></v>
<v t="ekr.20200815123601.7"><vh>Leo Bridge Options</vh></v>
</v>
<v t="ekr.20200815123601.8"><vh>viewsContainers</vh></v>
<v t="ekr.20200815123601.9"><vh>views</vh></v>
<v t="ekr.20200815123601.10"><vh>languages</vh></v>
<v t="ekr.20200815123601.11"><vh>grammars</vh></v>
<v t="ekr.20200815123601.12"><vh>snippets</vh></v>
<v t="ekr.20200815123601.13"><vh>commands</vh>
<v t="ekr.20200815123601.14"><vh>Tests</vh></v>
<v t="ekr.20200815123601.15"><vh>Show Webviews</vh></v>
<v t="ekr.20200815123601.16"><vh>Server</vh></v>
<v t="ekr.20200815123601.17"><vh>Scripting &amp; @buttons</vh></v>
<v t="ekr.20200815123601.18"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.19"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.20"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.21"><vh>Node Editing</vh></v>
<v t="felix.20201105010614.1"><vh>Text Editing</vh></v>
<v t="ekr.20200815123601.22"><vh>Move Nodes</vh></v>
<v t="ekr.20200815123601.23"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.24"><vh>Goto Nodes</vh></v>
<v t="ekr.20200815123601.25"><vh>Hoist/Dehoist</vh></v>
<v t="ekr.20200815123601.26"><vh>Undo/Redo</vh></v>
<v t="felix.20210517001143.1"><vh>Search</vh></v>
<v t="felix.20210517001459.1"><vh>Mark Nodes</vh></v>
</v>
<v t="ekr.20200815123601.28"><vh>viewsWelcome</vh>
<v t="ekr.20200815123601.29"><vh>Leo Integration</vh>
<v t="ekr.20200815123601.30"><vh>Not Ready: [start], [connect] and settings</vh></v>
<v t="ekr.20200815123601.31"><vh>Not Ready Auto Start: [connect] and settings</vh></v>
<v t="ekr.20200815123601.32"><vh>Not Ready Server Started: [connect] and settings</vh></v>
<v t="ekr.20200815123601.33"><vh>Not Ready: Connecting</vh></v>
<v t="ekr.20200815123601.34"><vh>Ready: [open] and settings</vh></v>
</v>
<v t="ekr.20200815123601.35"><vh>Leo Documents</vh>
<v t="ekr.20200815123601.36"><vh>Not Ready</vh></v>
<v t="ekr.20200815123601.37"><vh>Ready: Empty</vh></v>
</v>
<v t="ekr.20200815123601.38"><vh>leoButtons</vh>
<v t="ekr.20200815123601.39"><vh>Not Ready</vh></v>
<v t="ekr.20200815123601.40"><vh>Ready: No Opened Files</vh></v>
<v t="ekr.20200815123601.41"><vh>Ready: No Buttons</vh></v>
</v>
<v t="felix.20210522233604.1"><vh>leoFind</vh>
<v t="felix.20210522233744.1"><vh>Not Ready</vh></v>
</v>
</v>
<v t="ekr.20200815123601.42"><vh>menus</vh>
<v t="ekr.20200815123601.43"><vh>commandPalette</vh>
<v t="ekr.20200815123601.44"><vh>Server</vh></v>
<v t="ekr.20200815123601.45"><vh>Scripting &amp; @buttons</vh></v>
<v t="ekr.20200815123601.46"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.47"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.48"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.49"><vh>Node Editing</vh></v>
<v t="felix.20210530160638.1"><vh>Text Editing</vh></v>
<v t="ekr.20200815123601.50"><vh>Move Nodes</vh></v>
<v t="ekr.20200815123601.51"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.52"><vh>Goto Nodes</vh></v>
<v t="ekr.20200815123601.53"><vh>Hoist/Dehoist</vh></v>
<v t="ekr.20200815123601.54"><vh>Undo/Redo</vh></v>
<v t="felix.20210530153353.1"><vh>Search</vh></v>
<v t="felix.20210530153359.1"><vh>Mark Nodes</vh></v>
<v t="ekr.20200815123601.56"><vh>Hidden Commands</vh>
<v t="ekr.20200815123601.57"><vh>Tests</vh></v>
<v t="felix.20210709004123.1"><vh>Status Bar Click</vh></v>
<v t="ekr.20200815123601.58"><vh>Scripting &amp; @buttons</vh></v>
<v t="ekr.20200815123601.59"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.60"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.61"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.62"><vh>Node Editing</vh></v>
<v t="ekr.20200815123601.63"><vh>Move Nodes</vh></v>
<v t="ekr.20200815123601.64"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.65"><vh>Goto Nodes</vh></v>
<v t="ekr.20200815123601.66"><vh>Hoist/Dehoist</vh></v>
<v t="ekr.20200815123601.67"><vh>Undo/Redo</vh></v>
<v t="felix.20210530161800.1"><vh>Search</vh></v>
</v>
</v>
<v t="ekr.20200815123601.68"><vh>explorer/context</vh></v>
<v t="felix.20210610022645.1"><vh>editor/title</vh></v>
<v t="felix.20210713005825.1"><vh>editor/context</vh></v>
<v t="felix.20201215210439.1"><vh>view/title</vh></v>
<v t="felix.20201215210510.1"><vh>view/item/context</vh></v>
</v>
<v t="ekr.20200815123601.76"><vh>keybindings</vh>
<v t="ekr.20200815123601.77"><vh>Scripting</vh></v>
<v t="ekr.20200815123601.78"><vh>Show UI Panes</vh></v>
<v t="ekr.20200815123601.79"><vh>Leo File Documents</vh></v>
<v t="ekr.20200815123601.80"><vh>Tree View</vh></v>
<v t="ekr.20200815123601.81"><vh>Node Editing</vh></v>
<v t="felix.20201105010253.1"><vh>Text Editing</vh></v>
<v t="ekr.20200815123601.82"><vh>Move Nodes</vh>
<v t="ekr.20200815123601.83"><vh>Move Down</vh></v>
<v t="ekr.20200815123601.84"><vh>Move left</vh></v>
<v t="ekr.20200815123601.85"><vh>Move right</vh></v>
<v t="ekr.20200815123601.86"><vh>Move Up</vh></v>
</v>
<v t="ekr.20200815123601.87"><vh>Outline Editing</vh></v>
<v t="ekr.20200815123601.88"><vh>Goto Nodes</vh></v>
<v t="felix.20210517004335.1"><vh>Search</vh></v>
</v>
<v t="ekr.20200815123601.89"><vh>resourceLabelFormatters</vh></v>
</v>
<v t="ekr.20200722130456.1"><vh>@edit .gitignore</vh></v>
</v>
<v t="felix.20200718165721.1"><vh>Files: Typescript</vh>
<v t="felix.20200718024635.1"><vh>@clean src/commandStack.ts</vh>
<v t="felix.20200718024635.2"><vh>class CommandStack</vh>
<v t="felix.20200718024635.3"><vh>size</vh></v>
<v t="felix.20200718024635.4"><vh>newSelection</vh></v>
<v t="felix.20200718024635.5"><vh>add</vh></v>
<v t="felix.20200718024635.6"><vh>_tryStart</vh></v>
<v t="felix.20200718024635.7"><vh>_runStackCommand</vh></v>
<v t="felix.20200718024635.8"><vh>_resolveResult</vh></v>
</v>
</v>
<v t="felix.20200718030926.1"><vh>@clean src/config.ts</vh>
<v t="felix.20200718030926.2"><vh>class Config</vh>
<v t="felix.20200718030926.3"><vh>getConfig</vh></v>
<v t="felix.20210727224122.1"><vh>getFontConfig</vh></v>
<v t="felix.20200718030926.4"><vh>setLeoIntegSettings</vh></v>
<v t="felix.20210727224135.1"><vh>setFontConfig</vh></v>
<v t="felix.20200718030926.5"><vh>buildFromSavedSettings</vh></v>
</v>
</v>
<v t="felix.20200718020912.1"><vh>@clean src/constants.ts</vh>
<v t="felix.20200718020912.2"><vh>class Constants</vh>
<v t="felix.20200718020912.3"><vh>general constants</vh></v>
<v t="felix.20210530233134.1"><vh>find panel ids</vh></v>
<v t="felix.20200718020912.5"><vh>workbench interface panels</vh></v>
<v t="felix.20200718020912.6"><vh>user messages</vh></v>
<v t="felix.20210602213308.1"><vh>import file types</vh></v>
<v t="felix.20200718020912.7"><vh>ask/save buttons</vh></v>
<v t="felix.20201126235315.1"><vh>at-buttons strings</vh></v>
<v t="felix.20200718020912.8"><vh>configuration keys</vh></v>
<v t="ekr.20200815084016.1"><vh>config defaults</vh></v>
<v t="felix.20200718020912.9"><vh>context flags</vh></v>
<v t="felix.20201208235246.1"><vh>vscode commands</vh></v>
<v t="felix.20200718020912.10"><vh>async actions</vh></v>
<v t="felix.20200718020912.11"><vh>async info messages codes</vh></v>
<v t="felix.20200718020912.12"><vh>async ask return codes</vh></v>
<v t="felix.20201103000337.1"><vh>body language code strings</vh></v>
<v t="felix.20200718020912.13"><vh>leoBridge action strings</vh></v>
<v t="felix.20200718020912.15"><vh>commands strings</vh></v>
<v t="felix.20210602151654.1"><vh>minibuffer overridden commands</vh></v>
</v>
</v>
<v t="felix.20200718031424.1"><vh>@clean src/extension.ts</vh>
<v t="felix.20200718031424.2"><vh>activate</vh>
<v t="ekr.20200815113156.1"><vh>&lt;&lt; Define entries for all commands &gt;&gt;</vh></v>
</v>
<v t="felix.20200718031424.24"><vh>deactivate</vh></v>
<v t="felix.20200718031424.25"><vh>showWelcomeIfNewer</vh></v>
</v>
<v t="felix.20200718035737.1"><vh>@clean src/leoAsync.ts</vh>
<v t="ekr.20200815083608.1"><vh>class LeoAsync</vh>
<v t="ekr.20200815083608.2"><vh>log</vh></v>
<v t="felix.20210804175113.1"><vh>refresh</vh></v>
<v t="ekr.20200815083608.3"><vh>showSaveAsDialog</vh></v>
<v t="ekr.20200815083609.1"><vh>showAskModalDialog</vh></v>
<v t="ekr.20200815083609.2"><vh>showWarnModalMessage</vh></v>
<v t="ekr.20200815083609.3"><vh>showChangesDetectedInfoMessage</vh></v>
<v t="ekr.20200815084550.1"><vh>&lt;&lt; TODO &gt;&gt;</vh></v>
</v>
</v>
<v t="felix.20200718040540.1"><vh>@clean src/leoBody.ts</vh>
<v t="felix.20200718040540.2"><vh>class LeoBodyProvider</vh>
<v t="felix.20200718040540.3"><vh>setBodyTime</vh></v>
<v t="felix.20200718040540.5"><vh>fireRefreshFile</vh></v>
<v t="felix.20200718040540.6"><vh>refreshPossibleGnxList</vh></v>
<v t="felix.20200718040540.8"><vh>watch</vh></v>
<v t="felix.20200718040540.10"><vh>stat</vh></v>
<v t="felix.20200718040540.11"><vh>readFile</vh></v>
<v t="felix.20200718040540.12"><vh>readDirectory</vh></v>
<v t="felix.20200718040540.13"><vh>createDirectory</vh></v>
<v t="felix.20200718040540.14"><vh>writeFile</vh></v>
<v t="felix.20200718040540.15"><vh>rename</vh></v>
<v t="felix.20200718040540.16"><vh>delete</vh></v>
<v t="felix.20200718040540.17"><vh>copy</vh></v>
<v t="felix.20200718040540.18"><vh>_fireSoon</vh></v>
</v>
</v>
<v t="felix.20200718153505.1"><vh>@clean src/leoBridge.ts</vh>
<v t="felix.20200718153505.2"><vh>class LeoBridge</vh>
<v t="felix.20200718153505.3"><vh>action</vh></v>
<v t="felix.20200718155251.1"><vh>isBusy</vh></v>
<v t="felix.20200718153505.4"><vh>_asyncAction</vh></v>
<v t="felix.20200718153505.5"><vh>_buildActionParameter</vh></v>
<v t="felix.20200718153505.6"><vh>_resolveBridgeReady</vh></v>
<v t="felix.20200718153505.7"><vh>_rejectAction</vh></v>
<v t="felix.20200718153505.8"><vh>_callAction</vh></v>
<v t="felix.20200718153505.9"><vh>_tryParseJSON</vh></v>
<v t="felix.20200718153505.11"><vh>_processAnswer</vh></v>
<v t="felix.20200718153505.12"><vh>initLeoProcess</vh></v>
<v t="felix.20210802163703.1"><vh>closeLeoProcess</vh></v>
<v t="felix.20200718153505.13"><vh>_send</vh></v>
</v>
</v>
<v t="felix.20200718162303.1"><vh>@clean src/leoButtonNode.ts</vh>
<v t="felix.20200718162303.2"><vh>class LeoButtonNode</vh>
<v t="felix.20200718162435.1"><vh>iconPath</vh></v>
<v t="felix.20200718162442.1"><vh>id</vh></v>
<v t="felix.20200718162452.1"><vh>tooltip</vh></v>
<v t="felix.20200718162459.1"><vh>description</vh></v>
</v>
</v>
<v t="felix.20200718164130.1"><vh>@clean src/leoButtons.ts</vh>
<v t="felix.20200718164130.2"><vh>class LeoButtonsProvider</vh>
<v t="felix.20200718164130.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718164130.4"><vh>getTreeItem</vh></v>
<v t="felix.20200718164130.5"><vh>getChildren</vh></v>
<v t="felix.20200718164130.6"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718164509.1"><vh>@clean src/leoDocumentNode.ts</vh>
<v t="felix.20200718164509.2"><vh>class LeoDocumentNode</vh>
<v t="felix.20200718164635.1"><vh>iconPath</vh></v>
<v t="felix.20200718164638.1"><vh>id</vh></v>
</v>
</v>
<v t="felix.20200718165108.1"><vh>@clean src/leoDocuments.ts</vh>
<v t="felix.20200718165108.2"><vh>class LeoDocumentsProvider</vh>
<v t="felix.20200718165108.3"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718165108.4"><vh>getTreeItem</vh></v>
<v t="felix.20200718165108.5"><vh>getChildren</vh></v>
<v t="felix.20200718165108.6"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718170429.1"><vh>@clean src/leoFileBrowser.ts</vh>
<v t="felix.20200718170429.2"><vh>class LeoFilesBrowser</vh>
<v t="felix.20200718170429.3"><vh>_getBestOpenFolderUri</vh></v>
<v t="felix.20210602160216.1"><vh>getImportFileUrl</vh></v>
<v t="felix.20200718170429.4"><vh>getLeoFileUrl</vh></v>
</v>
</v>
<v t="felix.20200719025231.1"><vh>@clean src/leoIntegration.ts</vh>
<v t="felix.20200719025231.2"><vh>class LeoIntegration</vh>
<v t="felix.20200719025231.3"><vh>Constructor</vh></v>
<v t="felix.20200719025231.4"><vh>Server</vh>
<v t="felix.20200719025231.5"><vh>sendAction</vh></v>
<v t="felix.20200719025231.6"><vh>startNetworkServices</vh></v>
<v t="felix.20200719025231.7"><vh>startServer</vh></v>
<v t="felix.20210717204048.1"><vh>stopServer</vh></v>
<v t="felix.20210802162424.1"><vh>stopConnection</vh></v>
<v t="felix.20200719025231.8"><vh>connect</vh></v>
<v t="felix.20200719025231.9"><vh>cancelConnect</vh></v>
<v t="felix.20210613210351.1"><vh>chooseLeoFolder</vh></v>
<v t="felix.20200719031346.1"><vh>sendConfigToServer</vh></v>
</v>
<v t="felix.20200719025231.10"><vh>Recently Opened Files</vh>
<v t="felix.20200719025231.11"><vh>_openLastFiles</vh></v>
<v t="felix.20200719025231.12"><vh>_addRecentAndLastFile</vh></v>
<v t="felix.20200719025231.13"><vh>_removeRecentFile</vh></v>
<v t="felix.20200719025231.14"><vh>_removeLastFile</vh></v>
<v t="felix.20200719025231.15"><vh>showRecentLeoFiles</vh></v>
</v>
<v t="ekr.20200815085229.1"><vh>Log &amp; Terminal panes</vh>
<v t="ekr.20200815085316.1"><vh>showTerminalPane</vh></v>
<v t="ekr.20200815085316.2"><vh>hideTerminalPane</vh></v>
<v t="ekr.20200815085316.3"><vh>addTerminalPaneEntry</vh></v>
<v t="ekr.20200815085316.4"><vh>showLogPane</vh></v>
<v t="ekr.20200815085316.5"><vh>hideLogPane</vh></v>
<v t="ekr.20200815085316.6"><vh>addLogPaneEntry</vh></v>
</v>
<v t="felix.20200719031802.1"><vh>Document States</vh>
<v t="felix.20200719025231.19"><vh>_triggerGetStates</vh></v>
<v t="felix.20200719025231.20"><vh>_isBusy</vh></v>
<v t="felix.20201107224112.1"><vh>_isBusyTriggerSave</vh></v>
<v t="felix.20200719025231.21"><vh>_isCurrentFileNamed</vh></v>
<v t="felix.20200719025231.22"><vh>_setupNoOpenedLeoDocument</vh></v>
<v t="felix.20200719025231.23"><vh>_setupOpenedLeoDocument</vh></v>
</v>
<v t="felix.20200719030811.1"><vh>UI Change Events</vh>
<v t="felix.20200719025231.24"><vh>_onChangeConfiguration</vh></v>
<v t="ekr.20200815085628.1"><vh>_onDidOpenTextDocument</vh></v>
<v t="felix.20200719025231.25"><vh>_onChangeCollapsedState</vh></v>
<v t="felix.20200719025231.26"><vh>_onTreeViewVisibilityChanged</vh></v>
<v t="felix.20200719025231.27"><vh>_onDocTreeViewVisibilityChanged</vh></v>
<v t="ekr.20200815085705.1"><vh>_onButtonsTreeViewVisibilityChanged</vh></v>
<v t="felix.20200719025231.29"><vh>_onActiveEditorChanged</vh></v>
<v t="felix.20210418014039.1"><vh>_changedTextEditorViewColumn</vh></v>
<v t="felix.20210418014040.1"><vh>_changedVisibleTextEditors</vh></v>
<v t="felix.20210418014040.2"><vh>_changedWindowState</vh></v>
<v t="felix.20200928004727.1"><vh>_onChangeEditorSelection</vh></v>
<v t="felix.20201014020145.1"><vh>_onChangeEditorScroll</vh></v>
<v t="felix.20200719025231.31"><vh>_onDocumentChanged</vh></v>
</v>
<v t="felix.20200719030842.1"><vh>Body Editing</vh>
<v t="felix.20200719025231.32"><vh>triggerBodySave</vh></v>
<v t="felix.20200928133238.1"><vh>_bodySaveSelection</vh></v>
<v t="felix.20200719025231.33"><vh>_bodySaveDocument</vh></v>
</v>
<v t="felix.20200719030902.1"><vh>Refresh UI</vh>
<v t="felix.20200719025231.34"><vh>setDocumentSelection</vh></v>
<v t="felix.20200719025231.35"><vh>showOutline</vh></v>
<v t="felix.20201114185218.1"><vh>setTreeViewTitle</vh></v>
<v t="ekr.20200815085806.1"><vh>configTreeRefresh</vh></v>
<v t="ekr.20200815085830.1"><vh>_refreshOutline</vh></v>
<v t="ekr.20200815085830.2"><vh>_revealTreeViewNode</vh></v>
<v t="ekr.20200815085830.3"><vh>launchRefresh</vh></v>
<v t="ekr.20200815085830.5"><vh>_gotSelection</vh></v>
<v t="felix.20210528012836.1"><vh>getBridgeFocus</vh></v>
</v>
<v t="felix.20200719030909.1"><vh>Conversion</vh>
<v t="felix.20200719025231.38"><vh>apToLeoNode</vh></v>
<v t="felix.20200719025231.39"><vh>_apToLeoNodeConvertReveal</vh></v>
<v t="felix.20200719025231.40"><vh>arrayToLeoNodesArray</vh></v>
</v>
<v t="felix.20200719031115.1"><vh>Body Pane Management</vh>
<v t="ekr.20200815090152.1"><vh>_tryApplyNodeToBody</vh></v>
<v t="felix.20200719025231.47"><vh>_switchBody</vh></v>
<v t="felix.20200719025231.48"><vh>_locateOpenedBody</vh></v>
<v t="felix.20210418230204.1"><vh>_findUriColumn</vh></v>
<v t="felix.20210418230204.2"><vh>_findGnxColumn</vh></v>
<v t="felix.20210418013332.1"><vh>_hideDeleteBody</vh></v>
<v t="felix.20210418220343.1"><vh>_checkPreviewMode</vh></v>
<v t="felix.20200719025231.49"><vh>closeBody</vh></v>
<v t="felix.20210718155134.1"><vh>cleanupBody</vh></v>
<v t="felix.20200719025231.50"><vh>showBody</vh></v>
</v>
<v t="felix.20200719025231.51"><vh>Commands</vh>
<v t="felix.20201114185813.1"><vh>minibuffer</vh></v>
<v t="felix.20200719025231.52"><vh>selectTreeNode</vh></v>
<v t="ekr.20200815090400.1"><vh>nodeCommand</vh></v>
<v t="felix.20200719025231.54"><vh>changeMark</vh></v>
<v t="felix.20200719025231.55"><vh>editHeadline</vh></v>
<v t="felix.20200719025231.56"><vh>insertNode</vh></v>
</v>
<v t="felix.20210530225640.1"><vh>Search</vh>
<v t="felix.20210516233931.1"><vh>startSearch</vh></v>
<v t="felix.20210613212439.1"><vh>newHeadline</vh></v>
<v t="felix.20210613205741.1"><vh>_inputFindPattern</vh></v>
<v t="felix.20210516234059.1"><vh>find</vh></v>
<v t="felix.20210713000442.1"><vh>findSymbol</vh></v>
<v t="felix.20210530223726.1"><vh>replace</vh></v>
<v t="felix.20210530230354.1"><vh>replaceAll</vh></v>
<v t="felix.20210530230400.1"><vh>cloneFind</vh></v>
<v t="felix.20210530225306.1"><vh>setSearchOption</vh></v>
<v t="felix.20210525232728.1"><vh>loadSearchSettings</vh></v>
<v t="felix.20210524215215.1"><vh>saveSearchSettings</vh></v>
<v t="felix.20210601164915.1"><vh>gotoGlobalLine</vh></v>
<v t="felix.20210620220655.1"><vh>tagChildren</vh></v>
<v t="felix.20210620220702.1"><vh>cloneFindTag</vh></v>
</v>
<v t="felix.20200719025231.57"><vh>Leo Documents</vh>
<v t="felix.20200719025231.58"><vh>saveAsLeoFile</vh></v>
<v t="felix.20200719025231.59"><vh>saveLeoFile</vh></v>
<v t="felix.20200719025231.60"><vh>switchLeoFile</vh></v>
<v t="felix.20200719025231.61"><vh>selectOpenedLeoDocument</vh></v>
<v t="fil.20210609233100.1"><vh>clearRecentLeoFiles</vh></v>
<v t="felix.20200719025231.64"><vh>closeLeoFile</vh></v>
<v t="felix.20200719025231.65"><vh>newLeoFile</vh></v>
<v t="felix.20200719025231.66"><vh>openLeoFile</vh></v>
<v t="felix.20210602155312.1"><vh>importFile</vh></v>
</v>
<v t="felix.20200719033306.1"><vh>AtButtons</vh>
<v t="ekr.20200815090517.1"><vh>clickAtButton</vh></v>
<v t="ekr.20200815090517.2"><vh>removeAtButton</vh></v>
</v>
<v t="felix.20200719033511.1"><vh>Other</vh>
<v t="felix.20210610022836.1"><vh>prevNextNode</vh></v>
<v t="felix.20210524231157.1"><vh>setFindPanel</vh></v>
<v t="felix.20200719025231.69"><vh>statusBarOnClick</vh></v>
<v t="felix.20200719025231.70"><vh>test</vh></v>
</v>
</v>
</v>
<v t="felix.20200718170712.1"><vh>@clean src/leoNode.ts</vh>
<v t="felix.20200718170712.2"><vh>class LeoNode</vh>
<v t="felix.20200718170712.4"><vh>setRoot</vh></v>
<v t="felix.20200718170712.5"><vh>_getNodeContextValue</vh></v>
<v t="felix.20200718171904.1"><vh>get_iconPath</vh></v>
<v t="felix.20200718171854.1"><vh>get_id</vh></v>
<v t="felix.20200718171837.1"><vh>get_description</vh></v>
<v t="felix.20200718171849.1"><vh>get tooltip</vh></v>
</v>
</v>
<v t="felix.20200718180428.1"><vh>@clean src/leoOutline.ts</vh>
<v t="felix.20200718180428.2"><vh>class LeoOutlineProvider</vh>
<v t="felix.20200718180428.4"><vh>refreshTreeRoot</vh></v>
<v t="felix.20200718180428.5"><vh>getTreeItem</vh></v>
<v t="felix.20200718180428.6"><vh>getChildren</vh></v>
<v t="felix.20200718180428.7"><vh>getParent</vh></v>
</v>
</v>
<v t="felix.20200718192351.1"><vh>@clean src/leoStates.ts</vh>
<v t="felix.20200718192411.1"><vh>class LeoStates</vh>
<v t="felix.20200718193719.1"><vh>General State Flags</vh>
<v t="felix.20200718193219.1"><vh>leoBridgeReady &amp; helper</vh></v>
<v t="felix.20200718193222.1"><vh>fileOpenedReady &amp; helper</vh></v>
<v t="felix.20200718193226.1"><vh>leoOpenedFileName</vh></v>
<v t="felix.20200718193230.1"><vh>leoChanged &amp; helper</vh></v>
<v t="felix.20200718193233.1"><vh>leoCanUndo &amp; helper</vh></v>
<v t="felix.20200718193235.1"><vh>leoCanRedo &amp; helper</vh></v>
<v t="felix.20200718193238.1"><vh>leoCanDemote &amp; helper</vh></v>
<v t="felix.20200718193241.1"><vh>leoCanPromote &amp; helper</vh></v>
<v t="felix.20200718193244.1"><vh>leoCanDehoist &amp; helper</vh></v>
</v>
<v t="felix.20200718193731.1"><vh>Selected Node Flags</vh>
<v t="felix.20200718193338.1"><vh>leoMarked</vh></v>
<v t="felix.20200718193341.1"><vh>leoCloned</vh></v>
<v t="felix.20200718193343.1"><vh>leoDirty</vh></v>
<v t="felix.20200718193348.1"><vh>leoEmpty</vh></v>
<v t="felix.20200718193350.1"><vh>leoChild</vh></v>
<v t="felix.20200718193353.1"><vh>leoAtFile</vh></v>
<v t="felix.20200718193403.1"><vh>leoRoot</vh></v>
</v>
<v t="felix.20200718193500.1"><vh>constructor</vh></v>
<v t="felix.20200718192411.2"><vh>selectedNodeFlags</vh></v>
<v t="felix.20200718192411.3"><vh>leoStateFlags</vh></v>
</v>
</v>
<v t="felix.20200718185403.1"><vh>@clean src/leoStatusBar.ts</vh>
<v t="felix.20200718185403.2"><vh>class LeoStatusBar</vh>
<v t="felix.20200718185403.3"><vh>show</vh></v>
<v t="felix.20200718185403.4"><vh>hide</vh></v>
<v t="felix.20200718185403.5"><vh>setString</vh></v>
<v t="felix.20200718185403.6"><vh>update</vh></v>
<v t="felix.20200718185403.7"><vh>_updateLeoObjectIndicatorDebounced</vh></v>
<v t="felix.20200718185403.8"><vh>_updateLeoObjectIndicator</vh></v>
</v>
</v>
<v t="felix.20200718191946.1"><vh>@clean src/serverManager.ts</vh>
<v t="felix.20200718191946.2"><vh>class ServerService</vh>
<v t="ekr.20200815091220.1"><vh>_gotTerminalData</vh></v>
<v t="felix.20200718191946.4"><vh>startServer</vh></v>
<v t="felix.20210717192921.1"><vh>killServer</vh></v>
</v>
</v>
<v t="felix.20200718194857.1"><vh>@clean src/types.d.ts</vh>
<v t="felix.20210727225050.1"><vh>IVsCodeApi</vh></v>
<v t="felix.20200718194857.2"><vh>ConfigMembers</vh></v>
<v t="felix.20201017224340.1"><vh>ConfigSetting</vh></v>
<v t="felix.20210727224655.1"><vh>FontSettings</vh></v>
<v t="felix.20200718194857.3"><vh>RevealType</vh></v>
<v t="felix.20200718194857.4"><vh>RefreshType</vh></v>
<v t="felix.20200718194857.5"><vh>UserCommand</vh></v>
<v t="ekr.20200815091346.1"><vh>ShowBodyParam</vh></v>
<v t="felix.20200718194857.6"><vh>LeoAction</vh></v>
<v t="felix.20200718194857.7"><vh>LeoLogEntry</vh></v>
<v t="felix.20200718194857.8"><vh>ArchivedPosition</vh></v>
<v t="ekr.20200815091408.1"><vh>LeoPackageStates</vh></v>
<v t="felix.20200718194857.10"><vh>LeoBridgePackage</vh></v>
<v t="felix.20200718194857.11"><vh>LeoDocument</vh></v>
<v t="felix.20200718194857.12"><vh>LeoButton</vh></v>
<v t="felix.20210522152922.1"><vh>LeoSearchScope</vh></v>
<v t="felix.20210522152739.1"><vh>LeoSearchSettings</vh></v>
<v t="felix.20210523162125.1"><vh>LeoGuiFindTabManagerSettings</vh></v>
<v t="felix.20200718194857.13"><vh>Icon</vh></v>
<v t="felix.20200718194857.14"><vh>BodyTimeInfo</vh></v>
<v t="felix.20201119002510.1"><vh>BodyPosition</vh></v>
<v t="felix.20201006195046.1"><vh>BodySelectionInfo</vh></v>
<v t="felix.20200718194857.15"><vh>showSaveAsDialogParameters</vh></v>
<v t="felix.20200718194857.16"><vh>runAskYesNoDialogParameters</vh></v>
<v t="felix.20200718194857.17"><vh>runWarnMessageDialogParameters</vh></v>
<v t="felix.20200718194857.18"><vh>runInfoMessageDialogParameters</vh></v>
<v t="felix.20200718194857.19"><vh>AskMessageItem</vh></v>
<v t="felix.20200718194857.20"><vh>ChooseDocumentItem</vh></v>
</v>
<v t="felix.20200718195558.1"><vh>@clean src/utils.ts</vh>
<v t="felix.20210706233101.1"><vh>uniqueId</vh></v>
<v t="felix.20210706233106.1"><vh>getUniqueId</vh></v>
<v t="felix.20200718195558.2"><vh>padNumber2</vh></v>
<v t="ekr.20200815091619.1"><vh>hashNode</vh></v>
<v t="felix.20201106200100.1"><vh>addFileToGlobal</vh></v>
<v t="felix.20201106200109.1"><vh>removeFileFromGlobal</vh></v>
<v t="felix.20200718195558.3"><vh>buildNodeIconPaths</vh></v>
<v t="felix.20200718195558.4"><vh>buildDocumentIconPaths</vh></v>
<v t="ekr.20200815091945.1"><vh>buildButtonsIconPaths</vh></v>
<v t="felix.20200718195558.6"><vh>buildNodeAndTextJson</vh></v>
<v t="felix.20210614235023.1"><vh>chooseLeoFolderDialog</vh></v>
<v t="felix.20201018163510.1"><vh>getDurationMilliseconds</vh></v>
<v t="felix.20200718195558.7"><vh>getFileFromPath</vh></v>
<v t="felix.20200718195558.8"><vh>isIconChangedByEdit</vh></v>
<v t="felix.20200718195558.9"><vh>isHexColor</vh></v>
<v t="felix.20200718195558.10"><vh>strToLeoUri</vh></v>
<v t="felix.20200718195558.11"><vh>leoUriToStr</vh></v>
<v t="felix.20200718195558.12"><vh>setContext</vh></v>
<v t="felix.20210612214028.1"><vh>findNextAvailablePort</vh></v>
</v>
<v t="felix.20210522001751.1"><vh>@clean src/webviews/leoFindPanelWebview.ts</vh>
<v t="felix.20210522001814.1"><vh>class LeoFindPanelProvider</vh>
<v t="fil.20210603195851.1"><vh>resolveWebviewView</vh></v>
<v t="fil.20210603195902.1"><vh>_getHtmlForWebview</vh></v>
<v t="fil.20210603195909.1"><vh>getNonce</vh></v>
</v>
</v>
<v t="fil.20210603195218.1"><vh>@clean src/webviews/leoSettingsWebview.ts</vh>
<v t="fil.20210603195319.1"><vh>class LeoSettingsWebview</vh>
<v t="fil.20210603195319.2"><vh>changedConfiguration</vh></v>
<v t="fil.20210603195319.3"><vh>openWebview</vh></v>
<v t="fil.20210603195319.4"><vh>_getBaseHtml</vh></v>
</v>
</v>
</v>
<v t="fil.20210603223013.1"><vh>Files: Find Panel Webview</vh>
<v t="fil.20210603223013.2"><vh>@clean find-panel/main.css</vh></v>
<v t="fil.20210603223013.4"><vh>@clean find-panel/main.js</vh>
<v t="fil.20210603223013.5"><vh>function</vh>
<v t="fil.20210603223013.6"><vh>window.addEventListener =&gt;</vh></v>
<v t="fil.20210603223013.7"><vh>function setSearchSetting</vh></v>
<v t="fil.20210603223013.8"><vh>function setSettings</vh>
<v t="fil.20210603223013.9"><vh>inputIds.forEach =&gt;</vh></v>
<v t="fil.20210603223013.10"><vh>checkboxIds.forEach =&gt;</vh></v>
</v>
<v t="fil.20210603223013.11"><vh>function sendSearchConfig</vh></v>
<v t="fil.20210603223013.12"><vh>function processChange</vh>
<v t="fil.20210603223013.13"><vh>timer = setTimeout =&gt;</vh></v>
</v>
<v t="fil.20210603223013.14"><vh>inputIds.forEach =&gt;</vh>
<v t="fil.20210603223013.15"><vh>document.getElementById(p_inputId).onkeypress = function</vh></v>
<v t="fil.20210603223013.16"><vh>document.getElementById(p_inputId).addEventListener('input', function</vh></v>
</v>
<v t="fil.20210603223013.17"><vh>checkboxIds.forEach =&gt;</vh>
<v t="fil.20210603223013.18"><vh>document.getElementById(p_inputId).addEventListener('change', function</vh></v>
</v>
<v t="fil.20210603223013.19"><vh>radioIds.forEach =&gt;</vh>
<v t="fil.20210603223013.20"><vh>document.getElementById(p_inputId).addEventListener('change', function</vh></v>
</v>
<v t="fil.20210603223013.21"><vh>function toggleCheckbox</vh></v>
<v t="fil.20210603223013.22"><vh>function setRadio</vh></v>
<v t="fil.20210603223013.23"><vh>function checkKeyDown</vh></v>
<v t="fil.20210603223013.24"><vh>function focusOnField</vh>
<v t="fil.20210603223013.25"><vh>setTimeout =&gt;</vh></v>
</v>
<v t="fil.20210603223013.26"><vh>function getSettings</vh></v>
</v>
</v>
<v t="fil.20210603223014.2"><vh>@clean find-panel/reset.css</vh></v>
<v t="fil.20210603223014.4"><vh>@clean find-panel/vscode.css</vh></v>
</v>
<v t="fil.20210603223933.1"><vh>Files: Settings Panel Webview</vh>
<v t="fil.20210603223933.2"><vh>@clean src/webviews/settingsPanel/colors.ts</vh>
<v t="fil.20210603223933.3"><vh>adjustLight</vh></v>
<v t="fil.20210603223933.4"><vh>darken</vh></v>
<v t="fil.20210603223933.5"><vh>lighten</vh></v>
<v t="fil.20210603223933.6"><vh>opacity</vh></v>
<v t="fil.20210603223933.7"><vh>toRgba</vh></v>
</v>
<v t="fil.20210603223933.9"><vh>@clean src/webviews/settingsPanel/index.html</vh>
<v t="fil.20210603223933.10"><vh>&lt;html&gt;</vh></v>
</v>
<v t="fil.20210603223933.165"><vh>@clean src/webviews/settingsPanel/index.ts</vh>
<v t="fil.20210603223933.166"><vh>main</vh>
<v t="fil.20210603223934.1"><vh>listenAll</vh></v>
<v t="fil.20210603223934.2"><vh>chooseLeoServerPath</vh></v>
<v t="fil.20210603223934.3"><vh>onBind</vh></v>
<v t="fil.20210603223934.4"><vh>onInputSelected</vh></v>
<v t="fil.20210603223934.5"><vh>onInputChecked</vh></v>
<v t="fil.20210603223934.6"><vh>onInputBlurred</vh></v>
<v t="fil.20210603223934.7"><vh>onInputFocused</vh></v>
<v t="fil.20210603223934.8"><vh>onInputChanged</vh></v>
<v t="felix.20210725221438.1"><vh>onVscodeInputChanged</vh></v>
<v t="felix.20210725221447.1"><vh>setFontControls</vh></v>
<v t="fil.20210603223934.9"><vh>setControls</vh></v>
<v t="fil.20210603223934.10"><vh>setVisibility</vh></v>
<v t="fil.20210603223934.11"><vh>parseStateExpression</vh></v>
<v t="fil.20210603223934.12"><vh>evaluateStateExpression</vh></v>
<v t="fil.20210603223934.13"><vh>getSettingValue</vh></v>
</v>
</v>
<v t="fil.20210603223934.15"><vh>@clean src/webviews/settingsPanel/theme.ts</vh>
<v t="fil.20210603223934.16"><vh>initializeAndWatchThemeColors</vh></v>
</v>
<v t="fil.20210603223956.2"><vh>@clean src/webviews/settingsPanel/scss/main.scss</vh></v>
<v t="fil.20210603223956.4"><vh>@clean src/webviews/settingsPanel/scss/popup.scss</vh></v>
</v>
<v t="ekr.20200808100339.1"><vh>----- TS Classes</vh>
<v t="felix.20200718024635.2"></v>
<v t="felix.20200718030926.2"></v>
<v t="felix.20200718020912.2"></v>
<v t="ekr.20200815083608.1"></v>
<v t="felix.20200718040540.2"></v>
<v t="felix.20200718153505.2"></v>
<v t="felix.20200718162303.2"></v>
<v t="felix.20200718164130.2"></v>
<v t="felix.20200718164509.2"></v>
<v t="felix.20200718165108.2"></v>
<v t="felix.20200718170429.2"></v>
<v t="felix.20210522001814.1"></v>
<v t="felix.20200719025231.2"></v>
<v t="felix.20200718170712.2"></v>
<v t="fil.20210603195319.1"></v>
<v t="felix.20200718192411.1"></v>
<v t="felix.20200718180428.2"></v>
<v t="felix.20200718185403.2"></v>
<v t="felix.20200718191946.2"></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20200722125546.1">@language python

g.cls()
d = c.commandsDict  # keys are command names, values are functions.
for command_name in sorted(d):
    if command_name.startswith('@'):
        continue
    func = d.get(command_name)
    # Prefer func.__func_name__ to func.__name__: Leo's decorators change func.__name__!
    func_name = getattr(func, '__func_name__', func.__name__)
    # print(f"{command_name:&gt;40} {func_name}")
    print(command_name)
print('len(d)', len(d))

</t>
<t tx="ekr.20200722190504.1"></t>
<t tx="ekr.20200722190517.1"></t>
<t tx="ekr.20200724052304.1">c.backup_helper(sub_dir='leoInteg')
</t>
<t tx="ekr.20200808100339.1"></t>
<t tx="ekr.20200808100711.1"></t>
<t tx="ekr.20200808100717.1">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20200815083608.1">/**
 * * Handles the functions called by Leo through leoBridge such as adding a log pane entry, runAskYesNoDialog for file changes, etc.
 * * Some config settings affect this behavior, such as defaultReloadIgnore and checkForChangeExternalFiles
 */
export class LeoAsync {

    private _askResult: string = "";

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others

}

&lt;&lt; TODO &gt;&gt;
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200815083608.2">/**
 * * Adds message string to leoInteg's log pane, used when leoBridge gets an async 'log' command
 */
public log(p_message: string): void {
    this._leoIntegration.addLogPaneEntry(p_message);
}

</t>
<t tx="ekr.20200815083608.3">/**
 * * Equivalent to runSaveFileDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * @param p_saveAsArg
 */
public showSaveAsDialog(p_saveAsArg: showSaveAsDialogParameters): void {
    console.log('TODO: SHOW SAVE AS DIALOG!');
}

</t>
<t tx="ekr.20200815083609.1">/**
 * * Equivalent to runAskYesNoDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * * Opens a modal dialog to return one of 'yes', 'yes-all', 'no' or 'no-all' to be sent back with the leoBridge 'ASK_RESULT' action
 * @param p_askArg an async package object {"ask": title, "message": message, "yes_all": yes_all, "no_all": no_all}
 */
public showAskModalDialog(p_askArg: runAskYesNoDialogParameters): void {
    this._askResult = "no"; // defaults to not doing anything, matches isCloseAffordance just to be safe
    // Note: "last line" could be eventually used in the message
    // const w_lastLine = p_askArg.message.substr(p_askArg.message.lastIndexOf("\n") + 1);
    const w_items: AskMessageItem[] = [
        {
            title: Constants.USER_MESSAGES.YES,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES,
            isCloseAffordance: false
        },
        {
            title: Constants.USER_MESSAGES.NO,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO,
            isCloseAffordance: true
        }
    ];
    if (p_askArg.yes_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.YES_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES_ALL,
            isCloseAffordance: false
        });
    }
    if (p_askArg.no_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.NO_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO_ALL,
            isCloseAffordance: false
        });
    }
    const w_askRefreshInfoMessage: Thenable&lt;AskMessageItem | undefined&gt; = vscode.window.showInformationMessage(
        p_askArg.message,
        { modal: true },
        ...w_items
    );
    w_askRefreshInfoMessage.then((p_result: AskMessageItem | undefined) =&gt; {
        if (p_result) {
            this._askResult = p_result.value;
        }
        const w_sendResultPromise = this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.ASK_RESULT,
            JSON.stringify({ "result": this._askResult })
        );
        if (this._askResult.includes(Constants.ASYNC_ASK_RETURN_CODES.YES)) {
            w_sendResultPromise.then(() =&gt; {
                this._leoIntegration.launchRefresh({ tree: true, body: true, buttons: true, states: true, documents: true }, false);
            });
        }
    });
}

</t>
<t tx="ekr.20200815083609.2">/**
 * * Equivalent to runAskOkDialog from Leo's qt_gui.py, used when leoBridge gets an async 'warn' command
 * @param p_waitArg an async package object {"warn": "", "message": ""}
 */
public showWarnModalMessage(p_waitArg: runWarnMessageDialogParameters): void {
    vscode.window.showInformationMessage(
        p_waitArg.message,
        { modal: true }
    ).then(() =&gt; {
        this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.ASK_RESULT,
            JSON.stringify({ "result": Constants.ASYNC_ASK_RETURN_CODES.OK })
        );
    });
}

</t>
<t tx="ekr.20200815083609.3">/**
 * * Show non-blocking info message about detected file changes, used when leoBridge gets an async 'info' command
 * @param p_infoArg an async package object { "message": string; }
 */
public showChangesDetectedInfoMessage(p_infoArg: runInfoMessageDialogParameters): void {
    let w_message = Constants.USER_MESSAGES.CHANGES_DETECTED;
    switch (p_infoArg.message) {
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_REFRESHED:
            w_message += Constants.USER_MESSAGES.REFRESHED;
            // TODO : #34 @boltex Deal with focus placement
            this._leoIntegration.launchRefresh({ tree: true, body: true, states: true, documents: true }, false);
            break;
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_IGNORED:
            w_message += Constants.USER_MESSAGES.IGNORED;
            break;
        default:
            w_message = w_message + " " + p_infoArg.message;
            break;
    }
    vscode.window.showInformationMessage(w_message);
}

</t>
<t tx="ekr.20200815084016.1">/**
 * * Configuration Defaults used in config.ts
 * Used when setting itself and getting parameters from vscode
 */
public static CONFIG_DEFAULTS = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "none",  // Used in leoBridge scrip,
    DEFAULT_RELOAD_IGNORE: "none", // Used in leoBridge scrip,
    LEO_TREE_BROWSE: true,
    TREE_KEEP_FOCUS: true,
    TREE_KEEP_FOCUS_WHEN_ASIDE: false,
    STATUSBAR_STRING: "", // Strings like "Literate", "Leo", UTF-8 also supported: \u{1F981}
    STATUSBAR_COLOR: "fb7c47",
    TREE_IN_EXPLORER: true,
    SHOW_OPEN_ASIDE: true,
    SHOW_EDIT: true,
    SHOW_ARROWS: false,
    SHOW_ADD: false,
    SHOW_MARK: false,
    SHOW_CLONE: false,
    SHOW_COPY: false,

    SHOW_EDITION_BODY: true,
    SHOW_CLIPBOARD_BODY: true,
    SHOW_PROMOTE_BODY: true,
    SHOW_EXECUTE_BODY: true,
    SHOW_EXTRACT_BODY: true,
    SHOW_IMPORT_BODY: true,
    SHOW_REFRESH_BODY: true,
    SHOW_HOIST_BODY: true,
    SHOW_MARK_BODY: true,
    SHOW_SORT_BODY: true,

    INVERT_NODES: false,
    LEO_PYTHON_COMMAND: "",
    LEO_EDITOR_PATH: "",
    AUTO_START_SERVER: false,
    AUTO_CONNECT: false,
    IP_ADDRESS: "localhost",
    IP_LOOPBACK: "127.0.0.1",
    IP_PORT: 32125
};

</t>
<t tx="ekr.20200815084550.1">/*
    TODO : Should Reproduce those interactive controls that may be asked by Leo, and redo a true UI bridge

def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    return self.simulateDialog("aboutLeoDialog", None)

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog", None)

def runAskOkDialog(self, c, title, message=None, text="Ok"):
    return self.simulateDialog("okDialog", "Ok")

def runAskOkCancelNumberDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
):
    return self.simulateDialog("numberDialog", -1)

def runAskOkCancelStringDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
    default="",
    wide=False,
):
    return self.simulateDialog("stringDialog", '')

def runCompareDialog(self, c):
    return self.simulateDialog("compareDialog", '')

def runOpenFileDialog(self, c, title, filetypes, defaultextension,
    multiple=False,
    startpath=None,
):
    return self.simulateDialog("openFileDialog", None)

def runSaveFileDialog(self, c, initialfile, title, filetypes, defaultextension):
    return self.simulateDialog("saveFileDialog", None)

def runAskYesNoDialog(self, c, title,
    message=None,
    yes_all=False,
    no_all=False,
):
    return self.simulateDialog("yesNoDialog", "no")

def runAskYesNoCancelDialog(self, c, title,
    message=None,
    yesMessage="Yes",
    noMessage="No",
    yesToAllMessage=None,
    defaultButton="Yes",
    cancelMessage=None,
):
    return self.simulateDialog("yesNoCancelDialog", "cancel")

def simulateDialog(self, key, defaultVal):
    return defaultVal

*/
</t>
<t tx="ekr.20200815085229.1"></t>
<t tx="ekr.20200815085316.1">/**
 * * Reveals the leoBridge server terminal output if not already visible
 */
public showTerminalPane(): void {
    if (this._leoTerminalPane) {
        this._leoTerminalPane.show(true);
    }
}

</t>
<t tx="ekr.20200815085316.2">/**
 * * Hides the leoBridge server terminal output
 */
public hideTerminalPane(): void {
    if (this._leoTerminalPane) {
        this._leoTerminalPane.hide();
    }
}

</t>
<t tx="ekr.20200815085316.3">/**
 * * Adds a message string to leoInteg's leoBridge server terminal output.
 * @param p_message The string to be added in the log
 */
public addTerminalPaneEntry(p_message: string): void {
    if (this._leoTerminalPane) {
        this._leoTerminalPane.appendLine(p_message);
    }
}

</t>
<t tx="ekr.20200815085316.4">/**
 * * Reveals the log pane if not already visible
 */
public showLogPane(): void {
    this._leoLogPane.show(true);
}

</t>
<t tx="ekr.20200815085316.5">/**
 * * Hides the log pane
 */
public hideLogPane(): void {
    this._leoLogPane.hide();
}

</t>
<t tx="ekr.20200815085316.6">/**
 * * Adds a message string to leoInteg's log pane. Used when leoBridge receives an async 'log' command.
 * @param p_message The string to be added in the log
 */
public addLogPaneEntry(p_message: string): void {
    this._leoLogPane.appendLine(p_message);
}

</t>
<t tx="ekr.20200815085628.1">/**
 * * Handles the opening of a file in vscode, and check if it's a Leo file to suggest opening options
 * @param p_event The opened document event passed by vscode
 */
private _onDidOpenTextDocument(p_document: vscode.TextDocument): void {
    if (
        this.leoStates.leoBridgeReady &amp;&amp;
        p_document.uri.scheme === Constants.URI_LEO_SCHEME &amp;&amp;
        p_document.uri.fsPath.toLowerCase().endsWith('.leo')
    ) {
        if (!this._hasShownContextOpenMessage) {
            vscode.window.showInformationMessage(Constants.USER_MESSAGES.RIGHT_CLICK_TO_OPEN);
            this._hasShownContextOpenMessage = true;
        }
        // vscode.window.showQuickPick(
        //     [Constants.USER_MESSAGES.YES, Constants.USER_MESSAGES.NO],
        //     { placeHolder: Constants.USER_MESSAGES.OPEN_WITH_LEOINTEG }
        // )
        //     .then(p_result =&gt; {
        //         if (p_result &amp;&amp; p_result === Constants.USER_MESSAGES.YES) {
        //             const w_uri = p_document.uri;
        //             vscode.window.showTextDocument(p_document.uri, { preview: true, preserveFocus: false })
        //                 .then(() =&gt; {
        //                     return vscode.commands.executeCommand('workbench.action.closeActiveEditor');
        //                 })
        //                 .then(() =&gt; {
        //                     this.openLeoFile(w_uri);
        //                 });
        //         }
        //     });
    }
}

</t>
<t tx="ekr.20200815085705.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onButtonsTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {
    if (p_explorerView) {
    } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this.refreshButtonsPane();
    }
}

</t>
<t tx="ekr.20200815085806.1">/**
 * * Refresh tree for 'node hover icons' to show up properly after changing their settings
 */
public configTreeRefresh(): void {
    if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
        this._preventShowBody = true;
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="ekr.20200815085830.1">/**
 * * Refreshes the outline. A reveal type can be passed along to specify the reveal type for the selected node
 * @param p_revealType Facultative reveal type to specify type of reveal when the 'selected node' is encountered
 */
private _refreshOutline(p_incrementTreeID: boolean, p_revealType?: RevealType): void {
    if (p_incrementTreeID) {
        this._treeId++;
    }
    if (p_revealType !== undefined) {
        // To check if selected node should self-select while redrawing whole tree
        this._revealType = p_revealType; // To be read/cleared (in arrayToLeoNodesArray instead of directly by nodes)
    }
    // Force showing last used Leo outline first
    if (this.lastSelectedNode &amp;&amp; !(this._leoTreeExView.visible || this._leoTreeView.visible)) {
        this._lastTreeView.reveal(this.lastSelectedNode).then(() =&gt; {
            this._leoTreeProvider.refreshTreeRoot();
        });
    } else {
        this._leoTreeProvider.refreshTreeRoot();
    }
}

</t>
<t tx="ekr.20200815085830.2">/**
 * * 'TreeView.reveal' for any opened leo outline that is currently visible
 * @param p_leoNode The node to be revealed
 * @param p_options Options object for the revealed node to either also select it, focus it, and expand it
 */
private _revealTreeViewNode(
    p_leoNode: LeoNode,
    p_options?: { select?: boolean; focus?: boolean; expand?: boolean | number }
): Thenable&lt;void&gt; {
    if (this._leoTreeView.visible) {
        return this._leoTreeView.reveal(p_leoNode, p_options);
    }
    if (this._leoTreeExView.visible &amp;&amp; this.config.treeInExplorer) {
        return this._leoTreeExView.reveal(p_leoNode, p_options);
    }
    return Promise.resolve(); // Defaults to resolving even if both are hidden
}

</t>
<t tx="ekr.20200815085830.3">/**
 * * Launches refresh for UI components and states
 * @param p_refreshType choose to refresh the outline, or the outline and body pane along with it
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_ap // TODO ! DOCUMENT !
 */
public launchRefresh(
    p_refreshType: ReqRefresh,
    p_fromOutline: boolean,
    p_ap?: ArchivedPosition
): void {
    // Set w_revealType, it will ultimately set this._revealType.
    // Used when finding the OUTLINE's selected node and setting or preventing focus into it
    // Set this._fromOutline. Used when finding the selected node and showing the BODY to set or prevent focus in it
    this._refreshType = Object.assign({}, p_refreshType);
    let w_revealType: RevealType;
    if (p_fromOutline) {
        this._fromOutline = true;
        w_revealType = RevealType.RevealSelectFocus;
    } else {
        this._fromOutline = false;
        w_revealType = RevealType.RevealSelect;
    }
    if (
        p_ap &amp;&amp;
        this._refreshType.body &amp;&amp;
        this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty
    ) {
        // When this refresh is launched with 'refresh body' requested, we need to lose any pending edits and save on vscode's side.
        // do this only if gnx is different from what is coming from Leo in this refresh cycle
        if (
            p_ap.gnx !== utils.leoUriToStr(this._bodyLastChangedDocument.uri) &amp;&amp;
            !this._bodyLastChangedDocumentSaved
        ) {
            this._bodyLastChangedDocument.save(); // Voluntarily save to 'clean' any pending body
            this._bodyLastChangedDocumentSaved = true;
        }

        if (p_ap.gnx === utils.leoUriToStr(this._bodyLastChangedDocument.uri)) {
            this._leoFileSystem.preventSaveToLeo = true;
            this._bodyLastChangedDocument.save();
        }
    }
    // * _focusInterrupt insertNode Override
    if (this._focusInterrupt) {
        // this._focusInterrupt = false; // TODO : Test if reverting this in _gotSelection is 'ok'
        w_revealType = RevealType.RevealSelect;
    }
    // * Either the whole tree refreshes, or a single tree node is revealed when just navigating
    if (this._refreshType.tree) {
        this._refreshType.tree = false;
        this._refreshOutline(true, w_revealType);
    } else if (this._refreshType.node &amp;&amp; p_ap) {
        // * Force single node "refresh" by revealing it, instead of "refreshing" it
        this._refreshType.node = false;
        const w_node = this.apToLeoNode(p_ap);
        this.leoStates.setSelectedNodeFlags(w_node);
        this._revealTreeViewNode(w_node, {
            select: true,
            focus: true, // FOCUS FORCED TO TRUE always leave focus on tree when navigating
        });
        if (this._refreshType.body) {
            this._refreshType.body = false;
            this._tryApplyNodeToBody(w_node, false, true); // ! NEEDS STACK AND THROTTLE!
        }
    }
    this.getStates();
}

</t>
<t tx="ekr.20200815085830.5">/**
 * * Handle the selected node that was reached while converting received ap_nodes to LeoNodes
 * @param p_node The selected node that was reached while receiving 'children' from tree view api implementing Leo's outline
 */
private _gotSelection(p_node: LeoNode): void {
    // * Use the 'from outline' concept to decide if focus should be on body or outline after editing a headline
    let w_showBodyKeepFocus: boolean = this._fromOutline; // Will preserve focus where it is without forcing into the body pane if true
    if (this._focusInterrupt) {
        this._focusInterrupt = false; // TODO : Test if reverting this in _gotSelection is 'ok'
        w_showBodyKeepFocus = true;
    }
    this._tryApplyNodeToBody(p_node, false, w_showBodyKeepFocus);
}

</t>
<t tx="ekr.20200815090152.1">/**
 * * Makes sure the body now reflects the selected node.
 * This is called after 'selectTreeNode', or after '_gotSelection' when refreshing.
 * @param p_node Node that was just selected
 * @param p_aside Flag to indicate opening 'Aside' was required
 * @param p_showBodyKeepFocus Flag used to keep focus where it was instead of forcing in body
 * @param p_force_open Flag to force opening the body pane editor
 */
private _tryApplyNodeToBody(
    p_node: LeoNode,
    p_aside: boolean,
    p_showBodyKeepFocus: boolean,
    p_force_open?: boolean
): Thenable&lt;vscode.TextEditor&gt; {
    // console.log('try to apply node -&gt; ', p_node.gnx);

    this.lastSelectedNode = p_node; // Set the 'lastSelectedNode' this will also set the 'marked' node context
    this._commandStack.newSelection(); // Signal that a new selected node was reached and to stop using the received selection as target for next command

    if (this._bodyTextDocument) {
        // if not first time and still opened - also not somewhat exactly opened somewhere.
        if (
            !this._bodyTextDocument.isClosed &amp;&amp;
            !this._locateOpenedBody(p_node.gnx) // LOCATE NEW GNX
        ) {
            // if needs switching by actually having different gnx
            if (utils.leoUriToStr(this.bodyUri) !== p_node.gnx) {
                this._locateOpenedBody(utils.leoUriToStr(this.bodyUri)); // * LOCATE OLD GNX FOR PROPER COLUMN*
                return this._bodyTextDocument.save().then(() =&gt; {
                    return this._switchBody(p_node.gnx, p_aside, p_showBodyKeepFocus);
                });
            }
        }
    } else {
        // first time?
        this.bodyUri = utils.strToLeoUri(p_node.gnx);
    }
    return this.showBody(p_aside, p_showBodyKeepFocus);

    /*
        this._showBodyParams = {
            node: p_node,
            aside: p_aside,
            showBodyKeepFocus: p_showBodyKeepFocus,
            force_open: p_force_open // can be undefined
        };
        // Start it if possible, otherwise the last _showBodyParams will be used again right after
        if (!this._showBodyStarted) {
            this._showBodyStarted = true;
            this._applyNodeToBody(this._showBodyParams)
                .then((p_textEditor: vscode.TextEditor) =&gt; {
                    // finished
                    this._showBodyStarted = false;
                    if (this._showBodyParams) {
                        // New node to show again! Call itself faking params from the specified ones.
                        this._tryApplyNodeToBody(
                            this._showBodyParams.node,
                            this._showBodyParams.aside,
                            this._showBodyParams.showBodyKeepFocus,
                            this._showBodyParams.force_open
                        );
                    }
                });
            // Clear global body params, will get refilled if needed
            this._showBodyParams = undefined;
        }
        */
}

</t>
<t tx="ekr.20200815090400.1">/**
 * * Tries to add a command to the frontend stack, returns true if added, false otherwise
 * @param p_action A string commands for leobridgeserver.py, from Constants.LEOBRIDGE,
 * @param p_node Specific node to pass as parameter, or the selected node if omitted
 * @param p_refresh Specifies to either refresh nothing, the tree or body and tree when finished
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_text Specific string to pass along as parameter with the action, similar to p_node parameter
 * @returns Promise back from commands execution on leoBridgeServer if added, undefined otherwise
 * (see command stack 'rules' in commandStack.ts)
 */
public nodeCommand(p_userCommand: UserCommand): Promise&lt;LeoBridgePackage&gt; | undefined {
    // No forced vscode save-triggers for direct calls from extension.js
    this.triggerBodySave();
    const q_result = this._commandStack.add(p_userCommand);
    if (q_result) {
        return q_result;
    } else {
        // TODO : Use cleanup message string CONSTANT instead
        vscode.window.showInformationMessage(
            Constants.USER_MESSAGES.TOO_FAST + p_userCommand.action
        );
        return undefined;
    }
}

</t>
<t tx="ekr.20200815090517.1">/**
 * * Invoke an '@button' click directly by index string. Used by '@buttons' treeview.
 * @returns the launchRefresh promise started after it's done running the 'atButton' command
 */
public clickAtButton(p_node: LeoButtonNode): Promise&lt;boolean&gt; {
    console.log('click but');

    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {
            return this.sendAction(
                Constants.LEOBRIDGE.CLICK_BUTTON,
                JSON.stringify({ index: p_node.button.index })
            );
        })
        .then((p_clickButtonResult: LeoBridgePackage) =&gt; {
            console.log('back from click but');
            this.launchRefresh(
                { tree: true, body: true, documents: true, buttons: true, states: true },
                false
            );
            return Promise.resolve(true); // TODO launchRefresh should be a returned promise
        });
}

</t>
<t tx="ekr.20200815090517.2">/**
 * * Removes an '@button' from Leo's button dict, directly by index string. Used by '@buttons' treeview.
 * @returns the launchRefresh promise started after it's done removing the button
 */
public removeAtButton(p_node: LeoButtonNode): Promise&lt;boolean&gt; {
    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {
            return this.sendAction(
                Constants.LEOBRIDGE.REMOVE_BUTTON,
                JSON.stringify({ index: p_node.button.index })
            );
        })
        .then((p_removeButtonResult: LeoBridgePackage) =&gt; {
            this.launchRefresh({ buttons: true }, false);
            return Promise.resolve(true); // TODO launchRefresh should be a returned promise
        });
}

</t>
<t tx="ekr.20200815091220.1">/**
 * * Splits the received data into lines and parses output to detect server start event
 * * Otherwise just outputs lines to the terminal Output
 * @param p_data Data object (not pure string)
 */
private _gotTerminalData(p_data: string): void {
    p_data.toString().split("\n").forEach(p_line =&gt; {
        p_line = p_line.trim();
        if (p_line) { // * std out process line by line: json shouldn't have line breaks
            if (p_line.startsWith(Constants.SERVER_STARTED_TOKEN)) {
                if (this._resolvePromise &amp;&amp; !this._isStarted) {
                    this._isStarted = true;
                    this._resolvePromise(p_line); // * Server confirmed started
                }
            }
            this._leoIntegration.addTerminalPaneEntry(p_line); // Output message anyways
        }
    });
}

</t>
<t tx="ekr.20200815091346.1">/**
 * * Object container for parameters of leoIntegration's "apply-selected-node-to-body" method
 */
export interface ShowBodyParam {
    node: LeoNode,
    aside: boolean,
    showBodyKeepFocus: boolean,
    force_open?: boolean
}
</t>
<t tx="ekr.20200815091408.1">/**
 * * Object sent back from leoInteg's 'getStates' command
 */
export interface LeoPackageStates {
    changed: boolean; // Leo document has changed (is dirty)
    canUndo: boolean; // Leo document can undo the last operation done
    canRedo: boolean; // Leo document can redo the last operation 'undone'
    canDemote: boolean; // Currently selected node can have its siblings demoted
    canPromote: boolean; // Currently selected node can have its children promoted
    canDehoist: boolean; // Leo Document is currently hoisted and can be de-hoisted
}

</t>
<t tx="ekr.20200815091619.1">/**
 * * Builds a string hash out of of an archived position, default without taking collapsed state into account
 * @param p_ap Archived position
 * @param p_salt To be added to the hashing process (Change when tree changes)
 */
export function hashNode(p_ap: ArchivedPosition, p_salt: string, p_withCollapse?: boolean): string {
    const w_string1: string = p_ap.headline + p_ap.gnx + p_ap.childIndex.toString(36);
    const w_string2: string = w_string1 + p_ap.childIndex.toString(36) + JSON.stringify(p_ap.stack);
    const w_first: string = murmur.murmur3(w_string2).toString(36);
    if (p_withCollapse) {
        p_salt += p_ap.expanded ? "1" : "0";
    }
    return p_salt + w_string1 + w_first + murmur.murmur3(w_first + w_string2).toString(36);
}

</t>
<t tx="ekr.20200815091945.1">/**
 * * Build all possible strings for buttons icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildButtonsIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON_ADD),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON_ADD)
        }
    ];
}

</t>
<t tx="ekr.20200815113156.1">// * Define entries for all commands
[CMD.MINIBUFFER, () =&gt; w_leo.minibuffer()], // Is referenced in package.json
[CMD.STATUS_BAR, () =&gt; w_leo.statusBarOnClick()],
[CMD.EXECUTE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXECUTE_SCRIPT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],

[CMD.CLICK_BUTTON, (p_node: LeoButtonNode) =&gt; w_leo.clickAtButton(p_node)], // Not referenced in package.json
[CMD.REMOVE_BUTTON, (p_node: LeoButtonNode) =&gt; w_leo.removeAtButton(p_node)],

[CMD.CLOSE_FILE, () =&gt; w_leo.closeLeoFile()],
[CMD.NEW_FILE, () =&gt; w_leo.newLeoFile()],

[CMD.OPEN_FILE, (p_uri?: vscode.Uri) =&gt; w_leo.openLeoFile(p_uri)],
[CMD.IMPORT_ANY_FILE, () =&gt; w_leo.importAnyFile()], // No URL passed from the command definition.

[CMD.CLEAR_RECENT_FILES, () =&gt; w_leo.clearRecentLeoFiles()],
[CMD.RECENT_FILES, () =&gt; w_leo.showRecentLeoFiles()],
[CMD.SAVE_AS_FILE, () =&gt; w_leo.saveAsLeoFile()],
[CMD.SAVE_FILE, () =&gt; w_leo.saveLeoFile()],
// [CMD.SAVE_DISABLED, () =&gt; { }],
[CMD.SAVE_FILE_FO, () =&gt; w_leo.saveLeoFile(true)],
[CMD.SWITCH_FILE, () =&gt; w_leo.switchLeoFile()],

[CMD.SET_OPENED_FILE, (p_index: number) =&gt; w_leo.selectOpenedLeoDocument(p_index)],

[CMD.REFRESH_FROM_DISK, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.REFRESH_FROM_DISK_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: false
})],
[CMD.REFRESH_FROM_DISK_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REFRESH_FROM_DISK_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.REFRESH_FROM_DISK_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REFRESH_FROM_DISK_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.GIT_DIFF, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GIT_DIFF,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],

[CMD.HEADLINE, (p_node: LeoNode) =&gt; w_leo.editHeadline(p_node, true)],
[CMD.HEADLINE_SELECTION, () =&gt; w_leo.editHeadline(U, false)],
[CMD.HEADLINE_SELECTION_FO, () =&gt; w_leo.editHeadline(U, true)],

// cut/copy/paste/delete given node.
[CMD.COPY, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.COPY_PNODE,
    node: p_node,
    refreshType: NO_REFRESH,
    fromOutline: true,
    keepSelection: true
})],
[CMD.CUT, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.CUT_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.DELETE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.PASTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: false
})],
[CMD.PASTE_CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_CLONE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: false
})],

// cut/copy/paste/delete current selection (self.commander.p)
[CMD.COPY_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.COPY_PNODE,
    node: U,
    refreshType: NO_REFRESH,
    fromOutline: false
})],
[CMD.CUT_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CUT_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.CUT_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CUT_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.DELETE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.DELETE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.PASTE_CLONE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.PASTE_CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.PASTE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.PASTE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PASTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.CONTRACT_ALL, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.CONTRACT_ALL_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.CONTRACT_OR_GO_LEFT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CONTRACT_OR_GO_LEFT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.EXPAND_AND_GO_RIGHT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXPAND_AND_GO_RIGHT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.GOTO_NEXT_CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: p_node,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_NEXT_CLONE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: false
})],
[CMD.GOTO_NEXT_CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_CLONE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],

[CMD.GOTO_NEXT_MARKED, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_MARKED,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_FIRST_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_FIRST_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_LAST_SIBLING, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_LAST_SIBLING,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_LAST_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_LAST_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_NEXT_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_NEXT_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.GOTO_PREV_VISIBLE, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.GOTO_PREV_VISIBLE,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],

[CMD.PAGE_UP, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PAGE_UP,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],
[CMD.PAGE_DOWN, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PAGE_DOWN,
    node: U,
    refreshType: REFRESH_NODE_BODY,
    fromOutline: true
})],

[CMD.DEHOIST, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEHOIST,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.DEHOIST_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEHOIST,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.HOIST, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.HOIST_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.HOIST_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.HOIST_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.CLONE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.CLONE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.CLONE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.INSERT, (p_node: LeoNode) =&gt; w_leo.insertNode(p_node, true, false)],
[CMD.INSERT_SELECTION, () =&gt; w_leo.insertNode(U, false, false)],
[CMD.INSERT_SELECTION_FO, () =&gt; w_leo.insertNode(U, true, false)],
[CMD.INSERT_CHILD, (p_node: LeoNode) =&gt; w_leo.insertNode(p_node, true, true)],
[CMD.INSERT_CHILD_SELECTION, () =&gt; w_leo.insertNode(U, false, true)],
[CMD.INSERT_CHILD_SELECTION_FO, () =&gt; w_leo.insertNode(U, true, true)],

// Special command for when inserting rapidly more than one node without
// even specifying a headline label, such as spamming CTRL+I rapidly.
[CMD.INSERT_SELECTION_INTERRUPT, () =&gt; w_leo.insertNode(U, false, false, true)],
[CMD.INSERT_CHILD_SELECTION_INTERRUPT, () =&gt; w_leo.insertNode(U, false, true, true)],

[CMD.MARK, (p_node: LeoNode) =&gt; w_leo.changeMark(true, p_node, true)],
[CMD.MARK_SELECTION, () =&gt; w_leo.changeMark(true, U, false)],
[CMD.MARK_SELECTION_FO, () =&gt; w_leo.changeMark(true, U, true)],

[CMD.UNMARK, (p_node: LeoNode) =&gt; w_leo.changeMark(false, p_node, true)],
[CMD.UNMARK_SELECTION, () =&gt; w_leo.changeMark(false, U, false)],
[CMD.UNMARK_SELECTION_FO, () =&gt; w_leo.changeMark(false, U, true)],

[CMD.EXTRACT, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXTRACT,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.EXTRACT_NAMES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.EXTRACT_NAMES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],

[CMD.MOVE_DOWN, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_DOWN_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_DOWN_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_DOWN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.MOVE_LEFT, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_LEFT_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_LEFT_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_LEFT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.MOVE_RIGHT, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_RIGHT_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_RIGHT_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_RIGHT,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.MOVE_UP, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.MOVE_UP_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.MOVE_UP_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_PNODE_UP,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.DEMOTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.DEMOTE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.DEMOTE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DEMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],
[CMD.PROMOTE, (p_node: LeoNode) =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: p_node,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true,
    keepSelection: true
})],
[CMD.PROMOTE_SELECTION, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false
})],
[CMD.PROMOTE_SELECTION_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.PROMOTE_PNODE,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true
})],

[CMD.SORT_CHILDREN, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_CHILDREN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false,
    keepSelection: true
})],
[CMD.SORT_CHILDREN_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_CHILDREN,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true,
    keepSelection: true
})],
[CMD.SORT_SIBLING, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_SIBLINGS,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: false,
    keepSelection: true
})],
[CMD.SORT_SIBLING_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.SORT_SIBLINGS,
    node: U,
    refreshType: REFRESH_TREE,
    fromOutline: true,
    keepSelection: true
})],

[CMD.REDO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.REDO_DISABLED, () =&gt; { }],
[CMD.REDO_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.REDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.UNDO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: false
})],
[CMD.UNDO_DISABLED, () =&gt; { }],
[CMD.UNDO_FO, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNDO,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.CONNECT, () =&gt; w_leo.connect()],
[CMD.START_SERVER, () =&gt; w_leo.startServer()],
[CMD.CHOOSE_LEO_FOLDER, () =&gt; w_leo.chooseLeoFolder()],

// Called by nodes in tree when selected either by mouse, or with enter
[CMD.SELECT_NODE, (p_node: LeoNode) =&gt; w_leo.selectTreeNode(p_node, false, false)],
[CMD.OPEN_ASIDE, (p_node: LeoNode) =&gt; w_leo.selectTreeNode(p_node, false, true)],

[CMD.SHOW_OUTLINE, () =&gt; w_leo.showOutline(true)], // Also focuses on outline

[CMD.SHOW_LOG, () =&gt; w_leo.showLogPane()],
[CMD.SHOW_BODY, () =&gt; w_leo.showBody(false)], // Also focuses on body

[CMD.SHOW_WELCOME, () =&gt; w_leoSettingsWebview.openWebview()],
[CMD.SHOW_SETTINGS, () =&gt; w_leoSettingsWebview.openWebview()], // Same as SHOW_WELCOME

[CMD.COPY_MARKED, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.COPY_MARKED,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.DIFF_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DIFF_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.MARK_CHANGED_ITEMS, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MARK_CHANGED_ITEMS,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.MARK_SUBHEADS, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MARK_SUBHEADS,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.UNMARK_ALL, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.UNMARK_ALL,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.CLONE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.CLONE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.DELETE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.DELETE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],
[CMD.MOVE_MARKED_NODES, () =&gt; w_leo.nodeCommand({
    action: BRIDGE.MOVE_MARKED_NODES,
    node: U,
    refreshType: REFRESH_TREE_BODY,
    fromOutline: true
})],

[CMD.PREV_NODE, () =&gt; w_leo.prevNextNode(false)],
[CMD.PREV_NODE_FO, () =&gt; w_leo.prevNextNode(false)],
[CMD.NEXT_NODE, () =&gt; w_leo.prevNextNode(true)],
[CMD.NEXT_NODE_FO, () =&gt; w_leo.prevNextNode(true)],

[CMD.START_SEARCH, () =&gt; w_leo.startSearch()],
[CMD.FIND_ALL, () =&gt; w_leo.findAll(false)],
[CMD.FIND_NEXT, () =&gt; w_leo.find(false, false)],
[CMD.FIND_NEXT_FO, () =&gt; w_leo.find(true, false)],
[CMD.FIND_PREVIOUS, () =&gt; w_leo.find(false, true)],
[CMD.FIND_PREVIOUS_FO, () =&gt; w_leo.find(true, true)],
[CMD.FIND_VAR, () =&gt; w_leo.findSymbol(false)],
[CMD.FIND_DEF, () =&gt; w_leo.findSymbol(true)],
[CMD.REPLACE, () =&gt; w_leo.replace(false, false)],
[CMD.REPLACE_FO, () =&gt; w_leo.replace(true, false)],
[CMD.REPLACE_THEN_FIND, () =&gt; w_leo.replace(false, true)],
[CMD.REPLACE_THEN_FIND_FO, () =&gt; w_leo.replace(true, true)],
[CMD.REPLACE_ALL, () =&gt; w_leo.findAll(true)],
[CMD.GOTO_GLOBAL_LINE, () =&gt; w_leo.gotoGlobalLine()],
[CMD.TAG_CHILDREN, () =&gt; w_leo.tagChildren()],

[CMD.CLONE_FIND_ALL, () =&gt; w_leo.cloneFind(false, false)],
[CMD.CLONE_FIND_ALL_FLATTENED, () =&gt; w_leo.cloneFind(false, true)],
[CMD.CLONE_FIND_TAG, () =&gt; w_leo.cloneFindTag()],
[CMD.CLONE_FIND_MARKED, () =&gt; w_leo.cloneFind(true, false)],
[CMD.CLONE_FIND_FLATTENED_MARKED, () =&gt; w_leo.cloneFind(true, true)],

[CMD.SET_FIND_EVERYWHERE_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.ENTIRE_OUTLINE)],
[CMD.SET_FIND_NODE_ONLY_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.NODE_ONLY)],
[CMD.SET_FIND_SUBOUTLINE_ONLY_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.SUBOUTLINE_ONLY)],
[CMD.TOGGLE_FIND_IGNORE_CASE_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.IGNORE_CASE)],
[CMD.TOGGLE_FIND_MARK_CHANGES_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.MARK_CHANGES)],
[CMD.TOGGLE_FIND_MARK_FINDS_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.MARK_FINDS)],
[CMD.TOGGLE_FIND_REGEXP_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.REG_EXP)],
[CMD.TOGGLE_FIND_WORD_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.WHOLE_WORD)],
[CMD.TOGGLE_FIND_SEARCH_BODY_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.SEARCH_BODY)],
[CMD.TOGGLE_FIND_SEARCH_HEADLINE_OPTION, () =&gt; w_leo.setSearchSetting(Constants.FIND_INPUTS_IDS.SEARCH_HEADLINE)],
</t>
<t tx="ekr.20200815113508.1">@language python
g.cls()

def is_significant(p):
    s = p.b
    for ch in '()[]{};':
        s = s.replace(ch, '')
    return s.strip()

for p in c.all_unique_positions():
    if not is_significant(p) and not p.hasChildren():
        print(p.h)
print('done')

</t>
<t tx="ekr.20200815123601.1">@language json
@tabwidth -2
{
  "name": "leointeg",
  "displayName": "Leo Editor Integration with Visual Studio Code",
  "description": "Use Leo, the literate editor with outline, directly in vscode.",
  "version": "0.1.17",
  "author": {
    "name": "Félix"
  },
  "publisher": "boltex",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/boltex/leointeg"
  },
  "engines": {
    "vscode": "^1.58.0"
  },
  "keywords": [
    "leo",
    "literate",
    "editor",
    "outline",
    "programming"
  ],
  "categories": [
    "Other"
  ],
  "activationEvents": [
    "*"
  ],
  "main": "./dist/extension",
  "icon": "resources/leoapp128px.png",
  "galleryBanner": {
    "color": "#fffbdc",
    "theme": "light"
  },
  "contributes": {
    @others
  },
  "scripts": {
    "vscode:prepublish": "webpack --mode production",
    "webpack": "webpack --mode development",
    "webpack-dev": "webpack --mode development --watch",
    "test-compile": "tsc -p ./",
    "lint": "tslint -p ./"
  },
  "devDependencies": {
    "@types/glob": "^7.1.3",
    "@types/mocha": "^7.0.2",
    "@types/node": "^14.11.2",
    "@types/vscode": "^1.58.0",
    "@types/ws": "^7.2.6",
    "clean-webpack-plugin": "^3.0.0",
    "csp-html-webpack-plugin": "^4.0.0",
    "css-loader": "^3.5.3",
    "eslint": "^7.9.0",
    "fork-ts-checker-webpack-plugin": "^4.1.6",
    "glob": "^7.1.6",
    "html-loader": "^1.1.0",
    "html-webpack-exclude-assets-plugin": "0.0.7",
    "html-webpack-plugin": "^3.2.0",
    "imagemin-webpack-plugin": "^2.4.2",
    "mini-css-extract-plugin": "^0.9.0",
    "mocha": "^7.2.0",
    "node-sass": "^4.14.1",
    "sass-loader": "^8.0.2",
    "ts-loader": "^7.0.5",
    "tslint": "^6.1.3",
    "typescript": "^3.9.7",
    "vscode-test": "^1.4.0",
    "webpack": "^4.44.2",
    "webpack-cli": "^3.3.12"
  },
  "dependencies": {
    "@types/debounce": "^1.2.0",
    "@types/murmurhash-js": "^1.0.3",
    "bufferutil": "^4.0.1",
    "debounce": "^1.2.0",
    "hasbin": "^1.2.3",
    "murmurhash-js": "^1.0.0",
    "portfinder": "^1.0.28",
    "tree-kill": "^1.2.2",
    "ws": "^7.3.1"
  }
}
</t>
<t tx="ekr.20200815123601.10">"languages": [
  {
    "id": "leobody.plain",
    "aliases": [
      "Leo Body Plain",
      "leobody"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.plain.language-configuration.json"
  },
  {
    "id": "leobody.python",
    "aliases": [
      "Leo Body Python",
      "leobody.python"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.python.language-configuration.json"
  },
  {
    "id": "leobody.typescript",
    "aliases": [
      "Leo Body Typescript",
      "leobody.typescript"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.typescript.language-configuration.json"
  },
  {
    "id": "leobody.javascript",
    "aliases": [
      "Leo Body Javascript",
      "leobody.javascript"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.javascript.language-configuration.json"
  },
  {
    "id": "leobody.c",
    "aliases": [
      "Leo Body c",
      "leobody.c"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.c.language-configuration.json"
  },
  {
    "id": "leobody.cpp",
    "aliases": [
      "Leo Body C++",
      "leobody.cpp"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.cpp.language-configuration.json"
  },
  {
    "id": "leobody.css",
    "aliases": [
      "Leo Body CSS",
      "leobody.css"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.css.language-configuration.json"
  },
  {
    "id": "leobody.html",
    "aliases": [
      "Leo Body HTML",
      "leobody.html"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.html.language-configuration.json"
  },
  {
    "id": "leobody.java",
    "aliases": [
      "Leo Body Java",
      "leobody.java"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.java.language-configuration.json"
  },
  {
    "id": "leobody.json",
    "aliases": [
      "Leo Body Json",
      "leobody.json"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.json.language-configuration.json"
  },
  {
    "id": "leobody.markdown",
    "aliases": [
      "Leo Body Markdown",
      "leobody.markdown"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.markdown.language-configuration.json"
  },
  {
    "id": "leobody.php",
    "aliases": [
      "Leo Body PHP",
      "leobody.php"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.php.language-configuration.json"
  },
  {
    "id": "leobody.rust",
    "aliases": [
      "Leo Body Rust",
      "leobody.rust"
    ],
    "extensions": [
      ""
    ],
    "configuration": "./language-configurations/leobody.rust.language-configuration.json"
  }
],
</t>
<t tx="ekr.20200815123601.11">"grammars": [
  {
    "language": "leobody.plain",
    "scopeName": "source.leobody.plain",
    "path": "./syntaxes/leobody.plain.tmLanguage.json"
  },
  {
    "language": "leobody.python",
    "scopeName": "source.leobody.python",
    "path": "./syntaxes/leobody.python.tmLanguage.json"
  },
  {
    "language": "leobody.typescript",
    "scopeName": "source.leobody.typescript",
    "path": "./syntaxes/leobody.typescript.tmLanguage.json"
  },
  {
    "language": "leobody.javascript",
    "scopeName": "source.leobody.javascript",
    "path": "./syntaxes/leobody.javascript.tmLanguage.json"
  },
  {
    "language": "leobody.c",
    "scopeName": "source.leobody.c",
    "path": "./syntaxes/leobody.c.tmLanguage.json"
  },
  {
    "language": "leobody.cpp",
    "scopeName": "source.leobody.cpp",
    "path": "./syntaxes/leobody.cpp.tmLanguage.json"
  },
  {
    "language": "leobody.css",
    "scopeName": "source.leobody.css",
    "path": "./syntaxes/leobody.css.tmLanguage.json"
  },
  {
    "language": "leobody.html",
    "scopeName": "source.leobody.html",
    "path": "./syntaxes/leobody.html.tmLanguage.json"
  },
  {
    "language": "leobody.java",
    "scopeName": "source.leobody.java",
    "path": "./syntaxes/leobody.java.tmLanguage.json"
  },
  {
    "language": "leobody.json",
    "scopeName": "source.leobody.json",
    "path": "./syntaxes/leobody.json.tmLanguage.json"
  },
  {
    "language": "leobody.markdown",
    "scopeName": "source.leobody.markdown",
    "path": "./syntaxes/leobody.markdown.tmLanguage.json"
  },
  {
    "language": "leobody.php",
    "scopeName": "source.leobody.php",
    "path": "./syntaxes/leobody.php.tmLanguage.json"
  },
  {
    "language": "leobody.rust",
    "scopeName": "source.leobody.rust",
    "path": "./syntaxes/leobody.rust.tmLanguage.json"
  },
  {
    "//TODO 1": "MAKE PHP/HTML/CSS/JS EMBEDDED FUNCTIONALITY WORK TOO",
    "injectTo": [
      "source.leobody.plain",
      "source.leobody.python",
      "source.leobody.typescript",
      "source.leobody.javascript",
      "source.leobody.c",
      "source.leobody.cpp",
      "source.leobody.css",
      "source.leobody.html",
      "source.leobody.java",
      "source.leobody.json",
      "source.leobody.markdown",
      "source.leobody.php",
      "source.leobody.rust"
    ],
    "path": "./syntaxes/leobody.tmLanguage.json",
    "scopeName": "leo.injection",
    "//TODO 2": "MAKE EMBEDDED LANGUAGE SWITCHES WORK",
    "//tokenTypes": {
      "//meta.embedded.block.leobody.python": "other",
      "//meta.embedded.block.leobody.typescript": "other",
      "//...": "..."
    },
    "//embeddedLanguages": {
      "//meta.embedded.block.leobody.python": "leobody.python",
      "//meta.embedded.block.leobody.typescript": "leobody.typescript",
      "//...": "..."
    }
  }
],
</t>
<t tx="ekr.20200815123601.12">"snippets": [
  {
    "language": "leobody.c",
    "path": "./snippets/c.code-snippets"
  },
  {
    "language": "leobody.cpp",
    "path": "./snippets/cpp.code-snippets"
  },
  {
    "language": "leobody.javascript",
    "path": "./snippets/javascript.code-snippets"
  },
  {
    "language": "leobody.typescript",
    "path": "./snippets/typescript.code-snippets"
  },
  {
    "language": "leobody.java",
    "path": "./snippets/java.code-snippets"
  },
  {
    "language": "leobody.php",
    "path": "./snippets/php.code-snippets"
  },
  {
    "language": "leobody.markdown",
    "path": "./snippets/markdown.code-snippets"
  },
  {
    "language": "leobody.rust",
    "path": "./snippets/rust.code-snippets"
  }
],
</t>
<t tx="ekr.20200815123601.13">"commands": [
  @others
],
</t>
<t tx="ekr.20200815123601.14">{
  "command": "leointeg.test",
  "category": "Leo",
  "title": "Test Leo Integration"
},
</t>
<t tx="ekr.20200815123601.15">{
  "command": "leointeg.showSettingsPage",
  "title": "LeoInteg Settings",
  "category": "Leo",
  "icon": {
    "light": "resources/light/gear.svg",
    "dark": "resources/dark/gear.svg"
  }
},
{
  "command": "leointeg.showWelcomePage",
  "title": "Welcome",
  "category": "Leo"
},
</t>
<t tx="ekr.20200815123601.16">{
  "command": "leointeg.chooseLeoFolder",
  "title": "Choose Leo Installation Folder",
  "category": "Leo"
},
{
  "command": "leointeg.startServer",
  "category": "Leo",
  "title": "Start Leo Bridge Server"
},
{
  "command": "leointeg.connectToServer",
  "title": "Connect to Leo Bridge Server",
  "category": "Leo",
  "icon": {
    "light": "resources/light/connect.svg",
    "dark": "resources/dark/connect.svg"
  }
},
</t>
<t tx="ekr.20200815123601.17">{
  "command": "leointeg.executeScript",
  "title": "Execute Script",
  "category": "Leo",
  "icon": {
    "light": "resources/light/execute.svg",
    "dark": "resources/dark/execute.svg"
  }
},
{
  "command": "leointeg.statusBar",
  "category": "Leo",
  "title": "Statusbar Click"
},
{
  "command": "leointeg.minibuffer",
  "category": "Leo",
  "title": "Minibuffer"
},
{
  "command": "leointeg.removeButton",
  "category": "Leo",
  "title": "Remove Button"
},
</t>
<t tx="ekr.20200815123601.18">{
  "command": "leointeg.showBody",
  "category": "Leo",
  "title": "Focus on Body"
},
{
  "command": "leointeg.showOutline",
  "category": "Leo",
  "title": "Focus on Tree"
},
{
  "command": "leointeg.showLogPane",
  "category": "Leo",
  "title": "Show Log Pane"
},
</t>
<t tx="ekr.20200815123601.19">{
  "command": "leointeg.openLeoFile",
  "title": "Open Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/folder.svg",
    "dark": "resources/dark/folder.svg"
  }
},
{
  "command": "leointeg.importAnyFile",
  "title": "Import File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/import.svg",
    "dark": "resources/dark/import.svg"
  }
},
{
  "command": "leointeg.clearRecentFiles",
  "category": "Leo",
  "title": "Clear Recent Files",
  "icon": {
    "light": "resources/light/clear-files.svg",
    "dark": "resources/dark/clear-files.svg"
  }
},
{
  "command": "leointeg.recentLeoFiles",
  "category": "Leo",
  "title": "Recent Files"
},
{
  "command": "leointeg.switchLeoFile",
  "title": "Switch Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/switch.svg",
    "dark": "resources/dark/switch.svg"
  }
},
{
  "command": "leointeg.newLeoFile",
  "title": "New Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/new-file.svg",
    "dark": "resources/dark/new-file.svg"
  }
},
{
  "command": "leointeg.closeLeoFile",
  "title": "Close Leo File",
  "category": "Leo",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leointeg.saveLeoFile",
  "category": "Leo",
  "title": "Save Leo File",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leointeg.saveLeoFileFromOutline",
  "category": "Leo",
  "title": "Save Leo File",
  "icon": {
    "light": "resources/light/save.svg",
    "dark": "resources/dark/save.svg"
  }
},
{
  "command": "leointeg.saveAsLeoFile",
  "category": "Leo",
  "title": "Save Leo File as...",
  "icon": {
    "light": "resources/light/save-as.svg",
    "dark": "resources/dark/save-as.svg"
  }
},
{
  "command": "leointeg.refreshFromDisk",
  "category": "Leo",
  "title": "Refresh from Disk",
  "icon": {
    "light": "resources/light/refresh.svg",
    "dark": "resources/dark/refresh.svg"
  }
},
{
  "command": "leointeg.refreshFromDiskSelection",
  "category": "Leo",
  "title": "Refresh from Disk",
  "icon": {
    "light": "resources/light/refresh.svg",
    "dark": "resources/dark/refresh.svg"
  }
},
{
  "command": "leointeg.refreshFromDiskSelectionFromOutline",
  "category": "Leo",
  "title": "Refresh from Disk",
  "icon": {
    "light": "resources/light/refresh.svg",
    "dark": "resources/dark/refresh.svg"
  }
},
{
  "command": "leointeg.gitDiff",
  "category": "Leo",
  "title": "Git Diff"
},
</t>
<t tx="ekr.20200815123601.2">"configuration": {
  "title": "Leo Integration",
  "properties": {
    @others
  }
},
</t>
<t tx="ekr.20200815123601.20">{
  "command": "leointeg.selectTreeNode",
  "category": "Leo",
  "title": "Select Node"
},
{
  "command": "leointeg.openAside",
  "category": "Leo",
  "title": "Open to the Side"
},
{
  "command": "leointeg.contractAll",
  "category": "Leo",
  "title": "Contract All",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
{
  "command": "leointeg.contractAllFromOutline",
  "category": "Leo",
  "title": "Contract All",
  "icon": {
    "light": "resources/light/collapse.svg",
    "dark": "resources/dark/collapse.svg"
  }
},
{
  "command": "leointeg.prev",
  "category": "Leo",
  "title": "Prev",
  "icon": {
    "light": "resources/light/prev.svg",
    "dark": "resources/dark/prev.svg"
  }
},
{
  "command": "leointeg.prevFromOutline",
  "category": "Leo",
  "title": "Prev",
  "icon": {
    "light": "resources/light/prev.svg",
    "dark": "resources/dark/prev.svg"
  }
},
{
  "command": "leointeg.next",
  "category": "Leo",
  "title": "Next",
  "icon": {
    "light": "resources/light/next.svg",
    "dark": "resources/dark/next.svg"
  }
},
{
  "command": "leointeg.nextFromOutline",
  "category": "Leo",
  "title": "Next",
  "icon": {
    "light": "resources/light/next.svg",
    "dark": "resources/dark/next.svg"
  }
},
</t>
<t tx="ekr.20200815123601.21">{
  "command": "leointeg.editHeadline",
  "category": "Leo",
  "title": "Edit Headline",
  "icon": {
    "light": "resources/light/edit.svg",
    "dark": "resources/dark/edit.svg"
  }
},
{
  "command": "leointeg.editSelectedHeadline",
  "category": "Leo",
  "title": "Edit Headline"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "category": "Leo",
  "title": "Edit Headline"
},
{
  "command": "leointeg.copyNode",
  "category": "Leo",
  "title": "Copy Node",
  "icon": {
    "light": "resources/light/clipboard.svg",
    "dark": "resources/dark/clipboard.svg"
  }
},
{
  "command": "leointeg.copyNodeSelection",
  "category": "Leo",
  "title": "Copy Node",
  "icon": {
    "light": "resources/light/clipboard.svg",
    "dark": "resources/dark/clipboard.svg"
  }
},
{
  "command": "leointeg.cutNode",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.cutNodeSelection",
  "category": "Leo",
  "title": "Cut Node",
  "icon": {
    "light": "resources/light/cut.svg",
    "dark": "resources/dark/cut.svg"
  }
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Cut Node"
},
{
  "command": "leointeg.pasteNode",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "category": "Leo",
  "title": "Paste Node",
  "icon": {
    "light": "resources/light/paste.svg",
    "dark": "resources/dark/paste.svg"
  }
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "category": "Leo",
  "title": "Paste Node"
},
{
  "command": "leointeg.pasteNodeAsClone",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelection",
  "category": "Leo",
  "title": "Paste Node as Clone",
  "icon": {
    "light": "resources/light/paste-clone.svg",
    "dark": "resources/dark/paste-clone.svg"
  }
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
  "category": "Leo",
  "title": "Paste Node as Clone"
},
{
  "command": "leointeg.delete",
  "category": "Leo",
  "title": "Delete",
  "icon": {
    "light": "resources/light/close.svg",
    "dark": "resources/dark/close.svg"
  }
},
{
  "command": "leointeg.deleteSelection",
  "category": "Leo",
  "title": "Delete Node",
  "icon": {
    "light": "resources/light/delete.svg",
    "dark": "resources/dark/delete.svg"
  }
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "category": "Leo",
  "title": "Delete Node"
},
</t>
<t tx="ekr.20200815123601.22">{
  "command": "leointeg.moveOutlineDown",
  "category": "Leo",
  "title": "Move Outline Down",
  "icon": {
    "light": "resources/light/arrow-down.svg",
    "dark": "resources/dark/arrow-down.svg"
  }
},
{
  "command": "leointeg.moveOutlineDownSelection",
  "category": "Leo",
  "title": "Move Outline Down"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Down"
},
{
  "command": "leointeg.moveOutlineLeft",
  "category": "Leo",
  "title": "Move Outline Left",
  "icon": {
    "light": "resources/light/arrow-left.svg",
    "dark": "resources/dark/arrow-left.svg"
  }
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "category": "Leo",
  "title": "Move Outline Left"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Left"
},
{
  "command": "leointeg.moveOutlineRight",
  "category": "Leo",
  "title": "Move Outline Right",
  "icon": {
    "light": "resources/light/arrow-right.svg",
    "dark": "resources/dark/arrow-right.svg"
  }
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "category": "Leo",
  "title": "Move Outline Right"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Right"
},
{
  "command": "leointeg.moveOutlineUp",
  "category": "Leo",
  "title": "Move Outline Up",
  "icon": {
    "light": "resources/light/arrow-up.svg",
    "dark": "resources/dark/arrow-up.svg"
  }
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "category": "Leo",
  "title": "Move Outline Up"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "category": "Leo",
  "title": "Move Outline Up"
},
</t>
<t tx="ekr.20200815123601.23">{
  "command": "leointeg.insertNode",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/plus.svg",
    "dark": "resources/dark/plus.svg"
  }
},
{
  "command": "leointeg.insertChildNode",
  "category": "Leo",
  "title": "Insert Child",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leointeg.insertNodeSelection",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/insert.svg",
    "dark": "resources/dark/insert.svg"
  }
},
{
  "command": "leointeg.insertChildNodeSelection",
  "category": "Leo",
  "title": "Insert Child",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/insert.svg",
    "dark": "resources/dark/insert.svg"
  }
},
{
  "command": "leointeg.insertChildNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Insert Child",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "category": "Leo",
  "title": "Insert Node",
  "icon": {
    "light": "resources/light/insert.svg",
    "dark": "resources/dark/insert.svg"
  }
},
{
  "command": "leointeg.insertChildNodeSelectionInterrupt",
  "category": "Leo",
  "title": "Insert Child",
  "icon": {
    "light": "resources/light/insert-child.svg",
    "dark": "resources/dark/insert-child.svg"
  }
},
{
  "command": "leointeg.cloneNode",
  "category": "Leo",
  "title": "Clone Node",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leointeg.cloneNodeSelection",
  "category": "Leo",
  "title": "Clone Node",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "category": "Leo",
  "title": "Clone Node",
  "icon": {
    "light": "resources/light/link.svg",
    "dark": "resources/dark/link.svg"
  }
},
{
  "command": "leointeg.promote",
  "category": "Leo",
  "title": "Promote Children",
  "icon": {
    "light": "resources/light/promote.svg",
    "dark": "resources/dark/promote.svg"
  }
},
{
  "command": "leointeg.promoteSelection",
  "category": "Leo",
  "title": "Promote Children",
  "icon": {
    "light": "resources/light/promote.svg",
    "dark": "resources/dark/promote.svg"
  }
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "category": "Leo",
  "title": "Promote Children",
  "icon": {
    "light": "resources/light/promote.svg",
    "dark": "resources/dark/promote.svg"
  }
},
{
  "command": "leointeg.demote",
  "category": "Leo",
  "title": "Demote Siblings",
  "icon": {
    "light": "resources/light/demote.svg",
    "dark": "resources/dark/demote.svg"
  }
},
{
  "command": "leointeg.demoteSelection",
  "category": "Leo",
  "title": "Demote Siblings",
  "icon": {
    "light": "resources/light/demote.svg",
    "dark": "resources/dark/demote.svg"
  }
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "category": "Leo",
  "title": "Demote Siblings",
  "icon": {
    "light": "resources/light/demote.svg",
    "dark": "resources/dark/demote.svg"
  }
},
{
  "command": "leointeg.sortChildrenSelection",
  "category": "Leo",
  "title": "Sort Children"
},
{
  "command": "leointeg.sortChildrenSelectionFromOutline",
  "category": "Leo",
  "title": "Sort Children"
},
{
  "command": "leointeg.sortSiblingsSelection",
  "category": "Leo",
  "title": "Sort Siblings",
  "icon": {
    "light": "resources/light/sort.svg",
    "dark": "resources/dark/sort.svg"
  }
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "category": "Leo",
  "title": "Sort Siblings",
  "icon": {
    "light": "resources/light/sort.svg",
    "dark": "resources/dark/sort.svg"
  }
},
</t>
<t tx="ekr.20200815123601.24">{
  "command": "leointeg.gotoFirstVisible",
  "category": "Leo",
  "title": "Goto First Visible"
},
{
  "command": "leointeg.gotoLastVisible",
  "category": "Leo",
  "title": "Goto Last Visible"
},
{
  "command": "leointeg.pageUp",
  "category": "Leo",
  "title": "Page Up"
},
{
  "command": "leointeg.pageDown",
  "category": "Leo",
  "title": "Page Down"
},
{
  "command": "leointeg.gotoLastSibling",
  "category": "Leo",
  "title": "Goto Last Sibling"
},
{
  "command": "leointeg.gotoNextVisible",
  "category": "Leo",
  "title": "Goto Next Visible"
},
{
  "command": "leointeg.gotoPrevVisible",
  "category": "Leo",
  "title": "Goto Prev Visible"
},
{
  "command": "leointeg.contractOrGoLeft",
  "category": "Leo",
  "title": "Contract Or Go Left"
},
{
  "command": "leointeg.expandAndGoRight",
  "category": "Leo",
  "title": "Expand And Go Right"
},
{
  "command": "leointeg.gotoNextMarked",
  "category": "Leo",
  "title": "Goto Next Marked"
},
{
  "command": "leointeg.gotoNextClone",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "category": "Leo",
  "title": "Goto Next Clone"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "category": "Leo",
  "title": "Goto Next Clone"
},
</t>
<t tx="ekr.20200815123601.25">{
  "command": "leointeg.hoistNode",
  "category": "Leo",
  "title": "Hoist",
  "icon": {
    "light": "resources/light/hoist.svg",
    "dark": "resources/dark/hoist.svg"
  }
},
{
  "command": "leointeg.hoistSelection",
  "category": "Leo",
  "title": "Hoist",
  "icon": {
    "light": "resources/light/hoist.svg",
    "dark": "resources/dark/hoist.svg"
  }
},
{
  "command": "leointeg.hoistSelectionFromOutline",
  "category": "Leo",
  "title": "Hoist",
  "icon": {
    "light": "resources/light/hoist.svg",
    "dark": "resources/dark/hoist.svg"
  }
},
{
  "command": "leointeg.deHoist",
  "category": "Leo",
  "title": "De-Hoist",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
{
  "command": "leointeg.deHoistFromOutline",
  "category": "Leo",
  "title": "De-Hoist",
  "icon": {
    "light": "resources/light/dehoist.svg",
    "dark": "resources/dark/dehoist.svg"
  }
},
</t>
<t tx="ekr.20200815123601.26">{
  "command": "leointeg.undo",
  "category": "Leo",
  "title": "Undo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leointeg.undoDisabled",
  "category": "Leo",
  "title": "Can't Undo",
  "icon": {
    "light": "resources/light/undo-disabled.svg",
    "dark": "resources/dark/undo-disabled.svg"
  }
},
{
  "command": "leointeg.undoFromOutline",
  "category": "Leo",
  "title": "Undo",
  "icon": {
    "light": "resources/light/undo.svg",
    "dark": "resources/dark/undo.svg"
  }
},
{
  "command": "leointeg.redo",
  "category": "Leo",
  "title": "Redo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
{
  "command": "leointeg.redoDisabled",
  "category": "Leo",
  "title": "Can't Redo",
  "icon": {
    "light": "resources/light/redo-disabled.svg",
    "dark": "resources/dark/redo-disabled.svg"
  }
},
{
  "command": "leointeg.redoFromOutline",
  "category": "Leo",
  "title": "Redo",
  "icon": {
    "light": "resources/light/redo.svg",
    "dark": "resources/dark/redo.svg"
  }
},
</t>
<t tx="ekr.20200815123601.28">"viewsWelcome": [
  @others
],
</t>
<t tx="ekr.20200815123601.29"></t>
<t tx="ekr.20200815123601.3">"leoIntegration.checkForChangeExternalFiles": {
  "scope": "application",
  "default": "none",
  "type": "string",
  "description": "Set default for checking changes to external files",
  "enum": [
    "none",
    "force-check",
    "force-ignore"
  ],
  "enumDescriptions": [
    "Default from Leo's config",
    "Check for changes",
    "Ignore all changes"
  ]
},
"leoIntegration.defaultReloadIgnore": {
  "scope": "application",
  "default": "none",
  "type": "string",
  "description": "Set default for derived files to always reload, or always ignore, when changes are detected",
  "enum": [
    "none",
    "yes-all",
    "no-all"
  ],
  "enumDescriptions": [
    "Choose each time",
    "Reload All",
    "Ignore All"
  ]
},
</t>
<t tx="ekr.20200815123601.30">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nStart a local server\n[Start Server](command:leointeg.startServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nStart a local server\n[Start Server](command:leointeg.startServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="ekr.20200815123601.31">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="ekr.20200815123601.32">{
  "view": "leoIntegration",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Not Connected\n[Connect to Server](command:leointeg.connectToServer)\nServer startup and connection can be automated in LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "!leoBridgeReady &amp;&amp; leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
},
</t>
<t tx="ekr.20200815123601.33">{
  "view": "leoIntegration",
  "contents": "Connecting...",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; connectToServerAutomatically"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "Connecting...",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; connectToServerAutomatically"
},
</t>
<t tx="ekr.20200815123601.34">{
  "view": "leoIntegration",
  "contents": "leoBridge Connected\n[Open Leo File](command:leointeg.openLeoFile)\nView LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoIntegrationExplorer",
  "contents": "leoBridge Connected\n[Open Leo File](command:leointeg.openLeoFile)\nView LeoInteg's [configuration settings](command:leointeg.showSettingsPage)",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.35"></t>
<t tx="ekr.20200815123601.36">{
  "view": "leoDocuments",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
{
  "view": "leoDocumentsExplorer",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
</t>
<t tx="ekr.20200815123601.37">{
  "view": "leoDocuments",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoDocumentsExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.38"></t>
<t tx="ekr.20200815123601.39">{
  "view": "leoButtons",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
{
  "view": "leoButtonsExplorer",
  "contents": "Not connected",
  "when": "!leoBridgeReady"
},
</t>
<t tx="ekr.20200815123601.4">"leoIntegration.leoTreeBrowse": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Specifies whether to use Leo's style of tree browsing with the arrow keys"
},
"leoIntegration.treeKeepFocus": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Specifies whether to keep focus in the outline when selecting a node - overridden by \"leoTreeBrowse\""
},
"leoIntegration.treeKeepFocusWhenAside": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Specifies whether to keep focus in the outline when opening a body pane on the side"
},
</t>
<t tx="ekr.20200815123601.40">{
  "view": "leoButtons",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
{
  "view": "leoButtonsExplorer",
  "contents": "There are no Leo files currently opened",
  "when": "leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.41">{
  "view": "leoButtons",
  "contents": "There are no @buttons in this outline",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "view": "leoButtonsExplorer",
  "contents": "There are no @buttons in this outline",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.42">"menus": {
  @others
},
</t>
<t tx="ekr.20200815123601.43">"commandPalette": [
  @others
],
</t>
<t tx="ekr.20200815123601.44">{
  "command": "leointeg.startServer",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened &amp;&amp; !leoServerStarted"
},
{
  "command": "leointeg.connectToServer",
  "when": "!leoBridgeReady &amp;&amp; !leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.45">{
  "command": "leointeg.executeScript",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.minibuffer",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.46">{
  "command": "leointeg.showLogPane",
  "when": "leoBridgeReady"
},
</t>
<t tx="ekr.20200815123601.47">{
  "command": "leointeg.openLeoFile",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.importAnyFile",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "command": "leointeg.recentLeoFiles",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.switchLeoFile",
  "when": "leoBridgeReady &amp;&amp; leoTreeOpened"
},
{
  "command": "leointeg.newLeoFile",
  "when": "leoBridgeReady"
},
{
  "command": "leointeg.closeLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.saveLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.saveAsLeoFile",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.refreshFromDiskSelection",
  "when": "leoTreeOpened &amp;&amp; leoAtFile"
},
{
  "command": "leointeg.gitDiff",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.48">{
  "command": "leointeg.contractAll",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.49">{
  "command": "leointeg.editSelectedHeadline",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markSelection",
  "when": "leoTreeOpened &amp;&amp; !leoMarked"
},
{
  "command": "leointeg.unmarkSelection",
  "when": "leoTreeOpened &amp;&amp; leoMarked"
},
{
  "command": "leointeg.copyNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cutNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.deleteSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.5">"leoIntegration.statusBarString": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Sets the message string of the Status Bar Indicator"
},
"leoIntegration.statusBarColor": {
  "scope": "application",
  "default": "fb7c47",
  "type": "string",
  "description": "Specifies the hexadecimal color string for the Status Bar Indicator"
},
</t>
<t tx="ekr.20200815123601.50">{
  "command": "leointeg.moveOutlineDownSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.51">{
  "command": "leointeg.insertNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneNodeSelection",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.promoteSelection",
  "when": "leoTreeOpened &amp;&amp; leoCanPromote"
},
{
  "command": "leointeg.demoteSelection",
  "when": "leoTreeOpened &amp;&amp; leoCanDemote"
},
{
  "command": "leointeg.sortChildrenSelection",
  "when": "leoTreeOpened &amp;&amp; leoChild"
},
{
  "command": "leointeg.sortSiblingsSelection",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.52">{
  "command": "leointeg.gotoNextMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "when": "leoTreeOpened &amp;&amp; leoCloned"
},
</t>
<t tx="ekr.20200815123601.53">{
  "command": "leointeg.hoistSelection",
  "when": "leoTreeOpened &amp;&amp; !leoRoot"
},
{
  "command": "leointeg.deHoist",
  "when": "leoTreeOpened &amp;&amp; leoCanDehoist"
},
</t>
<t tx="ekr.20200815123601.54">{
  "command": "leointeg.undo",
  "when": "leoTreeOpened &amp;&amp; leoCanUndo"
},
{
  "command": "leointeg.redo",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.56"></t>
<t tx="ekr.20200815123601.57">{
  "command": "leointeg.test",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.58">{
  "command": "leointeg.removeButton",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.59">{
  "command": "leointeg.showBody",
  "when": "false"
},
{
  "command": "leointeg.showOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.6">"leoIntegration.treeInExplorer": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Show the outline tree in the explorer view"
},
"leoIntegration.showOpenAside": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Offer 'Open to the Side' in nodes context menu"
},
"leoIntegration.showEditOnNodes": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Edit Headline' button on tree nodes"
},
"leoIntegration.showArrowsOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Move Node' arrow buttons on tree nodes"
},
"leoIntegration.showAddOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Insert' button on tree nodes"
},
"leoIntegration.showMarkOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Mark/Unmark' buttons on tree nodes"
},
"leoIntegration.showCloneOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Clone' button on tree nodes"
},
"leoIntegration.showCopyOnNodes": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Shows 'Copy' button on tree nodes"
},
"leoIntegration.invertNodeContrast": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Inverts the contrast of the dirty/clean border aspect of tree nodes"
},
</t>
<t tx="ekr.20200815123601.60">{
  "command": "leointeg.saveLeoFileFromOutline",
  "when": "false"
},
{
  "command": "leointeg.refreshFromDisk",
  "when": "false"
},
{
  "command": "leointeg.refreshFromDiskSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.61">{
  "command": "leointeg.selectTreeNode",
  "when": "false"
},
{
  "command": "leointeg.openAside",
  "when": "false"
},
{
  "command": "leointeg.contractAllFromOutline",
  "when": "false"
},
{
  "command": "leointeg.prevFromOutline",
  "when": "false"
},
{
  "command": "leointeg.nextFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.62">{
  "command": "leointeg.editHeadline",
  "when": "false"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "when": "false"
},
{
  "command": "leointeg.mark",
  "when": "false"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.unmark",
  "when": "false"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.copyNode",
  "when": "false"
},
{
  "command": "leointeg.cutNode",
  "when": "false"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.pasteNode",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAsClone",
  "when": "false"
},
{
  "command": "leointeg.pasteNodeAsCloneAtSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.delete",
  "when": "false"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.63">{
  "command": "leointeg.moveOutlineDown",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineLeft",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineRight",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineUp",
  "when": "false"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.64">{
  "command": "leointeg.insertNode",
  "when": "false"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "when": "false"
},
{
  "command": "leointeg.cloneNode",
  "when": "false"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.promote",
  "when": "false"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.demote",
  "when": "false"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.sortChildrenSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.65">{
  "command": "leointeg.gotoNextClone",
  "when": "false"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.gotoFirstVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoLastVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoLastSibling",
  "when": "false"
},
{
  "command": "leointeg.gotoNextVisible",
  "when": "false"
},
{
  "command": "leointeg.gotoPrevVisible",
  "when": "false"
},
{
  "command": "leointeg.contractOrGoLeft",
  "when": "false"
},
{
  "command": "leointeg.expandAndGoRight",
  "when": "false"
},
{
  "command": "leointeg.pageUp",
  "when": "false"
},
{
  "command": "leointeg.pageDown",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.66">{
  "command": "leointeg.hoistNode",
  "when": "false"
},
{
  "command": "leointeg.hoistSelectionFromOutline",
  "when": "false"
},
{
  "command": "leointeg.deHoistFromOutline",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.67">{
  "command": "leointeg.undoFromOutline",
  "when": "false"
},
{
  "command": "leointeg.redoFromOutline",
  "when": "false"
},
{
  "command": "leointeg.undoDisabled",
  "when": "false"
},
{
  "command": "leointeg.redoDisabled",
  "when": "false"
},
</t>
<t tx="ekr.20200815123601.68">"explorer/context": [
  {
    "command": "leointeg.openLeoFile",
    "when": "resourceScheme == file &amp;&amp; resourceExtname == .leo",
    "group": "navigation@1"
  }
],
</t>
<t tx="ekr.20200815123601.7">"leoIntegration.leoEditorPath": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Specifies the location of your Leo-Editor installation"
},
"leoIntegration.leoPythonCommand": {
  "scope": "application",
  "default": "",
  "type": "string",
  "description": "Specifies the command to start python (Defaults to 'py' on windows and 'python3' otherwise)"
},
"leoIntegration.startServerAutomatically": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Starts a LeoBridge server automatically, by running the Leo server script"
},
"leoIntegration.connectToServerAutomatically": {
  "scope": "application",
  "default": false,
  "type": "boolean",
  "description": "Connect automatically to a Leo server on specified 'Connection Port' upon activation of this extension"
},
"leoIntegration.connectionAddress": {
  "default": "localhost",
  "scope": "application",
  "type": "string",
  "description": "Connection host"
},
"leoIntegration.connectionPort": {
  "default": 32125,
  "scope": "application",
  "minimum": 0,
  "maximum": 65535,
  "type": "number",
  "description": "Connection port"
}
</t>
<t tx="ekr.20200815123601.76">"keybindings": [
  @others
],
</t>
<t tx="ekr.20200815123601.77">{
  "command": "leointeg.executeScript",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.executeScript",
  "key": "ctrl+b",
  "mac": "cmd+b",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.minibuffer",
  "key": "alt+x",
  "when": "leoTreeOpened"
},
</t>
<t tx="ekr.20200815123601.78">{
  "command": "leointeg.showOutline",
  "key": "alt+t",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.showOutline",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.showBody",
  "key": "ctrl+t",
  "mac": "cmd+t",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.showBody",
  "key": "alt+d",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.showBody",
  "key": "ctrl+g",
  "mac": "cmd+g",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.showBody",
  "key": "tab",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.showBody",
  "key": "enter",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.79">{
  "command": "leointeg.saveLeoFileFromOutline",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.saveLeoFile",
  "key": "ctrl+s",
  "mac": "cmd+s",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
</t>
<t tx="ekr.20200815123601.8">"viewsContainers": {
  "activitybar": [
    {
      "id": "leoIntegrationView",
      "title": "Leo",
      "icon": "resources/icon.svg"
    }
  ]
},
</t>
<t tx="ekr.20200815123601.80">{
  "command": "leointeg.contractAll",
  "key": "alt+-",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.contractAllFromOutline",
  "key": "alt+-",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
</t>
<t tx="ekr.20200815123601.81">{
  "command": "leointeg.editSelectedHeadline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.editSelectedHeadlineFromOutline",
  "key": "ctrl+h",
  "mac": "cmd+h",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.markSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.markSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; !leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.unmarkSelection",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "key": "ctrl+m",
  "mac": "cmd+m",
  "when": "leoTreeOpened &amp;&amp; leoMarked &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.82"></t>
<t tx="ekr.20200815123601.83">{
  "command": "leointeg.moveOutlineDownSelection",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineDownSelection",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "ctrl+d",
  "mac": "cmd+d",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "shift+down",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineDownSelectionFromOutline",
  "key": "shift+alt+down",
  "mac": "shift+alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.84">{
  "command": "leointeg.moveOutlineLeftSelection",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineLeftSelection",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "ctrl+l",
  "mac": "cmd+l",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "shift+left",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineLeftSelectionFromOutline",
  "key": "shift+alt+left",
  "mac": "shift+alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.85">{
  "command": "leointeg.moveOutlineRightSelection",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineRightSelection",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "ctrl+r",
  "mac": "cmd+r",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "shift+right",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineRightSelectionFromOutline",
  "key": "shift+alt+right",
  "mac": "shift+alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.86">{
  "command": "leointeg.moveOutlineUpSelection",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineUpSelection",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "ctrl+u",
  "mac": "cmd+u",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "shift+up",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.moveOutlineUpSelectionFromOutline",
  "key": "shift+alt+up",
  "mac": "shift+alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.87">{
  "command": "leointeg.sortSiblingsSelection",
  "key": "alt+a",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.sortSiblingsSelectionFromOutline",
  "key": "alt+a",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.promoteSelection",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.promoteSelectionFromOutline",
  "key": "ctrl+[BracketLeft]",
  "win": "ctrl+oem_4",
  "linux": "ctrl+[",
  "mac": "cmd+[BracketLeft]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.demoteSelection",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.demoteSelectionFromOutline",
  "key": "ctrl+[BracketRight]",
  "win": "ctrl+oem_6",
  "linux": "ctrl+]",
  "mac": "cmd+[BracketRight]",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelection",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "key": "ctrl+i",
  "mac": "cmd+i",
  "when": "leoTreeOpened &amp;&amp; !sideBarFocus &amp;&amp; !editorTextFocus"
},
{
  "command": "leointeg.insertNodeSelection",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelectionFromOutline",
  "key": "insert",
  "mac": "insert",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.insertNodeSelectionInterrupt",
  "key": "shift+insert",
  "mac": "shift+insert",
  "when": "leoTreeOpened &amp;&amp; !sideBarFocus &amp;&amp; !editorTextFocus"
},
{
  "command": "leointeg.insertChildNodeSelection",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.insertChildNodeSelectionFromOutline",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.insertChildNodeSelectionInterrupt",
  "key": "ctrl+insert",
  "mac": "cmd+insert",
  "when": "leoTreeOpened &amp;&amp; !sideBarFocus &amp;&amp; !editorTextFocus"
},
{
  "command": "leointeg.cloneNodeSelection",
  "key": "ctrl+`",
  "win": "ctrl+oem_3",
  "linux": "ctrl+`",
  "mac": "cmd+`",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.cloneNodeSelectionFromOutline",
  "key": "ctrl+`",
  "win": "ctrl+oem_3",
  "linux": "ctrl+`",
  "mac": "cmd+`",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.cutNodeSelection",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.cutNodeSelectionFromOutline",
  "key": "ctrl+shift+x",
  "mac": "cmd+shift+x",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.copyNodeSelection",
  "key": "ctrl+shift+c",
  "mac": "cmd+shift+c",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.pasteNodeAtSelection",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.pasteNodeAtSelectionFromOutline",
  "key": "ctrl+shift+v",
  "mac": "cmd+shift+v",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.deleteSelection",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "key": "ctrl+shift+backspace",
  "mac": "cmd+shift+backspace",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.deleteSelectionFromOutline",
  "key": "delete",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
</t>
<t tx="ekr.20200815123601.88">{
  "command": "leointeg.gotoFirstVisible",
  "key": "alt+home",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoLastSibling",
  "key": "alt+end",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoFirstVisible",
  "key": "home",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoLastVisible",
  "key": "end",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.pageUp",
  "key": "pageup",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.pageDown",
  "key": "pagedown",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextCloneSelectionFromOutline",
  "key": "alt+n",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextCloneSelection",
  "key": "alt+n",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "down",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "alt+down",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.gotoNextVisible",
  "key": "alt+down",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "up",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "alt+up",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.gotoPrevVisible",
  "key": "alt+up",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection  &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "left",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "alt+left",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.contractOrGoLeft",
  "key": "alt+left",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "right",
  "when": "leoTreeBrowse &amp;&amp; leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration/"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "alt+right",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /leoIntegration|leoDocuments|leoButtons/"
},
{
  "command": "leointeg.expandAndGoRight",
  "key": "alt+right",
  "when": "leoTreeOpened &amp;&amp; !editorHasSelection &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
</t>
<t tx="ekr.20200815123601.89">"resourceLabelFormatters": [
  {
    "scheme": "leo",
    "formatting": {
      "label": "LEO: BODY",
      "separator": "/",
      "workspaceSuffix": ""
    }
  }
]
</t>
<t tx="ekr.20200815123601.9">"views": {
  "explorer": [
    {
      "id": "leoIntegrationExplorer",
      "name": "Leo Integration",
      "contextualTitle": "Leo",
      "when": "treeInExplorer",
      "visibility": "visible"
    },
    {
      "id": "leoDocumentsExplorer",
      "name": "Leo Documents",
      "contextualTitle": "Leo",
      "when": "treeInExplorer &amp;&amp; leoTreeOpened",
      "visibility": "collapsed"
    },
    {
      "id": "leoButtonsExplorer",
      "name": "Leo Buttons",
      "contextualTitle": "Leo",
      "when": "treeInExplorer &amp;&amp; leoTreeOpened",
      "visibility": "collapsed"
    },
    {
      "type": "webview",
      "id": "leoFindPanelExplorer",
      "contextualTitle": "Leo",
      "name": "Leo Find",
      "title": "Leo Find",
      "when": "treeInExplorer &amp;&amp; leoTreeOpened",
      "visibility": "collapsed"
    }
  ],
  "leoIntegrationView": [
    {
      "id": "leoIntegration",
      "contextualTitle": "Leo",
      "name": "Integration",
      "visibility": "visible"
    },
    {
      "id": "leoDocuments",
      "contextualTitle": "Leo",
      "name": "Documents",
      "visibility": "collapsed"
    },
    {
      "id": "leoButtons",
      "contextualTitle": "Leo",
      "name": "Buttons",
      "visibility": "collapsed"
    },
    {
      "type": "webview",
      "contextualTitle": "Leo",
      "id": "leoFindPanel",
      "name": "Find",
      "title": "Find",
      "when": "leoTreeOpened",
      "visibility": "collapsed"
    }
  ]
},
</t>
<t tx="felix.20200718020912.1">import * as vscode from "vscode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718020912.10">/**
 * * Actions that can be invoked by Leo through leobridge
 */
public static ASYNC_ACTIONS = {
    ASYNC_LOG: "log",
    ASYNC_REFRESH: "refresh",
    ASYNC_ASK: "ask",
    ASYNC_WARN: "warn",
    ASYNC_INFO: "info",
    ASYNC_INTERVAL: "interval"
};

</t>
<t tx="felix.20200718020912.11">/**
 * * When async action was ASYNC_INFO
 */
public static ASYNC_INFO_MESSAGE_CODES = {
    ASYNC_REFRESHED: "refreshed",
    ASYNC_IGNORED: "ignored"
};

</t>
<t tx="felix.20200718020912.12">/**
 * * runAskYesNoDialog or runAskOkDialog result codes, used when async action requires a response
 */
public static ASYNC_ASK_RETURN_CODES = {
    YES: "yes",
    NO: "no",
    YES_ALL: "yes-all",
    NO_ALL: "no-all",
    OK: "ok"
};

</t>
<t tx="felix.20200718020912.13">/**
 * * Commands for leobridgeserver.py
 */
public static LEOBRIDGE = {
    TEST: "!test",
    // * Server Commands
    GET_COMMANDS: "!get_all_leo_commands", // "getCommands",
    APPLY_CONFIG: "!set_config", // "applyConfig",
    ASK_RESULT: "!set_ask_result", // "askResult",
    // * GUI
    GET_ALL_GNX: "!get_all_gnx", // "getAllGnx",
    GET_BODY_LENGTH: "!get_body_length", // "getBodyLength",
    GET_BODY_STATES: "!get_body_states", // "getBodyStates",
    GET_BODY: "!get_body", // "getBody",
    GET_PARENT: "!get_parent", // "getParent",
    GET_CHILDREN: "!get_children", // "getChildren",
    SET_SELECTED_NODE: "!set_current_position", // "setSelectedNode",
    SET_BODY: "!set_body", // "setBody",
    SET_SELECTION: "!set_selection", // "setSelection",
    SET_HEADLINE: "!set_headline", // "setNewHeadline",
    EXPAND_NODE: "!expand_node", // "expandNode",
    COLLAPSE_NODE: "!contract_node", // "collapseNode",
    CONTRACT_ALL: "contractAllHeadlines", // * Direct Leo Command
    GET_STATES: "!get_ui_states", // "getStates",
    // * Leo Documents
    GET_OPENED_FILES: "!get_all_open_commanders", //"getOpenedFiles",
    SET_OPENED_FILE: "!set_opened_file", // "setOpenedFile",
    OPEN_FILE: "!open_file", // "openFile",
    IMPORT_ANY_FILE: "!import_any_file", // "importAnyFile",
    OPEN_FILES: "!open_files", //  "openFiles",
    CLOSE_FILE: "!close_file", // "closeFile",
    SAVE_FILE: "!save_file", // "saveFile",
    // * @-Buttons
    GET_BUTTONS: "!get_buttons", // "getButtons",
    REMOVE_BUTTON: "!remove_button", // "removeButton",
    CLICK_BUTTON: "!click_button", // "clickButton",
    // * Goto operations
    PAGE_UP: "!page_up", // "pageUp",
    PAGE_DOWN: "!page_down", // "pageDown",
    GOTO_FIRST_VISIBLE: "goToFirstVisibleNode", // * Direct Leo Command
    GOTO_LAST_VISIBLE: "goToLastVisibleNode", // * Direct Leo Command
    GOTO_LAST_SIBLING: "goToLastSibling", // * Direct Leo Command
    GOTO_NEXT_VISIBLE: "selectVisNext", // * Direct Leo Command
    GOTO_PREV_VISIBLE: "selectVisBack", // * Direct Leo Command
    GOTO_NEXT_MARKED: "goToNextMarkedHeadline", // * Direct Leo Command
    GOTO_NEXT_CLONE: "goToNextClone", // * Direct Leo Command
    CONTRACT_OR_GO_LEFT: "contractNodeOrGoToParent", // * Direct Leo Command
    EXPAND_AND_GO_RIGHT: "expandNodeAndGoToFirstChild", // * Direct Leo Command
    // * Leo Operations
    MARK_PNODE: "!mark_node", // "markPNode",
    UNMARK_PNODE: "!unmark_node", // "unmarkPNode",
    COPY_PNODE: "copyOutline", // * Direct Leo Command
    CUT_PNODE: "!cut_node", // "cutPNode",
    PASTE_PNODE: "pasteOutline", // * Direct Leo Command
    PASTE_CLONE_PNODE: "pasteOutlineRetainingClones", // * Direct Leo Command
    DELETE_PNODE: "!delete_node", // "deletePNode",
    MOVE_PNODE_DOWN: "moveOutlineDown", // * Direct Leo Command
    MOVE_PNODE_LEFT: "moveOutlineLeft", // * Direct Leo Command
    MOVE_PNODE_RIGHT: "moveOutlineRight", // * Direct Leo Command
    MOVE_PNODE_UP: "moveOutlineUp", // * Direct Leo Command
    INSERT_PNODE: "!insert_node", // "insertPNode",
    INSERT_NAMED_PNODE: "!insert_named_node", // "insertNamedPNode",
    INSERT_CHILD_PNODE: "!insert_child_node",
    INSERT_CHILD_NAMED_PNODE: "!insert_child_named_node",
    CLONE_PNODE: "!clone_node", // "clonePNode",
    PROMOTE_PNODE: "promote", // * Direct Leo Command
    DEMOTE_PNODE: "demote", // * Direct Leo Command
    REFRESH_FROM_DISK_PNODE: "refreshFromDisk", // * Direct Leo Command
    SORT_CHILDREN: "sortChildren", // * Direct Leo Command
    SORT_SIBLINGS: "sortSiblings", // * Direct Leo Command
    UNDO: "!undo",
    REDO: "!redo",
    EXECUTE_SCRIPT: "executeScript", // * Direct Leo Command
    HOIST_PNODE: "hoist", // * Direct Leo Command
    DEHOIST: "dehoist", // * Direct Leo Command
    EXTRACT: "extract", // * Direct Leo Command
    EXTRACT_NAMES: "extractSectionNames", // * Direct Leo Command
    COPY_MARKED: "copyMarked", // * Direct Leo Command
    DIFF_MARKED_NODES: "deleteMarked", // * Direct Leo Command
    MARK_CHANGED_ITEMS: "markChangedHeadlines", // * Direct Leo Command
    MARK_SUBHEADS: "markSubheads", // * Direct Leo Command
    UNMARK_ALL: "unmarkAll", // * Direct Leo Command
    CLONE_MARKED_NODES: "cloneMarked", // * Direct Leo Command
    DELETE_MARKED_NODES: "deleteMarked", // * Direct Leo Command
    MOVE_MARKED_NODES: "moveMarked", // * Direct Leo Command
    GIT_DIFF: "gitDiff", // * Direct Leo Command
    GET_FOCUS: "!get_focus",
    GET_SEARCH_SETTINGS: "!get_search_settings",
    SET_SEARCH_SETTINGS: "!set_search_settings",
    START_SEARCH: "!start_search",
    FIND_ALL: "!find_all",
    FIND_NEXT: "!find_next",
    FIND_PREVIOUS: "!find_previous",
    FIND_VAR: "!find_var",
    FIND_DEF: "!find_def",
    REPLACE: "!replace",
    REPLACE_THEN_FIND: "!replace_then_find",
    REPLACE_ALL: "!replace_all",
    GOTO_GLOBAL_LINE: "!goto_global_line",
    TAG_CHILDREN: "!tag_children",
    CLONE_FIND_TAG: "!clone_find_tag",
    CLONE_FIND_ALL: "!clone_find_all",
    CLONE_FIND_ALL_FLATTENED: "!clone_find_all_flattened",
    CLONE_FIND_MARKED: "!clone_find_all_marked",
    CLONE_FIND_FLATTENED_MARKED: "!clone_find_all_flattened_marked",
    GOTO_PREV_HISTORY: "goToPrevHistory", // * Direct Leo Command
    GOTO_NEXT_HISTORY: "goToNextHistory" // * Direct Leo Command
};

</t>
<t tx="felix.20200718020912.15">/**
 * * All commands this expansion exposes (in package.json, contributes &gt; commands)
 */
public static COMMANDS = {
    // * Access to the Settings/Welcome Webview
    SHOW_WELCOME: Constants.NAME + ".showWelcomePage", // Always available: not in the commandPalette section of package.json
    SHOW_SETTINGS: Constants.NAME + ".showSettingsPage", // Always available: not in the commandPalette section of package.json
    STATUS_BAR: Constants.NAME + ".statusBar", // Status Bar Click Command
    // * LeoBridge
    CHOOSE_LEO_FOLDER: Constants.NAME + ".chooseLeoFolder",
    START_SERVER: Constants.NAME + ".startServer",
    CONNECT: Constants.NAME + ".connectToServer",
    SET_OPENED_FILE: Constants.NAME + ".setOpenedFile",
    OPEN_FILE: Constants.NAME + ".openLeoFile", // sets focus on BODY
    CLEAR_RECENT_FILES: Constants.NAME + ".clearRecentFiles",
    IMPORT_ANY_FILE: Constants.NAME + ".importAnyFile",
    RECENT_FILES: Constants.NAME + ".recentLeoFiles", // shows recent Leo files, opens one on selection
    SWITCH_FILE: Constants.NAME + ".switchLeoFile",
    NEW_FILE: Constants.NAME + ".newLeoFile",
    SAVE_FILE: Constants.NAME + ".saveLeoFile",
    // SAVE_DISABLED: Constants.NAME + ".saveLeoFileDisabled", // Disabled - nop
    SAVE_FILE_FO: Constants.NAME + ".saveLeoFileFromOutline",
    SAVE_AS_FILE: Constants.NAME + ".saveAsLeoFile",
    CLOSE_FILE: Constants.NAME + ".closeLeoFile",
    CLICK_BUTTON: Constants.NAME + ".clickButton",
    REMOVE_BUTTON: Constants.NAME + ".removeButton",
    MINIBUFFER: Constants.NAME + ".minibuffer",
    GIT_DIFF: Constants.NAME + ".gitDiff", // TODO : Test &amp; Fix this Proof of concept leoCommand
    // * Outline selection
    SELECT_NODE: Constants.NAME + ".selectTreeNode",
    OPEN_ASIDE: Constants.NAME + ".openAside",
    // * Goto operations that always finish with focus in outline
    PAGE_UP: Constants.NAME + ".pageUp",
    PAGE_DOWN: Constants.NAME + ".pageDown",
    GOTO_FIRST_VISIBLE: Constants.NAME + ".gotoFirstVisible",
    GOTO_LAST_VISIBLE: Constants.NAME + ".gotoLastVisible",
    GOTO_LAST_SIBLING: Constants.NAME + ".gotoLastSibling",
    GOTO_NEXT_VISIBLE: Constants.NAME + ".gotoNextVisible",
    GOTO_PREV_VISIBLE: Constants.NAME + ".gotoPrevVisible",
    GOTO_NEXT_MARKED: Constants.NAME + ".gotoNextMarked",
    GOTO_NEXT_CLONE: Constants.NAME + ".gotoNextClone",
    GOTO_NEXT_CLONE_SELECTION: Constants.NAME + ".gotoNextCloneSelection",
    GOTO_NEXT_CLONE_SELECTION_FO: Constants.NAME + ".gotoNextCloneSelectionFromOutline",
    CONTRACT_OR_GO_LEFT: Constants.NAME + ".contractOrGoLeft",
    EXPAND_AND_GO_RIGHT: Constants.NAME + ".expandAndGoRight",
    // * Leo Operations
    UNDO: Constants.NAME + ".undo", // From command Palette
    UNDO_FO: Constants.NAME + ".undoFromOutline", // from button, return focus on OUTLINE
    UNDO_DISABLED: Constants.NAME + ".undoDisabled", // Disabled - nop
    REDO: Constants.NAME + ".redo", // From command Palette
    REDO_FO: Constants.NAME + ".redoFromOutline", // from button, return focus on OUTLINE
    REDO_DISABLED: Constants.NAME + ".redoDisabled", // Disabled - nop
    EXECUTE: Constants.NAME + ".executeScript",
    SHOW_BODY: Constants.NAME + ".showBody",
    SHOW_OUTLINE: Constants.NAME + ".showOutline",
    SHOW_LOG: Constants.NAME + ".showLogPane",
    SORT_CHILDREN: Constants.NAME + ".sortChildrenSelection",
    SORT_CHILDREN_FO: Constants.NAME + ".sortChildrenSelectionFromOutline",
    SORT_SIBLING: Constants.NAME + ".sortSiblingsSelection",
    SORT_SIBLING_FO: Constants.NAME + ".sortSiblingsSelectionFromOutline",
    CONTRACT_ALL: Constants.NAME + ".contractAll", // From command Palette
    CONTRACT_ALL_FO: Constants.NAME + ".contractAllFromOutline", // from button, return focus on OUTLINE
    PREV_NODE: Constants.NAME + ".prev",
    PREV_NODE_FO: Constants.NAME + ".prevFromOutline",
    NEXT_NODE: Constants.NAME + ".next",
    NEXT_NODE_FO: Constants.NAME + ".nextFromOutline",
    // * Commands from tree panel buttons or context: focus on OUTLINE
    MARK: Constants.NAME + ".mark",
    UNMARK: Constants.NAME + ".unmark",
    COPY: Constants.NAME + ".copyNode",
    CUT: Constants.NAME + ".cutNode",
    PASTE: Constants.NAME + ".pasteNode",
    PASTE_CLONE: Constants.NAME + ".pasteNodeAsClone",
    DELETE: Constants.NAME + ".delete",
    HEADLINE: Constants.NAME + ".editHeadline",
    MOVE_DOWN: Constants.NAME + ".moveOutlineDown",
    MOVE_LEFT: Constants.NAME + ".moveOutlineLeft",
    MOVE_RIGHT: Constants.NAME + ".moveOutlineRight",
    MOVE_UP: Constants.NAME + ".moveOutlineUp",
    INSERT: Constants.NAME + ".insertNode",
    INSERT_CHILD: Constants.NAME + ".insertChildNode",
    CLONE: Constants.NAME + ".cloneNode",
    PROMOTE: Constants.NAME + ".promote",
    DEMOTE: Constants.NAME + ".demote",
    REFRESH_FROM_DISK: Constants.NAME + ".refreshFromDisk",
    // * Commands from keyboard, while focus on BODY (command-palette returns to BODY for now)
    MARK_SELECTION: Constants.NAME + ".markSelection",
    UNMARK_SELECTION: Constants.NAME + ".unmarkSelection",
    COPY_SELECTION: Constants.NAME + ".copyNodeSelection", // Nothing to refresh/focus so no "FO" version
    CUT_SELECTION: Constants.NAME + ".cutNodeSelection",
    PASTE_SELECTION: Constants.NAME + ".pasteNodeAtSelection",
    PASTE_CLONE_SELECTION: Constants.NAME + ".pasteNodeAsCloneAtSelection",
    DELETE_SELECTION: Constants.NAME + ".deleteSelection",
    HEADLINE_SELECTION: Constants.NAME + ".editSelectedHeadline",
    MOVE_DOWN_SELECTION: Constants.NAME + ".moveOutlineDownSelection",
    MOVE_LEFT_SELECTION: Constants.NAME + ".moveOutlineLeftSelection",
    MOVE_RIGHT_SELECTION: Constants.NAME + ".moveOutlineRightSelection",
    MOVE_UP_SELECTION: Constants.NAME + ".moveOutlineUpSelection",

    INSERT_SELECTION: Constants.NAME + ".insertNodeSelection", // Can be interrupted
    INSERT_SELECTION_INTERRUPT: Constants.NAME + ".insertNodeSelectionInterrupt", // Interrupted version

    INSERT_CHILD_SELECTION: Constants.NAME + ".insertChildNodeSelection", // Can be interrupted
    INSERT_CHILD_SELECTION_INTERRUPT: Constants.NAME + ".insertChildNodeSelectionInterrupt", // Can be interrupted

    CLONE_SELECTION: Constants.NAME + ".cloneNodeSelection",
    PROMOTE_SELECTION: Constants.NAME + ".promoteSelection",
    DEMOTE_SELECTION: Constants.NAME + ".demoteSelection",
    REFRESH_FROM_DISK_SELECTION: Constants.NAME + ".refreshFromDiskSelection",
    // * Commands from keyboard, while focus on OUTLINE
    MARK_SELECTION_FO: Constants.NAME + ".markSelectionFromOutline",
    UNMARK_SELECTION_FO: Constants.NAME + ".unmarkSelectionFromOutline",
    // COPY_SELECTION Nothing to refresh/focus for "copy a node" so no "FO" version
    CUT_SELECTION_FO: Constants.NAME + ".cutNodeSelectionFromOutline",
    PASTE_SELECTION_FO: Constants.NAME + ".pasteNodeAtSelectionFromOutline",
    PASTE_CLONE_SELECTION_FO: Constants.NAME + ".pasteNodeAsCloneAtSelectionFromOutline",
    DELETE_SELECTION_FO: Constants.NAME + ".deleteSelectionFromOutline",
    HEADLINE_SELECTION_FO: Constants.NAME + ".editSelectedHeadlineFromOutline",
    MOVE_DOWN_SELECTION_FO: Constants.NAME + ".moveOutlineDownSelectionFromOutline",
    MOVE_LEFT_SELECTION_FO: Constants.NAME + ".moveOutlineLeftSelectionFromOutline",
    MOVE_RIGHT_SELECTION_FO: Constants.NAME + ".moveOutlineRightSelectionFromOutline",
    MOVE_UP_SELECTION_FO: Constants.NAME + ".moveOutlineUpSelectionFromOutline",
    INSERT_SELECTION_FO: Constants.NAME + ".insertNodeSelectionFromOutline",
    INSERT_CHILD_SELECTION_FO: Constants.NAME + ".insertChildNodeSelectionFromOutline",
    CLONE_SELECTION_FO: Constants.NAME + ".cloneNodeSelectionFromOutline",
    PROMOTE_SELECTION_FO: Constants.NAME + ".promoteSelectionFromOutline",
    DEMOTE_SELECTION_FO: Constants.NAME + ".demoteSelectionFromOutline",
    REFRESH_FROM_DISK_SELECTION_FO: Constants.NAME + ".refreshFromDiskSelectionFromOutline",
    HOIST: Constants.NAME + ".hoistNode",
    HOIST_SELECTION: Constants.NAME + ".hoistSelection",
    HOIST_SELECTION_FO: Constants.NAME + ".hoistSelectionFromOutline",
    DEHOIST: Constants.NAME + ".deHoist",
    DEHOIST_FO: Constants.NAME + ".deHoistFromOutline",
    EXTRACT: Constants.NAME + ".extract",
    EXTRACT_NAMES: Constants.NAME + ".extractNames",
    COPY_MARKED: Constants.NAME + ".copyMarked",
    DIFF_MARKED_NODES: Constants.NAME + ".diffMarkedNodes",
    MARK_CHANGED_ITEMS: Constants.NAME + ".markChangedItems",
    MARK_SUBHEADS: Constants.NAME + ".markSubheads",
    UNMARK_ALL: Constants.NAME + ".unmarkAll",
    CLONE_MARKED_NODES: Constants.NAME + ".cloneMarkedNodes",
    DELETE_MARKED_NODES: Constants.NAME + ".deleteMarkedNodes",
    MOVE_MARKED_NODES: Constants.NAME + ".moveMarkedNodes",
    START_SEARCH: Constants.NAME + ".startSearch",
    FIND_ALL: Constants.NAME + ".findAll",
    FIND_NEXT: Constants.NAME + ".findNext",
    FIND_NEXT_FO: Constants.NAME + ".findNextFromOutline",
    FIND_PREVIOUS: Constants.NAME + ".findPrevious",
    FIND_PREVIOUS_FO: Constants.NAME + ".findPreviousFromOutline",
    FIND_VAR: Constants.NAME + ".findVar",
    FIND_DEF: Constants.NAME + ".findDef",
    REPLACE: Constants.NAME + ".replace",
    REPLACE_FO: Constants.NAME + ".replaceFromOutline",
    REPLACE_THEN_FIND: Constants.NAME + ".replaceThenFind",
    REPLACE_THEN_FIND_FO: Constants.NAME + ".replaceThenFindFromOutline",
    REPLACE_ALL: Constants.NAME + ".replaceAll",
    CLONE_FIND_ALL: Constants.NAME + ".cloneFindAll",
    CLONE_FIND_ALL_FLATTENED: Constants.NAME + ".cloneFindAllFlattened",
    CLONE_FIND_TAG: Constants.NAME + ".cloneFindTag",
    CLONE_FIND_MARKED: Constants.NAME + ".cloneFindMarked",
    CLONE_FIND_FLATTENED_MARKED: Constants.NAME + ".cloneFindFlattenedMarked",
    GOTO_GLOBAL_LINE: Constants.NAME + ".gotoGlobalLine",
    TAG_CHILDREN: Constants.NAME + ".tagChildren",
    SET_FIND_EVERYWHERE_OPTION: Constants.NAME + ".setFindEverywhereOption",
    SET_FIND_NODE_ONLY_OPTION: Constants.NAME + ".setFindNodeOnlyOption",
    SET_FIND_SUBOUTLINE_ONLY_OPTION: Constants.NAME + ".setFindSuboutlineOnlyOption",
    TOGGLE_FIND_IGNORE_CASE_OPTION: Constants.NAME + ".toggleFindIgnoreCaseOption",
    TOGGLE_FIND_MARK_CHANGES_OPTION: Constants.NAME + ".toggleFindMarkChangesOption",
    TOGGLE_FIND_MARK_FINDS_OPTION: Constants.NAME + ".toggleFindMarkFindsOption",
    TOGGLE_FIND_REGEXP_OPTION: Constants.NAME + ".toggleFindRegexpOption",
    TOGGLE_FIND_WORD_OPTION: Constants.NAME + ".toggleFindWordOption",
    TOGGLE_FIND_SEARCH_BODY_OPTION: Constants.NAME + ".toggleFindSearchBodyOption",
    TOGGLE_FIND_SEARCH_HEADLINE_OPTION: Constants.NAME + ".toggleFindSearchHeadlineOption",
};

</t>
<t tx="felix.20200718020912.2">/**
 * * Text and numeric constants used throughout leoInteg
 */
export class Constants {

    @others
}
</t>
<t tx="felix.20200718020912.3">public static PUBLISHER: string = "boltex";
public static NAME: string = "leointeg";
public static CONFIG_NAME: string = "leoIntegration";
public static CONFIG_WORKBENCH_ENABLED_PREVIEW: string = "workbench.editor.enablePreview";
public static CONFIG_REFRESH_MATCH: string = "OnNodes"; // substring to distinguish 'on-hover' icon commands

public static TREEVIEW_ID: string = Constants.CONFIG_NAME;
public static TREEVIEW_EXPLORER_ID: string = Constants.CONFIG_NAME + "Explorer";

public static DOCUMENTS_ID: string = "leoDocuments";
public static DOCUMENTS_EXPLORER_ID: string = "leoDocumentsExplorer";

public static BUTTONS_ID: string = "leoButtons";
public static BUTTONS_EXPLORER_ID: string = "leoButtonsExplorer";

public static FIND_ID: string = "leoFindPanel";
public static FIND_EXPLORER_ID: string = "leoFindPanelExplorer";

public static VERSION_STATE_KEY: string = "leoIntegVersion";

public static FILE_EXTENSION: string = "leo";
public static URI_LEO_SCHEME: string = "leo";
public static URI_FILE_SCHEME: string = "file";
public static URI_SCHEME_HEADER: string = "leo:/";
public static FILE_OPEN_FILTER_MESSAGE: string = "Leo Files";
public static UNTITLED_FILE_NAME: string = "untitled";
public static RECENT_FILES_KEY: string = "leoRecentFiles";
public static LAST_FILES_KEY: string = "leoLastFiles";

public static DEFAULT_PYTHON: string = "python3";
public static WIN32_PYTHON: string = "py";
public static OLD_SERVER_NAME: string = "/leobridgeserver.py";
public static SERVER_NAME: string = "/leoserver.py";
public static SERVER_STARTED_TOKEN: string = "LeoBridge started";
public static TCPIP_DEFAULT_PROTOCOL: string = "ws://";

public static ERROR_PACKAGE_ID: number = 0;
public static STARTING_PACKAGE_ID: number = 1;
public static STATUSBAR_DEBOUNCE_DELAY: number = 60;
public static DOCUMENTS_DEBOUNCE_DELAY: number = 80;
public static BUTTONS_DEBOUNCE_DELAY: number = 80;
public static REFRESH_ALL_DEBOUNCE_DELAY: number = 333;
public static STATES_DEBOUNCE_DELAY: number = 100;

</t>
<t tx="felix.20200718020912.5">/**
 * * Strings used in the workbench interface panels (not for messages or dialogs)
 */
public static GUI = {
    ICON_LIGHT_DOCUMENT: "resources/light/document.svg",
    ICON_DARK_DOCUMENT: "resources/dark/document.svg",
    ICON_LIGHT_DOCUMENT_DIRTY: "resources/light/document-dirty.svg",
    ICON_DARK_DOCUMENT_DIRTY: "resources/dark/document-dirty.svg",
    ICON_LIGHT_BUTTON: "resources/light/button.svg",
    ICON_DARK_BUTTON: "resources/dark/button.svg",
    ICON_LIGHT_BUTTON_ADD: "resources/light/button-add.svg",
    ICON_DARK_BUTTON_ADD: "resources/dark/button-add.svg",
    ICON_LIGHT_PATH: "resources/light/box",
    ICON_DARK_PATH: "resources/dark/box",
    ICON_FILE_EXT: ".svg",
    STATUSBAR_INDICATOR: "$(keyboard) ",
    QUICK_OPEN_LEO_COMMANDS: "&gt;leo: ",
    EXPLORER_TREEVIEW_PREFIX: "LEO ",
    TREEVIEW_TITLE: "OUTLINE",
    TREEVIEW_TITLE_NOT_CONNECTED: "NOT CONNECTED",
    TREEVIEW_TITLE_CONNECTED: "CONNECTED",
    TREEVIEW_TITLE_INTEGRATION: "INTEGRATION",
    BODY_TITLE: "LEO BODY",
    LOG_PANE_TITLE: "Leo Log Window",
    TERMINAL_PANE_TITLE: "LeoBridge Server",
    THEME_STATUSBAR: "statusBar.foreground"
};

</t>
<t tx="felix.20200718020912.6">/**
 * * Basic user messages strings for messages and dialogs
 */
public static USER_MESSAGES = {
    SCRIPT_BUTTON: "Creates a button from selected node",
    SCRIPT_BUTTON_TOOLTIP:
        "Creates a new button with the presently selected node.\n" +
        "For example, to run a script on any part of an outline:\n" +
        "\n" +
        "1.  Select the node containing a script. e.g. \"g.es(p.h)\"\n" +
        "2.  Press 'Script Button' to create a new button.\n" +
        "3.  Select another node on which to run the script.\n" +
        "4.  Press the *new* button.",
    SAVE_CHANGES: "Save changes to",
    BEFORE_CLOSING: "before closing?",
    CANCEL: "Cancel",
    OPEN_WITH_LEOINTEG: "Open this Leo file with LeoInteg?",
    OPEN_RECENT_FILE: "Open Recent Leo File",
    RIGHT_CLICK_TO_OPEN: "Right-click Leo files to open with LeoInteg",
    FILE_ALREADY_OPENED: "Leo file already opened",
    CHOOSE_OPENED_FILE: "Select an opened Leo File",
    FILE_NOT_OPENED: "No files opened.",
    STATUSBAR_TOOLTIP_ON: "Leo Key Bindings are in effect", // TODO : Add description of what happens if clicked
    STATUSBAR_TOOLTIP_OFF: "Leo Key Bindings off", // TODO : Add description of what happens if clicked
    PROMPT_EDIT_HEADLINE: "Edit Headline",
    PROMPT_INSERT_NODE: "Insert Node",
    DEFAULT_HEADLINE: "New Headline",
    TITLE_GOTO_GLOBAL_LINE: "Goto global line",
    PLACEHOLDER_GOTO_GLOBAL_LINE: "#",
    PROMPT_GOTO_GLOBAL_LINE: "Line number",
    TITLE_TAG_CHILDREN: "Tag Children",
    PLACEHOLDER_TAG_CHILDREN: "&lt;tag&gt;",
    PROMPT_TAG_CHILDREN: "Enter a tag name",
    TITLE_FIND_TAG: "Find Tag",
    PLACEHOLDER_CLONE_FIND_TAG: "&lt;tag&gt;",
    PROMPT_CLONE_FIND_TAG: "Enter a tag name",
    START_SERVER_ERROR: "Error - Cannot start server: ",
    CONNECT_FAILED: "Leo Bridge Connection Failed",
    CONNECT_ERROR: "Leo Bridge Connection Error: Incorrect id",
    CONNECTED: "Connected",
    ALREADY_CONNECTED: "Already connected",
    DISCONNECTED: "Disconnected",
    CLEARED_RECENT: "Cleared recent files list",
    CLOSE_ERROR: "Cannot close: No files opened.",
    LEO_PATH_MISSING: "Leo Editor Path Setting Missing",
    CANNOT_FIND_SERVER_SCRIPT: "Cannot find server script",
    YES: "Yes",
    NO: "No",
    YES_ALL: "Yes to all",
    NO_ALL: "No to all",
    MINIBUFFER_PROMPT: "Minibuffer Full Command",
    CHANGES_DETECTED: "Changes to external files were detected.",
    REFRESHED: " Nodes refreshed.", // with voluntary leading space
    IGNORED: " They were ignored.", // with voluntary leading space
    TOO_FAST: "leoInteg is busy! " // with voluntary trailing space
};

</t>
<t tx="felix.20200718020912.7">/**
 * * Choices offered when about to lose current changes to a Leo Document
 */
public static ASK_SAVE_CHANGES_BUTTONS: vscode.MessageItem[] = [
    {
        title: Constants.USER_MESSAGES.YES,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.NO,
        isCloseAffordance: false
    },
    {
        title: Constants.USER_MESSAGES.CANCEL,
        isCloseAffordance: true
    }
];

</t>
<t tx="felix.20200718020912.8">/**
 * * String for JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public static CONFIG_NAMES = {
    CHECK_FOR_CHANGE_EXTERNAL_FILES: "checkForChangeExternalFiles",
    DEFAULT_RELOAD_IGNORE: "defaultReloadIgnore",
    LEO_TREE_BROWSE: "leoTreeBrowse",
    TREE_KEEP_FOCUS: "treeKeepFocus",
    TREE_KEEP_FOCUS_WHEN_ASIDE: "treeKeepFocusWhenAside",
    STATUSBAR_STRING: "statusBarString",
    STATUSBAR_COLOR: "statusBarColor",
    TREE_IN_EXPLORER: "treeInExplorer",
    SHOW_OPEN_ASIDE: "showOpenAside",
    SHOW_EDIT: "showEditOnNodes",
    SHOW_ARROWS: "showArrowsOnNodes",
    SHOW_ADD: "showAddOnNodes",
    SHOW_MARK: "showMarkOnNodes",
    SHOW_CLONE: "showCloneOnNodes",
    SHOW_COPY: "showCopyOnNodes",

    SHOW_EDITION_BODY: "showEditionOnBody",
    SHOW_CLIPBOARD_BODY: "showClipboardOnBody",
    SHOW_PROMOTE_BODY: "showPromoteOnBody",
    SHOW_EXECUTE_BODY: "showExecuteOnBody",
    SHOW_EXTRACT_BODY: "showExtractOnBody",
    SHOW_IMPORT_BODY: "showImportOnBody",
    SHOW_REFRESH_BODY: "showRefreshOnBody",
    SHOW_HOIST_BODY: "showHoistOnBody",
    SHOW_MARK_BODY: "showMarkOnBody",
    SHOW_SORT_BODY: "showSortOnBody",

    INVERT_NODES: "invertNodeContrast",
    LEO_EDITOR_PATH: "leoEditorPath",
    LEO_PYTHON_COMMAND: "leoPythonCommand",
    AUTO_START_SERVER: "startServerAutomatically",
    AUTO_CONNECT: "connectToServerAutomatically",
    IP_ADDRESS: "connectionAddress",
    IP_PORT: "connectionPort",
};

</t>
<t tx="felix.20200718020912.9">/**
 * * Used in 'when' clauses, set with vscode.commands.executeCommand("setContext",...)
 */
public static CONTEXT_FLAGS = {
    // Main flags for connection and opened file
    BRIDGE_READY: "leoBridgeReady", // Connected to leoBridge
    TREE_OPENED: "leoTreeOpened", // At least one Leo file opened
    TREE_TITLED: "leoTreeTitled", // Tree is a Leo file and not a new untitled document
    SERVER_STARTED: "leoServerStarted", // Auto-start or manually started
    // 'states' flags for currently opened tree view
    LEO_CHANGED: "leoChanged",
    LEO_CAN_UNDO: "leoCanUndo",
    LEO_CAN_REDO: "leoCanRedo",
    LEO_CAN_DEMOTE: "leoCanDemote",
    LEO_CAN_PROMOTE: "leoCanPromote",
    LEO_CAN_DEHOIST: "leoCanDehoist",
    // 'states' flags about current selection, for visibility and commands availability
    SELECTED_MARKED: "leoMarked", // no need for unmarked here, use !leoMarked
    SELECTED_CLONE: "leoCloned",
    SELECTED_DIRTY: "leoDirty",
    SELECTED_EMPTY: "leoEmpty",
    SELECTED_CHILD: "leoChild", // Has children
    SELECTED_ATFILE: "leoAtFile", // Can be refreshed
    SELECTED_ROOT: "leoRoot", // ! Not given by Leo: Computed by leoInteg/vscode instead
    // Statusbar Flag 'keybindings in effect'
    LEO_SELECTED: "leoObjectSelected", // keybindings "On": Outline or body has focus
    // Context Flags for 'when' clauses, used concatenated, for each outline node
    NODE_MARKED: "leoNodeMarked",  // Selected node is marked
    NODE_UNMARKED: "leoNodeUnmarked", // Selected node is unmarked (Needed for regexp)
    NODE_ATFILE: "leoNodeAtFile", // Selected node is an @file or @clean, etc...
    NODE_CLONED: "leoNodeCloned",
    NODE_ROOT: "leoNodeRoot",
    NODE_NOT_ROOT: "leoNodeNotRoot",
    // Flags for Leo documents tree view icons and hover node command buttons
    DOCUMENT_SELECTED_TITLED: "leoDocumentSelectedTitled",
    DOCUMENT_TITLED: "leoDocumentTitled",
    DOCUMENT_SELECTED_UNTITLED: "leoDocumentSelectedUntitled",
    DOCUMENT_UNTITLED: "leoDocumentUntitled",
    // Flags that match specific LeoInteg config settings
    LEO_TREE_BROWSE: Constants.CONFIG_NAMES.LEO_TREE_BROWSE, // Force ar'jan's suggestion of Leo's tree behavior override
    TREE_IN_EXPLORER: Constants.CONFIG_NAMES.TREE_IN_EXPLORER, // Leo outline also in the explorer view
    SHOW_OPEN_ASIDE: Constants.CONFIG_NAMES.SHOW_OPEN_ASIDE,   // Show 'open aside' in context menu
    SHOW_EDIT: Constants.CONFIG_NAMES.SHOW_EDIT,              // Hover Icons on outline nodes
    SHOW_ARROWS: Constants.CONFIG_NAMES.SHOW_ARROWS,           // Hover Icons on outline nodes
    SHOW_ADD: Constants.CONFIG_NAMES.SHOW_ADD,                 // Hover Icons on outline nodes
    SHOW_MARK: Constants.CONFIG_NAMES.SHOW_MARK,               // Hover Icons on outline nodes
    SHOW_CLONE: Constants.CONFIG_NAMES.SHOW_CLONE,             // Hover Icons on outline nodes
    SHOW_COPY: Constants.CONFIG_NAMES.SHOW_COPY,               // Hover Icons on outline nodes
    AUTO_START_SERVER: Constants.CONFIG_NAMES.AUTO_START_SERVER,   // Used at startup
    AUTO_CONNECT: Constants.CONFIG_NAMES.AUTO_CONNECT,             // Used at startup

    SHOW_EDITION_BODY: Constants.CONFIG_NAMES.SHOW_EDITION_BODY,
    SHOW_CLIPBOARD_BODY: Constants.CONFIG_NAMES.SHOW_CLIPBOARD_BODY,
    SHOW_PROMOTE_BODY: Constants.CONFIG_NAMES.SHOW_PROMOTE_BODY,
    SHOW_EXECUTE_BODY: Constants.CONFIG_NAMES.SHOW_EXECUTE_BODY,
    SHOW_EXTRACT_BODY: Constants.CONFIG_NAMES.SHOW_EXTRACT_BODY,
    SHOW_IMPORT_BODY: Constants.CONFIG_NAMES.SHOW_IMPORT_BODY,
    SHOW_REFRESH_BODY: Constants.CONFIG_NAMES.SHOW_REFRESH_BODY,
    SHOW_HOIST_BODY: Constants.CONFIG_NAMES.SHOW_HOIST_BODY,
    SHOW_MARK_BODY: Constants.CONFIG_NAMES.SHOW_MARK_BODY,
    SHOW_SORT_BODY: Constants.CONFIG_NAMES.SHOW_SORT_BODY

};

</t>
<t tx="felix.20200718024635.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { UserCommand, LeoBridgePackage, ReqRefresh } from "./types";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718024635.2">/**
 * * Front-facing, user command stack of actions
 * This implements a user-facing command stack, (push on top, remove bottom)
 * Commands can also be added while this stack has started resolving.
 * This 'stack' concept is similar to the 'LeoBridge' class used for interacting with Leo.
 */
export class CommandStack {

    private _stack: UserCommand[] = []; // Actual commands array
    private _busy: boolean = false; // Flag stating commands started resolving

    // Refresh type, for use after the last command has done resolving (From highest so far)
    private _finalRefreshType: ReqRefresh = {}; // new empty ReqRefresh

    // Flag used to set focus on outline instead of body when done resolving (From last pushed)
    private _finalFromOutline: boolean = false;

    // Received selection from the last command that finished as JSON string representation
    // It will be re-sent as 'target node' instead of lastSelectedNode if present
    private _selectedNode: string = ""; // Empty string is used as 'falsy'

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20200718024635.3">/**
 * * Returns the command stack size
 * @returns number of actions on the command stack
 */
public size(): number {
    return this._stack.length;
}

</t>
<t tx="felix.20200718024635.4">/**
 * * Signal to the command stack that a new selected node was received.
 * Command stack needs to know when to clear its own '_receivedSelection'
 */
public newSelection(): void {
    if (!this._busy) {
        this._selectedNode = "";
    }
}

</t>
<t tx="felix.20200718024635.5">/**
 * * Adds on top and try to execute the bottom command if not already running
 * Targeted command (targeting a specific node) can only be added on an empty stack
 * @param p_command Object that has the action, targeted node (if any), refresh type and 'fromOutline' flag
 * @returns true if added, false if it could not (due to front end stack 'rules')
 */
public add(p_command: UserCommand): Promise&lt;LeoBridgePackage&gt; | undefined {
    if (p_command.node &amp;&amp; this.size()) {
        return undefined; // Can only add a command which targets a node if the stack is empty
    } else {
        const q_promise = new Promise&lt;LeoBridgePackage&gt;((p_resolve, p_reject) =&gt; {
            p_command.resolveFn = p_resolve;
            p_command.rejectFn = p_reject;
        });
        this._stack.push(p_command);
        this._finalFromOutline = p_command.fromOutline; // Set final "focus-placement"
        this._tryStart();
        return q_promise;
    }
}

</t>
<t tx="felix.20200718024635.6">/**
 * * Try to launch commands that were added on the stack, if any.
 */
private _tryStart(): void {
    if (this.size() &amp;&amp; !this._busy) {
        // Ok to start, so set the busy flag and start from the bottom
        this._busy = true; // Cleared when the last command has returned (and the stack is empty)
        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}

</t>
<t tx="felix.20200718024635.7">/**
 * * Run the command at index 0: The bottom of the stack.
 */
private _runStackCommand(): Promise&lt;LeoBridgePackage&gt; {
    // Reference from bottom of stack, but don't remove it yet!
    const w_command: UserCommand = this._stack[0];

    let w_nodeJson: string = ""; // ap json used in building w_jsonParam
    let w_jsonParam: string = ""; // Finished parameter that is sent

    // First command uses given node or last selected node.
    // Other subsequent commands on stack will use _receivedSelection regardless.
    // (Commands such as 'collapse all' just ignore node parameter)
    if (w_command.node) {
        // Was node specific, so starting a new stack of commands
        w_nodeJson = w_command.node.apJson;
    } else {
        // Use received "selected node" unless first use, then use last selected node
        if (this._selectedNode) {
            w_nodeJson = this._selectedNode;
        } else {
            w_nodeJson = this._leoIntegration.lastSelectedNode ? this._leoIntegration.lastSelectedNode.apJson : "";
        }
        if (!w_nodeJson) {
            console.log('ERROR NO ARCHIVED POSITION JSON');
        }
    }
    w_jsonParam = utils.buildNodeCommandJson(w_nodeJson, w_command); // 'Insert Named Node' or 'Edit Headline'

    // Setup _finalRefreshType, if command requires higher than the one setup so far
    Object.assign(this._finalRefreshType, w_command.refreshType); // add all properties (expecting only 'true' properties)

    // Submit this action to Leo and return a promise of its packaged answer
    return this._leoIntegration.sendAction(w_command.action, w_jsonParam)
        .then((p_package) =&gt; {
            if (w_command.resolveFn) {
                w_command.resolveFn(p_package);
            }
            return p_package;
        },
            (p_reason) =&gt; {
                if (w_command.rejectFn) {
                    w_command.rejectFn(p_reason);
                }
                return p_reason;
            }
        );
}

</t>
<t tx="felix.20200718024635.8">/**
 * * Handle the result from the command that has finished: either launch the next one, or refresh accordingly.
 * @param p_package is the json return 'package' that was just received back from Leo
 */
private _resolveResult(p_package: LeoBridgePackage): void {
    this._stack.shift(); // Finally remove resolved command from stack bottom

    this._selectedNode = JSON.stringify(p_package.node);

    if (!this.size()) {
        // If last is done then do refresh outline and focus on outline, or body, as required
        this._busy = false;
        if (Object.keys(this._finalRefreshType).length) {
            // At least some type of refresh
            this._leoIntegration.launchRefresh(this._finalRefreshType, this._finalFromOutline, p_package.node);
        }
        // Reset refresh type and focus flag nonetheless
        this._finalRefreshType = {};
        this._finalFromOutline = false;
    } else {
        // Size &gt; 0, so call _runStackCommand again, keep _busy set to true
        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}

</t>
<t tx="felix.20200718030926.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { ConfigMembers, ConfigSetting, FontSettings } from "./types";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718030926.2">/**
 * * Configuration Settings Service
 */
export class Config implements ConfigMembers {

    // Config settings used in leobridgeserver.py, on Leo's side
    public checkForChangeExternalFiles: string = Constants.CONFIG_DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES;
    public defaultReloadIgnore: string = Constants.CONFIG_DEFAULTS.DEFAULT_RELOAD_IGNORE;
    // Config settings used in leoInteg/vscode's side
    public leoTreeBrowse: boolean = Constants.CONFIG_DEFAULTS.LEO_TREE_BROWSE;
    public treeKeepFocus: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS;
    public treeKeepFocusWhenAside: boolean = Constants.CONFIG_DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE;
    public statusBarString: string = Constants.CONFIG_DEFAULTS.STATUSBAR_STRING;
    public statusBarColor: string = Constants.CONFIG_DEFAULTS.STATUSBAR_COLOR;
    public treeInExplorer: boolean = Constants.CONFIG_DEFAULTS.TREE_IN_EXPLORER;
    public showOpenAside: boolean = Constants.CONFIG_DEFAULTS.SHOW_OPEN_ASIDE;
    public showEditOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_EDIT;
    public showArrowsOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_ARROWS;
    public showAddOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_ADD;
    public showMarkOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_MARK;
    public showCloneOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_CLONE;
    public showCopyOnNodes: boolean = Constants.CONFIG_DEFAULTS.SHOW_COPY;

    public showEditionOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EDITION_BODY;
    public showClipboardOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_CLIPBOARD_BODY;
    public showPromoteOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_PROMOTE_BODY;
    public showExecuteOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EXECUTE_BODY;
    public showExtractOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_EXTRACT_BODY;
    public showImportOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_IMPORT_BODY;
    public showRefreshOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_REFRESH_BODY;
    public showHoistOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_HOIST_BODY;
    public showMarkOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_MARK_BODY;
    public showSortOnBody: boolean = Constants.CONFIG_DEFAULTS.SHOW_SORT_BODY;

    public invertNodeContrast: boolean = Constants.CONFIG_DEFAULTS.INVERT_NODES;
    public leoPythonCommand: string = Constants.CONFIG_DEFAULTS.LEO_PYTHON_COMMAND;
    public leoEditorPath: string = Constants.CONFIG_DEFAULTS.LEO_EDITOR_PATH;
    public startServerAutomatically: boolean = Constants.CONFIG_DEFAULTS.AUTO_START_SERVER;
    public connectToServerAutomatically: boolean = Constants.CONFIG_DEFAULTS.AUTO_CONNECT;
    public connectionAddress: string = Constants.CONFIG_DEFAULTS.IP_ADDRESS;
    public connectionPort: number = Constants.CONFIG_DEFAULTS.IP_PORT;

    private _isBusySettingConfig: boolean = false;
    private _needsTreeRefresh: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20200718030926.3">/**
 * * Get actual 'live' Leointeg configuration
 * @returns An object with config settings members such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public getConfig(): ConfigMembers {
    return {
        checkForChangeExternalFiles: this.checkForChangeExternalFiles,  // Used in leoBridge script
        defaultReloadIgnore: this.defaultReloadIgnore,  // Used in leoBridge script
        leoTreeBrowse: this.leoTreeBrowse,
        treeKeepFocus: this.treeKeepFocus,
        treeKeepFocusWhenAside: this.treeKeepFocusWhenAside,
        statusBarString: this.statusBarString,
        statusBarColor: this.statusBarColor,
        treeInExplorer: this.treeInExplorer,
        showOpenAside: this.showOpenAside,
        showEditOnNodes: this.showEditOnNodes,
        showArrowsOnNodes: this.showArrowsOnNodes,
        showAddOnNodes: this.showAddOnNodes,
        showMarkOnNodes: this.showMarkOnNodes,
        showCloneOnNodes: this.showCloneOnNodes,
        showCopyOnNodes: this.showCopyOnNodes,

        showEditionOnBody: this.showEditionOnBody,
        showClipboardOnBody: this.showClipboardOnBody,
        showPromoteOnBody: this.showPromoteOnBody,
        showExecuteOnBody: this.showExecuteOnBody,
        showExtractOnBody: this.showExtractOnBody,
        showImportOnBody: this.showImportOnBody,
        showRefreshOnBody: this.showRefreshOnBody,
        showHoistOnBody: this.showHoistOnBody,
        showMarkOnBody: this.showMarkOnBody,
        showSortOnBody: this.showSortOnBody,

        invertNodeContrast: this.invertNodeContrast,
        leoPythonCommand: this.leoPythonCommand,
        leoEditorPath: this.leoEditorPath,
        startServerAutomatically: this.startServerAutomatically,
        connectToServerAutomatically: this.connectToServerAutomatically,
        connectionAddress: this.connectionAddress,
        connectionPort: this.connectionPort,
    };
}

</t>
<t tx="felix.20200718030926.4">/**
 * * Apply changes to the expansion config settings and save them in user settings.
 * @param p_changes is an array of codes and values to be changed
 * @returns a promise that resolves upon completion
 */
public setLeoIntegSettings(p_changes: ConfigSetting[]): Promise&lt;void&gt; {
    this._isBusySettingConfig = true;
    const w_promises: Thenable&lt;void&gt;[] = [];
    const w_vscodeConfig = vscode.workspace.getConfiguration(Constants.CONFIG_NAME);
    p_changes.forEach(i_change =&gt; {
        if (i_change &amp;&amp; i_change.code.includes(Constants.CONFIG_REFRESH_MATCH)) {
            // Check if tree refresh is required for hover-icons to be displayed or hidden accordingly
            this._needsTreeRefresh = true;
        }
        if (w_vscodeConfig.inspect(i_change.code)!.defaultValue === i_change.value) {
            // Set as undefined - same as default
            w_promises.push(w_vscodeConfig.update(i_change.code, undefined, true));
        } else {
            // Set as value which is not default
            w_promises.push(w_vscodeConfig.update(i_change.code, i_change.value, true));
        }
    });
    return Promise.all(w_promises).then(() =&gt; {
        if (this._needsTreeRefresh) {
            this._needsTreeRefresh = false;
            setTimeout(() =&gt; {
                this._leoIntegration.configTreeRefresh();
            }, 200);
        }
        this._isBusySettingConfig = false;
        this.buildFromSavedSettings();
        return Promise.resolve();
    });
}

</t>
<t tx="felix.20200718030926.5">/**
 * * Build config from settings from vscode's saved config settings
 */
public buildFromSavedSettings(): void {
    // Shorthand pointers for readability
    const GET = vscode.workspace.getConfiguration;
    const NAME = Constants.CONFIG_NAME;
    const NAMES = Constants.CONFIG_NAMES;
    const DEFAULTS = Constants.CONFIG_DEFAULTS;
    const FLAGS = Constants.CONTEXT_FLAGS;

    if (this._isBusySettingConfig) {
        // * Currently setting config, wait until its done all, and this will be called automatically
        return;
    } else {
        this.checkForChangeExternalFiles = GET(NAME).get(NAMES.CHECK_FOR_CHANGE_EXTERNAL_FILES, DEFAULTS.CHECK_FOR_CHANGE_EXTERNAL_FILES);
        this.defaultReloadIgnore = GET(NAME).get(NAMES.DEFAULT_RELOAD_IGNORE, DEFAULTS.DEFAULT_RELOAD_IGNORE);
        this.leoTreeBrowse = GET(NAME).get(NAMES.LEO_TREE_BROWSE, DEFAULTS.LEO_TREE_BROWSE);
        this.treeKeepFocus = GET(NAME).get(NAMES.TREE_KEEP_FOCUS, DEFAULTS.TREE_KEEP_FOCUS);
        this.treeKeepFocusWhenAside = GET(NAME).get(NAMES.TREE_KEEP_FOCUS_WHEN_ASIDE, DEFAULTS.TREE_KEEP_FOCUS_WHEN_ASIDE);
        this.statusBarString = GET(NAME).get(NAMES.STATUSBAR_STRING, DEFAULTS.STATUSBAR_STRING);
        if (this.statusBarString.length &gt; 8) {
            this.statusBarString = DEFAULTS.STATUSBAR_STRING;
        }
        this.statusBarColor = GET(NAME).get(NAMES.STATUSBAR_COLOR, DEFAULTS.STATUSBAR_COLOR);
        if (!utils.isHexColor(this.statusBarColor)) {
            this.statusBarColor = DEFAULTS.STATUSBAR_COLOR;
        }
        this.treeInExplorer = GET(NAME).get(NAMES.TREE_IN_EXPLORER, DEFAULTS.TREE_IN_EXPLORER);
        this.showOpenAside = GET(NAME).get(NAMES.SHOW_OPEN_ASIDE, DEFAULTS.SHOW_OPEN_ASIDE);
        this.showEditOnNodes = GET(NAME).get(NAMES.SHOW_EDIT, DEFAULTS.SHOW_EDIT);
        this.showArrowsOnNodes = GET(NAME).get(NAMES.SHOW_ARROWS, DEFAULTS.SHOW_ARROWS);
        this.showAddOnNodes = GET(NAME).get(NAMES.SHOW_ADD, DEFAULTS.SHOW_ADD);
        this.showMarkOnNodes = GET(NAME).get(NAMES.SHOW_MARK, DEFAULTS.SHOW_MARK);
        this.showCloneOnNodes = GET(NAME).get(NAMES.SHOW_CLONE, DEFAULTS.SHOW_CLONE);
        this.showCopyOnNodes = GET(NAME).get(NAMES.SHOW_COPY, DEFAULTS.SHOW_COPY);

        this.showEditionOnBody = GET(NAME).get(NAMES.SHOW_EDITION_BODY, DEFAULTS.SHOW_EDITION_BODY);
        this.showClipboardOnBody = GET(NAME).get(NAMES.SHOW_CLIPBOARD_BODY, DEFAULTS.SHOW_CLIPBOARD_BODY);
        this.showPromoteOnBody = GET(NAME).get(NAMES.SHOW_PROMOTE_BODY, DEFAULTS.SHOW_PROMOTE_BODY);
        this.showExecuteOnBody = GET(NAME).get(NAMES.SHOW_EXECUTE_BODY, DEFAULTS.SHOW_EXECUTE_BODY);
        this.showExtractOnBody = GET(NAME).get(NAMES.SHOW_EXTRACT_BODY, DEFAULTS.SHOW_EXTRACT_BODY);
        this.showImportOnBody = GET(NAME).get(NAMES.SHOW_IMPORT_BODY, DEFAULTS.SHOW_IMPORT_BODY);
        this.showRefreshOnBody = GET(NAME).get(NAMES.SHOW_REFRESH_BODY, DEFAULTS.SHOW_REFRESH_BODY);
        this.showHoistOnBody = GET(NAME).get(NAMES.SHOW_HOIST_BODY, DEFAULTS.SHOW_HOIST_BODY);
        this.showMarkOnBody = GET(NAME).get(NAMES.SHOW_MARK_BODY, DEFAULTS.SHOW_MARK_BODY);
        this.showSortOnBody = GET(NAME).get(NAMES.SHOW_SORT_BODY, DEFAULTS.SHOW_SORT_BODY);

        this.invertNodeContrast = GET(NAME).get(NAMES.INVERT_NODES, DEFAULTS.INVERT_NODES);
        this.leoEditorPath = GET(NAME).get(NAMES.LEO_EDITOR_PATH, DEFAULTS.LEO_EDITOR_PATH);
        this.leoPythonCommand = GET(NAME).get(NAMES.LEO_PYTHON_COMMAND, DEFAULTS.LEO_PYTHON_COMMAND);
        this.startServerAutomatically = GET(NAME).get(NAMES.AUTO_START_SERVER, DEFAULTS.AUTO_START_SERVER);
        this.connectToServerAutomatically = GET(NAME).get(NAMES.AUTO_CONNECT, DEFAULTS.AUTO_CONNECT);
        this.connectionAddress = GET(NAME).get(NAMES.IP_ADDRESS, DEFAULTS.IP_ADDRESS);
        this.connectionPort = GET(NAME).get(NAMES.IP_PORT, DEFAULTS.IP_PORT);

        // * Set context for tree items visibility that are based on config options
        if (this._leoIntegration.leoStates.leoBridgeReady) {
            this._leoIntegration.sendConfigToServer(this.getConfig());
        }
        utils.setContext(FLAGS.LEO_TREE_BROWSE, this.leoTreeBrowse);
        utils.setContext(FLAGS.TREE_IN_EXPLORER, this.treeInExplorer);
        utils.setContext(FLAGS.SHOW_OPEN_ASIDE, this.showOpenAside);
        utils.setContext(FLAGS.SHOW_EDIT, this.showEditOnNodes);
        utils.setContext(FLAGS.SHOW_ARROWS, this.showArrowsOnNodes);
        utils.setContext(FLAGS.SHOW_ADD, this.showAddOnNodes);
        utils.setContext(FLAGS.SHOW_MARK, this.showMarkOnNodes);
        utils.setContext(FLAGS.SHOW_CLONE, this.showCloneOnNodes);
        utils.setContext(FLAGS.SHOW_COPY, this.showCopyOnNodes);

        utils.setContext(FLAGS.SHOW_EDITION_BODY, this.showEditionOnBody);
        utils.setContext(FLAGS.SHOW_CLIPBOARD_BODY, this.showClipboardOnBody);
        utils.setContext(FLAGS.SHOW_PROMOTE_BODY, this.showPromoteOnBody);
        utils.setContext(FLAGS.SHOW_EXECUTE_BODY, this.showExecuteOnBody);
        utils.setContext(FLAGS.SHOW_EXTRACT_BODY, this.showExtractOnBody);
        utils.setContext(FLAGS.SHOW_IMPORT_BODY, this.showImportOnBody);
        utils.setContext(FLAGS.SHOW_REFRESH_BODY, this.showRefreshOnBody);
        utils.setContext(FLAGS.SHOW_HOIST_BODY, this.showHoistOnBody);
        utils.setContext(FLAGS.SHOW_MARK_BODY, this.showMarkOnBody);
        utils.setContext(FLAGS.SHOW_SORT_BODY, this.showSortOnBody);

        if (!this._leoIntegration.finishedStartup &amp;&amp; this.leoEditorPath) {
            // Only relevant 'viewWelcome' content at startup.
            utils.setContext(FLAGS.AUTO_START_SERVER, this.startServerAutomatically); // server started
            utils.setContext(FLAGS.AUTO_CONNECT, this.connectToServerAutomatically); // server started
        } else {
            utils.setContext(FLAGS.AUTO_START_SERVER, false); // server started
            utils.setContext(FLAGS.AUTO_CONNECT, false); // server started
        }
    }
}

</t>
<t tx="felix.20200718031424.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { ReqRefresh } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { LeoSettingsProvider } from "./webviews/leoSettingsWebview";
import { LeoButtonNode } from "./leoButtonNode";

var LeoInteg: LeoIntegration | undefined = undefined;

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718031424.2">/**
 * * Called by vscode when extension is activated
 * It creates the leoIntegration instance
 * Will also open the 'welcome/Settings' webview instance if a new version is opened
 */
export function activate(p_context: vscode.ExtensionContext) {

    // * Reset Extension context flags (used in 'when' clauses in package.json)
    utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, false); // Connected to a leobridge server?
    utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, false); // Having a Leo file opened on that server?

    const w_leoIntegExtension = vscode.extensions.getExtension(Constants.PUBLISHER + '.' + Constants.NAME)!;
    const w_leoIntegVersion = w_leoIntegExtension.packageJSON.version;
    const w_leo: LeoIntegration = new LeoIntegration(p_context);
    if (w_leo) {
        LeoInteg = w_leo;
    }
    const w_leoSettingsWebview: LeoSettingsProvider = w_leo.leoSettingsWebview;
    const w_previousVersion = p_context.globalState.get&lt;string&gt;(Constants.VERSION_STATE_KEY);
    const w_start = process.hrtime(); // For calculating total startup time duration

    // Shortcut pointers for readability
    const U = undefined;
    const BRIDGE = Constants.LEOBRIDGE;
    const CMD = Constants.COMMANDS;
    const NO_REFRESH: ReqRefresh = {};
    const REFRESH_NODE_BODY: ReqRefresh = {
        node: true, // Reveal the returned 'selected position' without changes to the tree
        body: true, // Goto/select another node needs the body pane refreshed
        states: true
    };
    const REFRESH_TREE: ReqRefresh = {
        tree: true,
        states: true
    };
    const REFRESH_TREE_BODY: ReqRefresh = {
        tree: true,
        body: true,
        states: true
    };

    const w_commands: [string, (...args: any[]) =&gt; any][] = [

        // ! REMOVE TESTS ENTRIES FROM PACKAGE.JSON FOR MASTER BRANCH RELEASES !
        ["leointeg.test", () =&gt; w_leo.test()], // Test function useful when debugging
        // ["leointeg.testFromOutline", () =&gt; w_leo.test(true)], // Test function useful when debugging.

        &lt;&lt; Define entries for all commands &gt;&gt;
    ];

    w_commands.map(function (p_command) {
        p_context.subscriptions.push(vscode.commands.registerCommand(...p_command));
    });

    showWelcomeIfNewer(w_leoIntegVersion, w_previousVersion).then(() =&gt; {
        // Start server and/or connect to it, as per user settings
        w_leo.startNetworkServices();
        // Save version # for next startup comparison
        p_context.globalState.update(Constants.VERSION_STATE_KEY, w_leoIntegVersion);
        console.log('leoInteg startup launched in ', utils.getDurationMs(w_start), 'ms');
    });
}

</t>
<t tx="felix.20200718031424.24">/**
 * * Called when extension is deactivated
 */
export function deactivate(): Promise&lt;boolean&gt; {
    if (LeoInteg) {
        LeoInteg.cleanupBody().then(() =&gt; {
            LeoInteg?.stopConnection();
        });
        // Call to LeoInteg.stopServer() is not needed: server should handle disconnects.
        // Server should open tk GUI dialogs if dirty files still remain before closing itself.
        return new Promise(resolve =&gt; setTimeout(() =&gt; {
            resolve(true); // 200 ms to save last dirty body text.
        }, 200));
    } else {
        return Promise.resolve(false);
    }
}

</t>
<t tx="felix.20200718031424.25">/**
 * * Show welcome screen if needed, based on last version executed
 * @param p_version Current version, as a string, from packageJSON.version
 * @param p_previousVersion Previous version, as a string, from context.globalState.get service
 * @returns A promise that triggers when command to show the welcome screen is finished, or immediately if not needed
 */
async function showWelcomeIfNewer(p_version: string, p_previousVersion: string | undefined): Promise&lt;unknown&gt; {
    let w_showWelcomeScreen: boolean = false;
    if (p_previousVersion === undefined) {
        console.log('leointeg first-time install');
        w_showWelcomeScreen = true;
    } else {
        if (p_previousVersion !== p_version) {
            vscode.window.showInformationMessage(`leoInteg upgraded from v${p_previousVersion} to v${p_version}`);
        }
        const [w_major, w_minor] = p_version.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        const [w_prevMajor, w_prevMinor] = p_previousVersion.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        if (
            (w_major === w_prevMajor &amp;&amp; w_minor === w_prevMinor) ||
            // Don't notify on downgrades
            (w_major &lt; w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &lt; w_prevMinor))
        ) {
            w_showWelcomeScreen = false;
        } else if (w_major !== w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &gt; w_prevMinor)) {
            // Will show on major or minor upgrade (Formatted as 'Major.Minor.Revision' eg. 1.2.3)
            w_showWelcomeScreen = true;
        }
    }
    if (w_showWelcomeScreen) {
        return vscode.commands.executeCommand(Constants.COMMANDS.SHOW_WELCOME);
    } else {
        return Promise.resolve();
    }
}
</t>
<t tx="felix.20200718035737.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import {
    AskMessageItem,
    runAskYesNoDialogParameters,
    runWarnMessageDialogParameters,
    runInfoMessageDialogParameters,
    showSaveAsDialogParameters
} from "./types";
import { LeoIntegration } from "./leoIntegration";

@others
</t>
<t tx="felix.20200718040540.1">import * as vscode from "vscode";
import * as utils from "./utils";
import * as path from 'path';
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { BodyTimeInfo } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718040540.10">public stat(p_uri: vscode.Uri): vscode.FileStat | Thenable&lt;vscode.FileStat&gt; {
    // TODO : Fix/Check extraneous stat(...) call(s)
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        const w_gnx = utils.leoUriToStr(p_uri);
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            // console.log('called stat on root');
            return { type: vscode.FileType.Directory, ctime: 0, mtime: 0, size: 0 };
        } else if (w_gnx === this._lastGnx &amp;&amp; this._openedBodiesGnx.includes(this._lastGnx)) {
            // If same as last checked, sending back time at absolute past
            // ? VERIFY this._selectedBody.mtime we get file changed on disk error??
            // console.log('VERIFY this._selectedBody.mtime we get file changed on disk error :', p_uri);
            return {
                type: vscode.FileType.File,
                ctime: this._openedBodiesInfo[this._lastGnx].ctime,
                mtime: this._openedBodiesInfo[this._lastGnx].mtime,
                size: this._lastBodyLength
            };
        } else if (this._openedBodiesGnx.includes(w_gnx)) {
            return this._leoIntegration.sendAction(
                Constants.LEOBRIDGE.GET_BODY_LENGTH,
                JSON.stringify({ "gnx": w_gnx })
            ).then((p_result) =&gt; {
                return Promise.resolve(
                    {
                        type: vscode.FileType.File,
                        ctime: this._openedBodiesInfo[w_gnx].ctime,
                        mtime: this._openedBodiesInfo[w_gnx].mtime,
                        size: p_result.len ? p_result.len : 0
                    }
                );
            });
        }
    }
    throw vscode.FileSystemError.FileNotFound();
}

</t>
<t tx="felix.20200718040540.11">public readFile(p_uri: vscode.Uri): Thenable&lt;Uint8Array&gt; {
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            throw vscode.FileSystemError.FileIsADirectory();
        } else {
            const w_gnx = utils.leoUriToStr(p_uri);
            // if (!this._possibleGnxList.includes(w_gnx)) {
            if (!this._openedBodiesGnx.includes(w_gnx)) {
                console.error("readFile: ERROR File not in _openedBodiesGnx! readFile missing refreshes?");
                throw vscode.FileSystemError.FileNotFound();
            } else {
                return this._leoIntegration.sendAction(
                    Constants.LEOBRIDGE.GET_BODY,
                    JSON.stringify({ "gnx": w_gnx })
                ).then((p_result) =&gt; {
                    if (p_result.body) {
                        this._lastGnx = w_gnx;
                        this._lastBodyData = p_result.body;
                        const w_buffer: Uint8Array = Buffer.from(p_result.body);
                        this._lastBodyLength = w_buffer.byteLength;
                        return Promise.resolve(w_buffer);
                    } else if (p_result.body === "") {
                        this._lastGnx = w_gnx;
                        this._lastBodyLength = 0;
                        this._lastBodyData = "";
                        return Promise.resolve(Buffer.from(""));
                    } else {
                        if (this._lastGnx === w_gnx) {
                            // was last gnx of closed file about to be switched to new document selected
                            console.log('Passed in not found: ' + w_gnx);

                            return Promise.resolve(Buffer.from(this._lastBodyData));
                        }
                        console.error("ERROR =&gt; readFile of unknown GNX"); // is possibleGnxList updated correctly?
                        return Promise.resolve(Buffer.from(""));
                        //  throw vscode.FileSystemError.FileNotFound();
                    }
                });
            }
        }
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20200718040540.12">public readDirectory(p_uri: vscode.Uri): Thenable&lt;[string, vscode.FileType][]&gt; {
    // console.warn('Called readDirectory with ', p_uri.fsPath); // should not happen
    if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
        const w_directory: [string, vscode.FileType][] = [];
        w_directory.push([this._lastBodyTimeGnx, vscode.FileType.File]);
        return Promise.resolve(w_directory);
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="felix.20200718040540.13">public createDirectory(p_uri: vscode.Uri): void {
    console.warn('Called createDirectory with ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20200718040540.14">public writeFile(p_uri: vscode.Uri, p_content: Uint8Array, p_options: { create: boolean, overwrite: boolean }): void {
    if (!this.preventSaveToLeo) {
        this._leoIntegration.triggerBodySave(true); // Might have been a vscode 'save' via the menu
    } else {
        this.preventSaveToLeo = false;
    }
    const w_gnx = utils.leoUriToStr(p_uri);
    if (!this._openedBodiesGnx.includes(w_gnx)) {
        console.error("ASKED TO SAVE NOT EVEN IN SELECTED BODY: ", w_gnx);
        this._openedBodiesGnx.push(w_gnx);
    }
    const w_now = new Date().getTime();
    this._openedBodiesInfo[w_gnx] = {
        ctime: w_now,
        mtime: w_now
    };
    this._fireSoon({ type: vscode.FileChangeType.Changed, uri: p_uri });
}

</t>
<t tx="felix.20200718040540.15">public rename(p_oldUri: vscode.Uri, p_newUri: vscode.Uri, p_options: { overwrite: boolean }): void {
    console.warn('Called rename on ', p_oldUri.fsPath, p_newUri.fsPath); // should not happen
    this._fireSoon(
        { type: vscode.FileChangeType.Deleted, uri: p_oldUri },
        { type: vscode.FileChangeType.Created, uri: p_newUri }
    );
}

</t>
<t tx="felix.20200718040540.16">public delete(p_uri: vscode.Uri): void {
    // console.log("delete", p_uri.fsPath);
    const w_gnx = utils.leoUriToStr(p_uri);
    if (this._openedBodiesGnx.includes(w_gnx)) {
        this._openedBodiesGnx.splice(this._openedBodiesGnx.indexOf(w_gnx), 1);
        delete this._openedBodiesInfo[w_gnx];
    } else {
        // console.log("not deleted");
    }

    // dirname is just a slash "/"
    let w_dirname = p_uri.with({ path: path.posix.dirname(p_uri.path) });

    this._fireSoon(
        { type: vscode.FileChangeType.Changed, uri: w_dirname },
        { uri: p_uri, type: vscode.FileChangeType.Deleted }
    );
}

</t>
<t tx="felix.20200718040540.17">public copy(p_uri: vscode.Uri): void {
    console.warn('Called copy on ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="felix.20200718040540.18">private _fireSoon(...p_events: vscode.FileChangeEvent[]): void {
    this._bufferedEvents.push(...p_events);
    if (this._fireSoonHandle) {
        clearTimeout(this._fireSoonHandle);
    }
    this._fireSoonHandle = setTimeout(() =&gt; {
        this._onDidChangeFileEmitter.fire(this._bufferedEvents);
        this._bufferedEvents.length = 0; // clearing events array
    }, 5);
}

</t>
<t tx="felix.20200718040540.2">/**
 * * Body panes implementation as a file system using "leo" as a scheme identifier
 * Saving and renaming prevents flickering and prevents undos to 'traverse through' different gnx
 */
export class LeoBodyProvider implements vscode.FileSystemProvider {

    // * Flag normally false
    public preventSaveToLeo: boolean = false;

    // * Simple structure to keep mtime of selected and renamed body virtual files
    private _selectedBody: string = "";

    // * Last file read data with the readFile method
    private _lastGnx: string = ""; // gnx of last file read
    private _lastBodyData: string = ""; // body content of last file read
    private _lastBodyLength: number = 0; // length of last file read

    // * List of currently opened body panes gnx (from 'watch' &amp; 'dispose' methods)
    private _watchedBodiesGnx: string[] = [];

    // * List of gnx that should be available (from more.selectNode and fs.delete)
    private _openedBodiesGnx: string[] = [];
    private _openedBodiesInfo: { [key: string]: BodyTimeInfo } = {};

    // * List of all possible vNodes gnx in the currently opened leo file (since last refresh/tree operation)
    private _possibleGnxList: string[] = []; // Maybe deprecated

    private _lastBodyTimeGnx: string = "";

    // * An event to signal that a resource has been changed
    // * It should fire for resources that are being [watched](#FileSystemProvider.watch) by clients of this provider
    private _onDidChangeFileEmitter = new vscode.EventEmitter&lt;vscode.FileChangeEvent[]&gt;();
    readonly onDidChangeFile: vscode.Event&lt;vscode.FileChangeEvent[]&gt; = this._onDidChangeFileEmitter.event;
    private _bufferedEvents: vscode.FileChangeEvent[] = [];
    private _fireSoonHandle?: NodeJS.Timer;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718040540.3">/**
 * * Sets selected node body's modified time for this gnx virtual file
 * @param p_uri URI of file for which to set made-up modified time
 */
public setBodyTime(p_uri: vscode.Uri): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    this._lastBodyTimeGnx = w_gnx;
    if (!this._openedBodiesGnx.includes(w_gnx)) {
        this._openedBodiesGnx.push(w_gnx);
    }
    const w_now = new Date().getTime();
    this._openedBodiesInfo[w_gnx] = {
        ctime: w_now,
        mtime: w_now
    };
}

</t>
<t tx="felix.20200718040540.5">/**
 * * Refresh the body pane for a particular gnx by telling vscode that the file from the Leo file provider has changed
 * @param p_gnx Gnx of body associated with this virtual file, mostly Leo's selected node
 */
public fireRefreshFile(p_gnx: string): void {
    this._selectedBody = p_gnx;
    if (!this._openedBodiesGnx.includes(p_gnx)) {
        console.error("ASKED TO REFRESH NOT EVEN IN SELECTED BODY: ", p_gnx);
        this._openedBodiesGnx.push(p_gnx);
    }
    const w_now = new Date().getTime();
    this._openedBodiesInfo[p_gnx] = {
        ctime: w_now,
        mtime: w_now
    };
    this._onDidChangeFileEmitter.fire([{
        type: vscode.FileChangeType.Changed,
        uri: utils.strToLeoUri(p_gnx)
    } as vscode.FileChangeEvent]);
}

</t>
<t tx="felix.20200718040540.6">/**
 * Maybe deprecated
 * * Refreshes the '_possibleGnxList' list of all unique gnx from Leo
 * @returns a promise that resolves to the fresh gnx string array
 */
public refreshPossibleGnxList(): Thenable&lt;string[]&gt; {
    // * Get updated list of possible gnx
    return this._leoIntegration.sendAction(
        Constants.LEOBRIDGE.GET_ALL_GNX
    ).then((p_result) =&gt; {
        this._possibleGnxList = p_result.gnx || [];
        return Promise.resolve(this._possibleGnxList);
    });
}

</t>
<t tx="felix.20200718040540.8">public watch(p_resource: vscode.Uri): vscode.Disposable {
    const w_gnx = utils.leoUriToStr(p_resource);
    if (!this._watchedBodiesGnx.includes(w_gnx)) {
        // console.log('MORE fs watch put in _openedBodiesGnx:', p_resource.fsPath);
        this._watchedBodiesGnx.push(w_gnx); // add gnx
    } else {
        // console.warn('MORE fs watch: already in _openedBodiesGnx:', p_resource.fsPath);
    }
    return new vscode.Disposable(() =&gt; {
        const w_position = this._watchedBodiesGnx.indexOf(w_gnx); // find and remove it
        if (w_position &gt; -1) {
            // console.log('MORE fs removed from _openedBodiesGnx: ', w_gnx);
            this._watchedBodiesGnx.splice(w_position, 1);
        }
    });
}

</t>
<t tx="felix.20200718153505.1">import * as vscode from "vscode";
import * as WebSocket from 'ws';
import { Constants } from "./constants";
import { LeoBridgePackage, LeoAction } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoAsync } from "./leoAsync";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718153505.11">/**
 * * Process data that came from the Leo process
 * @param p_data given JSON data
 */
private _processAnswer(p_data: string): void {
    // console.log('got data', p_data);
    const w_parsedData = this._tryParseJSON(p_data);
    if (w_parsedData &amp;&amp; (w_parsedData.id === 0 || w_parsedData.id)) {
        this._resolveBridgeReady(w_parsedData);
        this._callAction();
    } else if (w_parsedData &amp;&amp; w_parsedData.async) {
        // * Check for async messages such as log pane entries or other
        this._asyncAction(w_parsedData);
    } else {
        // unprocessed/unknown python output
        console.error("[leoBridge] Unprocessed or unknown JSON received: ", p_data);
    }
}

</t>
<t tx="felix.20200718153505.12">/**
 * * Create a websocket connection to leoserver on
 * @param p_port facultative port number to override config port
 * @returns A promise for a LeoBridgePackage object containing only an 'id' member of 1 that will resolve when the 'leoBridge' is established
 */
public initLeoProcess(p_port?: number): Promise&lt;LeoBridgePackage&gt; {
    this._websocket = new WebSocket(
        Constants.TCPIP_DEFAULT_PROTOCOL +
        this._leoIntegration.config.connectionAddress +
        ":" +
        (p_port ? p_port : this._leoIntegration.config.connectionPort)
    );
    // * Capture the python process output
    this._websocket.onmessage = (p_event) =&gt; {
        if (p_event.data) {
            this._processAnswer(p_event.data.toString());
        }
    };
    this._websocket.onerror = (p_event: WebSocket.ErrorEvent) =&gt; {
        console.error(`Websocket error: ${p_event.message}`);
    };
    this._websocket.onclose = (p_event: WebSocket.CloseEvent) =&gt; {
        // * Disconnected from server
        console.log(`Websocket closed, code: ${p_event.code}`);
        this._rejectAction(`Websocket closed, code: ${p_event.code}`);
        // TODO : Implement a better connection error handling
        if (this._leoIntegration.leoStates.leoBridgeReady) {
            this._leoIntegration.cancelConnect(`Websocket closed, code: ${p_event.code}`);
        }
    };
    // * Start first with 'preventCall' set to true: no need to call anything for the first 'ready'
    this._readyPromise = this.action("", "", { id: Constants.STARTING_PACKAGE_ID }, true);
    return this._readyPromise; // This promise will resolve when the started python process starts
}

</t>
<t tx="felix.20200718153505.13">/**
 * * Send into the python process input
 * @param p_data JSON Message string to be sent to leobridgeserver.py
 */
private _send(p_data: string): any {
    if (this._readyPromise) {
        this._readyPromise.then(() =&gt; { // using '.then' that was surely resolved already: to be buffered in case process isn't ready.
            if (this._websocket &amp;&amp; this._websocket.OPEN) {
                this._websocket.send(p_data); // p_message should be json
            }
        });
    }
}

</t>
<t tx="felix.20200718153505.2">/**
 * * Handles communication with the leobridgeserver.py python script via websockets
 * This implements a bridge-facing action stack, (push on top, remove bottom)
 * 'actions' get sent to Leo, and resolve a promise with the result when the answer comes back.
 * This 'stack' concept is similar to the 'CommandStack' class used for vscode's user interactions.
 */
export class LeoBridge {

    private _callStack: LeoAction[] = [];
    private _actionBusy: boolean = false; // Action was started from the bottom, but has yet to resolve

    private _leoBridgeSerialId: number = 0; // TODO : Error checking (should be Constants.STARTING_PACKAGE_ID or 0 or 2...?)
    private _readyPromise: Promise&lt;LeoBridgePackage&gt; | undefined;

    private _websocket: WebSocket | null = null;
    private _leoAsync: LeoAsync;

    // TODO : #10 @boltex See if this can help with anaconda/miniconda issues
    // private _hasbin = require('hasbin');

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._leoAsync = new LeoAsync(_context, _leoIntegration);
    }

    @others
}
</t>
<t tx="felix.20200718153505.3">/**
 * * Places an action on top of a stack, to be resolved from the bottom
 * @param p_action Command string to be performed by Leo via leobridgeserver.py
 * @param p_jsonParam Optional JSON parameter for the specified action
 * @param p_deferredPayload Used to build this._readyPromise that resolves itself at startup
 * @param p_preventCall Flag for special action used to build this._readyPromise that resolves itself at startup
 * @returns a Promise that will contain the JSON package answered back by leobridgeserver.py
 */
public action(p_action: string, p_jsonParam = "null", p_deferredPayload?: LeoBridgePackage, p_preventCall?: boolean): Promise&lt;LeoBridgePackage&gt; {
    return new Promise((p_resolve, p_reject) =&gt; {
        const w_action: LeoAction = {
            parameter: this._buildActionParameter(p_action, p_jsonParam),
            deferredPayload: p_deferredPayload ? p_deferredPayload : undefined,
            resolveFn: p_resolve,
            rejectFn: p_reject
        };

        this._callStack.push(w_action);
        if (!p_preventCall) {
            this._callAction();
        }
    });
}

</t>
<t tx="felix.20200718153505.4">/**
 * * Actions invoked by Leo that can be called asynchronously at any time
 * @param w_parsedData that contains an 'async' string member,
 * that was parsed from a _websocket.onmessage package
 */
private _asyncAction(w_parsedData: any): void {
    if (w_parsedData &amp;&amp; w_parsedData.async &amp;&amp; (typeof w_parsedData.async === "string")) {
        switch (w_parsedData.async) {
            case Constants.ASYNC_ACTIONS.ASYNC_LOG: {
                this._leoAsync.log(w_parsedData.log);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_REFRESH: {
                this._leoAsync.refresh(w_parsedData.action);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_ASK: {
                this._leoAsync.showAskModalDialog(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_WARN: {
                this._leoAsync.showWarnModalMessage(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_INFO: {
                this._leoAsync.showChangesDetectedInfoMessage(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_INTERVAL: {
                console.log("interval ", w_parsedData); // 'ping' interval for debugging
                break;
            }
            default: {
                console.error("[leoIntegration] Unknown async action ", w_parsedData);
                break;
            }
        }
    } else {
        console.error("[leoIntegration] Unknown async command from leoBridge");
    }
}

</t>
<t tx="felix.20200718153505.5">/**
 * * Build JSON string for action parameter to the leoBridge
 * @param p_action Action string to be invoked as command by Leo in the leobridgeserver.py script
 * @param p_jsonParam Optional JSON string to be added as a 'param' to the action sent to Leo
 */
private _buildActionParameter(p_action: string, p_jsonParam?: string): string {
    return "{\"id\":" + (++this._leoBridgeSerialId) + // no quotes, serial id is a number, pre incremented
        ", \"action\": \"" + p_action +  // action is string so surround with quotes
        "\", \"param\":" + p_jsonParam +  // param is already json, no need for added quotes
        "}";
}

</t>
<t tx="felix.20200718153505.6">/**
 * * Resolves promises with the answers from an action that was finished
 * @param p_object Parsed data that was given as the answer by the Leo command that finished
 */
private _resolveBridgeReady(p_object: string) {
    let w_bottomAction = this._callStack.shift();
    if (w_bottomAction) {
        if (w_bottomAction.deferredPayload) {
            // Used when the action already has a return value ready but is also waiting for python's side
            w_bottomAction.resolveFn(w_bottomAction.deferredPayload); // given back 'as is'
        } else {
            w_bottomAction.resolveFn(p_object);
        }
        this._actionBusy = false;
    } else {
        console.error("[leoBridge] Error stack empty");
    }
}

</t>
<t tx="felix.20200718153505.7">/**
 * * Rejects an action from the bottom of the stack
 * @param p_reason Given rejection 'reason'
 */
private _rejectAction(p_reason: string): void {
    const w_bottomAction = this._callStack.shift();
    if (w_bottomAction) {
        w_bottomAction.rejectFn(p_reason);
    }
}

</t>
<t tx="felix.20200718153505.8">/**
 * * Sends an action from the bottom of the stack
 */
private _callAction(): void {
    if (this._callStack.length &amp;&amp; !this._actionBusy) {
        this._actionBusy = true; // launch / resolve bottom one
        const w_action = this._callStack[0];
        this._send(w_action.parameter + "\n");
    }
}

</t>
<t tx="felix.20200718153505.9">/**
 * * JSON.parse encased in a Try/Catch block
 * @param p_jsonStr The JSON string to be parsed
 * @returns The resulting object or 'false' if unsuccessful
 */
private _tryParseJSON(p_jsonStr: string): boolean | any {
    try {
        var w_object = JSON.parse(p_jsonStr);
        // JSON.parse(null) returns null, and typeof null === "object", null is falsy, so this suffices:
        if (w_object &amp;&amp; typeof w_object === "object") {
            return w_object;
        }
    }
    catch (e) {
        console.error('[leoBridge] JSON was invalid: ' + p_jsonStr);
    }
    return false;
}

</t>
<t tx="felix.20200718155251.1">/**
 * * Busy state of the leoBridge's command stack
 */
public isBusy(): boolean {
    return this._actionBusy || !!this._callStack.length;
}

</t>
<t tx="felix.20200718162303.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoButton, Icon } from "./types";
import * as utils from "./utils";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718162303.2">/**
 * * Leo @buttons tree view node item implementation, for usage in a TreeDataProvider.
 */
export class LeoButtonNode extends vscode.TreeItem {

    // Context string that is checked in package.json with 'when' clauses
    public contextValue: string;
    private _id: string;

    // is the special 'add' button used to create button from a given node's script
    private _isAdd: boolean;

    constructor(
        public button: LeoButton,
        private _leoIntegration: LeoIntegration
    ) {
        super(button.name);
        // Cleanup button name of any directives starting with '@'
        // super(
        //     button.name.split(" ")
        //         .filter(item =&gt; item[0] !== "@")
        //         .join(" ")
        //         .trim()
        // );

        this._id = utils.getUniqueId();
        // Setup this instance (just differentiate 'script-button' for now)
        this.command = {
            command: Constants.COMMANDS.CLICK_BUTTON,
            title: '',
            arguments: [this]
        };
        this._isAdd = (this.button.index.startsWith(Constants.BUTTON_STRINGS.NULL_WIDGET) &amp;&amp;
            this.button.name === Constants.BUTTON_STRINGS.SCRIPT_BUTTON);
        this.contextValue = this._isAdd ? Constants.BUTTON_STRINGS.ADD_BUTTON : Constants.BUTTON_STRINGS.NORMAL_BUTTON;
    }

    @others
}
</t>
<t tx="felix.20200718162435.1">// @ts-ignore
public get iconPath(): Icon {
    return this._leoIntegration.buttonIcons[this._isAdd ? 1 : 0];
}

</t>
<t tx="felix.20200718162442.1">// @ts-ignore
public get id(): string {
    // Add prefix and suffix salt to index to prevent accidental duplicates
    return this._id;
    // return "p" + this.button.index + "s" + this.button.name;
}

</t>
<t tx="felix.20200718162452.1">// @ts-ignore
public get tooltip(): string {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON_TOOLTIP;
    } else {
        return this.button.name;
    }
}

</t>
<t tx="felix.20200718162459.1">// @ts-ignore
public get description(): string | boolean {
    if (this._isAdd) {
        return Constants.USER_MESSAGES.SCRIPT_BUTTON;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20200718164130.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoButtonNode } from "./leoButtonNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoButton } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718164130.2">/**
 * * '@buttons' shown as a list with this TreeDataProvider implementation
 */
export class LeoButtonsProvider implements vscode.TreeDataProvider&lt;LeoButtonNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoButtonNode | undefined&gt; = new vscode.EventEmitter&lt;LeoButtonNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoButtonNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718164130.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718164130.4">public getTreeItem(element: LeoButtonNode): Thenable&lt;LeoButtonNode&gt; | LeoButtonNode {
    return element;
}

</t>
<t tx="felix.20200718164130.5">public getChildren(element?: LeoButtonNode): Thenable&lt;LeoButtonNode[]&gt; {
    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

        // call action to get get list, and convert to LeoButtonNode(s) array
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BUTTONS).then(p_package =&gt; {
            if (p_package &amp;&amp; p_package.buttons) {
                const w_list: LeoButtonNode[] = [];
                const w_buttons: LeoButton[] = p_package.buttons;
                if (w_buttons &amp;&amp; w_buttons.length) {
                    w_buttons.forEach((i_button: LeoButton) =&gt; {
                        w_list.push(new LeoButtonNode(i_button, this._leoIntegration));
                    });
                }
                return w_list;
            } else {
                return [];
            }
        });
    } else {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
}

</t>
<t tx="felix.20200718164130.6">public getParent(element: LeoButtonNode): ProviderResult&lt;LeoButtonNode&gt; | null {
    // Buttons are just a list, as such, entries are always child of root so return null
    return null;
}

</t>
<t tx="felix.20200718164509.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoDocument, Icon } from "./types";
import * as utils from "./utils";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718164509.2">/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
export class LeoDocumentNode extends vscode.TreeItem {

    // Context string is checked in package.json with 'when' clauses
    public contextValue: string;
    private _id: string;

    constructor(
        public documentEntry: LeoDocument,
        private _leoIntegration: LeoIntegration
    ) {
        super(documentEntry.name);
        // Setup this instance
        this._id = utils.getUniqueId();
        const w_isNamed: boolean = !!this.documentEntry.name;
        this.label = w_isNamed ? utils.getFileFromPath(this.documentEntry.name) : Constants.UNTITLED_FILE_NAME;
        this.tooltip = w_isNamed ? this.documentEntry.name : Constants.UNTITLED_FILE_NAME;
        this.command = {
            command: Constants.COMMANDS.SET_OPENED_FILE,
            title: '',
            arguments: [this.documentEntry.index]
        };
        // If this was created as a selected node, make sure it's selected as we may have opened/closed document
        if (this.documentEntry.selected) {
            this._leoIntegration.setDocumentSelection(this);
            this.contextValue = w_isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_UNTITLED;
        } else {
            this.contextValue = w_isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_UNTITLED;
        }
    }

    @others
}
</t>
<t tx="felix.20200718164635.1">// @ts-ignore
public get iconPath(): Icon {
    return this._leoIntegration.documentIcons[this.documentEntry.changed ? 1 : 0];
}

</t>
<t tx="felix.20200718164638.1">// @ts-ignore
public get id(): string {
    // Add prefix and suffix salt to numeric index to prevent accidental duplicates
    // Should be unique when refreshed
    // return this._id;
    return "c" + (this.documentEntry.changed ? "y" : "n") +
        "p" + this.documentEntry.index +
        "s" + this.documentEntry.name;
}

</t>
<t tx="felix.20200718165108.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoDocumentNode } from "./leoDocumentNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoDocument } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718165108.2">/**
 * * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
export class LeoDocumentsProvider implements vscode.TreeDataProvider&lt;LeoDocumentNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoDocumentNode | undefined&gt; = new vscode.EventEmitter&lt;LeoDocumentNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoDocumentNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718165108.3">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718165108.4">public getTreeItem(element: LeoDocumentNode): Thenable&lt;LeoDocumentNode&gt; | LeoDocumentNode {
    return element;
}

</t>
<t tx="felix.20200718165108.5">public getChildren(element?: LeoDocumentNode): Thenable&lt;LeoDocumentNode[]&gt; {

    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

        // call action to get get list, and convert to LeoDocumentNode(s) array
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_OPENED_FILES).then(p_package =&gt; {
            if (p_package &amp;&amp; p_package.files) {
                const w_list: LeoDocumentNode[] = [];
                const w_files: LeoDocument[] = p_package.files;

                let w_index: number = 0;

                if (w_files &amp;&amp; w_files.length) {
                    w_files.forEach((i_file: LeoDocument) =&gt; {
                        i_file.index = w_index;
                        w_list.push(new LeoDocumentNode(i_file, this._leoIntegration));
                        w_index++;
                    });
                }
                return w_list;
            } else {
                return [];
            }
        });
    } else {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
}

</t>
<t tx="felix.20200718165108.6">public getParent(element: LeoDocumentNode): ProviderResult&lt;LeoDocumentNode&gt; | null {
    // Leo documents are just a list, as such, entries are always child of root, so return null
    return null;
}

</t>
<t tx="felix.20200718165721.1"></t>
<t tx="felix.20200718170429.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import * as path from "path"; // TODO : Use this to have reliable support for window-vs-linux file-paths

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718170429.2">/**
 * * Handles opening of file browser when choosing which Leo file to open
 */
export class LeoFilesBrowser {

    private _fileBrowserActive: boolean = false;

    constructor(private _context: vscode.ExtensionContext) { }

    @others
}
</t>
<t tx="felix.20200718170429.3">/**
 * * Finds a folder to propose when opening the browse-for-leo-file chooser
 * @returns An Uri for path to a folder for initial opening
 */
private _getBestOpenFolderUri(): vscode.Uri {
    let w_openedFileEnvUri: vscode.Uri | boolean = false;
    let w_activeUri: vscode.Uri | undefined = undefined;

    if (vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders[0]) {
        w_activeUri = vscode.workspace.workspaceFolders[0].uri;
    }

    if (w_activeUri) {
        const w_defaultFolder = vscode.workspace.getWorkspaceFolder(w_activeUri);
        if (w_defaultFolder) {
            w_openedFileEnvUri = w_defaultFolder.uri; // Set as current opened document-path's folder
        }
    }
    if (!w_openedFileEnvUri) {
        w_openedFileEnvUri = vscode.Uri.file("~"); // TODO : set as home folder properly, this doesn't work
        // ! EXAMPLE WITH os : const homedir = require('os').homedir();
    }
    return w_openedFileEnvUri;
}

</t>
<t tx="felix.20200718170429.4">/**
 * * Open a file browser and let the user choose a Leo file or cancel the operation
 * @param p_saveAsFlag Optional flag that will ask for a 'save' path+filename
 * @returns A promise resolving to a chosen path string, or rejected with an empty string if cancelled
 */
public getLeoFileUrl(p_saveAsFlag?: boolean): Promise&lt;string&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve("");
    }
    this._fileBrowserActive = true;
    return new Promise((p_resolve, p_reject) =&gt; {
        const w_filters: { [name: string]: string[] } = {};
        w_filters[Constants.FILE_OPEN_FILTER_MESSAGE] = [Constants.FILE_EXTENSION];

        if (p_saveAsFlag) {
            // Choose file
            vscode.window.showSaveDialog({
                saveLabel: "Save Leo File",
                defaultUri: this._getBestOpenFolderUri(),
                filters: { 'Leo File': ['leo'] }
            })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // single string
                        p_resolve(p_chosenLeoFile.fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                    } else {
                        p_resolve(""); // not rejection - resolve empty string
                    }
                });
        } else {
            vscode.window
                .showOpenDialog({
                    canSelectMany: false,
                    defaultUri: this._getBestOpenFolderUri(),
                    canSelectFolders: false,
                    filters: w_filters
                })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // array instead of single string
                        p_resolve(p_chosenLeoFile[0].fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                    } else {
                        p_resolve("");
                    }
                });
        }
    });
}

</t>
<t tx="felix.20200718170712.1">import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { ArchivedPosition, Icon } from "./types"; // ArchivedPosition included to help debug

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718170712.2">/**
 * * Implementation of tree nodes for usage in a TreeDataProvider
 */
export class LeoNode extends vscode.TreeItem {

    public contextValue: string; // * Context string is checked in package.json with 'when' clauses

    public isRoot: boolean = false; // * for hoist/dehoist context flags purposes

    constructor(
        public label: string, // Node headline
        public gnx: string,
        public collapsibleState: vscode.TreeItemCollapsibleState, // Computed in receiver/creator
        public apJson: string, // Key for leo/python side of things
        public childIndex: number, // For debugging purposes
        public cloned: boolean,
        public dirty: boolean,
        public marked: boolean,
        public atFile: boolean,
        public hasBody: boolean,
        public u: any,
        private _leoIntegration: LeoIntegration,
        private _id: string
    ) {
        super(label, collapsibleState);
        this.contextValue = this._getNodeContextValue();
        this.command = {
            command: Constants.COMMANDS.SELECT_NODE,
            title: '',
            arguments: [this]
        };
    }

    // * TO HELP DEBUG
    // get description(): string {
    //     // * some smaller grayed-out text accompanying the main label
    //     const w_ap: ArchivedPosition = JSON.parse(this.apJson);
    //     return "child:" + w_ap.childIndex + " lvl:" + w_ap.level + " gnx:" + w_ap.gnx;
    // }

    // get description(): string {
    //     // * some smaller grayed-out text accompanying the main label
    //     return "id:" + this.id;
    // }

    @others
}
</t>
<t tx="felix.20200718170712.4">/**
 * * Set this node as the root for hoist/dehoist context flags purposes
 */
public setRoot(): void {
    this.isRoot = true;
    this._leoIntegration.leoStates.leoRoot = true; // Set this special global 'selected node' flag
    this.contextValue = this._getNodeContextValue();
}

</t>
<t tx="felix.20200718170712.5">private _getNodeContextValue(): string {
    // Start it with 'leoNodeMarked' or 'leoNodeUnmarked'
    let w_contextValue = Constants.CONTEXT_FLAGS.NODE_UNMARKED;
    if (this.marked) {
        w_contextValue = Constants.CONTEXT_FLAGS.NODE_MARKED;
    }
    // then append 'leoNodeAtFile' to existing if needed
    if (this.atFile) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ATFILE;
    }
    // then append 'leoNodeCloned' to existing if needed
    if (this.cloned) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_CLONED;
    }
    // and finally, check for 'root' too
    if (this.isRoot) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ROOT;
    } else {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_NOT_ROOT;
    }
    return w_contextValue;
}

</t>
<t tx="felix.20200718171837.1">// @ts-ignore
public get description(): string {
    // * some smaller grayed-out text accompanying the main label
    if (this.u) {
        return "\u{1F4CE} (" + Object.keys(this.u).length + ")";
    } else {
        // return "id:" + this.id; // ! debug test
        // return "gnx:" + this.gnx; // ! debug test
        return ""; // Falsy will not be shown
    }
}

</t>
<t tx="felix.20200718171849.1">// @ts-ignore
public get tooltip(): string {
    if (this.u) {
        //  "\ntotal keys is :" + Object.keys(this.u).length
        return this.label + "\n" +
            JSON.stringify(this.u, undefined, 2);
    } else {
        return this.label; // * Whole headline as tooltip
    }
}

</t>
<t tx="felix.20200718171854.1">// Optional id for the tree item that has to be unique across tree.
// The id is used to preserve the selection and expansion state of the tree item.
// If not provided, an id is generated using the tree item's label.
// Note that when labels change, ids will change and that selection and expansion state cannot be kept stable anymore.
// @ts-ignore
public get id(): string { return this._id; }

</t>
<t tx="felix.20200718171904.1">// @ts-ignore
public get iconPath(): Icon {
    // From Leo's leoNodes.py computeIcon function
    // 1=has Body, 2=marked, 4=cloned, 8=dirty
    let w_dirty: boolean = this._leoIntegration.config.invertNodeContrast ? !this.dirty : this.dirty;
    let w_icon: number =
        (+w_dirty &lt;&lt; 3) |
        (+this.cloned &lt;&lt; 2) |
        (+this.marked &lt;&lt; 1) |
        +this.hasBody;
    return this._leoIntegration.nodeIcons[w_icon];
}

</t>
<t tx="felix.20200718180428.1">import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import * as utils from './utils';
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoBridgePackage } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718180428.2">/**
 * * Leo outline implemented as a tree view with this TreeDataProvider
 */
export class LeoOutlineProvider implements vscode.TreeDataProvider&lt;LeoNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    @others
}
</t>
<t tx="felix.20200718180428.4">/**
 * * Refresh the whole outline
 */
public refreshTreeRoot(): void {
    // TODO : have this return a promise that resolves when the selected node is encountered by ap_to_p
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="felix.20200718180428.5">public getTreeItem(element: LeoNode): Thenable&lt;LeoNode&gt; | LeoNode {
    return element;
}

</t>
<t tx="felix.20200718180428.6">public getChildren(element?: LeoNode): Thenable&lt;LeoNode[]&gt; {
    if (!this._leoIntegration.leoStates.fileOpenedReady) {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
    if (element) {
        return this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.GET_CHILDREN,
            utils.buildNodeCommandJson(element.apJson)
        ).then((p_package: LeoBridgePackage) =&gt; {
            return this._leoIntegration.arrayToLeoNodesArray(p_package.children!);
        });
    } else {
        return this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.GET_CHILDREN, "{}"
        ).then((p_package: LeoBridgePackage) =&gt; {
            const w_nodes = this._leoIntegration.arrayToLeoNodesArray(p_package.children!);
            if (w_nodes &amp;&amp; w_nodes.length === 1) {
                w_nodes[0].setRoot();
            }
            return w_nodes;
        });
    }
}

</t>
<t tx="felix.20200718180428.7">public getParent(element: LeoNode): ProviderResult&lt;LeoNode&gt; | null {
    // * This method should be implemented in order to access reveal API.
    // ! But it should NOT have to be called if only trying to 'select' already revealed nodes
    // ! Called when revealing single nodes

    // ! Might be called if nodes are revealed while in vscode's refresh process
    // ! Parent asked for this way will go up till root and effectively refresh whole tree.
    // console.log('ERROR! GET PARENT CALLED! on: ', element.label);

    if (this._leoIntegration.leoStates.fileOpenedReady) {
        return this._leoIntegration.sendAction(
            Constants.LEOBRIDGE.GET_PARENT,
            element ? utils.buildNodeCommandJson(element.apJson) : "{}"
        ).then((p_package: LeoBridgePackage) =&gt; {
            if (p_package.node === null) {
                return null;
            } else {
                return this._leoIntegration.apToLeoNode(p_package.node!);
            }
        });
    } else {
        return null; // Default gives no parent
    }
}

</t>
<t tx="felix.20200718185403.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718185403.2">/**
 * * Statusbar indicator controller service
 */
export class LeoStatusBar {

    private _leoStatusBarItem: vscode.StatusBarItem;
    private _statusbarNormalColor = new vscode.ThemeColor(Constants.GUI.THEME_STATUSBAR);  // "statusBar.foreground"
    private _updateStatusBarTimeout: NodeJS.Timeout | undefined;
    private _string: string = ""; // Use this string with indicator, using this will replace the default from config

    // * Represents having focus on a leo tree, body or document panel to enable leo keybindings
    private _statusBarFlag: boolean = false;
    set statusBarFlag(p_value: boolean) {
        this._statusBarFlag = p_value;
    }
    get statusBarFlag(): boolean {
        return this._statusBarFlag;
    }

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._leoStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
        this._leoStatusBarItem.color = this._leoIntegration.config.statusBarColor;

        this._leoStatusBarItem.command = Constants.COMMANDS.STATUS_BAR;
        // this._leoStatusBarItem.command = "leointeg.test"; // just call test function for now to help debugging
        this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR + this._leoIntegration.config.statusBarString;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;
        _context.subscriptions.push(this._leoStatusBarItem);
        this._leoStatusBarItem.hide();
    }

    @others
}
</t>
<t tx="felix.20200718185403.3">/**
 * * Makes the statusbar indicator visible
 */
public show(): void {
    this._leoStatusBarItem.show();
}

</t>
<t tx="felix.20200718185403.4">/**
 * * Hides the statusbar indicator
 */
public hide(): void {
    this._leoStatusBarItem.hide();
}

</t>
<t tx="felix.20200718185403.5">/**
 * * Sets string to replace default from config &amp; refresh it
 */
public setString(p_string: string): void {
    this._string = p_string;
    this._updateLeoObjectIndicator();
}

</t>
<t tx="felix.20200718185403.6">/**
 * * Updates the status bar visual indicator visual indicator with optional debouncing delay
 * @param p_state True/False flag for On or Off status
 * @param p_debounceDelay Optional, in milliseconds
 */
public update(p_state: boolean, p_debounceDelay?: number, p_forced?: boolean): void {
    if (p_forced || (p_state !== this.statusBarFlag)) {
        this.statusBarFlag = p_state;
        if (p_debounceDelay) {
            this._updateLeoObjectIndicatorDebounced(p_debounceDelay);
        } else {
            this._updateLeoObjectIndicator();
        }
    }
}

</t>
<t tx="felix.20200718185403.7">/**
 * * Updates the status bar visual indicator flag in a debounced manner
 * @param p_delay number of milliseconds
 */
private _updateLeoObjectIndicatorDebounced(p_delay: number): void {
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }
    this._updateStatusBarTimeout = setTimeout(() =&gt; {
        this._updateLeoObjectIndicator();
    }, p_delay);
}

</t>
<t tx="felix.20200718185403.8">/**
 * * Updates the status bar visual indicator flag directly
 */
private _updateLeoObjectIndicator(): void {
    // Can be called directly, so clear timer if any
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }

    utils.setContext(Constants.CONTEXT_FLAGS.LEO_SELECTED, !!this.statusBarFlag);

    this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR +
        (this._string ? this._string : this._leoIntegration.config.statusBarString) + " " +
        (this._leoIntegration.leoStates.leoOpenedFileName ? utils.getFileFromPath(this._leoIntegration.leoStates.leoOpenedFileName) : Constants.UNTITLED_FILE_NAME);

    // Also check in constructor for statusBar properties (the createStatusBarItem call itself)
    if (this.statusBarFlag &amp;&amp; this._leoIntegration.leoStates.fileOpenedReady) {
        this._leoStatusBarItem.color = "#" + this._leoIntegration.config.statusBarColor;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;
    } else {
        this._leoStatusBarItem.color = this._statusbarNormalColor;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_OFF;
    }
}

</t>
<t tx="felix.20200718191946.1">import * as os from 'os';
import * as fs from 'fs';
import * as child from 'child_process';
import * as path from "path"; // TODO : Use this to have reliable support for window-vs-linux file-paths
import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from './leoIntegration';
var kill = require('tree-kill');


@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718191946.2">/**
 * * Leo bridge server service
 * Provides simple automatic leo bridge server startup functionality
 */
export class ServerService {
    // TODO : See #10 @boltex Problem starting the leo-bridge server automatically with anaconda/miniconda on windows
    // See https://github.com/yhirose/vscode-filtertext/blob/master/src/extension.ts#L196

    private _platform: string;
    private _isWin32: boolean;
    public usingPort: number = 0; // set to other than zero if server is started by leointeg itself

    /**
     * * Leo Bridge Server Process
     */
    private _serverProcess: child.ChildProcess | undefined;

    private _resolvePromise: ((value?: unknown) =&gt; void) | undefined;
    private _rejectPromise: ((reason?: any) =&gt; void) | undefined;

    private _isStarted: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._platform = os.platform();
        this._isWin32 = this._platform === "win32";
    }

    @others
}
</t>
<t tx="felix.20200718191946.4">/**
 * * Get command from settings or best command for the current OS
 * @param p_leoPythonCommand String command to start python on this computer
 * @returns A promise that resolves when the server is started, or that is rejected in case of problem while starting
 */
public startServer(p_leoPythonCommand: string, p_leoEditorPath: string, p_port: number): Promise&lt;any&gt; {

    /*
        * -----------------------------------------------------------------
        * Documentation for child_process.spawn(command[, args][, options])
        * -----------------------------------------------------------------

        The child_process.spawn() method spawns a new process
        using the given command, with command-line arguments in args.
        If omitted, args defaults to an empty array.

        If the shell option is enabled, do not pass unsanitized
        user input to this function. Any input containing shell
        metacharacters may be used to trigger arbitrary command execution.

        A third argument may be used to specify additional options, with these defaults:

        const defaults = {
            cwd: undefined,
            env: process.env
        };
    */

    if (!p_leoEditorPath) {
        return Promise.reject(Constants.USER_MESSAGES.LEO_PATH_MISSING);
    }

    let w_pythonPath = ""; // Command of child.spawn call

    this._leoIntegration.showTerminalPane(); // Show problems when running the server, if any.

    // If a leo server path is set then use it - otherwise use old script for now
    // OLD // const w_serverScriptPath = p_leoEditorPath ? p_leoEditorPath : this._context.extensionPath + Constants.OLD_SERVER_NAME;

    return utils.findNextAvailablePort(p_port).then((p_availablePort) =&gt; {
        if (!p_availablePort) {
            // vscode.window.showInformationMessage("Port " + p_port+" already in use.");
            return Promise.reject("Port " + p_port + " already in use.");
        }

        this.usingPort = p_availablePort;

        // Leo Editor installation path is mandatory - Start with Leo Editor's folder
        let w_serverScriptPath = p_leoEditorPath + "/leo/core";

        try {
            if (fs.existsSync(w_serverScriptPath + Constants.OLD_SERVER_NAME)) {
                //old file exists
                console.log('Found old server');
                w_serverScriptPath += Constants.OLD_SERVER_NAME;
            } else if (fs.existsSync(w_serverScriptPath + Constants.SERVER_NAME)) {
                //new file exists
                console.log('found leoserver.py');
                w_serverScriptPath += Constants.SERVER_NAME;
            } else {
                return Promise.reject(Constants.USER_MESSAGES.CANNOT_FIND_SERVER_SCRIPT);
            }
        } catch (p_err) {
            console.error(p_err);
            return Promise.reject(Constants.USER_MESSAGES.CANNOT_FIND_SERVER_SCRIPT);
        }

        if (p_leoPythonCommand &amp;&amp; p_leoPythonCommand.length) {
            // Start by running command (see executeCommand for multiple useful snippets)
            w_pythonPath = p_leoPythonCommand; // Set path
        } else {
            w_pythonPath = Constants.DEFAULT_PYTHON;
            if (this._isWin32) {
                w_pythonPath = Constants.WIN32_PYTHON;
            }
        }

        const w_serverStartPromise = new Promise((p_resolve, p_reject) =&gt; {
            // * Spawn a python child process for a leoBridge server
            this._resolvePromise = p_resolve;
            this._rejectPromise = p_reject;
        });

        // * Setup arguments: Order is important!

        let w_args: string[] = []; //  "\"" + w_serverScriptPath + "\"" // For on windows ??

        // * on windows, if the default py is used, make sure it's got a '-3'
        if (this._isWin32 &amp;&amp; w_pythonPath === "py") {
            w_args.push("-3");
        }

        // * The server script itself
        w_args.push(w_serverScriptPath);

        // * Add port
        w_args.push("-p " + this.usingPort);

        this._leoIntegration.addTerminalPaneEntry(
            'Starting server with command: ' +
            w_pythonPath + " " + w_args.join(" ")
        );

        this._serverProcess = child.spawn(w_pythonPath, w_args);

        if (this._serverProcess &amp;&amp; this._serverProcess.stdout) {
            // * Capture the python process output
            this._serverProcess.stdout.on("data", (p_data: string) =&gt; {
                this._gotTerminalData(p_data);
            });
        } else {
            console.error("No stdout");
        }
        if (this._serverProcess &amp;&amp; this._serverProcess.stderr) {
            // * Capture other python process outputs
            this._serverProcess.stderr.on("data", (p_data: string) =&gt; {
                console.log(`stderr: ${p_data}`);
                this._isStarted = false;
                utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);
                this._serverProcess = undefined;
                if (this._rejectPromise) {
                    this._rejectPromise(`stderr: ${p_data}`);
                }
            });
        } else {
            console.error("No stderr");
        }
        if (this._serverProcess) {
            this._serverProcess!.on("close", (p_code: any) =&gt; {
                console.log(`leoBridge exited with code ${p_code}`);
                this._isStarted = false;
                utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);
                this._serverProcess = undefined;
                if (this._rejectPromise) {
                    this._rejectPromise(`leoBridge exited with code ${p_code}`);
                }
            });
        }

        return w_serverStartPromise;
    });

}

</t>
<t tx="felix.20200718192351.1">import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { LeoPackageStates } from "./types";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718192411.1">/**
 * * Global states service
 * Holds state flags used to restrict command availability and icon visibility
 * Changes UI by changing vscode's context variables
 */
export class LeoStates {

    @others
}
</t>
<t tx="felix.20200718192411.2">public setSelectedNodeFlags(p_node: LeoNode): void {
    this.leoRoot = false; // * RESET the root flag : It is set by vscode instead right after getting list of children for root of outline
    this.leoMarked = p_node.marked;
    this.leoCloned = p_node.cloned;
    this.leoDirty = p_node.dirty;
    this.leoEmpty = !p_node.hasBody;
    this.leoChild = !(p_node.collapsibleState === vscode.TreeItemCollapsibleState.None);
    this.leoAtFile = p_node.atFile;
}

</t>
<t tx="felix.20200718192411.3">public setLeoStateFlags(p_states: LeoPackageStates): void {
    this.leoChanged = p_states.changed;
    this.leoCanUndo = p_states.canUndo;
    this.leoCanRedo = p_states.canRedo;
    this.leoCanDemote = p_states.canDemote;
    this.leoCanPromote = p_states.canPromote;
    this.leoCanDehoist = p_states.canDehoist;
}
</t>
<t tx="felix.20200718193219.1">// * Connected to a Leo bridge server
private _leoBridgeReady: boolean = false;
get leoBridgeReady(): boolean {
    return this._leoBridgeReady;
}
set leoBridgeReady(p_value: boolean) {
    this._leoBridgeReady = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, p_value);
}

</t>
<t tx="felix.20200718193222.1">// * A Leo file is opened
private _fileOpenedReady: boolean = false; // Sets context flag along with treeview title
get fileOpenedReady(): boolean {
    return this._fileOpenedReady;
}
set fileOpenedReady(p_value: boolean) {
    this._fileOpenedReady = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, p_value);
    this._leoIntegration.setTreeViewTitle(
        p_value ? Constants.GUI.TREEVIEW_TITLE : Constants.GUI.TREEVIEW_TITLE_INTEGRATION
    );
}

</t>
<t tx="felix.20200718193226.1">// * Currently opened Leo file path and name, empty string if new unsaved file.
private _leoOpenedFileName: string = "";
get leoOpenedFileName(): string {
    return this._leoOpenedFileName;
}
set leoOpenedFileName(p_name: string) {
    if (p_name &amp;&amp; p_name.length) {
        this._leoOpenedFileName = p_name;
        utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, true);
    } else {
        this._leoOpenedFileName = "";
        utils.setContext(Constants.CONTEXT_FLAGS.TREE_TITLED, false);
    }
}

</t>
<t tx="felix.20200718193230.1">// * 'states' flags for currently opened tree view
private _leoChanged: boolean = false;
get leoChanged(): boolean {
    return this._leoChanged;
}
set leoChanged(p_value: boolean) {
    if (this._leoChanged !== p_value) {
        // Refresh Documents Panel
        this._leoIntegration.refreshDocumentsPane();
    }
    this._leoChanged = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CHANGED, p_value);
}

</t>
<t tx="felix.20200718193233.1">private _leoCanUndo: boolean = false;
get leoCanUndo(): boolean {
    return this._leoCanUndo;
}
set leoCanUndo(p_value: boolean) {
    this._leoCanUndo = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_UNDO, p_value);
}

</t>
<t tx="felix.20200718193235.1">private _leoCanRedo: boolean = false;
get leoCanRedo(): boolean {
    return this._leoCanRedo;
}
set leoCanRedo(p_value: boolean) {
    this._leoCanRedo = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_REDO, p_value);
}

</t>
<t tx="felix.20200718193238.1">private _leoCanDemote: boolean = false;
get leoCanDemote(): boolean {
    return this._leoCanDemote;
}
set leoCanDemote(p_value: boolean) {
    this._leoCanDemote = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEMOTE, p_value);
}

</t>
<t tx="felix.20200718193241.1">private _leoCanPromote: boolean = false;
get leoCanPromote(): boolean {
    return this._leoCanPromote;
}
set leoCanPromote(p_value: boolean) {
    this._leoCanPromote = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_PROMOTE, p_value);
}

</t>
<t tx="felix.20200718193244.1">private _leoCanDehoist: boolean = false;
get leoCanDehoist(): boolean {
    return this._leoCanDehoist;
}
set leoCanDehoist(p_value: boolean) {
    this._leoCanDehoist = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_CAN_DEHOIST, p_value);
}

</t>
<t tx="felix.20200718193338.1">// * 'states' flags about current selection, for visibility and commands availability
private _leoMarked: boolean = false;
get leoMarked(): boolean {
    return this._leoMarked;
}
set leoMarked(p_value: boolean) {
    this._leoMarked = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_value);
}

</t>
<t tx="felix.20200718193341.1">private _leoCloned: boolean = false;
get leoCloned(): boolean {
    return this._leoCloned;
}
set leoCloned(p_value: boolean) {
    this._leoCloned = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CLONE, p_value);
}

</t>
<t tx="felix.20200718193343.1">private _leoDirty: boolean = false;
get leoDirty(): boolean {
    return this._leoDirty;
}
set leoDirty(p_value: boolean) {
    this._leoDirty = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_DIRTY, p_value);
}

</t>
<t tx="felix.20200718193348.1">private _leoEmpty: boolean = false;
get leoEmpty(): boolean {
    return this._leoEmpty;
}
set leoEmpty(p_value: boolean) {
    this._leoEmpty = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_EMPTY, p_value);
}

</t>
<t tx="felix.20200718193350.1">private _leoChild: boolean = false;
get leoChild(): boolean {
    return this._leoChild;
}
set leoChild(p_value: boolean) {
    this._leoChild = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_CHILD, p_value);
}

</t>
<t tx="felix.20200718193353.1">private _leoAtFile: boolean = false;
get leoAtFile(): boolean {
    return this._leoAtFile;
}
set leoAtFile(p_value: boolean) {
    this._leoAtFile = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_ATFILE, p_value);
}

</t>
<t tx="felix.20200718193403.1">// * Special is-root 'state' flag about current selection, for visibility and commands availability
private _leoRoot: boolean = false;
get leoRoot(): boolean {
    return this._leoRoot;
}
set leoRoot(p_value: boolean) {
    this._leoRoot = p_value;
    utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_ROOT, p_value);
}

</t>
<t tx="felix.20200718193500.1">constructor(
    private _context: vscode.ExtensionContext,
    private _leoIntegration: LeoIntegration
) { }

</t>
<t tx="felix.20200718193719.1"></t>
<t tx="felix.20200718193731.1"></t>
<t tx="felix.20200718194857.1">import * as vscode from "vscode";
import { LeoNode } from "./leoNode";

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718194857.10">/**
 * * Main interface for JSON sent from Leo back to leoInteg
 */
export interface LeoBridgePackage {
    // * Common to all result packages
    id: number;
    // * Possible answers from a "Constants.LEOBRIDGE" command
    gnx?: string[]; // get_all_gnx
    len?: number; // get_body_length
    body?: string; // get_body
    buttons?: LeoButton[]; // get_buttons
    commands?: vscode.QuickPickItem[]; // getCommands
    filename?: string; // set_opened_file, open_file(s), ?close_file
    files?: LeoDocument[]; // get_all_open_commanders
    focus?: string; // find_next, find_previous
    found?: boolean // find_next, find_previous
    index?: number; // get_all_open_commanders
    language?: string; // get_body_states
    node?: ArchivedPosition; // get_parent, set_opened_file, open_file(s), ?close_file
    children?: ArchivedPosition[]; // get_children
    searchSettings?: LeoGuiFindTabManagerSettings // get_search_settings
    selection?: BodySelectionInfo; // get_body_states
    states?: LeoPackageStates; // get_ui_states
    total?: number; // set_opened_file, open_file(s), close_file
}

</t>
<t tx="felix.20200718194857.11">/**
 * * Leo document structure used in the 'Opened Leo Documents' tree view provider sent back by the server
 */
export interface LeoDocument {
    name: string;
    index: number;
    changed: boolean;
    selected: boolean;
}

</t>
<t tx="felix.20200718194857.12">/**
 * * Leo '@button' structure used in the '@buttons' tree view provider sent back by the server
 */
export interface LeoButton {
    name: string;
    index: string; // STRING KEY
}

</t>
<t tx="felix.20200718194857.13">/**
 * * Icon path names used in leoNodes for rendering in treeview
 */
export interface Icon {
    light: string;
    dark: string;
}

</t>
<t tx="felix.20200718194857.14">/**
 * * LeoBody virtual file time information object
 */
export interface BodyTimeInfo {
    ctime: number;
    mtime: number;
}

</t>
<t tx="felix.20200718194857.15">/**
 * * Parameter structure used in the 'runSaveFileDialog' equivalent when asking user input
 */
export interface showSaveAsDialogParameters {
    // See TODO in leoAsync.ts
    initialFile: string;
    title: string;
    message: string;
    filetypes: string[];
    defaultExtension: string;
}

</t>
<t tx="felix.20200718194857.16">/**
 * * Parameter structure used in the 'runAskYesNoDialog' equivalent when asking user input
 */
export interface runAskYesNoDialogParameters {
    ask: string;
    message: string;
    yes_all: boolean;
    no_all: boolean;
}

</t>
<t tx="felix.20200718194857.17">/**
 * * Parameter structure used in the 'runAskOkDialog' equivalent when showing a warning
 */
export interface runWarnMessageDialogParameters {
    warn: string;
    message: string;
}

</t>
<t tx="felix.20200718194857.18">/**
 * * Parameter structure for non-blocking info message about detected file changes
 */
export interface runInfoMessageDialogParameters {
    message: string;
}

</t>
<t tx="felix.20200718194857.19">/**
 * * Used in showAskModalDialog to get answer from user interaction
 */
export interface AskMessageItem extends vscode.MessageItem {
    value: string;
}

</t>
<t tx="felix.20200718194857.2">/**
 * * Types of the various JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
export interface ConfigMembers {
    checkForChangeExternalFiles: string;
    defaultReloadIgnore: string;
    leoTreeBrowse: boolean;
    treeKeepFocus: boolean;
    treeKeepFocusWhenAside: boolean;
    statusBarString: string;
    statusBarColor: string;
    treeInExplorer: boolean;
    showOpenAside: boolean;
    showEditOnNodes: boolean;
    showArrowsOnNodes: boolean;
    showAddOnNodes: boolean;
    showMarkOnNodes: boolean;
    showCloneOnNodes: boolean;
    showCopyOnNodes: boolean;

    showEditionOnBody: boolean; // clone delete insert(s)
    showClipboardOnBody: boolean; // cut copy paste(s)
    showPromoteOnBody: boolean; // promote demote
    showExecuteOnBody: boolean; // extract(s)
    showExtractOnBody: boolean;
    showImportOnBody: boolean;
    showRefreshOnBody: boolean;
    showHoistOnBody: boolean;
    showMarkOnBody: boolean;
    showSortOnBody: boolean;

    invertNodeContrast: boolean;
    leoEditorPath: string;
    leoPythonCommand: string;
    startServerAutomatically: boolean;
    connectToServerAutomatically: boolean;
    connectionAddress: string;
    connectionPort: number;
}

</t>
<t tx="felix.20200718194857.20">/**
 * * Used in switch Leo document to get answer from user interaction
 */
export interface ChooseDocumentItem extends vscode.QuickPickItem {
    value: number;
}

</t>
<t tx="felix.20200718194857.3">/**
 * * When refreshing the outline and getting to Leo's selected node
 */
export const enum RevealType {
    NoReveal = 0, // In apToLeoNode conversion, If if the global revealType is "NoReveal" and its the selected node, re-use the old id
    Reveal,
    RevealSelect,
    RevealSelectFocus
}

</t>
<t tx="felix.20200718194857.4">/**
 * * Required Refresh Dictionary of "elements to refresh" flags
 */
export interface ReqRefresh {
    node?: boolean; // Reveal received selected node (Navigation only, no tree change)
    tree?: boolean; // Tree needs refresh
    body?: boolean; // Body needs refresh
    scroll?: boolean; // Body needs to scroll to selection
    states?: boolean; // States needs refresh (changed, canUndo, canRedo, canDemote, canPromote, canDehoist)
    buttons?: boolean; // Buttons needs refresh
    documents?: boolean; // Documents needs refresh
}

</t>
<t tx="felix.20200718194857.5">/**
 * * Stackable front end commands
 */
export interface UserCommand {
    action: string; // String from Constants.LEOBRIDGE, which are commands for leobridgeserver
    node?: LeoNode | undefined;  // We can START a stack with a targeted command
    name?: string | undefined; // If a string is required, for headline, etc.
    refreshType: ReqRefresh; // Minimal refresh level required by this command
    fromOutline: boolean; // Focus back on outline instead of body
    keepSelection?: boolean; // Should bring back selection on node prior to command
    resolveFn?: (result: any) =&gt; void; // call that with an answer from python's (or other) side
    rejectFn?: (reason: any) =&gt; void; // call if problem is encountered
}

</t>
<t tx="felix.20200718194857.6">
/**
 * * Stackable leoBridge actions to be performed by Leo
 */
export interface LeoAction {
    parameter: string; // to pass along with action to python's side
    deferredPayload?: any | undefined; // Used when the action already has a return value ready but is also waiting for python's side
    resolveFn: (result: any) =&gt; void; // call that with an answer from python's (or other) side
    rejectFn: (reason: any) =&gt; void; // call if problem is encountered
}

</t>
<t tx="felix.20200718194857.7">/**
 * * Simple 'string log entry' package format
 */
export interface LeoLogEntry {
    log: string;
}

</t>
<t tx="felix.20200718194857.8">/**
 * * ArchivedPosition format package from Leo's leoflexx.py
 */
export interface ArchivedPosition {
    hasBody: boolean;       // bool(p.b),
    hasChildren: boolean;   // p.hasChildren()
    childIndex: number;     // p._childIndex
    cloned: boolean;        // p.isCloned()
    dirty: boolean;         // p.isDirty()
    expanded: boolean;      // p.isExpanded()
    gnx: string;            // p.v.gnx
    level: number;          // p.level()
    headline: string;       // p.h
    marked: boolean;        // p.isMarked()
    atFile: boolean         // p.isAnyAtFileNode():
    selected: boolean;      // p == commander.p
    u?: any;               // User Attributes
    stack: {
        gnx: string;        // stack_v.gnx
        childIndex: number; // stack_childIndex
        headline: string;   // stack_v.h
    }[];                    // for (stack_v, stack_childIndex) in p.stack]
}

</t>
<t tx="felix.20200718195558.1">import * as vscode from "vscode";
import * as murmur from "murmurhash-js";
import { Constants } from "./constants";
import { Icon, UserCommand, ArchivedPosition } from "./types";
import { LeoNode } from "./leoNode";
var portfinder = require('portfinder');

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20200718195558.10">/**
 * * Builds a 'Leo Scheme' vscode.Uri from a gnx (or strings like 'LEO BODY' or empty strings to decorate breadcrumbs)
 * with a scheme header like "leo:/" or 'more:/'
 * @param p_str leo node gnx strings are used to build Uri
 * @returns A vscode 'Uri' object
 */
export function strToLeoUri(p_str: string): vscode.Uri {
    return vscode.Uri.parse(Constants.URI_SCHEME_HEADER + p_str);
}

</t>
<t tx="felix.20200718195558.11">/**
 * * Gets the gnx, (or another string like 'LEO BODY' or other), from a vscode.Uri object
 * @param p_uri Source uri to extract from
 * @returns The string source that was used to build this Uri
 */
export function leoUriToStr(p_uri: vscode.Uri): string {
    // TODO : Use length of a constant or something other than 'fsPath'
    // For now, just remove the '/' (or backslash on Windows) before the path string
    return p_uri.fsPath.substr(1);
}

</t>
<t tx="felix.20200718195558.12">/**
 * * Sets a vscode context variable with 'vscode.commands.executeCommand' &amp; 'setContext'
 * @param p_key Key string name such as constants 'bridgeReady' or 'treeOpened', etc.
 * @param p_value Value to be assigned to the p_key 'key'
 * @returns A Thenable that is returned by the executeCommand call
 */
export function setContext(p_key: string, p_value: any): Thenable&lt;unknown&gt; {
    return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.SET_CONTEXT, p_key, p_value);
}

</t>
<t tx="felix.20200718195558.2">/**
 * * Build a string for representing a number that's 2 digits wide, padding with a zero if needed
 * @param p_number Between 0 and 99
 * @returns a 2 digit wide string representation of the number, left padded with zeros as needed.
 */
export function padNumber2(p_number: number): string {
    return ("0" + p_number).slice(-2);
}

</t>
<t tx="felix.20200718195558.3">/**
 * * Build all possible strings for node icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array of the 16 vscode node icons used in this vscode expansion
 */
export function buildNodeIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return Array(16).fill("").map((p_val, p_index) =&gt; {
        return {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT)
        };
    });
}

</t>
<t tx="felix.20200718195558.4">/**
 * * Build all possible strings for documents icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildDocumentIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_DOCUMENT),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_DOCUMENT)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_DOCUMENT_DIRTY),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_DOCUMENT_DIRTY)
        }
    ];
}

</t>
<t tx="felix.20200718195558.6">/**
 * * Builds and returns a JSON string with 'node' and 'name' members
 * @param p_nodeJson Targeted tree node in the proper JSON format
 * @param p_command from which to extract possible name and 'keep selection' flag
 * @returns JSON string suitable for being a parameter of a leoBridge action
 */
export function buildNodeCommandJson(p_nodeJson: string, p_command?: UserCommand): string {
    let w_json = "{\"ap\":" + p_nodeJson; // already json
    if (p_command &amp;&amp; p_command.name) {
        w_json += ", \"name\": " + JSON.stringify(p_command.name);
    }
    if (p_command &amp;&amp; p_command.keepSelection) {
        w_json += ", \"keep\": true";
    }
    // TODO : Generalize this function to send any other members of p_command / other members
    w_json += "}";
    return w_json;
}

</t>
<t tx="felix.20200718195558.7">/**
 * * Extracts the file name from a full path, such as "foo.bar" from "/abc/def/foo.bar"
 * @param p_path Full path such as "/var/drop/foo/boo/moo.js" or "C:\Documents and Settings\img\recycled log.jpg"
 * @returns file name string such as "moo.js" or "recycled log.jpg""
 */
export function getFileFromPath(p_path: string): string {
    return p_path.replace(/^.*[\\\/]/, '');
}

</t>
<t tx="felix.20200718195558.8">/**
 * * Checks if a node would become dirty if it were to now have body content at all
 * @param p_node LeoNode from vscode's outline
 * @param p_newHasBody Flag to signify presence of body content, to be compared with its current state
 * @returns True if it would change the icon with actual body content, false otherwise
 */
export function isIconChangedByEdit(p_node: LeoNode, p_newHasBody: boolean): boolean {
    if (!p_node.dirty || (p_node.hasBody === !p_newHasBody)) {
        return true;
    }
    return false;
}

</t>
<t tx="felix.20200718195558.9">/**
 * * Checks if a string is formatted as a valid rrggbb color code.
 * @param p_hexString hexadecimal 6 digits string, without leading '0x'
 * @returns True if the string is a valid representation of an hexadecimal 6 digit number
 */
export function isHexColor(p_hexString: string): boolean {
    return typeof p_hexString === 'string'
        &amp;&amp; p_hexString.length === 6
        &amp;&amp; !isNaN(Number('0x' + p_hexString));
}

</t>
<t tx="felix.20200718220811.1"></t>
<t tx="felix.20200718220818.1">@language md
@tabwidth -4
# ![LeoEditor](https://raw.githubusercontent.com/boltex/leointeg/master/resources/leoapp.png) Leo for VS Code

## Literate Programming with _Directed Acyclic Graphs_ ([dag](https://en.wikipedia.org/wiki/Directed_acyclic_graph))

### Break your code down into sections structured as an outline, to derive or parse back your files

&gt; Leo is a fundamentally different way of using and organizing data, programs and scripts.\
&gt; [View Preview Video](https://www.youtube.com/watch?v=SYwlfdEukD4) 🎥

See Leo, the Literate Editor with Outline, at [leoeditor.com](https://leoeditor.com/)
or on [github](https://github.com/leo-editor/leo-editor), and VS Code at [code.visualstudio.com](https://code.visualstudio.com/).

![Screenshot](https://raw.githubusercontent.com/boltex/leointeg/master/resources/animated-screenshot.gif)

@others

---

**🤍 To sponsor, donate or contribute see my [user page](https://boltex.github.io/) 🦁 Enjoy!**
</t>
<t tx="felix.20200718220833.1">@language md
@tabwidth -4
# Change Log

## 0.1.17

- Saves recently opened Leo files list per workspace, instead of globally.
- Changed the default visible command icons above the body pane. Also makes sure 'settings' is visible.
- Added global zoom level and editor font-size in the LeoInteg settings panel to help change the body &amp; outline font sizes.
- Server now opens modal dialogs for saving dirty documents on exit.

@others
</t>
<t tx="felix.20200718220833.2">@language md
@tabwidth -4
# How to install and run the development version

Thanks for trying out the development version of LeoInteg! :sunglasses: Contributions and pull requests are more than welcome!

@others
</t>
<t tx="felix.20200718221645.1">## Requirements

- Having Leo Editor installed.
  _Install with :_ `pip install leo`\
   _Or with git._ (See [Installing Leo with git](http://leoeditor.com/installing.html#installing-leo-with-git))

- Having the Websocket Python Library installed.
  _Install with :_ `pip install websockets`\
  (See [websockets.readthedocs.io/en/stable/intro.html](https://websockets.readthedocs.io/en/stable/intro.html))

</t>
<t tx="felix.20200718222026.1">## Beta Version Installation

&gt; While in beta, this extension isn't available in the microsoft store, nor the extension panel yet. But you can drag the extension file onto it.

- Get the leointeg extension file at
  [boltex.github.io](https://boltex.github.io/),
  then **drag-and-drop** that '.vsix' file over the
  extension panel of VSCode's sidebar. (**on windows use the 'install from VSIX' command**)

- In addition to the above requirements,
  **use Leo's 'devel' branch**
  (This is temporary until Leo's 6.4 release)

</t>
<t tx="felix.20200718222035.1">## Features

- UI controls such as a **Leo Outline** in the explorer view, or as a standalone sidebar, **body pane**, **opened documents selector**, **find panel**, along with a **Log Window** and **Terminal** [output channels](https://code.visualstudio.com/api/extension-capabilities/common-capabilities#output-channel).
- Keybindings that match those of the Leo editor, including arrow keys behavior for outline keyboard navigation. (Can be turned off with the **'Leo Tree Browsing'** option setting)
- A **welcome screen** that also gives access to this extension's **settings**.
- **Derived files change detection**. See [External Files](#derive-external-files) below for more details
- **'@button' panel** for [creating your own commands with @buttons](https://leoeditor.com/tutorial-tips.html#use-button-nodes)
- Access **Leo commands** with context menus, outline-node hover icons, keyboard shortcuts, the command palette **`Ctrl+Shift+P`** or Leo's minibuffer **`Alt+X`**:
  - Open body panes to the side in any 'column'
  - Outline editing commands
  - Find operations
  - Clipboard operations
  - Undo/Redo commands

![Menu](https://raw.githubusercontent.com/boltex/leointeg/master/resources/context-hover-menus.png)

</t>
<t tx="felix.20200718222043.1">## Keybindings

| Outline Commands           |     |                  |                  |
| :------------------------- | :-- | :--------------- | :--------------- |
| `Ctrl + I`                 | or  | `Shift + Insert` | Insert Node      |
| `Ctrl + H`                 |     |                  | Edit Headline    |
| `Ctrl + Shift + C`         |     |                  | Copy Node        |
| `Ctrl + Shift + X`         |     |                  | Cut Node         |
| `Ctrl + Shift + V`         |     |                  | Paste Node       |
| `Ctrl + Shift + Backspace` | or  | `Delete`         | Delete Node      |
| `Ctrl + Backquote`         |     |                  | Clone Node       |
| `Ctrl + {`                 | and | `Ctrl + }`       | Promote / Demote |

| Moving Outline Nodes |     |                         |                    |
| :------------------- | :-- | :---------------------- | :----------------- |
| `Ctrl + U`           | or  | `Shift [+ Alt] + Up`    | Move Outline Up    |
| `Ctrl + D`           | or  | `Shift [+ Alt] + Down`  | Move Outline Down  |
| `Ctrl + L`           | or  | `Shift [+ Alt] + Left`  | Move Outline Left  |
| `Ctrl + R`           | or  | `Shift [+ Alt] + Right` | Move Outline Right |

_Move Outline commands need the 'Alt' key modifier only when focus is on body pane._

| Common Operations  |     |           |                     |
| :----------------- | :-- | :-------- | :------------------ |
| `Alt + -`          |     |           | Contract All        |
| `Ctrl + M`         |     |           | Mark / Unmark       |
| `Ctrl + B`         |     |           | Execute Script      |
| `Ctrl + T`         |     |           | Toggle Outline/Body |
| `Tab`              | or  | `Alt + D` | Focus on Body       |
| `Alt + T`          |     |           | Focus on Outline    |
| `Ctrl + Shift + D` |     |           | Extract             |
| `Ctrl + Shift + N` |     |           | Extract Names       |
| `Alt + A`          |     |           | Sort Siblings       |
| `Ctrl + F`         |     |           | Start Search        |
| `F3`               |     |           | Find Next           |
| `F2`               |     |           | Find Previous       |

| Tree Navigation    |     |                 |                          |
| :----------------- | :-- | :-------------- | :----------------------- |
| `Alt + Home`       | or  | `Home` \*       | Go To First Visible Node |
| `Alt + End`        |     |                 | Go To Last Sibling       |
|                    |     | `End` \*        | Go To Last Visible Node  |
| `Alt + N`          |     |                 | Go To Next Clone         |
| `Alt + Arrow Keys` | or  | `Arrow Keys` \* | Browse Tree              |
| `Ctrl + T`         |     |                 | Switch Tree/Body Focus   |
| `Tab`              |     |                 | Focus from Tree to Body  |
| `Alt + G`          |     |                 | Go To Global Line        |

\* _With the **'Leo Tree Browsing'** setting enabled by default, all arrows and numeric keypad keys change the outline's selection directly_

---

</t>
<t tx="felix.20200718222048.1">## Derive External Files

Use the **Save Leo File** command to derive external files.

Leo will detect derived file changes and will ask to either **refresh from disk** or **ignore the changes**.

![derive files](https://raw.githubusercontent.com/boltex/leointeg/master/resources/derived-file.gif)

</t>
<t tx="felix.20200718222053.1">## Automate Synchronization

The **change detection** process can be automated to always refresh, or ignore file changes: A **notification** will inform you of the action taken instead.

![auto sync](https://raw.githubusercontent.com/boltex/leointeg/master/resources/auto-sync.gif)

</t>
<t tx="felix.20200718222058.1">## Status Bar Indicator

A customizable keyboard status bar indicator is shown when this extension is activated.
It will turn orange (or your choice of text and color), when leo's **keyboard shortcuts** are active.
This occurs when an outline node or a body pane has focus:

![Statusbar](https://raw.githubusercontent.com/boltex/leointeg/master/resources/statusbar-keyboard.gif)

</t>
<t tx="felix.20200718222102.1">## Extension Settings

### Open the command palette `Ctrl+Shift+P` and start typing `leo settings` to access LeoInteg's welcome/settings screen

&gt; _(Changes are auto-saved to the user's profile after 0.5 seconds)_

- Control the visibility of the outline pane in the explorer view.
- Decide how and when to refresh and synchronize content when derived (external) file are modified.
- Show additional icons on outline nodes (Move, delete, mark, copy, paste...)
- Choose to either focus on the body pane, or keep focus in the outline when a node is selected.
- Hide or show the "Open on the side" command in the context menu to open a node beside the active editor
- Set preferences for setting the address and port, and for automatically starting, and/or connecting, to a Leo Bridge server.

![Settings](https://raw.githubusercontent.com/boltex/leointeg/master/resources/welcome-settings.gif)

</t>
<t tx="felix.20200718222108.1">## Issues

Main issues are listed below. See the repository's [Issues Page](https://github.com/boltex/leointeg/issues) to submit issues.

### Keybindings Conflicts Resolution

If you have a keybinding conflict that you would like to be resolved by Leo when the focus is on the body pane, add **`&amp;&amp; resourceScheme != 'leo'`** to the keybinding's "_when_" condition. (Use **`Ctrl+K Ctrl+S`** in vscode to open the Keyboards Shortcuts panel)

### Linux Keybindings

If you're experiencing trouble with the keyboard shortcuts for
the 'Clone Node' or the 'Promote' and 'Demote' commands,
use **"keyboard.dispatch": "keyCode"** in your settings and restart vscode.
See [Troubleshoot Linux Keybindings](https://github.com/microsoft/vscode/wiki/Keybinding-Issues#troubleshoot-linux-keybindings)
for more information.

### Move Outline Keyboard Commands

For some users, the **`Alt+[Arrow Keys]`**, **`Ctrl+D`** and **`Ctrl+T`** keybinding are already assigned.
To help with this conflict, tree-browsing, outline-move keyboard commands, and switch focus command will only trigger
with the additional condition of having no text selection in the editor.
So select at least one character to use the previously assigned original keyboard commands while focus is in the body pane.

&gt; This extension is still in development, so please refer to its [issue tracker](https://github.com/boltex/leointeg/issues) to learn more about its intended features, or to contribute with additional information if you encounter other issues yourself.

</t>
<t tx="felix.20200718222113.1">## How It Works

Leo integration into VS Code is done by starting a python server script and connecting to it via a [websocket](https://websockets.readthedocs.io/en/stable/intro.html) to exchange JSON data. That script leverages [leoBridge](https://leoeditor.com/leoBridge.html) and re-uses code from the leoflexx.py plugin.

The outline pane is made by implementing a [TreeDataProvider for vscode's TreeView API](https://code.visualstudio.com/api/extension-guides/tree-view#tree-view-api-basics), while the body-pane's _virtual document_ is made by [implementing a filesystem provider](https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api) and using the node's gnx as identifier.

---

</t>
<t tx="felix.20200718222118.1">## Acknowledgments

### _Thanks to_

- [Edward K. Ream](https://github.com/edreamleo) creator of the [Leo Editor](https://leoeditor.com/)
- [Eric Amodio](https://github.com/eamodio) for the [welcome screen templates](https://github.com/eamodio/vscode-gitlens/tree/master/src/webviews)
- [Vitalije](https://github.com/vitalije) for his contributions and support
- [Arjan](https://github.com/ar-jan) for his suggestions and ideas
</t>
<t tx="felix.20200718222417.1">## 0.1.12

- Added support for multiple opened files along with the 'new', 'Close', 'Save-As' commands.
- Improved the icons and commands, which are visible, or invisible depending on context.
- Added 'tree view' listing the opened Leo documents which is available in the Leo view, and the explorer view.
- Added basic leonine syntax coloring. (No specific \@languages yet)
- Added selection support to the 'Execute-Script' command.

</t>
<t tx="felix.20200718222419.1">## 0.1.11

- Fixed undo operation for the _insert_ and _rename_ commands (Some other commands may still need fixes to their 'undo' support)
- Fixed crashing when editing body pane under Leo 6.2.

</t>
<t tx="felix.20200718222422.1">## 0.1.10

- Added more [welcome content](https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content) in outlines panes that have not yet opened a tree for starting a server, connecting to it, and added content to help with automation settings.
- Changed the starting default configuration setting for starting and connecting to the leoBridge server script to false.
- Made starting and connecting to the leoBridge server script easier to access in the interface, and in the welcome/settings webview.
- Added new CONTRIBUTING.md markdown file for running the development version of the leoInteg extension.
- Closes [#44](https://github.com/boltex/leointeg/issues/44)

</t>
<t tx="felix.20200718222425.1">## 0.1.9

- Added new compilation configuration (server, extension, or both) to help debugging.
- Support async output from leoBridge, for log pane and other events.
- External file change detection with modal dialogs matching Leo's gui dialogs.
- Added config options to bypass derived files change detection dialogs with defaults, allowing automatic synchronization of derived files in both directions.
- Added support for redo, refresh from disk and many any other core Leo commands and operations.
- Added support for rapid outline edition command entry, including 'insert node' command **`Ctrl+I`** and for replacing focus on relevant elements to mimic actual Leo interface workflow.
- Added [welcome content](https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content) in outlines panes that have not yet opened a tree to help with connecting and opening
- Replaced body-editor content transfer logic and removed the related option in the expansion's settings. The body is sent to Leo when appropriate without need of a timed delay.
- _REMOVED FEATURE_ Rolled back 'multi-body' feature for simultaneous body panes from different gnx. Body panes from the same gnx are still available.

</t>
<t tx="felix.20200718222427.1">## 0.1.8

- Extension now built with webpack. [As recommended by vsCode's extension guidelines](https://code.visualstudio.com/api/working-with-extensions/bundling-extension#using-webpack)
- Added a 'Welcome Screen' webview (also compiled by webpack from html, scss and ts files) to show a greeting with basic info, and provide an easy way to change the configuration settings.
- Added commands accessible via either tree menu, context menu, and 'standard' Leo keyboard shortcuts:
  - Insert, delete
  - Cut/Copy/Paste/Clone/Paste as clone
  - Move, promote, demote node operations
  - Mark, unmark, sort children, sort siblings and undo

</t>
<t tx="felix.20200718222429.1">## 0.1.7

- Changed main mode of communication from stdin/out to tcp/ip websockets.
- Made a standalone 'Leo Server' python script.

</t>
<t tx="felix.20200718222433.1">## 0.1.6

- Major 'Browsing' update before adding outline editing and file saving &amp; derivation (Thanks for testing!)
- Refactored and simplified communication between vscode and leoBridge.
- Stabilized browsing with multiple simultaneous body panes.
- Added Leo Outline into explorer view.
- Supports new command to open a node on the side from the context menu.
- Multiple configuration options: Open Settings with CTRL+',' type 'leo', or look for 'leo integration' in extensions.

_Note: Headline and body edition does not affect the Leo file yet._

</t>
<t tx="felix.20200718222435.1">## 0.1.5

- Stabilized tree browsing, along with headline and body editing.

</t>
<t tx="felix.20200718222437.1">## 0.1.4

- Major Refactor to streamline codebase; Eliminated code duplication.
- Complete rewrite after going trying out most of what is possible with both vscode and leo APIs.
- New body pane system that prevents corrupting undos across different positions: It uses the node's actual gnx instead of a generic "body" string as a file path for the custom filesystem.

</t>
<t tx="felix.20200718222439.1">## 0.1.3

- This version creates a body panel via a custom filesystem: 'leo'. It only has a file, "leo:/body", the body of the currently selected node.

_Note: This editable body panel does not affect Leo file yet._

</t>
<t tx="felix.20200718222440.1">## 0.1.2

- Prototype Goal Achieved!
- Browsing Now shows body text too, just like browsing in Leo without editing body nor headlines. (read only for now)

</t>
<t tx="felix.20200718222442.1">## 0.1.1

- Leo File Opening.
- Basic outline browsing, along with the recognizable node icons.

</t>
<t tx="felix.20200718222445.1">## 0.0.1

- Initial basic skeleton of this extension. Press F5 to view icon and test the startup of the extension!
- Implemented [leoBridge](https://leoeditor.com/leoBridge.html) interaction.

![LeoEditor](https://raw.githubusercontent.com/boltex/leointeg/master/resources/leoapp96px.png)
</t>
<t tx="felix.20200718222731.1">## Introduction

[Video tutorial of installation and startup](https://www.youtube.com/watch?v=rutt11xL54I):

[![Installation and startup video](https://img.youtube.com/vi/rutt11xL54I/0.jpg)](https://www.youtube.com/watch?v=rutt11xL54I)

If you're new to vscode and want to try out Leo with this vscode extension, you might want to look at this [Getting Started](https://code.visualstudio.com/docs#vscode-in-action) page to get an overview of vscode.

Furthermore, if you've never ran a vscode extension in an **Extension Development Host**, here is a [short overview about running and modifying a simple extension](https://code.visualstudio.com/api/get-started/your-first-extension).

If you're having problems with the procedures below, try [running this sample extension](https://github.com/Microsoft/vscode-extension-samples/tree/master/helloworld-sample#running-the-sample) first to catch underlying problems or missing dependencies.

</t>
<t tx="felix.20200718222739.1">## Development requirements

- **use Leo's 'devel' branch** (This is temporary until Leo's next release)

- Make sure you have [Node.js](https://nodejs.org/en/download/) and [Git](https://git-scm.com/downloads) installed.

- Check your node.js version by typing `node -v` in a terminal. [The latest lts version is 12.18.0](https://nodejs.org/en/download/).

- Also check your vscode version by opening the 'about' dialog from the help menu. You should at least match or exceed the version below.

On Windows:

![about](resources/vscode-about-win.png)

On Linux:

![about](resources/vscode-about.png)

</t>
<t tx="felix.20200718222741.1">## Getting the source and its development dependencies

- Clone the repository using the command line by typing : `git clone https://github.com/boltex/leointeg.git`

![clone](resources/git-clone.png)

- Although you could 'cd' into the leoInteg folder and run some commands from the same terminal, let's instead use the terminal from within vscode. So open the leoInteg folder with vscode instead, either with the context menu as shown below, or by choosing "Open Folder..." from within vscode:

![open with vscode](resources/open-with-vscode.png)

- With vscode now opened with the **leoInteg folder as its workspace**, use the `ctrl+shift+p` keyboard shortcut to open command palette and toggle the terminal. (You can find any command through the command palette)

![open terminal](resources/open-terminal.png)

- Install the development dependencies by entering the `npm install` command in the terminal. **(Important if you also just _pulled_ updated sources)**

- When the command has finished running, you should see logged results in the terminal and also that a new **node_modules** folder was created.

![dependencies](resources/node-modules.png)

- You're now ready to **compile and run** the development version of the leoInteg extension.

</t>
<t tx="felix.20200718222745.1">## Choosing a debug profile

- Bring up the **Run view**, by selecting the Run icon in the **Activity Bar**. _(Screenshot below)_

- When simply running the extension, choose the **Run Extension** profile.

![profile](resources/debug-profile.png)

&gt; (**Optional**) To contribute code to the python server script, or run it through the vscode debugger, you may need to install the [python development extension](https://marketplace.visualstudio.com/items?itemName=ms-python.python).

- For simply running and using leoInteg, just start the extension and the server as shown below.

</t>
<t tx="felix.20200718222748.1">## Starting the extension

- Use the **Start Debugging** command (or press **F5**) to start another vscode window with the expansion _installed and running_ within it.

![extension started](resources/leointeg-started.png)

- If any problems occurred during the extension compilation it will be logged in the vscode instance that started the debug process in its **task-webpack** terminal panel. Otherwise if its running, the extension itself will be logging any messages in the **debug-console** panel. (See animation below)

![extension logs](resources/debug-anim.gif)

</t>
<t tx="felix.20200718222754.1">## The python server script

- This extension needs the **`leobridgeserver.py`** script to be running. That is where the two extra extension requirements come into play:
  - Having [Leo's path made available in the \$PYTHONPATH environment variable](https://docs.python.org/2/using/windows.html#excursus-setting-environment-variables) ([More info](https://docs.python.org/2/using/cmdline.html#environment-variables))
  - Having the [Websocket Python Library installed](https://websockets.readthedocs.io/en/stable/intro.html)

### 3 ways to start the server script

1. You can have LeoInteg try to start a server script instance itself via the **Start Leo Bridge Server** command or button. It will use the 'py' command on Windows and 'python3' command on other OSes by default. _You can automate this process via leoInteg's configuration settings._
2. You can have vscode's **Debug View** start it as a debug session starts by choosing a debug profile that includes the server script. It's then possible to step in, inspect and debug the python server script. _The [python development extension](https://marketplace.visualstudio.com/items?itemName=ms-python.python) may be required._
3. You can also start it yourself manually, by running the leobridgeserver.py script from a command prompt.

### Using Anaconda or other custom python installations

- LeoInteg provides configuration options to specify how to launch python interpreter but this may not be enough to get it to start on your system, see [#10](https://github.com/boltex/leointeg/issues/10) and other issues relating to configurations in _sitecustomize.py_ file as noted in [Leo's google group forum](https://groups.google.com/d/msg/leo-editor/FAP8lVnWLyQ/lWHWEYH9AgAJ).

- If Leointeg or vscode cannot start running the server script on you system or OS, a **workaround** is to start the server script beforehand manually with whichever python interpreter you have installed.

![launch server](resources/manual-server-start.png)

- It will terminate automatically when a user disconnect.

**Note**: If force-closing the server from the integrated vscode terminal, use the 'Kill terminal' button instead of the 'X' that just hides the panel.

![kill terminal](resources/kill-terminal.png)

</t>
<t tx="felix.20200718222757.1">## Issues

More information can be found on the repository's [Issues Page](https://github.com/boltex/leointeg/issues), where details and troubleshooting can be addressed more directly.
</t>
<t tx="felix.20200719025231.1">import * as vscode from 'vscode';
import { debounce } from 'debounce';
import * as utils from './utils';
import { Constants } from './constants';
import {
    LeoBridgePackage,
    RevealType,
    ArchivedPosition,
    Icon,
    ConfigMembers,
    ReqRefresh,
    ChooseDocumentItem,
    LeoDocument,
    UserCommand,
    ShowBodyParam,
    BodySelectionInfo,
    LeoGuiFindTabManagerSettings,
    LeoSearchSettings,
} from './types';
import { Config } from './config';
import { LeoFilesBrowser } from './leoFileBrowser';
import { LeoNode } from './leoNode';
import { LeoOutlineProvider } from './leoOutline';
import { LeoBodyProvider } from './leoBody';
import { LeoBridge } from './leoBridge';
import { ServerService } from './serverManager';
import { LeoStatusBar } from './leoStatusBar';
import { CommandStack } from './commandStack';
import { LeoDocumentsProvider } from './leoDocuments';
import { LeoDocumentNode } from './leoDocumentNode';
import { LeoStates } from './leoStates';
import { LeoButtonsProvider } from './leoButtons';
import { LeoButtonNode } from './leoButtonNode';
import { LeoFindPanelProvider } from './webviews/leoFindPanelWebview';
import { LeoSettingsProvider } from './webviews/leoSettingsWebview';

@others
@language typescript
@tabwidth -4
</t>
<t tx="felix.20200719025231.10"></t>
<t tx="felix.20200719025231.11">/**
 * * Open Leo files found in "context.workspaceState.leoFiles"
 * @returns promise that resolves with editor of last opened from the list, or rejects if empty
 */
private _openLastFiles(): Promise&lt;vscode.TextEditor&gt; {
    // Loop through context.workspaceState.&lt;something&gt; and check if they exist: open them
    const w_lastFiles: string[] = this._context.workspaceState.get(Constants.LAST_FILES_KEY) || [];
    if (w_lastFiles.length) {
        return this.sendAction(
            Constants.LEOBRIDGE.OPEN_FILES,
            JSON.stringify({ files: w_lastFiles })
        ).then(
            (p_openFileResult: LeoBridgePackage) =&gt; {
                this.leoStates.leoBridgeReady = true;
                this.finishedStartup = true;
                return this._setupOpenedLeoDocument(p_openFileResult);
            },
            (p_errorOpen) =&gt; {
                this.leoStates.leoBridgeReady = true;
                this.finishedStartup = true;
                console.log('in .then not opened or already opened');
                return Promise.reject(p_errorOpen);
            }
        );
    } else {
        return Promise.reject('Recent files list is empty');
    }
}

</t>
<t tx="felix.20200719025231.12">/**
 * * Adds to the context.workspaceState.&lt;xxx&gt;files if not already in there (no duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when all workspace storage modifications are done
 */
private _addRecentAndLastFile(p_file: string): Promise&lt;void&gt; {
    if (!p_file.length) {
        return Promise.resolve();
    }
    return Promise.all([
        utils.addFileToWorkspace(this._context, p_file, Constants.RECENT_FILES_KEY),
        utils.addFileToWorkspace(this._context, p_file, Constants.LAST_FILES_KEY),
    ]).then(() =&gt; {
        return Promise.resolve();
    });
}

</t>
<t tx="felix.20200719025231.13">/**
 * * Removes from context.workspaceState.leoRecentFiles if found (should not have duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when the workspace storage modification is done
 */
private _removeRecentFile(p_file: string): Thenable&lt;void&gt; {
    return utils.removeFileFromWorkspace(this._context, p_file, Constants.RECENT_FILES_KEY);
}

</t>
<t tx="felix.20200719025231.14">/**
 * * Removes from context.workspaceState.leoLastFiles if found (should not have duplicates)
 * @param p_file path+file name string
 * @returns A promise that resolves when the workspace storage modification is done
 */
private _removeLastFile(p_file: string): Thenable&lt;void&gt; {
    return utils.removeFileFromWorkspace(this._context, p_file, Constants.LAST_FILES_KEY);
}

</t>
<t tx="felix.20200719025231.15">/**
 * * Shows the recent Leo files list, choosing one will open it
 * @returns A promise that resolves when the a file is finally opened, rejected otherwise
 */
public showRecentLeoFiles(): Thenable&lt;vscode.TextEditor | undefined&gt; {
    const w_recentFiles: string[] =
        this._context.workspaceState.get(Constants.RECENT_FILES_KEY) || [];
    let q_chooseFile: Thenable&lt;string | undefined&gt;;
    if (w_recentFiles.length) {
        q_chooseFile = vscode.window.showQuickPick(w_recentFiles, {
            placeHolder: Constants.USER_MESSAGES.OPEN_RECENT_FILE,
        });
    } else {
        // No file to list
        return Promise.resolve(undefined);
    }
    return q_chooseFile.then((p_result) =&gt; {
        if (p_result) {
            return this.openLeoFile(vscode.Uri.file(p_result));
        } else {
            // Canceled
            return Promise.resolve(undefined);
        }
    });
}

</t>
<t tx="felix.20200719025231.19">/**
 * * 'getStates' action for use in debounced method call
 */
private _triggerGetStates(): void {
    if (this._refreshType.documents) {
        this._refreshType.documents = false;
        this.refreshDocumentsPane();
    }
    if (this._refreshType.buttons) {
        this._refreshType.buttons = false;
        this.refreshButtonsPane();
    }
    if (this._refreshType.states) {
        this._refreshType.states = false;
        this.sendAction(Constants.LEOBRIDGE.GET_STATES).then((p_package: LeoBridgePackage) =&gt; {
            //                            **********************************
            //                             TODO : Check if still same GNX !
            //                            **********************************

            if (p_package.states) {
                this.leoStates.setLeoStateFlags(p_package.states);
            }
        });
    }
}

</t>
<t tx="felix.20200719025231.2">/**
 * * Orchestrates Leo integration into vscode
 */
export class LeoIntegration {
    // * Status Flags
    public finishedStartup: boolean = false;
    private _leoIsConnecting: boolean = false; // Used in connect method, to prevent other attempts while trying
    private _leoBridgeReadyPromise: Promise&lt;LeoBridgePackage&gt; | undefined; // Is set when leoBridge has a leo controller ready
    private _currentOutlineTitle: string = Constants.GUI.TREEVIEW_TITLE_INTEGRATION; // Might need to be re-set when switching visibility
    private _hasShownContextOpenMessage: boolean = false; // Used to show this information only once

    // * State flags
    public leoStates: LeoStates;
    public verbose: boolean = false;
    public trace: boolean = false;

    // * Frontend command stack
    private _commandStack: CommandStack;

    // * Configuration Settings Service
    public config: Config; // Public configuration service singleton, used in leoSettingsWebview, leoBridge, and leoNode for inverted contrast

    // * Icon Paths
    public nodeIcons: Icon[] = []; // Singleton static array of all icon paths used in leoNodes for rendering in treeview
    public documentIcons: Icon[] = [];
    public buttonIcons: Icon[] = [];

    // * File Browser
    private _leoFilesBrowser: LeoFilesBrowser; // Browsing dialog service singleton used in the openLeoFile and save-as methods

    // * LeoBridge
    private _leoBridge: LeoBridge; // Singleton service to access leobridgeserver

    // * Outline Pane
    private _leoTreeProvider: LeoOutlineProvider; // TreeDataProvider single instance
    private _leoTreeView: vscode.TreeView&lt;LeoNode&gt;; // Outline tree view added to the Tree View Container with an Activity Bar icon
    private _leoTreeExView: vscode.TreeView&lt;LeoNode&gt;; // Outline tree view added to the Explorer Sidebar
    private _lastTreeView: vscode.TreeView&lt;LeoNode&gt;; // Last visible treeview
    private _treeId: number = 0; // Starting salt for tree node murmurhash generated Ids

    private _lastSelectedNode: LeoNode | undefined; // Last selected node we got a hold of; leoTreeView.selection maybe newer and unprocessed
    get lastSelectedNode(): LeoNode | undefined {
        return this._lastSelectedNode;
    }
    set lastSelectedNode(p_leoNode: LeoNode | undefined) {
        // Needs undefined type because it cannot be set in the constructor
        this._lastSelectedNode = p_leoNode;
        if (p_leoNode) {
            utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_leoNode.marked); // Global context to 'flag' the selected node's marked state
        }
    }

    // * Outline Pane redraw/refresh flags. Also set when calling refreshTreeRoot
    // If there's no reveal and its the selected node, the old id will be re-used for the node. (see _id property in LeoNode)
    private _revealType: RevealType = RevealType.NoReveal; // to be read/cleared in arrayToLeoNodesArray, to check if any should self-select
    private _preventShowBody = false; // Used when refreshing treeview from config: It requires not to open the body pane when refreshing.

    // * Documents Pane
    private _leoDocumentsProvider: LeoDocumentsProvider;
    private _leoDocuments: vscode.TreeView&lt;LeoDocumentNode&gt;;
    private _leoDocumentsExplorer: vscode.TreeView&lt;LeoDocumentNode&gt;;
    private _currentDocumentChanged: boolean = false; // if clean and an edit is done: refresh opened documents view

    // * Commands stack finishing resolving "refresh flags", for type of refresh after finishing stack
    private _refreshType: ReqRefresh = {}; // Flags for commands to require parts of UI to refresh
    private _fromOutline: boolean = false; // Last command issued had focus on outline, as opposed to the body
    private _focusInterrupt: boolean = false; // Flag for preventing setting focus when interrupting (canceling) an 'insert node' text input dialog with another one

    // * Body Pane
    private _bodyFileSystemStarted: boolean = false;
    private _bodyEnablePreview: boolean = true;
    private _leoFileSystem: LeoBodyProvider; // as per https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api
    private _bodyTextDocument: vscode.TextDocument | undefined; // Set when selected in tree by user, or opening a Leo file in showBody. and by _locateOpenedBody.
    private _bodyMainSelectionColumn: vscode.ViewColumn | undefined; // Column of last body 'textEditor' found, set to 1

    private _bodyPreviewMode: boolean = true;

    private _showBodyStarted: boolean = false; // Flag for when _applySelectionToBody 'show body' cycle is busy
    private _showBodyParams: ShowBodyParam | undefined; // _applySelectionToBody parameters, may be overwritten at each call if not finished

    // * Find panel
    private _findPanelWebviewView: vscode.WebviewView | undefined;
    private _findPanelWebviewExplorerView: vscode.WebviewView | undefined;
    private _lastSettingsUsed: LeoSearchSettings | undefined; // Last settings loaded / saved for current document

    // * Selection
    private _selectionDirty: boolean = false; // Flag set when cursor selection is changed
    private _selectionGnx: string = ''; // Packaged into 'BodySelectionInfo' structures, sent to Leo
    private _selection: vscode.Selection | undefined; // also packaged into 'BodySelectionInfo'
    private _scrollDirty: boolean = false; // Flag set when cursor selection is changed
    private _scrollGnx: string = '';
    private _scroll: vscode.Range | undefined;

    private _bodyUri: vscode.Uri = utils.strToLeoUri('');
    get bodyUri(): vscode.Uri {
        return this._bodyUri;
    }
    set bodyUri(p_uri: vscode.Uri) {
        this._leoFileSystem.setBodyTime(p_uri);
        this._bodyUri = p_uri;
    }

    // * '@button' pane
    private _leoButtonsProvider: LeoButtonsProvider;
    private _leoButtons: vscode.TreeView&lt;LeoButtonNode&gt;;
    private _leoButtonsExplorer: vscode.TreeView&lt;LeoButtonNode&gt;;

    // * Leo Find Panel
    private _leoFindPanelProvider: vscode.WebviewViewProvider;

    // * Settings / Welcome webview
    public leoSettingsWebview: LeoSettingsProvider;

    // * Log and terminal Panes
    private _leoLogPane: vscode.OutputChannel = vscode.window.createOutputChannel(
        Constants.GUI.LOG_PANE_TITLE
    );
    private _leoTerminalPane: vscode.OutputChannel | undefined;

    // * Status Bar
    private _leoStatusBar: LeoStatusBar;

    // * Edit/Insert Headline Input Box options instance, setup so clicking outside cancels the headline change
    private _headlineInputOptions: vscode.InputBoxOptions = {
        ignoreFocusOut: false,
        value: '',
        valueSelection: undefined,
        prompt: '',
    };

    // * Automatic leobridgeserver startup management service
    private _serverService: ServerService;

    // * Timing
    private _needLastSelectedRefresh = false;
    private _bodyLastChangedDocument: vscode.TextDocument | undefined; // Only set in _onDocumentChanged
    private _bodyLastChangedDocumentSaved: boolean = true; // don't use 'isDirty' of the document!

    // * Debounced method used to get states for UI display flags (commands such as undo, redo, save, ...)
    public getStates: (() =&gt; void) &amp; {
        clear(): void;
    } &amp; {
        flush(): void;
    };

    // * Debounced method used to get opened Leo Files for the documents pane
    public refreshDocumentsPane: (() =&gt; void) &amp; {
        clear(): void;
    } &amp; {
        flush(): void;
    };

    // * Debounced method used to get content of the at-buttons pane
    public refreshButtonsPane: (() =&gt; void) &amp; {
        clear(): void;
    } &amp; {
        flush(): void;
    };

    // * Debounced method used to refresh all
    public refreshAll: (() =&gt; void) &amp; {
        clear(): void;
    } &amp; {
        flush(): void;
    };

    @others
}
</t>
<t tx="felix.20200719025231.20">/**
 * * Returns the 'busy' state flag of the command stack, and leoBridge stack, while showing a message if it is.
 * Needed by special unstackable commands such as new, open,...
 * @param p_all Flag to also return true if either front command stack or bridge stack is busy
 * @returns true if command stack is busy, also returns true if p_all flag is set and bridge is busy
 */
private _isBusy(p_all?: boolean): boolean {
    if (this._commandStack.size() || (p_all &amp;&amp; this._leoBridge.isBusy())) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.TOO_FAST);
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="felix.20200719025231.21">/**
 * * Returns true if the current opened Leo document's filename has some content. (not a new unnamed file)
 */
private _isCurrentFileNamed(): boolean {
    return !!this.leoStates.leoOpenedFileName.length; // checks if it's an empty string
}

</t>
<t tx="felix.20200719025231.22">/**
 * * Setup leoInteg's UI for having no opened Leo documents
 */
private _setupNoOpenedLeoDocument(): void {
    this.leoStates.fileOpenedReady = false;
    this._bodyTextDocument = undefined;
    this.lastSelectedNode = undefined;
    this._refreshOutline(false, RevealType.NoReveal);
    this.refreshDocumentsPane();
    this.refreshButtonsPane();
    this.closeBody();
}

</t>
<t tx="felix.20200719025231.23">/**
 * * A Leo file was opened: setup leoInteg's UI accordingly.
 * @param p_openFileResult Returned info about currently opened and editing document
 * @return a promise that resolves to an opened body pane text editor
 */
private _setupOpenedLeoDocument(
    p_openFileResult: LeoBridgePackage
): Promise&lt;vscode.TextEditor&gt; {
    this._needLastSelectedRefresh = true;
    const w_selectedLeoNode = this.apToLeoNode(p_openFileResult.node!, false); // Just to get gnx for the body's fist appearance
    this.leoStates.leoOpenedFileName = p_openFileResult.filename!;

    // * If not unnamed file add to recent list &amp; last opened list
    this._addRecentAndLastFile(p_openFileResult.filename!);

    let q_switchTextEditor: Promise&lt;vscode.TextEditor&gt; | false = false;
    // * Could be already opened, so perform 'switch body' as if another node was selected
    if (this._bodyTextDocument &amp;&amp; this.bodyUri) {

        q_switchTextEditor = new Promise((p_resolve, p_reject) =&gt; {
            this._switchBody(w_selectedLeoNode.gnx, false, true).then((p_te) =&gt; {
                p_resolve(p_te);
            });
        });
    } else {
        this.bodyUri = utils.strToLeoUri(w_selectedLeoNode.gnx);
    }

    // * Start body pane system
    if (!this._bodyFileSystemStarted) {
        this._context.subscriptions.push(
            vscode.workspace.registerFileSystemProvider(
                Constants.URI_LEO_SCHEME,
                this._leoFileSystem,
                { isCaseSensitive: true }
            )
        );
        this._bodyFileSystemStarted = true;
    }
    // * Startup flag
    this.leoStates.fileOpenedReady = true;
    // * Maybe first valid redraw of tree along with the selected node and its body
    this._refreshOutline(true, RevealType.RevealSelectFocus); // p_revealSelection flag set
    // * Maybe first StatusBar appearance
    this._leoStatusBar.update(true, 0, true);
    this._leoStatusBar.show(); // Just selected a node
    // * Show leo log pane
    this.showLogPane();
    // * Send config to python's side (for settings such as defaultReloadIgnore and checkForChangeExternalFiles)
    this.sendConfigToServer(this.config.getConfig());
    // * Refresh Opened tree views
    this.refreshDocumentsPane();
    this.refreshButtonsPane();
    this.loadSearchSettings();
    // * Maybe first Body appearance
    // return this.showBody(false);
    if (q_switchTextEditor) {
        return q_switchTextEditor;
    } else {
        return this.showBody(false);
    }
}

</t>
<t tx="felix.20200719025231.24">/**
 * * Handles the change of vscode config: a onDidChangeConfiguration event triggered
 * @param p_event The configuration-change event passed by vscode
 */
private _onChangeConfiguration(p_event: vscode.ConfigurationChangeEvent): void {
    if (p_event.affectsConfiguration(Constants.CONFIG_NAME)) {
        this.config.buildFromSavedSettings();
    }
    // also check if workbench.editor.enablePreview
    this._bodyEnablePreview = !!vscode.workspace
        .getConfiguration('workbench.editor')
        .get('enablePreview');
}

</t>
<t tx="felix.20200719025231.25">/**
 * * Handles the node expanding and collapsing interactions by the user in the treeview
 * @param p_event The event passed by vscode
 * @param p_expand True if it was an expand, false if it was a collapse event
 * @param p_treeView Pointer to the treeview itself, either the standalone treeview or the one under the explorer
 */
private _onChangeCollapsedState(
    p_event: vscode.TreeViewExpansionEvent&lt;LeoNode&gt;,
    p_expand: boolean,
    p_treeView: vscode.TreeView&lt;LeoNode&gt;
): void {
    // * Expanding or collapsing via the treeview interface selects the node to mimic Leo
    this.triggerBodySave(true);
    if (p_treeView.selection[0] &amp;&amp; p_treeView.selection[0] === p_event.element) {
        // * This happens if the tree selection is the same as the expanded/collapsed node: Just have Leo do the same
        // Pass
    } else {
        // * This part only happens if the user clicked on the arrow without trying to select the node
        this._revealTreeViewNode(p_event.element, { select: true, focus: false }); // No force focus : it breaks collapse/expand when direct parent
        this.selectTreeNode(p_event.element, true); // not waiting for a .then(...) so not to add any lag
    }
    this.sendAction(
        p_expand ? Constants.LEOBRIDGE.EXPAND_NODE : Constants.LEOBRIDGE.COLLAPSE_NODE,
        utils.buildNodeCommandJson(p_event.element.apJson)
    ).then(() =&gt; {
        if (this.config.leoTreeBrowse) {
            this._refreshOutline(true, RevealType.RevealSelect);
        }
    });
}

</t>
<t tx="felix.20200719025231.26">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flag to signify that the treeview who triggered this event is the one in the explorer view
 */
private _onTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {
    if (p_event.visible) {
        this._lastTreeView = p_explorerView ? this._leoTreeExView : this._leoTreeView;
        this.setTreeViewTitle();
        this._needLastSelectedRefresh = true; // Its a new node in a new tree so refresh lastSelectedNode too
        if (this.leoStates.fileOpenedReady) {
            this.loadSearchSettings();
        }
        this._refreshOutline(true, RevealType.RevealSelect);
    }
}

</t>
<t tx="felix.20200719025231.27">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flags that the treeview who triggered this event is the one in the explorer view
 */
private _onDocTreeViewVisibilityChanged(
    p_event: vscode.TreeViewVisibilityChangeEvent,
    p_explorerView: boolean
): void {
    if (p_explorerView) {
    } // (Facultative/unused) Do something different if explorer view is used
    if (p_event.visible) {
        this.refreshDocumentsPane();
    }
}

</t>
<t tx="felix.20200719025231.29">/**
 * * Handles detection of the active editor having changed from one to another, or closed
 * TODO : Make sure the selection in tree if highlighted when a body pane is selected
 * @param p_editor The editor itself that is now active
 * @param p_internalCall Flag used to signify the it was called voluntarily by leoInteg itself
 */
private _onActiveEditorChanged(
    p_editor: vscode.TextEditor | undefined,
    p_internalCall?: boolean
): void {
    if (p_editor &amp;&amp; p_editor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        if (this.bodyUri.fsPath !== p_editor.document.uri.fsPath) {
            this._hideDeleteBody(p_editor);
        }
        this._checkPreviewMode(p_editor);
    }
    if (!p_internalCall) {
        this.triggerBodySave(true); // Save in case edits were pending
    }
    // * Status flag check
    if (!p_editor &amp;&amp; this._leoStatusBar.statusBarFlag) {
        return;
    }
    // * Status flag check
    if (vscode.window.activeTextEditor) {
        this._leoStatusBar.update(
            vscode.window.activeTextEditor.document.uri.scheme === Constants.URI_LEO_SCHEME
        );
    }
}

</t>
<t tx="felix.20200719025231.3">constructor(private _context: vscode.ExtensionContext) {
    // * Setup States
    this.leoStates = new LeoStates(_context, this);

    // * Get configuration settings
    this.config = new Config(_context, this);

    // * also check workbench.editor.enablePreview
    this.config.buildFromSavedSettings();
    this._bodyEnablePreview = !!vscode.workspace
        .getConfiguration('workbench.editor')
        .get('enablePreview');

    // * Build Icon filename paths
    this.nodeIcons = utils.buildNodeIconPaths(_context);
    this.documentIcons = utils.buildDocumentIconPaths(_context);
    this.buttonIcons = utils.buildButtonsIconPaths(_context);

    // * Create file browser instance
    this._leoFilesBrowser = new LeoFilesBrowser(_context);

    // * Setup leoBridge
    this._leoBridge = new LeoBridge(_context, this);

    // * Setup frontend command stack
    this._commandStack = new CommandStack(_context, this);

    // * Create a single data provider for both outline trees, Leo view and Explorer view
    this._leoTreeProvider = new LeoOutlineProvider(this);

    // * Create Leo stand-alone view and Explorer view outline panes
    // Uses 'select node' command, so 'onDidChangeSelection' is not used
    this._leoTreeView = vscode.window.createTreeView(Constants.TREEVIEW_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoTreeProvider,
    });
    this._leoTreeView.onDidExpandElement((p_event) =&gt;
        this._onChangeCollapsedState(p_event, true, this._leoTreeView)
    );
    this._leoTreeView.onDidCollapseElement((p_event) =&gt;
        this._onChangeCollapsedState(p_event, false, this._leoTreeView)
    );
    this._leoTreeView.onDidChangeVisibility((p_event) =&gt;
        this._onTreeViewVisibilityChanged(p_event, false)
    ); // * Trigger 'show tree in Leo's view'
    this._leoTreeExView = vscode.window.createTreeView(Constants.TREEVIEW_EXPLORER_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoTreeProvider,
    });
    this._leoTreeExView.onDidExpandElement((p_event) =&gt;
        this._onChangeCollapsedState(p_event, true, this._leoTreeExView)
    );
    this._leoTreeExView.onDidCollapseElement((p_event) =&gt;
        this._onChangeCollapsedState(p_event, false, this._leoTreeExView)
    );
    this._leoTreeExView.onDidChangeVisibility((p_event) =&gt;
        this._onTreeViewVisibilityChanged(p_event, true)
    ); // * Trigger 'show tree in explorer view'
    this._lastTreeView = this.config.treeInExplorer ? this._leoTreeExView : this._leoTreeView;

    // * Create Leo Opened Documents Treeview Providers and tree views
    this._leoDocumentsProvider = new LeoDocumentsProvider(this);
    this._leoDocuments = vscode.window.createTreeView(Constants.DOCUMENTS_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoDocumentsProvider,
    });
    this._leoDocuments.onDidChangeVisibility((p_event) =&gt;
        this._onDocTreeViewVisibilityChanged(p_event, false)
    );
    this._leoDocumentsExplorer = vscode.window.createTreeView(Constants.DOCUMENTS_EXPLORER_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoDocumentsProvider,
    });
    this._leoDocumentsExplorer.onDidChangeVisibility((p_event) =&gt;
        this._onDocTreeViewVisibilityChanged(p_event, true)
    );

    // * Create '@buttons' Treeview Providers and tree views
    this._leoButtonsProvider = new LeoButtonsProvider(this);
    this._leoButtons = vscode.window.createTreeView(Constants.BUTTONS_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoButtonsProvider,
    });
    this._leoButtons.onDidChangeVisibility((p_event) =&gt;
        this._onButtonsTreeViewVisibilityChanged(p_event, false)
    );
    this._leoButtonsExplorer = vscode.window.createTreeView(Constants.BUTTONS_EXPLORER_ID, {
        showCollapseAll: false,
        treeDataProvider: this._leoButtonsProvider,
    });
    this._leoButtonsExplorer.onDidChangeVisibility((p_event) =&gt;
        this._onButtonsTreeViewVisibilityChanged(p_event, true)
    );

    // * Create Body Pane
    this._leoFileSystem = new LeoBodyProvider(this);
    this._bodyMainSelectionColumn = 1;

    // * Create Status bar Entry
    this._leoStatusBar = new LeoStatusBar(_context, this);

    // * Automatic server start service
    this._serverService = new ServerService(_context, this);

    // * Leo Find Panel
    this._leoFindPanelProvider = new LeoFindPanelProvider(
        _context.extensionUri,
        _context,
        this
    );
    this._context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(
            Constants.FIND_ID,
            this._leoFindPanelProvider,
            { webviewOptions: { retainContextWhenHidden: true } }
        )
    );
    this._context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(
            Constants.FIND_EXPLORER_ID,
            this._leoFindPanelProvider,
            { webviewOptions: { retainContextWhenHidden: true } }
        )
    );

    // * Configuration / Welcome webview
    this.leoSettingsWebview = new LeoSettingsProvider(_context, this);

    // * React to change in active panel/text editor (window.activeTextEditor) - also fires when the active editor becomes undefined
    vscode.window.onDidChangeActiveTextEditor((p_editor) =&gt;
        this._onActiveEditorChanged(p_editor)
    );

    // * React to change in selection, cursor position and scroll position
    vscode.window.onDidChangeTextEditorSelection((p_event) =&gt;
        this._onChangeEditorSelection(p_event)
    );
    vscode.window.onDidChangeTextEditorVisibleRanges((p_event) =&gt;
        this._onChangeEditorScroll(p_event)
    );

    // * Triggers when a different text editor/vscode window changed focus or visibility, or dragged
    // This is also what triggers after drag and drop, see '_onChangeEditorViewColumn'
    vscode.window.onDidChangeTextEditorViewColumn((p_columnChangeEvent) =&gt;
        this._changedTextEditorViewColumn(p_columnChangeEvent)
    ); // Also triggers after drag and drop
    vscode.window.onDidChangeVisibleTextEditors((p_editors) =&gt;
        this._changedVisibleTextEditors(p_editors)
    ); // Window.visibleTextEditors changed
    vscode.window.onDidChangeWindowState((p_windowState) =&gt;
        this._changedWindowState(p_windowState)
    ); // Focus state of the current window changes

    // * React when typing and changing body pane
    vscode.workspace.onDidChangeTextDocument((p_textDocumentChange) =&gt;
        this._onDocumentChanged(p_textDocumentChange)
    );

    // * React to configuration settings events
    vscode.workspace.onDidChangeConfiguration((p_configChange) =&gt;
        this._onChangeConfiguration(p_configChange)
    );

    // * React to opening of any file in vscode
    vscode.workspace.onDidOpenTextDocument((p_document) =&gt;
        this._onDidOpenTextDocument(p_document)
    );

    // * Debounced refresh flags and UI parts, other than the tree and body
    this.getStates = debounce(
        () =&gt; { this._triggerGetStates(); },
        Constants.STATES_DEBOUNCE_DELAY
    );
    this.refreshDocumentsPane = debounce(
        () =&gt; { this._leoDocumentsProvider.refreshTreeRoot(); },
        Constants.DOCUMENTS_DEBOUNCE_DELAY
    );
    this.refreshButtonsPane = debounce(
        () =&gt; { this._leoButtonsProvider.refreshTreeRoot(); },
        Constants.BUTTONS_DEBOUNCE_DELAY
    );
    this.refreshAll = debounce(
        () =&gt; {
            this.launchRefresh({
                tree: true,
                body: true,
                buttons: true,
                states: true,
                documents: true
            }, false);
        },
        Constants.REFRESH_ALL_DEBOUNCE_DELAY
    );
}

</t>
<t tx="felix.20200719025231.31">/**
 * * Handle typing that was detected in a document
 * @param p_textDocumentChange Text changed event passed by vscode
 */
private _onDocumentChanged(p_textDocumentChange: vscode.TextDocumentChangeEvent): void {
    // ".length" check necessary, see https://github.com/microsoft/vscode/issues/50344
    if (
        this.lastSelectedNode &amp;&amp;
        p_textDocumentChange.contentChanges.length &amp;&amp;
        p_textDocumentChange.document.uri.scheme === Constants.URI_LEO_SCHEME
    ) {
        // * There was an actual change on a Leo Body by the user
        this._bodyLastChangedDocument = p_textDocumentChange.document;
        this._bodyLastChangedDocumentSaved = false;
        this._bodyPreviewMode = false;
        this._fromOutline = false; // Focus is on body pane

        // * If icon should change then do it now (if there's no document edit pending)
        if (
            !this._currentDocumentChanged ||
            utils.leoUriToStr(p_textDocumentChange.document.uri) === this.lastSelectedNode.gnx
        ) {
            const w_hasBody = !!p_textDocumentChange.document.getText().length;
            if (utils.isIconChangedByEdit(this.lastSelectedNode, w_hasBody)) {
                this._bodySaveDocument(p_textDocumentChange.document).then(() =&gt; {
                    if (this.lastSelectedNode) {
                        this.lastSelectedNode.dirty = true;
                        this.lastSelectedNode.hasBody = w_hasBody;
                        // NOT incrementing this.treeID to keep ids intact
                    }
                    // NoReveal since we're keeping the same id.
                    this._refreshOutline(false, RevealType.NoReveal);
                });
                // also refresh document panel (icon may be dirty now)
                this.refreshDocumentsPane();
            }
        }
    }
}

</t>
<t tx="felix.20200719025231.32">/**
 * * Save body to Leo if its dirty. That is, only if a change has been made to the body 'document' so far
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the possible saving process is finished
 */
public triggerBodySave(p_forcedVsCodeSave?: boolean): Promise&lt;boolean&gt; {
    // * Save body to Leo if a change has been made to the body 'document' so far
    let q_savePromise: Promise&lt;boolean&gt;;
    if (
        this._bodyLastChangedDocument &amp;&amp;
        this._bodyLastChangedDocument.isDirty &amp;&amp;
        !this._bodyLastChangedDocumentSaved
    ) {
        const w_document = this._bodyLastChangedDocument; // backup for bodySaveDocument before reset
        this._bodyLastChangedDocumentSaved = true;
        q_savePromise = this._bodySaveDocument(w_document, p_forcedVsCodeSave);
    } else {
        this._bodyLastChangedDocumentSaved = true;
        q_savePromise = this._bodySaveSelection();
    }
    return q_savePromise.then((p_result) =&gt; {
        return p_result;
    }, (p_reason) =&gt; {
        console.log('BodySave rejected :', p_reason);
        return false;
    });
}

</t>
<t tx="felix.20200719025231.33">/**
 * * Sets new body text on leo's side, and may optionally save vsCode's body editor (which will trim spaces)
 * @param p_document Vscode's text document which content will be used to be the new node's body text in Leo
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the complete saving process is finished
 */
private _bodySaveDocument(
    p_document: vscode.TextDocument,
    p_forcedVsCodeSave?: boolean
): Promise&lt;boolean&gt; {
    if (p_document) {
        // * Fetch gnx and document's body text first, to be reused more than once in this method
        const w_param = {
            gnx: utils.leoUriToStr(p_document.uri),
            body: p_document.getText(),
        };
        this.sendAction(Constants.LEOBRIDGE.SET_BODY, JSON.stringify(w_param)); // Don't wait for promise
        // This bodySaveSelection is placed on the stack right after saving body, returns promise either way
        return this._bodySaveSelection().then(() =&gt; {
            this._refreshType.states = true;
            this.getStates();
            if (p_forcedVsCodeSave) {
                return p_document.save(); // ! USED INTENTIONALLY: This trims trailing spaces
            }
            return Promise.resolve(p_document.isDirty);
        });
    } else {
        return Promise.resolve(false);
    }
}

</t>
<t tx="felix.20200719025231.34">/**
 * * Places selection on the required node with a 'timeout'. Used after refreshing the opened Leo documents view.
 * @param p_documentNode Document node instance in the Leo document view to be the 'selected' one.
 */
public setDocumentSelection(p_documentNode: LeoDocumentNode): void {
    this._currentDocumentChanged = p_documentNode.documentEntry.changed;
    this.leoStates.leoOpenedFileName = p_documentNode.documentEntry.name;
    @others
    setTimeout(() =&gt; {
        if (!this._leoDocuments.visible &amp;&amp; !this._leoDocumentsExplorer.visible) {
            return;
        }
        let w_trigger = false;
        let w_docView: vscode.TreeView&lt;LeoDocumentNode&gt;;
        if (this._leoDocuments.visible) {
            w_docView = this._leoDocuments;
        } else {
            w_docView = this._leoDocumentsExplorer;
        }
        if (w_docView.selection.length &amp;&amp; w_docView.selection[0] === p_documentNode) {
            // console.log('already selected!');
        } else {
            w_trigger = true;
        }
        if (w_trigger) {
            w_docView.reveal(p_documentNode, { select: true, focus: false })
                .then(
                    (p_result) =&gt; {
                        // Shown document node
                    },
                    (p_reason) =&gt; {
                        if (this.trace || this.verbose) {
                            console.log('shown doc error on reveal: ');
                        }
                    }
                );
        }
    });
}

</t>
<t tx="felix.20200719025231.35">/**
 * * Show the outline, with Leo's selected node also selected, and optionally focussed
 * @param p_focusOutline Flag for focus to be placed in outline
 */
public showOutline(p_focusOutline?: boolean): void {
    if (this.lastSelectedNode) {
        this._lastTreeView.reveal(this.lastSelectedNode, {
            select: true,
            focus: p_focusOutline,
        });
    }
}

</t>
<t tx="felix.20200719025231.38">/**
 * * Converts an archived position object to a LeoNode instance
 * @param p_ap The archived position to convert
 * @param p_revealSelected Flag that will trigger the node to reveal, select, and focus if its selected node in Leo
 * @param p_specificNode Other specific LeoNode to be used to override when revealing the the selected node is encountered
 */
public apToLeoNode(
    p_ap: ArchivedPosition,
    p_revealSelected?: boolean,
    p_specificNode?: LeoNode
): LeoNode {
    let w_collapse: vscode.TreeItemCollapsibleState = vscode.TreeItemCollapsibleState.None;
    if (p_ap.hasChildren) {
        w_collapse = p_ap.expanded
            ? vscode.TreeItemCollapsibleState.Expanded
            : vscode.TreeItemCollapsibleState.Collapsed;
    }
    // * Unknown attributes are one-way read-only data, don't carry this in for string key for leo/python side of things
    let w_u = false;
    if (p_ap.u) {
        w_u = p_ap.u;
        delete p_ap.u;
    }
    const w_leoNode = new LeoNode(
        p_ap.headline, // label-headline
        p_ap.gnx, // gnx
        w_collapse, // collapsibleState
        JSON.stringify(p_ap), // string key for leo/python side of things
        p_ap.childIndex, // childIndex
        !!p_ap.cloned, // cloned
        !!p_ap.dirty, // dirty
        !!p_ap.marked, // marked
        !!p_ap.atFile, // atFile
        !!p_ap.hasBody, // hasBody
        w_u, // unknownAttributes
        this, // _leoIntegration pointer
        utils.hashNode(p_ap, this._treeId.toString(36))
    );
    if (p_revealSelected &amp;&amp; this._revealType &amp;&amp; p_ap.selected) {
        this._apToLeoNodeConvertReveal(p_specificNode ? p_specificNode : w_leoNode);
    }
    return w_leoNode;
}

</t>
<t tx="felix.20200719025231.39">/**
 * * Reveals the node that was detected as being the selected one while converting from archived positions
 * Also select it, or focus on it too depending on global this._revealType variable
 * @param p_leoNode The node that was detected as the selected node in Leo
 */
private _apToLeoNodeConvertReveal(p_leoNode: LeoNode): void {
    this.leoStates.setSelectedNodeFlags(p_leoNode);
    // First setup flags for selecting and focusing based on the current reveal type needed
    const w_selectFlag = this._revealType &gt;= RevealType.RevealSelect; // at least RevealSelect
    let w_focusFlag = this._revealType &gt;= RevealType.RevealSelectFocus; // at least RevealSelectFocus
    // Flags are setup so now reveal, select and / or focus as needed
    this._revealType = RevealType.NoReveal; // ok reset
    // If first time, or when treeview switched, lastSelectedNode will be undefined
    if (!this.lastSelectedNode || this._needLastSelectedRefresh) {
        this._needLastSelectedRefresh = false;
        this.lastSelectedNode = p_leoNode; // special case only: lastSelectedNode should be set in selectTreeNode
    }
    setTimeout(() =&gt; {
        // TODO : MAKE SURE TIMEOUT IS REALLY REQUIRED
        this._revealTreeViewNode(p_leoNode, { select: w_selectFlag, focus: w_focusFlag }).then(
            () =&gt; {
                // console.log('did this ask for parent?', p_leoNode.id, p_leoNode.label); // ! debug
                if (w_selectFlag) {
                    this._gotSelection(p_leoNode);
                }
            }
        );
    });
}

</t>
<t tx="felix.20200719025231.4"></t>
<t tx="felix.20200719025231.40">/**
 * * Converts an array of 'ap' to an array of leoNodes.  This is used in 'getChildren' of leoOutline.ts
 * @param p_array Array of archived positions to be converted to leoNodes for the vscode treeview
 */
public arrayToLeoNodesArray(p_array: ArchivedPosition[]): LeoNode[] {
    const w_leoNodesArray: LeoNode[] = [];
    for (let w_apData of p_array) {
        const w_leoNode = this.apToLeoNode(w_apData, true);
        w_leoNodesArray.push(w_leoNode);
    }
    return w_leoNodesArray;
}

</t>
<t tx="felix.20200719025231.47">/**
 * * Close body pane document and change the bodyUri
 * This blocks 'undos' from crossing over
 * @param p_newGnx New gnx body id to switch to
 */
private _switchBody(
    p_newGnx: string,
    p_aside: boolean,
    p_preserveFocus?: boolean
): Thenable&lt;vscode.TextEditor&gt; {
    const w_oldUri: vscode.Uri = this.bodyUri;

    // ? Set timestamps ?
    // this._leoFileSystem.setRenameTime(p_newGnx);

    let w_visibleCount = 0;
    vscode.window.visibleTextEditors.forEach((p_editor) =&gt; {
        if (p_editor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
            w_visibleCount++;
        }
    });

    if (this._bodyPreviewMode &amp;&amp; this._bodyEnablePreview &amp;&amp; w_visibleCount &lt; 2) {
        // just show in same column and delete after
        this.bodyUri = utils.strToLeoUri(p_newGnx);
        const q_showBody = this.showBody(p_aside, p_preserveFocus);
        vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', w_oldUri.path);
        return q_showBody;
    } else {
        // Gotta delete to close all and re-open, so:
        // Promise to Delete first, synchronously (as thenable),
        // tagged along with automatically removeFromRecentlyOpened in parallel
        const w_edit = new vscode.WorkspaceEdit();
        w_edit.deleteFile(w_oldUri, { ignoreIfNotExists: true });
        return vscode.workspace.applyEdit(w_edit).then(() =&gt; {
            // Set new uri and remove from 'Recently opened'
            this._bodyPreviewMode = true;
            this.bodyUri = utils.strToLeoUri(p_newGnx);
            // async, so don't wait for this to finish
            if (w_oldUri.fsPath !== this.bodyUri.fsPath) {
                vscode.commands.executeCommand(
                    'vscode.removeFromRecentlyOpened',
                    w_oldUri.path
                );
            }
            return this.showBody(p_aside, p_preserveFocus);
        });
    }
}

</t>
<t tx="felix.20200719025231.48">/**
 * * Sets globals if the current body is found opened in an editor panel for a particular gnx
 * @param p_gnx gnx to match
 */
private _locateOpenedBody(p_gnx: string): boolean {
    let w_found = false;
    // * Only gets to visible editors, not every tab per editor
    vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
        if (utils.leoUriToStr(p_textEditor.document.uri) === p_gnx) {
            w_found = true;
            this._bodyTextDocument = p_textEditor.document;
            this._bodyMainSelectionColumn = p_textEditor.viewColumn;
        }
    });
    return w_found;
}

</t>
<t tx="felix.20200719025231.49">/**
 * * Closes any body pane opened in this vscode window instance
 */
public closeBody(): Thenable&lt;any&gt; {
    // TODO : CLEAR UNDO HISTORY AND FILE HISTORY for this.bodyUri !
    let q_closed;
    if (this.bodyUri) {
        q_closed = vscode.commands.executeCommand('vscode.removeFromRecentlyOpened', this.bodyUri.path);
    } else {
        q_closed = Promise.resolve(true);
    }
    vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
        if (p_textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
            vscode.commands.executeCommand(
                'vscode.removeFromRecentlyOpened',
                p_textEditor.document.uri.path
            );
            if (p_textEditor.hide) {
                p_textEditor.hide();
            }
        }
    });
    return q_closed;
}

</t>
<t tx="felix.20200719025231.5">/**
 * * Core of the integration of Leo into vscode: Sends an action to leobridgeserver.py, to run in Leo.
 * @param p_action is the action string constant, from Constants.LEOBRIDGE
 * @param p_jsonParam (optional) JSON string to be given to the python script action call
 * @param p_deferredPayload (optional) a pre-made package that will be given back as the response, instead of package coming back from python
 * @param p_preventCall (optional) Flag for special case, only used at startup
 * @returns a Promise that will contain the JSON package answered back by leobridgeserver.py
 */
public sendAction(
    p_action: string,
    p_jsonParam = 'null',
    p_deferredPayload?: LeoBridgePackage,
    p_preventCall?: boolean
): Promise&lt;LeoBridgePackage&gt; {
    return this._leoBridge.action(p_action, p_jsonParam, p_deferredPayload, p_preventCall);
}

</t>
<t tx="felix.20200719025231.50">/**
 * * Opens an an editor for the currently selected node: "this.bodyUri". If already opened, this just 'reveals' it
 * @param p_aside Flag for opening the editor beside any currently opened and focused editor
 * @param p_preserveFocus flag that when true will stop the editor from taking focus once opened
 */
public showBody(p_aside: boolean, p_preserveFocus?: boolean): Promise&lt;vscode.TextEditor&gt; {
    // First setup timeout asking for gnx file refresh in case we were resolving a refresh of type 'RefreshTreeAndBody'
    if (this._refreshType.body) {
        this._refreshType.body = false;
        // TODO : CHECK IF TIMEOUT NECESSARY!
        setTimeout(() =&gt; {
            this._leoFileSystem.fireRefreshFile(utils.leoUriToStr(this.bodyUri));
        }, 0);
    }

    if (this._preventShowBody) {
        this._preventShowBody = false;
        return Promise.resolve(vscode.window.activeTextEditor!);
    }

    return Promise.resolve(vscode.workspace.openTextDocument(this.bodyUri)).then(
        (p_document) =&gt; {
            this._bodyTextDocument = p_document;

            // * Set document language along with the proper cursor position, selection range and scrolling position
            let q_bodyStates: Promise&lt;LeoBridgePackage&gt; | undefined;

            if (!this._needLastSelectedRefresh) {

                q_bodyStates = this.sendAction(
                    Constants.LEOBRIDGE.GET_BODY_STATES,
                    utils.buildNodeCommandJson(this.lastSelectedNode!.apJson)
                );

                q_bodyStates.then((p_bodyStates: LeoBridgePackage) =&gt; {
                    let w_language: string = p_bodyStates.language!;
                    // Replace language string if in 'exceptions' array
                    w_language = 'leobody.' + (Constants.LANGUAGE_CODES[w_language] || w_language);
                    // Apply language if the selected node is still the same after all those events
                    if (
                        !p_document.isClosed &amp;&amp;
                        this.lastSelectedNode &amp;&amp;
                        utils.leoUriToStr(p_document.uri) === this.lastSelectedNode.gnx
                    ) {
                        vscode.languages.setTextDocumentLanguage(p_document, w_language);
                    }
                });
            }

            // Find body pane's position if already opened with same gnx (language still needs to be set per position)
            vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
                if (p_textEditor.document.uri.fsPath === p_document.uri.fsPath) {
                    this._bodyMainSelectionColumn = p_textEditor.viewColumn;
                    this._bodyTextDocument = p_textEditor.document;
                }
            });
            // Setup options for the preview state of the opened editor, and to choose which column it should appear
            const w_showOptions: vscode.TextDocumentShowOptions = p_aside
                ? {
                    viewColumn: vscode.ViewColumn.Beside,
                    preserveFocus: p_preserveFocus, // an optional flag that when true will stop the editor from taking focus
                    preview: true, // should text document be in preview only? set false for fully opened
                    // selection is instead set when the GET_BODY_STATES above resolves
                }
                : {
                    viewColumn: this._bodyMainSelectionColumn
                        ? this._bodyMainSelectionColumn
                        : 1, // view column in which the editor should be shown
                    preserveFocus: p_preserveFocus, // an optional flag that when true will stop the editor from taking focus
                    preview: true, // should text document be in preview only? set false for fully opened
                    // selection is instead set when the GET_BODY_STATES above resolves
                };

            // NOTE: textEditor.show() is deprecated — Use window.showTextDocument instead.
            const q_showTextDocument = vscode.window.showTextDocument(
                this._bodyTextDocument,
                w_showOptions
            ).then(
                (p_result) =&gt; { return p_result; },
                (p_reason) =&gt; {
                    if (this.trace || this.verbose) {
                        console.log('showTextDocument rejected');
                    }
                }
            );

            // else q_bodyStates will exist.
            if (q_bodyStates &amp;&amp; !this._needLastSelectedRefresh) {
                Promise.all([q_bodyStates, q_showTextDocument]).then(
                    (p_values: [LeoBridgePackage, vscode.TextEditor]) =&gt; {
                        const w_resultBodyStates = p_values[0];
                        const w_bodyTextEditor = p_values[1];
                        if (!w_resultBodyStates.selection) {
                            console.log("no selection in returned package from get_body_states");
                        }
                        const w_leoBodySel: BodySelectionInfo = w_resultBodyStates.selection!;

                        // Cursor position and selection range
                        const w_activeRow: number = w_leoBodySel.insert.line;
                        const w_activeCol: number = w_leoBodySel.insert.col;
                        let w_anchorLine: number = w_leoBodySel.start.line;
                        let w_anchorCharacter: number = w_leoBodySel.start.col;

                        if (w_activeRow === w_anchorLine &amp;&amp; w_activeCol === w_anchorCharacter) {
                            // Active insertion same as start selection, so use the other ones
                            w_anchorLine = w_leoBodySel.end.line;
                            w_anchorCharacter = w_leoBodySel.end.col;
                        }

                        const w_selection = new vscode.Selection(
                            w_anchorLine,
                            w_anchorCharacter,
                            w_activeRow,
                            w_activeCol
                        );

                        let w_scrollRange: vscode.Range | undefined;

                        // ! Test scroll position from selection range instead
                        // const w_scroll: number = w_leoBodySel.scroll;
                        // if (w_scroll) {
                        // w_scrollRange = new vscode.Range(w_scroll, 0, w_scroll, 0);
                        // }

                        // Build scroll position from selection range.
                        w_scrollRange = new vscode.Range(
                            w_activeRow,
                            w_activeCol,
                            w_activeRow,
                            w_activeCol
                        );

                        if (w_bodyTextEditor) {
                            w_bodyTextEditor.selection = w_selection; // set cursor insertion point &amp; selection range
                            if (!w_scrollRange) {
                                w_scrollRange = w_bodyTextEditor.document.lineAt(0).range;
                            }

                            if (this._refreshType.scroll) {
                                this._refreshType.scroll = false;
                                w_bodyTextEditor.revealRange(w_scrollRange); // set scroll approximation
                            }

                        } else {
                            if (this.trace || this.verbose) {
                                console.log("no selection in returned package from showTextDocument");
                            }
                        }


                    }
                );
            }
            return q_showTextDocument;
        }
    );
}

</t>
<t tx="felix.20200719025231.51"></t>
<t tx="felix.20200719025231.52">/**
 * * Select a tree node. Either called from user interaction, or used internally (p_internalCall flag)
 * @param p_node Node that was just selected
 * @param p_internalCall Flag used to indicate the selection is forced, and NOT originating from user interaction
 * @param p_aside Flag to force opening the body "Aside", i.e. when the selection was made from choosing "Open Aside"
 * @returns a promise with the package gotten back from Leo when asked to select the tree node
 */
public selectTreeNode(
    p_node: LeoNode,
    p_internalCall?: boolean,
    p_aside?: boolean
): Promise&lt;LeoBridgePackage | vscode.TextEditor&gt; {
    this.triggerBodySave(true);

    // * check if used via context menu's "open-aside" on an unselected node: check if p_node is currently selected, if not select it
    if (p_aside &amp;&amp; p_node !== this.lastSelectedNode) {
        this._revealTreeViewNode(p_node, { select: true, focus: false }); // no need to set focus: tree selection is set to right-click position
    }

    this.leoStates.setSelectedNodeFlags(p_node);
    this._leoStatusBar.update(true); // Just selected a node directly, or via expand/collapse
    const w_showBodyKeepFocus = p_aside
        ? this.config.treeKeepFocusWhenAside
        : this.config.treeKeepFocus;

    // * Check if having already this exact node position selected : Just show the body and exit
    // (other tree nodes with same gnx may have different syntax language coloring because of parents lineage)
    if (p_node === this.lastSelectedNode) {
        this._locateOpenedBody(p_node.gnx); // LOCATE NEW GNX
        return this.showBody(!!p_aside, w_showBodyKeepFocus); // Voluntary exit
    }

    // * Set selected node in Leo via leoBridge
    const q_setSelectedNode = this.sendAction(
        Constants.LEOBRIDGE.SET_SELECTED_NODE,
        utils.buildNodeCommandJson(p_node.apJson)
    ).then((p_setSelectedResult) =&gt; {
        if (!p_internalCall) {
            this._refreshType.states = true;
            this.getStates();
        }
        return p_setSelectedResult;
    });

    // * Apply the node to the body text without waiting for the selection promise to resolve
    this._tryApplyNodeToBody(p_node, !!p_aside, w_showBodyKeepFocus, true);
    return q_setSelectedNode;
}

</t>
<t tx="felix.20200719025231.54">/**
 * * Changes the marked state of a specified, or currently selected node
 * @param p_isMark Set 'True' to mark, otherwise unmarks the node
 * @param p_node Specifies which node use, or leave undefined to mark or unmark the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 */
public changeMark(
    p_isMark: boolean,
    p_node?: LeoNode,
    p_fromOutline?: boolean
): Promise&lt;LeoBridgePackage&gt; {
    // No need to wait for body-save trigger for marking/un-marking a node
    const q_commandResult = this.nodeCommand({
        action: p_isMark ? Constants.LEOBRIDGE.MARK_PNODE : Constants.LEOBRIDGE.UNMARK_PNODE,
        node: p_node,
        refreshType: { tree: true },
        fromOutline: !!p_fromOutline,
    });
    if (q_commandResult) {
        if (!p_node || p_node === this.lastSelectedNode) {
            utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_isMark);
        }
        return q_commandResult;
    } else {
        return Promise.reject('Change mark on node not added on command stack');
    }
}

</t>
<t tx="felix.20200719025231.55">/**
 * * Asks for a new headline label, and replaces the current label with this new one one the specified, or currently selected node
 * @param p_node Specifies which node to rename, or leave undefined to rename the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 */
public editHeadline(
    p_node?: LeoNode,
    p_fromOutline?: boolean
): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(false, true)
        .then(() =&gt; {
            if (!p_node &amp;&amp; this.lastSelectedNode) {
                p_node = this.lastSelectedNode; // Gets last selected node if called via keyboard shortcut or command palette (not set in command stack class)
            }
            if (p_node) {
                this._headlineInputOptions.prompt =
                    Constants.USER_MESSAGES.PROMPT_EDIT_HEADLINE;
                this._headlineInputOptions.value = p_node.label; // preset input pop up
                return vscode.window.showInputBox(this._headlineInputOptions);
            } else {
                return Promise.reject('No node selected');
            }
        })
        .then((p_newHeadline) =&gt; {
            if (p_newHeadline) {
                p_node!.label = p_newHeadline; // ! When labels change, ids will change and its selection and expansion states cannot be kept stable anymore.
                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.SET_HEADLINE,
                    node: p_node,
                    refreshType: { tree: true, states: true },
                    fromOutline: !!p_fromOutline,
                    name: p_newHeadline,
                });
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject('Edit Headline not added on command stack');
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20200719025231.56">/**
 * * Asks for a headline label to be entered and creates (inserts) a new node under the current, or specified, node
 * @param p_node specified under which node to insert, or leave undefined to use whichever is currently selected
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_interrupt Signifies the insert action is actually interrupting itself (e.g. rapid CTRL+I actions by the user)
 */
public insertNode(
    p_node?: LeoNode,
    p_fromOutline?: boolean,
    p_asChild?: boolean,
    p_interrupt?: boolean
): Promise&lt;LeoBridgePackage&gt; {
    let w_fromOutline: boolean = !!p_fromOutline; // Use w_fromOutline for where we intend to leave focus when done with the insert
    if (p_interrupt) {
        this._focusInterrupt = true;
        w_fromOutline = this._fromOutline; // Going to use last state
    }
    // if no node parameter, the front command stack CAN be busy, but if a node is passed, stack must be free
    if (!p_node || !this._isBusy()) {
        this.triggerBodySave(true); // Don't wait for saving to resolve because we're waiting for user input anyways
        this._headlineInputOptions.prompt = Constants.USER_MESSAGES.PROMPT_INSERT_NODE;
        this._headlineInputOptions.value = Constants.USER_MESSAGES.DEFAULT_HEADLINE;
        return new Promise&lt;LeoBridgePackage&gt;((p_resolve, p_reject) =&gt; {
            vscode.window.showInputBox(this._headlineInputOptions).then((p_newHeadline) =&gt; {
                const w_action = p_newHeadline
                    ? (p_asChild ? Constants.LEOBRIDGE.INSERT_CHILD_NAMED_PNODE : Constants.LEOBRIDGE.INSERT_NAMED_PNODE)
                    : (p_asChild ? Constants.LEOBRIDGE.INSERT_CHILD_PNODE : Constants.LEOBRIDGE.INSERT_PNODE);
                const q_commandResult = this.nodeCommand({
                    action: w_action,
                    node: p_node,
                    refreshType: { tree: true, states: true },
                    fromOutline: w_fromOutline,
                    name: p_newHeadline,
                });
                if (q_commandResult) {
                    q_commandResult.then((p_package) =&gt; p_resolve(p_package));
                } else {
                    p_reject(w_action + ' not added on command stack');
                }
            });
        });
    } else {
        return Promise.reject('Insert node not added on command stack');
    }
}

</t>
<t tx="felix.20200719025231.57"></t>
<t tx="felix.20200719025231.58">/**
 * * Asks for file name and path, then saves the Leo file
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 */
public saveAsLeoFile(p_fromOutline?: boolean): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
                return this._leoFilesBrowser.getLeoFileUrl(true);
            } else {
                // 'when-conditions' should prevent this
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
                return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            }
        })
        .then((p_chosenLeoFile) =&gt; {
            if (p_chosenLeoFile.trim()) {
                const w_hasDot = p_chosenLeoFile.indexOf('.') !== -1;
                if (
                    !w_hasDot ||
                    (p_chosenLeoFile.split('.').pop() !== Constants.FILE_EXTENSION &amp;&amp; w_hasDot)
                ) {
                    if (!p_chosenLeoFile.endsWith('.')) {
                        p_chosenLeoFile += '.'; // Add dot if needed
                    }
                    p_chosenLeoFile += Constants.FILE_EXTENSION; // Add extension
                }
                if (this.leoStates.leoOpenedFileName) {
                    this._removeLastFile(this.leoStates.leoOpenedFileName);
                    this._removeRecentFile(this.leoStates.leoOpenedFileName);
                }
                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.SAVE_FILE,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    fromOutline: !!p_fromOutline,
                    name: p_chosenLeoFile,
                });
                this.leoStates.leoOpenedFileName = p_chosenLeoFile.trim();
                this._leoStatusBar.update(true, 0, true);
                this._addRecentAndLastFile(p_chosenLeoFile.trim());
                if (q_commandResult) {
                    return q_commandResult;
                } else {
                    return Promise.reject('Save file not added on command stack');
                }
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20200719025231.59">/**
 * * Invokes the self.commander.save() Leo command
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 * @returns Promise that resolves when the save command is placed on the front-end command stack
 */
public saveLeoFile(p_fromOutline?: boolean): Promise&lt;LeoBridgePackage | undefined&gt; {
    return this._isBusyTriggerSave(true, true).then((p_saveResult) =&gt; {
        if (this.leoStates.fileOpenedReady) {
            if (this.lastSelectedNode &amp;&amp; this._isCurrentFileNamed()) {
                const q_commandResult = this.nodeCommand({
                    action: Constants.LEOBRIDGE.SAVE_FILE,
                    node: undefined,
                    refreshType: { tree: true, states: true, documents: true },
                    fromOutline: !!p_fromOutline,
                    name: '',
                });
                return q_commandResult
                    ? q_commandResult
                    : Promise.reject('Save file not added on command stack');
            } else {
                return this.saveAsLeoFile(p_fromOutline); // Override this command call if file is unnamed!
            }
        } else {
            // 'when-conditions' should prevent this
            vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
            return Promise.reject(Constants.USER_MESSAGES.FILE_NOT_OPENED);
        }
    });
}

</t>
<t tx="felix.20200719025231.6">/**
 * * leoInteg starting entry point
 * Starts a leoBridge server, and/or establish a connection to a server, based on config settings.
 */
public startNetworkServices(): void {
    // * Check settings and start a server accordingly
    if (this.config.startServerAutomatically) {
        this.startServer();
    } else if (this.config.connectToServerAutomatically) {
        // * (via settings) Connect to Leo Bridge server automatically without starting one first
        this.connect();
    } else {
        this.finishedStartup = true;
    }
}

</t>
<t tx="felix.20200719025231.60">/**
 * * Show switch document 'QuickPick' dialog and switch file if selection is made, or just return if no files are opened.
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly selected document
 */
public switchLeoFile(): Promise&lt;vscode.TextEditor | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.GET_OPENED_FILES);
        })
        .then((p_package) =&gt; {
            const w_entries: ChooseDocumentItem[] = []; // Entries to offer as choices.
            const w_files: LeoDocument[] = p_package.files!;
            let w_index: number = 0;
            if (w_files &amp;&amp; w_files.length) {
                w_files.forEach(function (p_filePath: LeoDocument) {
                    w_entries.push({
                        label: w_index.toString(),
                        description: p_filePath.name
                            ? p_filePath.name
                            : Constants.UNTITLED_FILE_NAME,
                        value: w_index,
                        alwaysShow: true,
                    });
                    w_index++;
                });
                const w_pickOptions: vscode.QuickPickOptions = {
                    matchOnDescription: true,
                    placeHolder: Constants.USER_MESSAGES.CHOOSE_OPENED_FILE,
                };
                return vscode.window.showQuickPick(w_entries, w_pickOptions);
            } else {
                // "No opened documents"
                return Promise.resolve(undefined);
            }
        })
        .then((p_chosenDocument) =&gt; {
            if (p_chosenDocument) {
                return Promise.resolve(this.selectOpenedLeoDocument(p_chosenDocument.value));
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20200719025231.61">/**
 * * Switches Leo document directly by index number. Used by document treeview and switchLeoFile command.
 * @returns A promise that resolves with a textEditor of the selected node's body from the newly opened document
 */
public selectOpenedLeoDocument(p_index: number): Promise&lt;vscode.TextEditor&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(
                Constants.LEOBRIDGE.SET_OPENED_FILE,
                JSON.stringify({ index: p_index })
            );
        })
        .then((p_openFileResult: LeoBridgePackage) =&gt; {
            // Like we just opened or made a new file
            if (p_openFileResult.filename || p_openFileResult.filename === "") {
                return this._setupOpenedLeoDocument(p_openFileResult);
            } else {
                console.log('Select Opened Leo File Error');
                return Promise.reject('Select Opened Leo File Error');
            }
        });
}

</t>
<t tx="felix.20200719025231.64">/**
 * * Close an opened Leo file
 * @returns the launchRefresh promise started after it's done closing the Leo document
 */
public closeLeoFile(): Promise&lt;boolean&gt; {
    let w_removeLastFileName: string = '';
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            if (!this.leoStates.fileOpenedReady) {
                vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLOSE_ERROR);
                return Promise.reject(Constants.USER_MESSAGES.CLOSE_ERROR);
            }
            w_removeLastFileName = this.leoStates.leoOpenedFileName;
            return this.sendAction(
                Constants.LEOBRIDGE.CLOSE_FILE,
                JSON.stringify({ forced: false })
            );
        })
        .then((p_tryCloseResult) =&gt; {
            // Has a total member: closed file
            if (p_tryCloseResult.total || p_tryCloseResult.total === 0) {
                this._removeLastFile(w_removeLastFileName);
                if (p_tryCloseResult.total === 0) {
                    this._setupNoOpenedLeoDocument();
                } else {
                    this.loadSearchSettings();
                    this.launchRefresh(
                        {
                            tree: true,
                            body: true,
                            documents: true,
                            buttons: true,
                            states: true,
                        },
                        false
                    );
                }
                return Promise.resolve(true);
            } else {
                // No total member: did not close file
                const q_askSaveChangesInfoMessage: Thenable&lt;vscode.MessageItem | undefined&gt; =
                    vscode.window.showInformationMessage(
                        Constants.USER_MESSAGES.SAVE_CHANGES +
                        ' ' +
                        this.leoStates.leoOpenedFileName +
                        ' ' +
                        Constants.USER_MESSAGES.BEFORE_CLOSING,
                        { modal: true },
                        ...Constants.ASK_SAVE_CHANGES_BUTTONS
                    );
                return Promise.resolve(q_askSaveChangesInfoMessage)
                    .then((p_askSaveResult: vscode.MessageItem | undefined) =&gt; {
                        if (p_askSaveResult) {
                            if (p_askSaveResult.title === Constants.USER_MESSAGES.YES) {
                                // save and then force-close
                                let w_savePromise: Promise&lt;LeoBridgePackage | undefined&gt;;
                                if (this._isCurrentFileNamed()) {
                                    w_savePromise = this.sendAction(
                                        Constants.LEOBRIDGE.SAVE_FILE,
                                        JSON.stringify({ name: '' })
                                    );
                                } else {
                                    w_savePromise = this._leoFilesBrowser
                                        .getLeoFileUrl(true)
                                        .then((p_chosenLeoFile) =&gt; {
                                            if (p_chosenLeoFile.trim()) {
                                                return this.sendAction(
                                                    Constants.LEOBRIDGE.SAVE_FILE,
                                                    JSON.stringify({
                                                        name: p_chosenLeoFile.trim(),
                                                    })
                                                );
                                            } else {
                                                // Canceled
                                                return Promise.resolve(undefined);
                                            }
                                        });
                                }
                                return w_savePromise.then(
                                    (p_packageAfterSave) =&gt; {
                                        return this.sendAction(
                                            Constants.LEOBRIDGE.CLOSE_FILE,
                                            JSON.stringify({ forced: true })
                                        );
                                    },
                                    () =&gt; {
                                        return Promise.reject('Save failed');
                                    }
                                );
                            } else if (p_askSaveResult.title === Constants.USER_MESSAGES.NO) {
                                // Don't want to save so just force-close directly
                                return this.sendAction(
                                    Constants.LEOBRIDGE.CLOSE_FILE,
                                    JSON.stringify({ forced: true })
                                );
                            } else {
                                // Canceled
                                return Promise.resolve(undefined);
                            }
                        } else {
                            // Canceled
                            return Promise.resolve(undefined);
                        }
                    })
                    .then((p_closeResult: LeoBridgePackage | undefined) =&gt; {
                        if (p_closeResult) {
                            // * back from CLOSE_FILE action, the last that can be performed (after saving if dirty or not)
                            this._removeLastFile(w_removeLastFileName);
                            if (p_closeResult &amp;&amp; p_closeResult.total === 0) {
                                this._setupNoOpenedLeoDocument();
                            } else {
                                this.loadSearchSettings();
                                this.launchRefresh(
                                    {
                                        tree: true,
                                        body: true,
                                        documents: true,
                                        buttons: true,
                                        states: true,
                                    },
                                    false
                                );
                            }
                            return Promise.resolve(true);
                        }
                        // Canceled
                        return Promise.resolve(false);
                    });
            }
        });
}

</t>
<t tx="felix.20200719025231.65">/**
 * * Creates a new untitled Leo document
 * * If not shown already, it also shows the outline, body and log panes along with leaving focus in the outline
 * @returns A promise that resolves with a textEditor of the new file
 */
public newLeoFile(): Promise&lt;vscode.TextEditor&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.OPEN_FILE, JSON.stringify({ filename: "" }));
        })
        .then((p_openFileResult: LeoBridgePackage) =&gt; {
            if (p_openFileResult.filename || p_openFileResult.filename === "") {
                return this._setupOpenedLeoDocument(p_openFileResult);
            } else {
                return Promise.reject('New Leo File Error');
            }
        });
}

</t>
<t tx="felix.20200719025231.66">/**
 * * Shows an 'Open Leo File' dialog window and opens the chosen file
 * * If not shown already, it also shows the outline, body and log panes along with leaving focus in the outline
 * @returns A promise that resolves with a textEditor of the chosen file
 */
public openLeoFile(p_leoFileUri?: vscode.Uri): Promise&lt;vscode.TextEditor | undefined&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            let q_openedFile: Promise&lt;LeoBridgePackage | undefined&gt;; // Promise for opening a file
            if (p_leoFileUri &amp;&amp; p_leoFileUri.fsPath.trim()) {
                const w_fixedFilePath: string = p_leoFileUri.fsPath.replace(/\\/g, '/');
                q_openedFile = this.sendAction(
                    Constants.LEOBRIDGE.OPEN_FILE,
                    JSON.stringify({ filename: w_fixedFilePath })
                );
            } else {
                q_openedFile = this._leoFilesBrowser.getLeoFileUrl().then(
                    (p_chosenLeoFile) =&gt; {
                        if (p_chosenLeoFile.trim()) {
                            return this.sendAction(
                                Constants.LEOBRIDGE.OPEN_FILE,
                                JSON.stringify({ filename: p_chosenLeoFile })
                            );
                        } else {
                            return Promise.resolve(undefined);
                        }
                    },
                    (p_errorGetFile) =&gt; {
                        return Promise.reject(p_errorGetFile);
                    }
                );
            }
            return q_openedFile;
        })
        .then(
            (p_openFileResult: LeoBridgePackage | undefined) =&gt; {
                if (p_openFileResult) {
                    return this._setupOpenedLeoDocument(p_openFileResult);
                } else {
                    return Promise.resolve(undefined);
                }
            },
            (p_errorOpen) =&gt; {
                console.log('in .then not opened or already opened'); // TODO : IS REJECTION BEHAVIOR NECESSARY HERE TOO?
                return Promise.reject(p_errorOpen);
            }
        );
}

</t>
<t tx="felix.20200719025231.69">/**
 * * StatusBar click handler
 * @returns Thenable from the statusBar click customizable behavior
 */
public statusBarOnClick(): Thenable&lt;unknown&gt; {
    if (this.leoStates.fileOpenedReady) {
        return this.minibuffer();
        // return this.switchLeoFile();
    } else {
        return vscode.commands.executeCommand(
            Constants.VSCODE_COMMANDS.QUICK_OPEN,
            Constants.GUI.QUICK_OPEN_LEO_COMMANDS
        );
    }
}

</t>
<t tx="felix.20200719025231.7">/**
 * * Starts an instance of a leoBridge server, and may connect to it afterwards, based on configuration flags.
 */
public startServer(): void {
    if (!this._leoTerminalPane) {
        this._leoTerminalPane = vscode.window.createOutputChannel(
            Constants.GUI.TERMINAL_PANE_TITLE
        );
    }
    this._serverService
        .startServer(
            this.config.leoPythonCommand,
            this.config.leoEditorPath,
            this.config.connectionPort
        )
        .then(
            (p_message) =&gt; {
                utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, true); // server started
                if (this.config.connectToServerAutomatically) {
                    setTimeout(() =&gt; {
                        // Wait a full second
                        this.connect();
                    }, 1000);
                } else {
                    this.finishedStartup = true;
                }
            },
            (p_reason) =&gt; {
                // This context flag will remove the 'connecting' welcome view
                utils.setContext(Constants.CONTEXT_FLAGS.AUTO_START_SERVER, false);
                utils.setContext(Constants.CONTEXT_FLAGS.AUTO_CONNECT, false);
                if (
                    [Constants.USER_MESSAGES.LEO_PATH_MISSING,
                    Constants.USER_MESSAGES.CANNOT_FIND_SERVER_SCRIPT].includes(p_reason)
                ) {
                    vscode.window.showErrorMessage(Constants.USER_MESSAGES.START_SERVER_ERROR + p_reason, "Choose Folder")
                        .then(p_chosenButton =&gt; {
                            if (p_chosenButton === 'Choose Folder') {
                                vscode.commands.executeCommand(Constants.COMMANDS.CHOOSE_LEO_FOLDER);
                            }
                        });

                    return;
                }
                vscode.window.showErrorMessage(
                    Constants.USER_MESSAGES.START_SERVER_ERROR + p_reason,
                );
            }
        );
}

</t>
<t tx="felix.20200719025231.70">/**
 * * Test/Dummy command
 * @param p_fromOutline Flags if the call came with focus on the outline
 * @returns Thenable from the tested functionality
 */
public test(p_fromOutline?: boolean): Thenable&lt;unknown&gt; {
    // return this.statusBarOnClick();

    // vscode.commands.executeCommand(Constants.COMMANDS.MARK_SELECTION)
    //     .then((p_result) =&gt; {
    //         console.log(
    //             'BACK FROM EXEC COMMAND ' +
    //             Constants.COMMANDS.MARK_SELECTION +
    //             ', p_result: ',
    //             JSON.stringify(p_result)
    //         );

    //     });

    // Test setting scroll / selection range

    /*
    vscode.window.showQuickPick(["get", "set"]).then(p_results =&gt; {
        console.log('quick pick result:', p_results);
        let w_selection: vscode.Selection;
        let w_action = "";
        if (p_results === "get") {
           //  w_action = Constants.LEOBRIDGE.GET_SEARCH_SETTINGS;
            // w_selection = new vscode.Selection(1, 1, 1, 6);
            this.loadSearchSettings();
        } else {
            w_action = Constants.LEOBRIDGE.SET_SEARCH_SETTINGS;
            // w_selection = new vscode.Selection(2, 2, 3, 3);
        }
        console.log('w_action', w_action);
        const searchSettings: LeoGuiFindTabManagerSettings = {
            find_text: "new find text",
            change_text: "",
            ignore_case: false, // diff
            mark_changes: false,
            mark_finds: true, // diff
            node_only: false,
            pattern_match: false,
            search_body: true,
            search_headline: true,
            suboutline_only: false,
            whole_word: false
        };

        if (w_action) {
            this.sendAction(
                w_action, JSON.stringify({ searchSettings: searchSettings })
            ).then((p_result: LeoBridgePackage) =&gt; {
                console.log('got back settings: ', p_result);
            });
        }
    });
    */

    /*
    vscode.window.visibleTextEditors.forEach(p_textEditor =&gt; {
        console.log('p_textEditor.document.uri.scheme ', p_textEditor.document.uri.scheme);

        if (p_textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
            console.log('found');

            p_textEditor.selection = w_selection; // set cursor insertion point &amp; selection range
            // if (!w_scrollRange) {
            //     w_scrollRange = p_textEditor.document.lineAt(0).range;
            // }
            // p_textEditor.revealRange(w_scrollRange); // set
        }
    });
    */

    // GET_FOCUS AS A TEST
    return this.sendAction(
        // Constants.LEOBRIDGE.TEST, JSON.stringify({ testParam: "Some String" })
        Constants.LEOBRIDGE.GET_FOCUS,
        JSON.stringify({ testParam: 'Some String' })
    ).then((p_result: LeoBridgePackage) =&gt; {
        console.log('get focus: ', p_result);

        // this.launchRefresh({ buttons: true }, false);
        // return vscode.window.showInformationMessage(
        //     ' back from test, called from ' +
        //     (p_fromOutline ? "outline" : "body") +
        //     ', with result: ' +
        //     JSON.stringify(p_result)
        // );
    });
}
</t>
<t tx="felix.20200719025231.8">/**
 * * Initiate a connection to the leoBridge server, then show view title, log pane, and set 'bridge ready' flags.
 */
public connect(): void {
    if (this.leoStates.leoBridgeReady || this._leoIsConnecting) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.ALREADY_CONNECTED);
        return;
    }
    this._leoIsConnecting = true;
    console.log('connecting');

    this._leoBridgeReadyPromise = this._leoBridge.initLeoProcess(
        this._serverService.usingPort // This will be zero if no port found
    );
    this._leoBridgeReadyPromise.then(
        (p_package) =&gt; {
            console.log('connected');

            this._leoIsConnecting = false;
            if (p_package.id !== 1) {
                this.cancelConnect(Constants.USER_MESSAGES.CONNECT_ERROR);
            } else {
                const w_lastFiles: string[] =
                    this._context.workspaceState.get(Constants.LAST_FILES_KEY) || [];
                if (w_lastFiles.length) {
                    // This context flag will trigger 'Connecting...' placeholder
                    utils.setContext(Constants.CONTEXT_FLAGS.AUTO_CONNECT, true);

                    setTimeout(() =&gt; {
                        this._openLastFiles(); // Try to open last opened files, if any
                    }, 0);
                } else {
                    this.leoStates.leoBridgeReady = true;
                    this.finishedStartup = true;
                }

                this.showLogPane();
                if (!this.config.connectToServerAutomatically) {
                    vscode.window.showInformationMessage(Constants.USER_MESSAGES.CONNECTED);
                }
            }

            // TODO : Finish Closing and possibly SAME FOR OPENING AND CONNECTING
            // TODO : #14 @boltex COULD BE SOME FILES ALREADY OPENED OR NONE!
        },
        (p_reason) =&gt; {
            this._leoIsConnecting = false;
            this.cancelConnect(Constants.USER_MESSAGES.CONNECT_FAILED + ': ' + p_reason);
        }
    );
}

</t>
<t tx="felix.20200719025231.9">/**
 * * Cancels websocket connection and reverts context flags.
 * Called from leoBridge.ts when its websocket reports disconnection.
 * @param p_message
 */
public cancelConnect(p_message?: string): void {
    // 'disconnect error' versus 'failed to connect'
    if (this.leoStates.leoBridgeReady) {
        vscode.window.showErrorMessage(
            p_message ? p_message : Constants.USER_MESSAGES.DISCONNECTED
        );
    } else {
        vscode.window.showInformationMessage(
            p_message ? p_message : Constants.USER_MESSAGES.DISCONNECTED
        );
    }

    // to change the 'viewsWelcome' content.
    // bring back to !leoBridgeReady &amp;&amp; !leoServerStarted &amp;&amp; !startServerAutomatically &amp;&amp; !connectToServerAutomatically"
    utils.setContext(Constants.CONTEXT_FLAGS.AUTO_START_SERVER, false);
    utils.setContext(Constants.CONTEXT_FLAGS.AUTO_CONNECT, false);
    this.finishedStartup = true;

    this.leoStates.fileOpenedReady = false;
    this.leoStates.leoBridgeReady = false;
    this._leoBridgeReadyPromise = undefined;
    this._leoStatusBar.update(false);
    this._refreshOutline(false, RevealType.NoReveal);
}

</t>
<t tx="felix.20200719030811.1"></t>
<t tx="felix.20200719030842.1"></t>
<t tx="felix.20200719030902.1"></t>
<t tx="felix.20200719030909.1"></t>
<t tx="felix.20200719031115.1"></t>
<t tx="felix.20200719031346.1">/**
 * * Send user's configuration through leoBridge to the server script
 * @param p_config A config object containing all the configuration settings
 * @returns promise that will resolves with the package from "applyConfig" call in Leo bridge server
 */
public sendConfigToServer(p_config: ConfigMembers): Promise&lt;LeoBridgePackage&gt; {
    if (this.leoStates.leoBridgeReady) {
        return this.sendAction(Constants.LEOBRIDGE.APPLY_CONFIG, JSON.stringify(p_config));
    } else {
        return Promise.reject('Leo Bridge Not Ready');
    }
}

</t>
<t tx="felix.20200719031802.1"></t>
<t tx="felix.20200719033306.1"></t>
<t tx="felix.20200719033511.1"></t>
<t tx="felix.20200928004727.1">/**
 * * Handles detection of the active editor's selection change or cursor position
 * @param p_event a change event containing the active editor's selection, if any.
 */
private _onChangeEditorSelection(p_event: vscode.TextEditorSelectionChangeEvent): void {
    if (p_event.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        if (p_event.selections.length) {
            this._selectionDirty = true;
            this._selection = p_event.selections[0];
            this._selectionGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20200928133238.1">/**
 * * Saves the cursor position along with the text selection range and scroll position
 * @returns Promise that resolves when the "setSelection" action returns from Leo's side
 */
private _bodySaveSelection(): Promise&lt;boolean&gt; {
    if (this._selectionDirty &amp;&amp; this._selection) {
        // Prepare scroll data separately
        // ! TEST NEW SCROLL WITH SINGLE LINE NUMBER
        let w_scroll: number;
        if (this._selectionGnx === this._scrollGnx &amp;&amp; this._scrollDirty) {
            w_scroll = this._scroll?.start.line || 0;
        } else {
            w_scroll = 0;
        }
        // let w_scroll: { start: BodyPosition; end: BodyPosition; };
        // if (this._selectionGnx === this._scrollGnx &amp;&amp; this._scrollDirty) {
        //     w_scroll = {
        //         start: {
        //             line: this._scroll?.start.line || 0,
        //             col: this._scroll?.start.character || 0
        //         },
        //         end: {
        //             line: this._scroll?.end.line || 0,
        //             col: this._scroll?.end.character || 0
        //         }
        //     };
        // } else {
        //     w_scroll = {
        //         start: {
        //             line: 0, col: 0
        //         },
        //         end: {
        //             line: 0, col: 0
        //         }
        //     };
        // }
        // Send whole
        const w_param: BodySelectionInfo = {
            gnx: this._selectionGnx,
            scroll: w_scroll,
            insert: {
                line: this._selection.active.line || 0,
                col: this._selection.active.character || 0,
            },
            start: {
                line: this._selection.start.line || 0,
                col: this._selection.start.character || 0,
            },
            end: {
                line: this._selection.end.line || 0,
                col: this._selection.end.character || 0,
            },
        };
        // console.log("set scroll to leo: " + w_scroll + " start:" + this._selection.start.line);

        this._scrollDirty = false;
        this._selectionDirty = false; // don't wait for return of this call
        return this.sendAction(Constants.LEOBRIDGE.SET_SELECTION, JSON.stringify(w_param)).then(
            (p_result) =&gt; {
                return Promise.resolve(true);
            }
        );
    } else {
        return Promise.resolve(true);
    }
}

</t>
<t tx="felix.20201006195046.1">/**
 * * LeoBody cursor active position and text selection state, along with gnx
 */
export interface BodySelectionInfo {
    gnx: string;
    // scroll is stored as-is as the 'scrollBarSpot' in Leo
    // ! TEST scroll as single number only (for Leo vertical scroll value)
    scroll: number;
    // scroll: {
    //     start: BodyPosition;
    //     end: BodyPosition;
    // }
    insert: BodyPosition;
    start: BodyPosition;
    end: BodyPosition;
}

</t>
<t tx="felix.20201014020145.1">/**
 * * Handles detection of the active editor's scroll position changes
 * @param p_event a change event containing the active editor's visible range, if any.
 */
private _onChangeEditorScroll(p_event: vscode.TextEditorVisibleRangesChangeEvent): void {
    if (p_event.textEditor.document.uri.scheme === Constants.URI_LEO_SCHEME) {
        if (p_event.visibleRanges.length) {
            this._scrollDirty = true;
            this._scroll = p_event.visibleRanges[0];
            this._scrollGnx = utils.leoUriToStr(p_event.textEditor.document.uri);
        }
    }
}

</t>
<t tx="felix.20201017224340.1">/**
 * * Structure for configuration settings changes used along with welcome/settings webview.
 */
export interface ConfigSetting {
    code: string;
    value: any;
}

</t>
<t tx="felix.20201018163510.1">/**
 * * Returns the milliseconds between a given starting process.hrtime tuple and the current call to process.hrtime
 * @param p_start starting process.hrtime to subtract from current immediate time
 * @returns number of milliseconds passed since the given start hrtime
 */
export function getDurationMs(p_start: [number, number]): number {
    const [w_secs, w_nanosecs] = process.hrtime(p_start);
    return w_secs * 1000 + Math.floor(w_nanosecs / 1000000);
}

</t>
<t tx="felix.20201103000337.1">/**
 * * Table for converting Leo languages names for the currently opened body pane
 * Used in showBody method of leoIntegration.ts
 */
public static LANGUAGE_CODES: { [key: string]: string | undefined } = {
    cplusplus: 'cpp',
    md: 'markdown'
};

</t>
<t tx="felix.20201105010253.1">{
  "command": "leointeg.extract",
  "key": "ctrl+shift+d",
  "mac": "cmd+shift+d",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.extract",
  "key": "ctrl+shift+d",
  "mac": "cmd+shift+d",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.extractNames",
  "key": "ctrl+shift+n",
  "mac": "cmd++shift+n",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; editorHasSelection &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.extractNames",
  "key": "ctrl+shift+n",
  "mac": "cmd+shift+n",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
</t>
<t tx="felix.20201105010614.1">{
  "command": "leointeg.extract",
  "category": "Leo",
  "title": "Extract",
  "icon": {
    "light": "resources/light/extract.svg",
    "dark": "resources/dark/extract.svg"
  }
},
{
  "command": "leointeg.extractNames",
  "category": "Leo",
  "title": "Extract Names",
  "icon": {
    "light": "resources/light/extract-name.svg",
    "dark": "resources/dark/extract-name.svg"
  }
},
</t>
<t tx="felix.20201106200100.1">/**
 * * Performs the actual addition into workspaceState context
 * @param p_context Needed to get to vscode workspace storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the workspace storage modification is done
 */
export function addFileToWorkspace(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Just push that string into the context.workspaceState.&lt;something&gt; array
    const w_contextEntry: string[] = p_context.workspaceState.get(p_key) || [];
    if (w_contextEntry) {
        if (!w_contextEntry.includes(p_file)) {
            w_contextEntry.push(p_file);
            if (w_contextEntry.length &gt; 10) {
                w_contextEntry.shift();
            }
        }
        return p_context.workspaceState.update(p_key, w_contextEntry); // Added file
    } else {
        // First so create key entry with an array of single file
        return p_context.workspaceState.update(p_key, [p_file]);
    }
}

</t>
<t tx="felix.20201106200109.1">/**
 * * Removes file entry from workspaceState context
 * @param p_context Needed to get to vscode workspace storage
 * @param p_file path+file name string
 * @param p_key A constant string such as RECENT_FILES_KEY or LAST_FILES_KEY
 * @returns A promise that resolves when the workspace storage modification is done
  */
export function removeFileFromWorkspace(p_context: vscode.ExtensionContext, p_file: string, p_key: string): Thenable&lt;void&gt; {
    // Check if exist in context.workspaceState.&lt;something&gt; and remove if found
    const w_files: string[] = p_context.workspaceState.get(p_key) || [];
    if (w_files &amp;&amp; w_files.includes(p_file)) {
        w_files.splice(w_files.indexOf(p_file), 1); // Splice and update
        return p_context.workspaceState.update(p_key, w_files);
    }
    return Promise.resolve(); // not even in list so just resolve
}

</t>
<t tx="felix.20201107224112.1">/**
 * * Promise that triggers body save (rejects if busy), and resolves when done
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 * @returns a promise that resolves when the possible saving process is finished
 */
private _isBusyTriggerSave(p_all: boolean, p_forcedVsCodeSave?: boolean): Promise&lt;boolean&gt; {
    if (this._isBusy(p_all)) {
        return Promise.reject('Command stack busy'); // Warn user to wait for end of busy state
    }
    return this.triggerBodySave(p_forcedVsCodeSave);
}

</t>
<t tx="felix.20201114185218.1">/**
 * * Sets the outline pane top bar string message or refreshes with existing title if no title passed
 * @param p_title new string to replace the current title
 */
public setTreeViewTitle(p_title?: string): void {
    if (p_title) {
        this._currentOutlineTitle = p_title;
    }
    // * Set/Change outline pane title e.g. "INTEGRATION", "OUTLINE"
    if (this._leoTreeView) {
        this._leoTreeView.title = this._currentOutlineTitle;
    }
    if (this._leoTreeExView) {
        this._leoTreeExView.title =
            Constants.GUI.EXPLORER_TREEVIEW_PREFIX + this._currentOutlineTitle;
    }
}

</t>
<t tx="felix.20201114185813.1">/**
 * * Opens quickPick minibuffer pallette to choose from all commands in this file's commander
 * @returns Promise that resolves when the chosen command is placed on the front-end command stack
 */
public minibuffer(): Thenable&lt;LeoBridgePackage | undefined&gt; {
    // Wait for _isBusyTriggerSave resolve because the full body save may change available commands
    return this._isBusyTriggerSave(false)
        .then((p_saveResult) =&gt; {
            const q_commandList: Thenable&lt;vscode.QuickPickItem[]&gt; = this.sendAction(
                Constants.LEOBRIDGE.GET_COMMANDS
            ).then((p_result: LeoBridgePackage) =&gt; {
                if (p_result.commands &amp;&amp; p_result.commands.length) {
                    return p_result.commands;
                } else {
                    return [];
                }
            });
            const w_options: vscode.QuickPickOptions = {
                placeHolder: Constants.USER_MESSAGES.MINIBUFFER_PROMPT,
                matchOnDetail: true,
            };
            return vscode.window.showQuickPick(q_commandList, w_options);
        })
        .then((p_picked) =&gt; {
            if (
                p_picked &amp;&amp;
                p_picked.label &amp;&amp;
                Constants.MINIBUFFER_OVERRIDDEN_COMMANDS[p_picked.label]
            ) {
                return vscode.commands.executeCommand(
                    Constants.MINIBUFFER_OVERRIDDEN_COMMANDS[p_picked.label]
                );
            }
            if (p_picked &amp;&amp; p_picked.label) {
                const w_commandResult = this.nodeCommand({
                    action: "-" + p_picked.label, // Adding HYPHEN prefix to specify a command-name
                    node: undefined,
                    refreshType: {
                        tree: true,
                        body: true,
                        documents: true,
                        buttons: true,
                        states: true,
                    },
                    fromOutline: false, // true // TODO : Differentiate from outline?
                });
                return w_commandResult ? w_commandResult : Promise.reject('Command not added');
            } else {
                // Canceled
                return Promise.resolve(undefined);
            }
        });
}

</t>
<t tx="felix.20201119002510.1">/**
 * * Body position
 * Used in BodySelectionInfo interface
 */
export interface BodyPosition {
    line: number;
    col: number;
}

</t>
<t tx="felix.20201126235315.1">/**
 * * Strings used in 'at-button' panel display in LeoButtonNode
 */
public static BUTTON_STRINGS = {
    NULL_WIDGET: "nullButtonWidget",
    SCRIPT_BUTTON: "script-button",
    ADD_BUTTON: "leoButtonAdd",
    NORMAL_BUTTON: "leoButtonNode"
};

</t>
<t tx="felix.20201208235246.1">/**
 * * Command strings to be used with vscode.commands.executeCommand
 * See https://code.visualstudio.com/api/extension-guides/command#programmatically-executing-a-command
 */
public static VSCODE_COMMANDS = {
    SET_CONTEXT: "setContext",
    CLOSE_ACTIVE_EDITOR: "workbench.action.closeActiveEditor",
    QUICK_OPEN: "workbench.action.quickOpen"
};

</t>
<t tx="felix.20201215210439.1">"view/title": [
  {
    "command": "leointeg.openLeoFile",
    "when": "view =~ /leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "view =~ /leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.showSettingsPage",
    "when": "view =~ /leoDocuments/ &amp;&amp; leoBridgeReady",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.showSettingsPage",
    "when": "view =~ /leoIntegration/ &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.clearRecentFiles",
    "when": "view =~ /leoIntegration/ &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.connectToServer",
    "when": "view =~ /leoIntegration/ &amp;&amp; !leoBridgeReady &amp;&amp; !leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.openLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.newLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoBridgeReady",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoTreeTitled",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.undoFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanUndo",
    "group": "navigation@3"
  },
  {
    "command": "leointeg.undoDisabled",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoCanUndo",
    "group": "navigation@3"
  },
  {
    "command": "leointeg.redoFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanRedo",
    "group": "navigation@4"
  },
  {
    "command": "leointeg.redoDisabled",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; !leoCanRedo",
    "group": "navigation@4"
  },
  {
    "command": "leointeg.deHoistFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened &amp;&amp; leoCanDehoist",
    "group": "navigation@5"
  },
  {
    "command": "leointeg.contractAllFromOutline",
    "when": "view =~ /leoIntegration/ &amp;&amp; leoTreeOpened",
    "group": "navigation@6"
  }
],
</t>
<t tx="felix.20201215210510.1">"view/item/context": [
  {
    "command": "leointeg.saveLeoFileFromOutline",
    "when": "viewItem =~ /leoDocumentSelectedTitled/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.saveAsLeoFile",
    "when": "viewItem =~ /leoDocumentSelectedUntitled/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.closeLeoFile",
    "when": "viewItem =~ /leoDocumentSelected/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.editHeadline",
    "when": "showEditOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@1"
  },
  {
    "command": "leointeg.insertNode",
    "when": "showAddOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@2"
  },
  {
    "command": "leointeg.moveOutlineDown",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineLeft",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineRight",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.moveOutlineUp",
    "when": "showArrowsOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@3"
  },
  {
    "command": "leointeg.copyNode",
    "when": "showCopyOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "showCloneOnNodes &amp;&amp; viewItem =~ /leoNode/",
    "group": "inline@4"
  },
  {
    "command": "leointeg.mark",
    "when": "showMarkOnNodes &amp;&amp; viewItem =~ /leoNodeUnmarked/",
    "group": "inline@5"
  },
  {
    "command": "leointeg.unmark",
    "when": "showMarkOnNodes &amp;&amp; viewItem =~ /leoNodeMarked/",
    "group": "inline@5"
  },
  {
    "command": "leointeg.openAside",
    "when": "showOpenAside &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext1@1"
  },
  {
    "command": "leointeg.hoistNode",
    "when": "viewItem =~ /leoNodeNotRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.deHoist",
    "when": "leoCanDehoist &amp;&amp; viewItem =~ /leoNodeRoot/",
    "group": "leoNodeContext1@2"
  },
  {
    "command": "leointeg.refreshFromDisk",
    "when": "viewItem =~ /leoNodeAtFile/",
    "group": "leoNodeContext1@3"
  },
  {
    "command": "leointeg.mark",
    "when": "viewItem =~ /leoNodeUnmarked/",
    "group": "leoNodeContext2@1"
  },
  {
    "command": "leointeg.unmark",
    "when": "viewItem =~ /leoNodeMarked/",
    "group": "leoNodeContext2@2"
  },
  {
    "command": "leointeg.copyNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@3"
  },
  {
    "command": "leointeg.cutNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@4"
  },
  {
    "command": "leointeg.pasteNode",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@5"
  },
  {
    "command": "leointeg.pasteNodeAsClone",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@6"
  },
  {
    "command": "leointeg.delete",
    "when": "viewItem =~ /leoNode/",
    "group": "leoNodeContext2@7"
  },
  {
    "command": "leointeg.insertNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext3@1"
  },
  {
    "command": "leointeg.cloneNode",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNode/",
    "group": "leoNodeContext3@2"
  },
  {
    "command": "leointeg.gotoNextClone",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoNodeCloned/",
    "group": "leoNodeContext3@3"
  },
  {
    "command": "leointeg.removeButton",
    "when": "leoTreeOpened &amp;&amp; viewItem =~ /leoButtonNode/",
    "group": "leoButtonContext1@1"
  }
]
</t>
<t tx="felix.20210418013332.1">private _hideDeleteBody(p_textEditor: vscode.TextEditor): void {
    console.log('DELETE EXTRANEOUS:', p_textEditor.document.uri.fsPath);
    const w_edit = new vscode.WorkspaceEdit();
    w_edit.deleteFile(p_textEditor.document.uri, { ignoreIfNotExists: true });
    if (p_textEditor.hide) {
        p_textEditor.hide();
    }
    vscode.commands.executeCommand(
        'vscode.removeFromRecentlyOpened',
        p_textEditor.document.uri.path
    );
}

</t>
<t tx="felix.20210418014039.1">/**
 * * Moved a document to another column
 */
public _changedTextEditorViewColumn(
    p_columnChangeEvent: vscode.TextEditorViewColumnChangeEvent
): void {
    if (p_columnChangeEvent &amp;&amp; p_columnChangeEvent.textEditor.document.uri.scheme === 'more') {
        this._checkPreviewMode(p_columnChangeEvent.textEditor);
    }
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20210418014040.1">/**
 * * Tabbed on another editor
 */
public _changedVisibleTextEditors(p_editors: vscode.TextEditor[]): void {
    if (p_editors &amp;&amp; p_editors.length) {
        p_editors.forEach((p_textEditor) =&gt; {
            if (p_textEditor &amp;&amp; p_textEditor.document.uri.scheme === 'more') {
                if (this.bodyUri.fsPath !== p_textEditor.document.uri.fsPath) {
                    this._hideDeleteBody(p_textEditor);
                }
                this._checkPreviewMode(p_textEditor);
            }
        });
    }
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20210418014040.2">/**
 * * Whole window has been minimized/restored
 */
public _changedWindowState(p_windowState: vscode.WindowState): void {
    // no other action
    this.triggerBodySave(true);
}

</t>
<t tx="felix.20210418220343.1">private _checkPreviewMode(p_editor: vscode.TextEditor): void {
    // if selected gnx but in another column
    if (
        p_editor.document.uri.fsPath === this.bodyUri.fsPath &amp;&amp;
        p_editor.viewColumn !== this._bodyMainSelectionColumn
    ) {
        this._bodyPreviewMode = false;
        this._bodyMainSelectionColumn = p_editor.viewColumn;
    }
}

</t>
<t tx="felix.20210418230204.1">private _findUriColumn(p_uri: vscode.Uri): vscode.ViewColumn | undefined {
    let w_column: vscode.ViewColumn | undefined;
    vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
        if (p_textEditor.document.uri.fsPath === p_uri.fsPath) {
            w_column = p_textEditor.viewColumn;
        }
    });
    return w_column;
}

</t>
<t tx="felix.20210418230204.2">private findGnxColumn(p_gnx: string): vscode.ViewColumn | undefined {
    let w_column: vscode.ViewColumn | undefined;
    vscode.window.visibleTextEditors.forEach((p_textEditor) =&gt; {
        if (p_textEditor.document.uri.fsPath.substr(1) === p_gnx) {
            w_column = p_textEditor.viewColumn;
        }
    });
    return w_column;
}

</t>
<t tx="felix.20210509210502.1">## 0.1.13

- Added support for precise focus placement, focus switch between tree/body.
- Made the extension more aware of the current selection state, to have strictly relevant buttons visible shown only.
- Made the 'edit headline' hover icon removable, in order to enable 'Tab' keybinding to go from tree to body directly.
- Added commands and keybindings for 'goto' operations 'hoist/dehoist' [#25](https://github.com/boltex/leointeg/issues/25) and other commands. [#30](https://github.com/boltex/leointeg/issues/30)
- Added support for Leo-Style outline navigation. [#43](https://github.com/boltex/leointeg/issues/43) Has to be enabled with an option in the config settings: "Use Leo Tree Browsing" which makes the arrow keys, pgUp/pgDn, home/end move the selection instead of a cursor when focus is on Leo's outline.
- Implemented @buttons in it's own panel, visible where the already existing 'outline' and 'opened leo documents' panels reside.
- Added (basic) unknown attributes support as hover tooltip and small description on node headlines.
- Added a 'leoBridge Server Terminal Panel' to gather output of the leoBridge stdOut pipe. It's displayed among the 'output panels', along with the standard 'leo log window', when the server is started by leoInteg. (either with the auto-start config setting, or by calling the 'start server' command via buttons or the command-palette.)
- Syntax coloring and Snippets are now enabled for those languages : C, C++, CSS, HTML, Java, Javascript, json, Markdown, PHP, Python, Rust and Typescript. They are taken from the default extension for that language, or if non-existent, from the most popular extension for that language
- Recent files are now remembered and restored upon re-opening vscode.
- Leo files can be opened from the explorer pane directly.
- Added 'minibuffer' feature with the usual alt-x command from Leo.
- Added cursor position, selected range and scrolling position to be captured and restored when navigating the outline. [#39](https://github.com/boltex/leointeg/issues/39) This allows for commands that use the currently selected text, [#61](https://github.com/boltex/leointeg/issues/61) such as run script and extract/extract name, etc.
- Redid the body display and switching logic to support new vscode API features. (vscode now does not block 'undo' operations between file-rename operations, which were used to switch body pane content.)

</t>
<t tx="felix.20210516233931.1">/**
 * * Opens the find panel and selects all &amp; focuses on the find field.
 */
public startSearch(): void {
    let w_panelID = '';
    let w_panel: vscode.WebviewView | undefined;
    if (this._lastTreeView === this._leoTreeExView) {
        w_panelID = Constants.FIND_EXPLORER_ID;
        w_panel = this._findPanelWebviewExplorerView;
    } else {
        w_panelID = Constants.FIND_ID;
        w_panel = this._findPanelWebviewView;
    }
    vscode.commands.executeCommand(w_panelID + '.focus').then((p_result) =&gt; {
        if (w_panel &amp;&amp; w_panel.show &amp;&amp; !w_panel.visible) {
            w_panel.show(false);
        }
        w_panel?.webview.postMessage({ type: 'selectFind' });
    });
}

</t>
<t tx="felix.20210516234059.1">/**
 * * Find next / previous commands
 * @param p_fromOutline
 * @param p_reverse
 * @returns Promise that resolves when the "launch refresh" is started
 */
public find(p_fromOutline: boolean, p_reverse: boolean): Promise&lt;any&gt; {
    const w_action: string = p_reverse
        ? Constants.LEOBRIDGE.FIND_PREVIOUS
        : Constants.LEOBRIDGE.FIND_NEXT;
    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(w_action, JSON.stringify({ fromOutline: !!p_fromOutline }));
        })
        .then((p_findResult: LeoBridgePackage) =&gt; {
            if (!p_findResult.found || !p_findResult.focus) {
                vscode.window.showInformationMessage('Not found');
            } else {
                let w_focusOnOutline = false;
                const w_focus = p_findResult.focus.toLowerCase();
                if (w_focus.includes('tree') || w_focus.includes('head')) {
                    // tree
                    w_focusOnOutline = true;
                }
                this.launchRefresh(
                    {
                        tree: true,
                        body: true,
                        scroll: p_findResult.found &amp;&amp; !w_focusOnOutline,
                        documents: false,
                        buttons: false,
                        states: true,
                    },
                    w_focusOnOutline
                );
            }
        });
}

</t>
<t tx="felix.20210517001143.1">{
  "command": "leointeg.startSearch",
  "category": "Leo",
  "title": "Start Search"
},
{
  "command": "leointeg.findAll",
  "category": "Leo",
  "title": "Find All"
},
{
  "command": "leointeg.findNext",
  "category": "Leo",
  "title": "Find Next"
},
{
  "command": "leointeg.findNextFromOutline",
  "category": "Leo",
  "title": "Find Next"
},
{
  "command": "leointeg.findPrevious",
  "category": "Leo",
  "title": "Find Previous"
},
{
  "command": "leointeg.findPreviousFromOutline",
  "category": "Leo",
  "title": "Find Previous"
},
{
  "command": "leointeg.findVar",
  "category": "Leo",
  "title": "Find the var under the cursor"
},
{
  "command": "leointeg.findDef",
  "category": "Leo",
  "title": "Find the def or class under the cursor"
},
{
  "command": "leointeg.replace",
  "category": "Leo",
  "title": "Replace"
},
{
  "command": "leointeg.replaceFromOutline",
  "category": "Leo",
  "title": "Replace"
},
{
  "command": "leointeg.replaceThenFind",
  "category": "Leo",
  "title": "Replace Then Find"
},
{
  "command": "leointeg.replaceThenFindFromOutline",
  "category": "Leo",
  "title": "Replace Then Find"
},
{
  "command": "leointeg.replaceAll",
  "category": "Leo",
  "title": "Replace All"
},
{
  "command": "leointeg.gotoGlobalLine",
  "category": "Leo",
  "title": "Goto Global Line"
},
{
  "command": "leointeg.cloneFindAll",
  "category": "Leo",
  "title": "Clone Find All"
},
{
  "command": "leointeg.cloneFindAllFlattened",
  "category": "Leo",
  "title": "Clone Find All Flattened"
},
{
  "command": "leointeg.cloneFindMarked",
  "category": "Leo",
  "title": "cfam - Clone Find All Marked Nodes"
},
{
  "command": "leointeg.cloneFindFlattenedMarked",
  "category": "Leo",
  "title": "cffm - Clone Find All Flattened Marked"
},
{
  "command": "leointeg.cloneFindTag",
  "category": "Leo",
  "title": "cft - Clone Find Tag"
},
{
  "command": "leointeg.tagChildren",
  "category": "Leo",
  "title": "Tag Children"
},
{
  "command": "leointeg.setFindEverywhereOption",
  "category": "Leo",
  "title": "Set Find Everywhere Option"
},
{
  "command": "leointeg.setFindNodeOnlyOption",
  "category": "Leo",
  "title": "Set Find in Node Only Option"
},
{
  "command": "leointeg.setFindSuboutlineOnlyOption",
  "category": "Leo",
  "title": "Set Find in SubOutline Only Option"
},
{
  "command": "leointeg.toggleFindIgnoreCaseOption",
  "category": "Leo",
  "title": "Toggle Find Ignore Case Option"
},
{
  "command": "leointeg.toggleFindMarkChangesOption",
  "category": "Leo",
  "title": "Toggle Find Mark Changes Option"
},
{
  "command": "leointeg.toggleFindMarkFindsOption",
  "category": "Leo",
  "title": "Toggle Find Mark Finds Option"
},
{
  "command": "leointeg.toggleFindRegexpOption",
  "category": "Leo",
  "title": "Toggle Find RegExp Option"
},
{
  "command": "leointeg.toggleFindWordOption",
  "category": "Leo",
  "title": "Toggle Find Whole Word Option"
},
{
  "command": "leointeg.toggleFindSearchBodyOption",
  "category": "Leo",
  "title": "Toggle Find Search Body Option"
},
{
  "command": "leointeg.toggleFindSearchHeadlineOption",
  "category": "Leo",
  "title": "Toggle Find Search Headline Option"
},
</t>
<t tx="felix.20210517001459.1">{
  "command": "leointeg.mark",
  "category": "Leo",
  "title": "Mark",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leointeg.markSelection",
  "category": "Leo",
  "title": "Mark",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leointeg.markSelectionFromOutline",
  "category": "Leo",
  "title": "Mark",
  "icon": {
    "light": "resources/light/mark.svg",
    "dark": "resources/dark/mark.svg"
  }
},
{
  "command": "leointeg.unmark",
  "category": "Leo",
  "title": "Unmark",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leointeg.unmarkSelection",
  "category": "Leo",
  "title": "Unmark",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leointeg.unmarkSelectionFromOutline",
  "category": "Leo",
  "title": "Unmark",
  "icon": {
    "light": "resources/light/unmark.svg",
    "dark": "resources/dark/unmark.svg"
  }
},
{
  "command": "leointeg.unmarkAll",
  "category": "Leo",
  "title": "Unmark All"
},
{
  "command": "leointeg.markSubheads",
  "category": "Leo",
  "title": "Mark Subheads"
},
{
  "command": "leointeg.markChangedItems",
  "category": "Leo",
  "title": "Mark Changed Items"
},
{
  "command": "leointeg.copyMarked",
  "category": "Leo",
  "title": "Copy Marked"
},
{
  "command": "leointeg.cloneMarkedNodes",
  "category": "Leo",
  "title": "Clone Marked Nodes"
},
{
  "command": "leointeg.diffMarkedNodes",
  "category": "Leo",
  "title": "Diff Marked Nodes"
},
{
  "command": "leointeg.deleteMarkedNodes",
  "category": "Leo",
  "title": "Delete Marked Nodes"
},
{
  "command": "leointeg.moveMarkedNodes",
  "category": "Leo",
  "title": "Move Marked Nodes"
}
</t>
<t tx="felix.20210517004335.1">{
  "command": "leointeg.startSearch",
  "key": "ctrl+f",
  "mac": "cmd+f",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.startSearch",
  "key": "ctrl+f",
  "mac": "cmd+f",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.findNextFromOutline",
  "key": "f3",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.findNext",
  "key": "f3",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.findPreviousFromOutline",
  "key": "f2",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.findPrevious",
  "key": "f2",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.replace",
  "key": "ctrl+=",
  "mac": "cmd+=",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.replaceFromOutline",
  "key": "ctrl+=",
  "mac": "cmd+=",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.replaceThenFind",
  "key": "ctrl+-",
  "mac": "cmd+-",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.replaceThenFindFromOutline",
  "key": "ctrl+-",
  "mac": "cmd+-",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.gotoGlobalLine",
  "key": "alt+g",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.gotoGlobalLine",
  "key": "alt+g",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.setFindEverywhereOption",
  "key": "ctrl+alt+e",
  "mac": "cmd+alt+e",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.setFindEverywhereOption",
  "key": "ctrl+alt+e",
  "mac": "cmd+alt+e",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.setFindNodeOnlyOption",
  "key": "ctrl+alt+n",
  "mac": "cmd+alt+n",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.setFindNodeOnlyOption",
  "key": "ctrl+alt+n",
  "mac": "cmd+alt+n",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.setFindSuboutlineOnlyOption",
  "key": "ctrl+alt+s",
  "mac": "cmd+alt+s",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.setFindSuboutlineOnlyOption",
  "key": "ctrl+alt+s",
  "mac": "cmd+alt+s",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindIgnoreCaseOption",
  "key": "ctrl+alt+i",
  "mac": "cmd+alt+i",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.toggleFindIgnoreCaseOption",
  "key": "ctrl+alt+i",
  "mac": "cmd+alt+i",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindMarkChangesOption",
  "key": "ctrl+alt+c",
  "mac": "cmd+alt+c",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.toggleFindMarkChangesOption",
  "key": "ctrl+alt+c",
  "mac": "cmd+alt+c",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindMarkFindsOption",
  "key": "ctrl+alt+f",
  "mac": "cmd+alt+f",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.toggleFindMarkFindsOption",
  "key": "ctrl+alt+f",
  "mac": "cmd+alt+f",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindRegexpOption",
  "key": "ctrl+alt+x",
  "mac": "cmd+alt+x",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.toggleFindRegexpOption",
  "key": "ctrl+alt+x",
  "mac": "cmd+alt+x",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindWordOption",
  "key": "ctrl+alt+w",
  "mac": "cmd+alt+w",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.toggleFindWordOption",
  "key": "ctrl+alt+w",
  "mac": "cmd+alt+w",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindSearchBodyOption",
  "key": "ctrl+alt+b",
  "mac": "cmd+alt+b",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.toggleFindSearchBodyOption",
  "key": "ctrl+alt+b",
  "mac": "cmd+alt+b",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
},
{
  "command": "leointeg.toggleFindSearchHeadlineOption",
  "key": "ctrl+alt+h",
  "mac": "cmd+alt+h",
  "when": "leoTreeOpened &amp;&amp; sideBarFocus &amp;&amp; focusedView =~ /^leo/"
},
{
  "command": "leointeg.toggleFindSearchHeadlineOption",
  "key": "ctrl+alt+h",
  "mac": "cmd+alt+h",
  "when": "leoTreeOpened &amp;&amp; editorTextFocus &amp;&amp; resourceScheme == leo"
}
</t>
<t tx="felix.20210522001751.1">import * as vscode from 'vscode';
import { Constants } from '../constants';
import { LeoIntegration } from '../leoIntegration';
import * as utils from '../utils';

@language typescript
@tabwidth -4
@others
</t>
<t tx="felix.20210522001814.1">/**
 * Leo Find Panel provider
 */
export class LeoFindPanelProvider implements vscode.WebviewViewProvider {
    private _view?: vscode.WebviewView;

    constructor(
        private readonly _extensionUri: vscode.Uri,
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="felix.20210522152739.1">/**
 * * LeoInteg search settings structure for use with the 'find' webview
 */
export interface LeoSearchSettings {
    //Find/change strings...
    findText: string;
    replaceText: string;
    // Find options...
    wholeWord: boolean;
    ignoreCase: boolean;
    regExp: boolean;
    markFinds: boolean;
    markChanges: boolean;
    searchHeadline: boolean;
    searchBody: boolean;
    searchScope: LeoSearchScope; // 0, 1 or 2 for outline, sub-outline, or node.
}

</t>
<t tx="felix.20210522152922.1">/**
 * * LeoInteg's Enum type for the search scope radio buttons of the find panel.
 */
export const enum LeoSearchScope {
    entireOutline = 0,
    subOutlineOnly,
    nodeOnly
}

</t>
<t tx="felix.20210522233604.1"></t>
<t tx="felix.20210522233744.1">{
  "view": "leoFindPanel",
  "contents": "Not connected",
  "when": "!leoTreeOpened"
},
{
  "view": "leoFindPanelExplorer",
  "contents": "Not connected",
  "when": "!leoTreeOpened"
}
</t>
<t tx="felix.20210523162125.1">/**
 * * Leo's GUI search settings internal structure
 */
export interface LeoGuiFindTabManagerSettings {
    //Find/change strings...
    find_text: string,
    change_text: string,
    // Find options...
    ignore_case: boolean,
    mark_changes: boolean,
    mark_finds: boolean,
    node_only: boolean,
    pattern_match: boolean,
    search_body: boolean,
    search_headline: boolean,
    suboutline_only: boolean,
    whole_word: boolean
}

</t>
<t tx="felix.20210524215215.1">/**
 * * Send the settings to the Leo Bridge Server
 */
public saveSearchSettings(p_settings: LeoSearchSettings): Promise&lt;LeoBridgePackage&gt; {
    this._lastSettingsUsed = p_settings;
    // convert to LeoGuiFindTabManagerSettings
    const w_settings: LeoGuiFindTabManagerSettings = {
        //Find/change strings...
        find_text: p_settings.findText,
        change_text: p_settings.replaceText,
        // Find options...
        ignore_case: p_settings.ignoreCase,
        mark_changes: p_settings.markChanges,
        mark_finds: p_settings.markFinds,
        node_only: !!(p_settings.searchScope === 2),
        pattern_match: p_settings.regExp,
        search_body: p_settings.searchBody,
        search_headline: p_settings.searchHeadline,
        suboutline_only: !!(p_settings.searchScope === 1),
        whole_word: p_settings.wholeWord,
    };
    return this.sendAction(
        Constants.LEOBRIDGE.SET_SEARCH_SETTINGS,
        JSON.stringify({ searchSettings: w_settings })
    );
}

</t>
<t tx="felix.20210524231157.1">/**
 * * Capture instance for further calls on find panel webview
 */
public setFindPanel(p_panel: vscode.WebviewView) {
    if (this._lastTreeView === this._leoTreeExView) {
        this._findPanelWebviewExplorerView = p_panel;
    } else {
        this._findPanelWebviewView = p_panel;
    }
}

</t>
<t tx="felix.20210525232728.1">/**
 * * Get settings from Leo and apply them to the find panel webviews
 */
public loadSearchSettings(): void {
    this.sendAction(Constants.LEOBRIDGE.GET_SEARCH_SETTINGS).then(
        (p_result: LeoBridgePackage) =&gt; {
            const w_searchSettings: LeoGuiFindTabManagerSettings = p_result.searchSettings!;
            const w_settings: LeoSearchSettings = {
                //Find/change strings...
                findText: w_searchSettings.find_text,
                replaceText: w_searchSettings.change_text,
                // Find options...
                wholeWord: w_searchSettings.whole_word,
                ignoreCase: w_searchSettings.ignore_case,
                regExp: w_searchSettings.pattern_match,
                markFinds: w_searchSettings.mark_finds,
                markChanges: w_searchSettings.mark_changes,
                searchHeadline: w_searchSettings.search_headline,
                searchBody: w_searchSettings.search_body,
                // 0, 1 or 2 for outline, sub-outline, or node.
                searchScope:
                    0 +
                    (w_searchSettings.suboutline_only ? 1 : 0) +
                    (w_searchSettings.node_only ? 2 : 0),
            };
            if (w_settings.searchScope &gt; 2) {
                console.error('searchScope SHOULD BE 0,1,2 only: ', w_settings.searchScope);
            }
            this._lastSettingsUsed = w_settings;
            if (this._findPanelWebviewExplorerView) {
                this._findPanelWebviewExplorerView.webview.postMessage({
                    type: 'setSettings',
                    value: w_settings,
                });
            }
            if (this._findPanelWebviewView) {
                this._findPanelWebviewView.webview.postMessage({
                    type: 'setSettings',
                    value: w_settings,
                });
            }
        }
    );
}

</t>
<t tx="felix.20210528012836.1">/**
 * * Check if Leo should be focused on outline
 */
public getBridgeFocus(): void {
    this.sendAction(Constants.LEOBRIDGE.GET_FOCUS).then((p_resultFocus: LeoBridgePackage) =&gt; {
        if (p_resultFocus.focus) {
            const w_focus = p_resultFocus.focus.toLowerCase();
            if (w_focus.includes('tree') || w_focus.includes('head')) {
                this._fromOutline = true;
                // this.showOutline(true);
            }
        }
    });
}

</t>
<t tx="felix.20210530153353.1">{
  "command": "leointeg.startSearch",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findNext",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findPrevious",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findVar",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.findDef",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.replace",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.replaceThenFind",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.replaceAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.setFindEverywhereOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.setFindNodeOnlyOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.setFindSuboutlineOnlyOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindIgnoreCaseOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindMarkChangesOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindMarkFindsOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindRegexpOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindWordOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindSearchBodyOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.toggleFindSearchHeadlineOption",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.gotoGlobalLine",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindAllFlattened",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindFlattenedMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneFindTag",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.tagChildren",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20210530153359.1">{
  "command": "leointeg.copyMarked",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.diffMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markChangedItems",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.markSubheads",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.unmarkAll",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.cloneMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.deleteMarkedNodes",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.moveMarkedNodes",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20210530160638.1">{
  "command": "leointeg.extract",
  "when": "leoTreeOpened"
},
{
  "command": "leointeg.extractNames",
  "when": "leoTreeOpened"
},
</t>
<t tx="felix.20210530161800.1">{
  "command": "leointeg.findNextFromOutline",
  "when": "false"
},
{
  "command": "leointeg.findPreviousFromOutline",
  "when": "false"
},
{
  "command": "leointeg.replaceFromOutline",
  "when": "false"
},
{
  "command": "leointeg.replaceThenFindFromOutline",
  "when": "false"
}
</t>
<t tx="felix.20210530223726.1">/**
 * * Replace / Replace-Then-Find commands
 * @param p_fromOutline
 * @param p_thenFind
 * @returns Promise that resolves when the "launch refresh" is started
 */
public replace(p_fromOutline: boolean, p_thenFind: boolean): Promise&lt;any&gt; {
    const w_action: string = p_thenFind
        ? Constants.LEOBRIDGE.REPLACE_THEN_FIND
        : Constants.LEOBRIDGE.REPLACE;
    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(w_action, JSON.stringify({ fromOutline: !!p_fromOutline }));
        })
        .then((p_replaceResult: LeoBridgePackage) =&gt; {
            if (!p_replaceResult.found || !p_replaceResult.focus) {
                vscode.window.showInformationMessage('Not found');
            } else {
                let w_focusOnOutline = false;
                const w_focus = p_replaceResult.focus.toLowerCase();
                if (w_focus.includes('tree') || w_focus.includes('head')) {
                    // tree
                    w_focusOnOutline = true;
                }
                this.launchRefresh(
                    {
                        tree: true,
                        body: true,
                        scroll: true,
                        documents: false,
                        buttons: false,
                        states: true,
                    },
                    w_focusOnOutline
                );
            }
        });
}

</t>
<t tx="felix.20210530225306.1">/**
 * * Set search setting in the search webview
 */
public setSearchSetting(p_id: string): void {
    let w_panel: vscode.WebviewView | undefined;
    if (this._lastTreeView === this._leoTreeExView) {
        w_panel = this._findPanelWebviewExplorerView;
    } else {
        w_panel = this._findPanelWebviewView;
    }
    w_panel!.webview.postMessage({ type: 'setSearchSetting', id: p_id });
}

</t>
<t tx="felix.20210530225640.1"></t>
<t tx="felix.20210530230354.1">/*
 * * Find / Replace All
 */
public findAll(p_replace: boolean): Promise&lt;any&gt; {
    const w_action: string = p_replace
        ? Constants.LEOBRIDGE.REPLACE_ALL
        : Constants.LEOBRIDGE.FIND_ALL;

    let w_searchString: string = this._lastSettingsUsed!.findText;
    let w_replaceString: string = this._lastSettingsUsed!.replaceText;

    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            return this._inputFindPattern()
                .then((p_findString) =&gt; {
                    if (!p_findString) {
                        return true; // Cancelled with escape or empty string.
                    }
                    w_searchString = p_findString;
                    if (p_replace) {
                        return this._inputFindPattern(true).then((p_replaceString) =&gt; {
                            if (p_replaceString === undefined) {
                                return true;
                            }
                            w_replaceString = p_replaceString;
                            return false;
                        });
                    }
                    return false;
                });
        })
        .then((p_cancelled: boolean) =&gt; {
            if (this._lastSettingsUsed &amp;&amp; !p_cancelled) {
                this._lastSettingsUsed.findText = w_searchString;
                this._lastSettingsUsed.replaceText = w_replaceString;
                this.saveSearchSettings(this._lastSettingsUsed); // No need to wait, will be stacked.
                return this.sendAction(w_action)
                    .then((p_findResult: LeoBridgePackage) =&gt; {
                        let w_focusOnOutline = false;
                        const w_focus = p_findResult.focus!.toLowerCase();
                        if (w_focus.includes('tree') || w_focus.includes('head')) {
                            // tree
                            w_focusOnOutline = true;
                        }
                        this.loadSearchSettings();
                        this.launchRefresh(
                            { tree: true, body: true, documents: false, buttons: false, states: true },
                            w_focusOnOutline
                        );
                    });
            }
        });
}

</t>
<t tx="felix.20210530230400.1">/**
 * * Clone Find All / Marked / Flattened
 */
public cloneFind(p_marked: boolean, p_flat: boolean): Promise&lt;any&gt; {
    let w_searchString: string = this._lastSettingsUsed!.findText;
    let w_action: string;
    if (p_marked) {
        w_action = p_flat
            ? Constants.LEOBRIDGE.CLONE_FIND_FLATTENED_MARKED
            : Constants.LEOBRIDGE.CLONE_FIND_MARKED;
    } else {
        w_action = p_flat
            ? Constants.LEOBRIDGE.CLONE_FIND_ALL_FLATTENED
            : Constants.LEOBRIDGE.CLONE_FIND_ALL;
    }

    if (p_marked) {
        // don't use find methods.
        return this.nodeCommand({
            action: w_action,
            node: undefined,
            refreshType: {
                tree: true,
                body: true,
                documents: false,
                buttons: false,
                states: true,
            },
            fromOutline: false,
        }) || Promise.resolve();
    }

    return this._isBusyTriggerSave(false, true)
        .then(() =&gt; {
            return this._inputFindPattern()
                .then((p_findString) =&gt; {
                    if (!p_findString) {
                        return true; // Cancelled with escape or empty string.
                    }
                    w_searchString = p_findString;
                    return false;
                });
        })
        .then((p_cancelled: boolean) =&gt; {
            if (this._lastSettingsUsed &amp;&amp; !p_cancelled) {
                this._lastSettingsUsed.findText = w_searchString;
                this.saveSearchSettings(this._lastSettingsUsed); // No need to wait, will be stacked.
                return this.sendAction(w_action)
                    .then((p_cloneFindResult: LeoBridgePackage) =&gt; {
                        let w_focusOnOutline = false;
                        const w_focus = p_cloneFindResult.focus!.toLowerCase();
                        if (w_focus.includes('tree') || w_focus.includes('head')) {
                            // tree
                            w_focusOnOutline = true;
                        }
                        this.loadSearchSettings();
                        this.launchRefresh(
                            { tree: true, body: true, documents: false, buttons: false, states: true },
                            w_focusOnOutline
                        );
                    });
            }
        });
}

</t>
<t tx="felix.20210530233134.1">/**
 * * Find panel controls ids
 */
public static FIND_INPUTS_IDS = {
    FIND_TEXT: "findText",
    REPLACE_TEXT: "replaceText",
    ENTIRE_OUTLINE: "entireOutline",
    NODE_ONLY: "nodeOnly",
    SUBOUTLINE_ONLY: "subOutlineOnly",
    IGNORE_CASE: "ignoreCase",
    MARK_CHANGES: "markChanges",
    MARK_FINDS: "markFinds",
    REG_EXP: "regExp",
    WHOLE_WORD: "wholeWord",
    SEARCH_BODY: "searchBody",
    SEARCH_HEADLINE: "searchHeadline"
};

</t>
<t tx="felix.20210601164915.1">/**
 * * Goto Global Line
 */
public gotoGlobalLine(): void {
    this.triggerBodySave(false)
        .then((p_saveResult: boolean) =&gt; {
            return vscode.window.showInputBox({
                title: Constants.USER_MESSAGES.TITLE_GOTO_GLOBAL_LINE,
                placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_GOTO_GLOBAL_LINE,
                prompt: Constants.USER_MESSAGES.PROMPT_GOTO_GLOBAL_LINE,
            });
        })
        .then((p_inputResult?: string) =&gt; {
            if (p_inputResult) {
                const w_line = parseInt(p_inputResult);
                if (!isNaN(w_line)) {
                    this.sendAction(
                        Constants.LEOBRIDGE.GOTO_GLOBAL_LINE,
                        JSON.stringify({ line: w_line })
                    ).then((p_resultGoto: LeoBridgePackage) =&gt; {
                        if (!p_resultGoto.found) {
                            // Not found
                        }
                        this.launchRefresh(
                            {
                                tree: true,
                                body: true,
                                documents: false,
                                buttons: false,
                                states: true,
                            },
                            false
                        );
                    });
                }
            }
        });
}

</t>
<t tx="felix.20210602151654.1">/**
 * * Overridden 'good' minibuffer commands
 */
public static MINIBUFFER_OVERRIDDEN_COMMANDS: { [key: string]: string } = {
    "tag-children": Constants.COMMANDS.TAG_CHILDREN,
    "clone-find-tag": Constants.COMMANDS.CLONE_FIND_TAG,
    "import-file": Constants.COMMANDS.IMPORT_ANY_FILE,
    "redo": Constants.COMMANDS.REDO,
    "undo": Constants.COMMANDS.UNDO,
    "clone-find-all": Constants.COMMANDS.CLONE_FIND_ALL,
    "clone-find-all-flattened": Constants.COMMANDS.CLONE_FIND_ALL_FLATTENED,

    'import-MORE-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-free-mind-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-jupyter-notebook': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-legacy-external-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-mind-jet-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-tabbed-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-todo-text-files': Constants.COMMANDS.IMPORT_ANY_FILE,
    'import-zim-folder': Constants.COMMANDS.IMPORT_ANY_FILE,

    'file-new': Constants.COMMANDS.NEW_FILE,
    'file-open-by-name': Constants.COMMANDS.OPEN_FILE,
    'new': Constants.COMMANDS.NEW_FILE,
    'open-outline': Constants.COMMANDS.OPEN_FILE,
    'file-save': Constants.COMMANDS.SAVE_FILE,
    'file-save-as': Constants.COMMANDS.SAVE_AS_FILE,
    'file-save-as-unzipped': Constants.COMMANDS.SAVE_AS_FILE,
    'file-save-by-name': Constants.COMMANDS.SAVE_AS_FILE,
    'file-save-to': Constants.COMMANDS.SAVE_AS_FILE,
    'save': Constants.COMMANDS.SAVE_FILE,
    'save-as': Constants.COMMANDS.SAVE_AS_FILE,
    'save-file': Constants.COMMANDS.SAVE_FILE,
    'save-file-as': Constants.COMMANDS.SAVE_AS_FILE,
    'save-file-as-unzipped': Constants.COMMANDS.SAVE_AS_FILE,
    'save-file-by-name': Constants.COMMANDS.SAVE_AS_FILE,
    'save-file-to': Constants.COMMANDS.SAVE_AS_FILE,
    'save-to': Constants.COMMANDS.SAVE_AS_FILE,

    'clone-find-all-flattened-marked': Constants.COMMANDS.CLONE_FIND_FLATTENED_MARKED,
    'clone-find-all-marked': Constants.COMMANDS.CLONE_FIND_MARKED,

    'clone-marked-nodes': Constants.COMMANDS.CLONE_MARKED_NODES,

    'cfa': Constants.COMMANDS.CLONE_FIND_ALL,
    'cfam': Constants.COMMANDS.CLONE_FIND_MARKED,
    'cff': Constants.COMMANDS.CLONE_FIND_ALL_FLATTENED,
    'cffm': Constants.COMMANDS.CLONE_FIND_FLATTENED_MARKED,
    'cft': Constants.COMMANDS.CLONE_FIND_TAG,

    'git-diff': Constants.COMMANDS.GIT_DIFF,
    'gd': Constants.COMMANDS.GIT_DIFF,

    'find-tab-open': Constants.COMMANDS.START_SEARCH,
    'find-clone-all': Constants.COMMANDS.CLONE_FIND_ALL,
    'find-clone-all-flattened': Constants.COMMANDS.CLONE_FIND_ALL_FLATTENED,
    'find-clone-tag': Constants.COMMANDS.CLONE_FIND_TAG,
    'find-all': Constants.COMMANDS.FIND_ALL,
    'start-search': Constants.COMMANDS.START_SEARCH,
    'find-next': Constants.COMMANDS.FIND_NEXT,
    'find-prev': Constants.COMMANDS.FIND_PREVIOUS,
    'search-backward': Constants.COMMANDS.FIND_NEXT,
    'search-forward': Constants.COMMANDS.FIND_PREVIOUS,
    'find-var': Constants.COMMANDS.FIND_VAR,
    'find-def': Constants.COMMANDS.FIND_DEF,
    'replace': Constants.COMMANDS.REPLACE,
    'replace-all': Constants.COMMANDS.REPLACE_ALL,
    'change-all': Constants.COMMANDS.REPLACE_ALL,
    'change-then-find': Constants.COMMANDS.REPLACE_THEN_FIND,
    'replace-then-find': Constants.COMMANDS.REPLACE_THEN_FIND,
    'show-find-options': Constants.COMMANDS.START_SEARCH,
    'toggle-find-ignore-case-option': Constants.COMMANDS.TOGGLE_FIND_IGNORE_CASE_OPTION,
    'toggle-find-in-body-option': Constants.COMMANDS.TOGGLE_FIND_SEARCH_BODY_OPTION,
    'toggle-find-in-headline-option': Constants.COMMANDS.TOGGLE_FIND_SEARCH_HEADLINE_OPTION,
    'toggle-find-mark-changes-option': Constants.COMMANDS.TOGGLE_FIND_MARK_CHANGES_OPTION,
    'toggle-find-mark-finds-option': Constants.COMMANDS.TOGGLE_FIND_MARK_FINDS_OPTION,
    'toggle-find-regex-option': Constants.COMMANDS.TOGGLE_FIND_REGEXP_OPTION,
    'toggle-find-word-option': Constants.COMMANDS.TOGGLE_FIND_WORD_OPTION,

    'goto-next-history-node': Constants.COMMANDS.PREV_NODE,
    'goto-prev-history-node': Constants.COMMANDS.NEXT_NODE,


};

</t>
<t tx="felix.20210602155312.1">/**
 * * Import any File(s)
 * No URL passed from the command definition.
 * @param p_leoFileUri is offered for internal use only
 */
public importAnyFile(p_leoFileUri?: vscode.Uri): Thenable&lt;unknown&gt; {
    return this._isBusyTriggerSave(true, true)
        .then((p_saveResult) =&gt; {
            let q_importFile: Promise&lt;LeoBridgePackage | undefined&gt;; // Promise for opening a file
            if (p_leoFileUri &amp;&amp; p_leoFileUri.fsPath.trim()) {
                const w_fixedFilePath: string = p_leoFileUri.fsPath.replace(/\\/g, '/');
                q_importFile = this.sendAction(
                    Constants.LEOBRIDGE.IMPORT_ANY_FILE,
                    JSON.stringify({ filenames: w_fixedFilePath })
                );
            } else {
                q_importFile = this._leoFilesBrowser.getImportFileUrls().then(
                    (p_chosenLeoFiles) =&gt; {
                        if (p_chosenLeoFiles.length) {
                            return this.sendAction(
                                Constants.LEOBRIDGE.IMPORT_ANY_FILE,
                                JSON.stringify({ filenames: p_chosenLeoFiles })
                            );
                        } else {
                            return Promise.resolve(undefined);
                        }
                    },
                    (p_errorGetFile) =&gt; {
                        return Promise.reject(p_errorGetFile);
                    }
                );
            }
            return q_importFile;
        })
        .then(
            (p_importFileResult: LeoBridgePackage | undefined) =&gt; {
                if (p_importFileResult) {
                    return this.launchRefresh(
                        {
                            tree: true,
                            body: true,
                            documents: true,
                            buttons: false,
                            states: true,
                        },
                        false
                    );
                } else {
                    return Promise.resolve(undefined);
                }
            },
            (p_errorImport) =&gt; {
                console.log('in .then not imported'); // TODO : IS REJECTION BEHAVIOR NECESSARY HERE TOO?
                return Promise.reject(p_errorImport);
            }
        );
}

</t>
<t tx="felix.20210602160216.1">/**
 * * Open a file browser to let user choose file(s) to import
 * @param p_fileType can be used to restrict to a particular file type
 * @returns a promise of an array of filepath+name strings
 */
public getImportFileUrls(p_fileType?: string): Promise&lt;string[]&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve([]);
    }
    this._fileBrowserActive = true;
    let w_types: { [name: string]: string[]; };
    if (p_fileType &amp;&amp; Constants.IMPORT_FILE_TYPES[p_fileType]) {
        w_types = {};
        w_types[p_fileType] = Constants.IMPORT_FILE_TYPES[p_fileType];
    } else {
        w_types = Constants.IMPORT_FILE_TYPES;
    }
    return new Promise((p_resolve, p_reject) =&gt; {
        vscode.window
            .showOpenDialog({
                canSelectMany: true,
                openLabel: "Import File",
                canSelectFolders: false,
                filters: w_types,
                defaultUri: this._getBestOpenFolderUri()
            })
            .then(p_chosenLeoFiles =&gt; {
                this._fileBrowserActive = false;
                if (p_chosenLeoFiles) {
                    // array instead of single string
                    const w_result = p_chosenLeoFiles.map(function (e) {
                        return e.fsPath.replace(/\\/g, "/").trim();
                    });
                    p_resolve(w_result); // Replace backslashes for windows support
                } else {
                    p_resolve([]);
                }
            });
    });
}
</t>
<t tx="felix.20210602213308.1">/**
 * * Possible import file types
 */
public static IMPORT_FILE_TYPES: { [name: string]: string[]; } = {
    "All files": ["*"],
    "C/C++ files": ["c", "cpp", "h", "hpp"],
    "FreeMind files": ["mm.html"],
    "Java files": ["java"],
    "JavaScript files": ["js"],
    // "JSON files": ["json"],
    "Mindjet files": ["csv"],
    "MORE files": ["MORE"],
    "Lua files": ["lua"],
    "Pascal files": ["pas"],
    "Python files": ["py"],
    "Text files": ["txt"],
};

</t>
<t tx="felix.20210610022645.1">"editor/title": [
  {
    "command": "leointeg.showSettingsPage",
    "when": "resourceScheme == leo",
    "group": "2_custom"
  },
  {
    "command": "leointeg.prev",
    "when": "resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.next",
    "when": "resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@2"
  },
  {
    "command": "leointeg.hoistSelection",
    "when": "showHoistOnBody &amp;&amp; !leoRoot &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@3"
  },
  {
    "command": "leointeg.deHoist",
    "when": "showHoistOnBody &amp;&amp; leoCanDehoist &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@4"
  },
  {
    "command": "leointeg.promoteSelection",
    "when": "showPromoteOnBody &amp;&amp; leoCanPromote &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@5"
  },
  {
    "command": "leointeg.demoteSelection",
    "when": "showPromoteOnBody &amp;&amp; leoCanDemote &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@6"
  },
  {
    "command": "leointeg.executeScript",
    "when": "showExecuteOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@7"
  },
  {
    "command": "leointeg.extract",
    "when": "showExtractOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@8"
  },
  {
    "command": "leointeg.extractNames",
    "when": "showExtractOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@9"
  },
  {
    "command": "leointeg.cloneNodeSelection",
    "when": "showEditionOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@10"
  },
  {
    "command": "leointeg.insertNodeSelection",
    "when": "showEditionOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@11"
  },
  {
    "command": "leointeg.insertChildNodeSelection",
    "when": "showEditionOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@12"
  },
  {
    "command": "leointeg.deleteSelection",
    "when": "showEditionOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@13"
  },
  {
    "command": "leointeg.cutNodeSelection",
    "when": "showClipboardOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@14"
  },
  {
    "command": "leointeg.copyNodeSelection",
    "when": "showClipboardOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@15"
  },
  {
    "command": "leointeg.pasteNodeAtSelection",
    "when": "showClipboardOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@16"
  },
  {
    "command": "leointeg.pasteNodeAsCloneAtSelection",
    "when": "showClipboardOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@17"
  },
  {
    "command": "leointeg.markSelection",
    "when": "showMarkOnBody &amp;&amp; !leoMarked  &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@18"
  },
  {
    "command": "leointeg.unmarkSelection",
    "when": "showMarkOnBody &amp;&amp; leoMarked  &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@19"
  },
  {
    "command": "leointeg.sortSiblingsSelection",
    "when": "showSortOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@20"
  },
  {
    "command": "leointeg.importAnyFile",
    "when": "showImportOnBody &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@21"
  },
  {
    "command": "leointeg.refreshFromDiskSelection",
    "when": "showRefreshOnBody &amp;&amp; leoAtFile &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@22"
  }
],
</t>
<t tx="felix.20210610022836.1">/**
 * * Previous / Next Node Buttons
 */
public prevNextNode(p_next: boolean, p_fromOutline?: boolean): Promise&lt;any&gt; {
    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            let w_command: string;
            if (p_next) {
                w_command = Constants.LEOBRIDGE.GOTO_NEXT_HISTORY;
            } else {
                w_command = Constants.LEOBRIDGE.GOTO_PREV_HISTORY;
            }
            return this.nodeCommand({
                action: w_command,
                node: undefined,
                refreshType: { tree: true, states: true, body: true },
                fromOutline: !!p_fromOutline,
            });
        });
}

</t>
<t tx="felix.20210612000127.1">## 0.1.14

- Rewrite of the leobridgeserver.py to be made compatible with the standards in leoserver.py from Leo.
- Added option for specifying server file and path. Defaults to the internal leobridgeserver.py server.
- Fixed cursor position and selection bugs.
- Fixed automatic server startup and connection bugs.
- Added Search functionality along with a 'find' panel.
- Added goto global line and other clone-find related commands from Leo's 'Search' menu.
- Added import-file(s) command - an alias of the import-any-file command form Leo.
- Temporary fix for some minibuffer commands to override the widgets interactions (ex. clone-find-all, etc.)
- Undo and redo icons are now faded out instead of disappearing when unavailable - to help with button shifting when clicking rapidly.
- Many other small bugfixes.

</t>
<t tx="felix.20210612214028.1">/**
 * * Find next available port starting with p_startingPort inclusively,
 * * check next (max 5) additional ports and return port number, or 0 if none.
 * @param p_startingPort the port number at which to start looking for a free port
 * @returns a promise of an opened port number
 */
export function findNextAvailablePort(p_startingPort: number): Promise&lt;number&gt; {
    const q_portFinder = portfinder.getPortPromise({
        port: p_startingPort,
        startPort: p_startingPort,
        stopPort: p_startingPort + 5
    });
    return q_portFinder;
}

</t>
<t tx="felix.20210613205741.1">/**
 * * Return a promise for a find pattern string input from the user
 */
private _inputFindPattern(p_replace?: boolean): Thenable&lt;string | undefined&gt; {
    return vscode.window.showInputBox({
        title: p_replace ? "Replace with" : "Search for",
        prompt: p_replace ? "Type text to replace with and press enter." : "Type text to search for and press enter.",
        placeHolder: p_replace ? "Replace pattern here" : "Find pattern here",
    });
}

</t>
<t tx="felix.20210613210351.1">/**
 * * Popup browser to choose Leo-Editor installation folder path
 */
public chooseLeoFolder() {
    utils.chooseLeoFolderDialog().then(p_chosenPath =&gt; {
        if (p_chosenPath &amp;&amp; p_chosenPath.length) {
            this.config.setLeoIntegSettings(
                [{
                    code: Constants.CONFIG_NAMES.LEO_EDITOR_PATH,
                    value: p_chosenPath[0].fsPath
                }]
            ).then(() =&gt; {
                this.leoSettingsWebview.changedConfiguration();
                vscode.window.showInformationMessage("Leo-Editor installation folder chosen as " + p_chosenPath[0].fsPath);
                if (!this.finishedStartup &amp;&amp; this.config.startServerAutomatically) {
                    this.startServer();
                }
            });
        }
    });
}

</t>
<t tx="felix.20210613212439.1"></t>
<t tx="felix.20210614235023.1">/**
 * * Return dialog for choosing the Leo Editor installation folder path
 */
export function chooseLeoFolderDialog(): Thenable&lt;vscode.Uri[] | undefined&gt; {
    return vscode.window.showOpenDialog(
        {
            title: "Locate Leo-Editor Installation Folder",
            canSelectMany: false,
            openLabel: "Choose Folder",
            canSelectFiles: false,
            canSelectFolders: true
        }
    );
}

</t>
<t tx="felix.20210620220655.1">/**
 * * Tag Children
 */
public tagChildren(): void {
    this.triggerBodySave(false)
        .then((p_saveResult: boolean) =&gt; {
            return vscode.window.showInputBox({
                title: Constants.USER_MESSAGES.TITLE_TAG_CHILDREN,
                placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_TAG_CHILDREN,
                prompt: Constants.USER_MESSAGES.PROMPT_TAG_CHILDREN,
            });
        })
        .then((p_inputResult?: string) =&gt; {
            if (p_inputResult &amp;&amp; p_inputResult.trim()) {
                this.sendAction(
                    Constants.LEOBRIDGE.TAG_CHILDREN,
                    JSON.stringify({ tag: p_inputResult.trim() })
                ).then((p_resultFind: LeoBridgePackage) =&gt; {
                    if (!p_resultFind.found) {
                        // Not found
                    }
                    this.launchRefresh(
                        {
                            tree: true,
                            body: true,
                            documents: false,
                            buttons: false,
                            states: true,
                        },
                        false
                    );
                });
            }
        });
}

</t>
<t tx="felix.20210620220702.1">/**
 * * Clone Find Tag
 */
public cloneFindTag(): void {
    this.triggerBodySave(false)
        .then((p_saveResult: boolean) =&gt; {
            return vscode.window.showInputBox({
                title: Constants.USER_MESSAGES.TITLE_FIND_TAG,
                placeHolder: Constants.USER_MESSAGES.PLACEHOLDER_CLONE_FIND_TAG,
                prompt: Constants.USER_MESSAGES.PROMPT_CLONE_FIND_TAG,
            });
        })
        .then((p_inputResult?: string) =&gt; {
            if (p_inputResult &amp;&amp; p_inputResult.trim()) {
                this.sendAction(
                    Constants.LEOBRIDGE.CLONE_FIND_TAG,
                    JSON.stringify({ tag: p_inputResult.trim() })
                ).then((p_resultFind: LeoBridgePackage) =&gt; {
                    if (!p_resultFind.found) {
                        // Not found
                    }
                    this.launchRefresh(
                        {
                            tree: true,
                            body: true,
                            documents: false,
                            buttons: false,
                            states: true,
                        },
                        false
                    );
                });
            }
        });
}

</t>
<t tx="felix.20210703013251.1">"leoIntegration.showEditionOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows clone, delete and insert nodes above the body pane"
},
"leoIntegration.showClipboardOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows cut, copy &amp; paste nodes above the body pane"
},
"leoIntegration.showPromoteOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows promote and demote above the body pane"
},
"leoIntegration.showExecuteOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Execute Script' above the body pane"
},
"leoIntegration.showExtractOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows extract commands above the body pane"
},
"leoIntegration.showImportOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Import File' above the body pane"
},
"leoIntegration.showRefreshOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Refresh from disk' above the body pane"
},
"leoIntegration.showHoistOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows Hoist commands above the body pane"
},
"leoIntegration.showMarkOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows Mark commands above the body pane"
},
"leoIntegration.showSortOnBody": {
  "scope": "application",
  "default": true,
  "type": "boolean",
  "description": "Shows 'Sort Siblings' above the body pane"
},
</t>
<t tx="felix.20210706233101.1">/**
 * * Unique numeric Id
 */
var uniqueId: number = 0;

</t>
<t tx="felix.20210706233106.1">/**
 * * Get new uniqueID
 */
export function getUniqueId(): string {
    const id = uniqueId++;
    return id.toString();
}

</t>
<t tx="felix.20210709004123.1">{
  "command": "leointeg.statusBar",
  "when": "false"
},
</t>
<t tx="felix.20210713000442.1">/**
 * * find-var or find-def commands
 * @param p_def find-def instead of find-var
 * @returns Promise that resolves when the "launch refresh" is started
 */
public findSymbol(p_def: boolean): Promise&lt;any&gt; {
    const w_action: string = p_def
        ? Constants.LEOBRIDGE.FIND_DEF
        : Constants.LEOBRIDGE.FIND_VAR;
    return this._isBusyTriggerSave(false, true)
        .then((p_saveResult) =&gt; {
            return this.sendAction(w_action, JSON.stringify({ fromOutline: false }));
        })
        .then((p_findResult: LeoBridgePackage) =&gt; {
            if (!p_findResult.found || !p_findResult.focus) {
                vscode.window.showInformationMessage('Not found');
            } else {
                let w_focusOnOutline = false;
                const w_focus = p_findResult.focus.toLowerCase();
                if (w_focus.includes('tree') || w_focus.includes('head')) {
                    // tree
                    w_focusOnOutline = true;
                }
                this.loadSearchSettings();
                this.launchRefresh(
                    {
                        tree: true,
                        body: true,
                        scroll: p_findResult.found &amp;&amp; !w_focusOnOutline,
                        documents: false,
                        buttons: false,
                        states: true,
                    },
                    w_focusOnOutline
                );
            }
        });
}

</t>
<t tx="felix.20210713005825.1">"editor/context": [
  {
    "command": "leointeg.findVar",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.findDef",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.extract",
    "when": "!editorHasMultipleSelections &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  },
  {
    "command": "leointeg.extractNames",
    "when": "editorHasSelection &amp;&amp; !editorHasMultipleSelections &amp;&amp; resourceScheme == leo &amp;&amp; leoTreeOpened",
    "group": "navigation@1"
  }
],
</t>
<t tx="felix.20210717192921.1">/**
 * Kills the server if it was started by this instance of leoInteg
 */
public killServer(): void {
    if (this._serverProcess) {
        // this._serverProcess.kill();
        kill(this._serverProcess.pid);
    } else {
        console.error("No stdout");
    }
}

</t>
<t tx="felix.20210717204048.1">/**
 * * Stops the server if it was started by this instance of the extension
 */
public stopServer(): void {
    this._serverService.killServer();
}

</t>
<t tx="felix.20210718155134.1">/**
 * * cleanupBody closes all remaining body pane to shut down this vscode window
 */
public cleanupBody(): Promise&lt;boolean&gt; {
    let q_save: Thenable&lt;boolean&gt;;
    if (this._bodyLastChangedDocument) {
        q_save = this._bodySaveDocument(this._bodyLastChangedDocument, false);
    } else {
        q_save = Promise.resolve(true);
    }
    let q_edit: Thenable&lt;boolean&gt;;
    if (this.bodyUri) {
        const w_edit = new vscode.WorkspaceEdit();
        w_edit.deleteFile(this.bodyUri, { ignoreIfNotExists: true });
        q_edit = vscode.workspace.applyEdit(w_edit).then(() =&gt; {
            return true;
        });
    } else {
        q_edit = Promise.resolve(true);
    }
    return Promise.all([q_save, q_edit])
        .then(() =&gt; {
            return this.closeBody();
        });
}

</t>
<t tx="felix.20210718163005.1">## 0.1.15

- Modified server location logic
- Fixed find-prev, next, find all / clone-find commands
- fixed extract name command
- Fixed body being re-written to same string and being marked dirty when 'safety-saving' before switching docs.
- Detection of .Leo documents themselves now works by closing and re-opening the .leo file if reloading is chosen by the user. (or automatic via options)
- Added icons and commands for top of body pane menu.
- Added new commands such as insert-child along with their keybindings.
- Also added more keybindings to the 'insert-node' command such as 'insert' and 'shift-insert'.
- Added find-var and find-def commands.
- Made some text-related commands available through the right-click context menu in the body pane. (extract, find-var, find-def, etc.)

</t>
<t tx="felix.20210725153617.1">## 0.1.16

- Added procedures to cleanup when closing a vscode window. (closes server and body panes)

</t>
<t tx="felix.20210725221438.1">function onVscodeInputChanged(element: HTMLInputElement) {
    if (element.id === "zoomLevel") {
        frontFontConfig.zoomLevel = element.valueAsNumber;
    }
    if (element.id === "editorFontSize") {
        frontFontConfig.fontSize = element.valueAsNumber;
    }
    applyFontChanges();
}

</t>
<t tx="felix.20210725221447.1">function setFontControls(): void {
    if (frontFontConfig.zoomLevel || frontFontConfig.zoomLevel === 0) {
        const w_element = document.getElementById("zoomLevel");
        (w_element as HTMLInputElement).valueAsNumber = Number(frontFontConfig.zoomLevel);
    } else {
        console.log('Error : vscode font setting "zoomLevel" is missing');
    }
    if (frontFontConfig.fontSize) {
        const w_element = document.getElementById("editorFontSize");
        (w_element as HTMLInputElement).valueAsNumber = Number(frontFontConfig.fontSize);
    } else {
        console.log('Error : vscode font setting "fontSize" is missing');
    }
}

</t>
<t tx="felix.20210727224122.1">/**
 * * Get config from vscode for the UI font sizes
 */
public getFontConfig(): FontSettings {
    let w_zoomLevel = vscode.workspace.getConfiguration(
        "window"
    ).get("zoomLevel");
    let w_fontSize = vscode.workspace.getConfiguration(
        "editor"
    ).get("fontSize");

    const w_config: FontSettings = {
        zoomLevel: Number(w_zoomLevel),
        fontSize: Number(w_fontSize)
    };
    return w_config;
}

</t>
<t tx="felix.20210727224135.1">/**
 * * Apply changes in font size settings and save them in user settings.
 */
public setFontConfig(p_settings: FontSettings): void {
    if (p_settings.zoomLevel || p_settings.zoomLevel === 0) {
        if (!isNaN(p_settings.zoomLevel) &amp;&amp; p_settings.zoomLevel &lt;= 12 &amp;&amp; p_settings.zoomLevel &gt;= -12) {
            vscode.workspace.getConfiguration("window")
                .update("zoomLevel", p_settings.zoomLevel, true);
        } else {
            vscode.window.showInformationMessage(
                "Value for zoom level should be between -12 and 12"
            );
        }
    }
    if (p_settings.fontSize) {
        if (!isNaN(p_settings.fontSize) &amp;&amp; p_settings.fontSize &lt;= 30 &amp;&amp; p_settings.fontSize &gt;= 6) {
            vscode.workspace.getConfiguration("editor")
                .update("fontSize", p_settings.fontSize, true);
        } else {
            vscode.window.showInformationMessage(
                "Value for font size should be between 6 and 30"
            );
        }
    }
}

</t>
<t tx="felix.20210727224655.1">export interface FontSettings {
    zoomLevel: number;
    fontSize: number;
}

</t>
<t tx="felix.20210727225050.1">export interface IVsCodeApi {
    postMessage(msg: {}): void;
    setState(state: {}): void;
    getState(): { [key: string]: any };
}
</t>
<t tx="felix.20210802162424.1">/**
 * * Disconnects from the server
 */
public stopConnection(): void {
    this._leoBridge.closeLeoProcess();
}

</t>
<t tx="felix.20210802163703.1">/**
 * * Closes the websocket connection
 */
public closeLeoProcess(): void {
    if (this._websocket) {
        this._websocket.close(1001, "Quitting LeoInteg");
    } else {
        console.warn('LeoInteg websocket close called without websocket active');
    }
}

</t>
<t tx="felix.20210804175113.1">/**
 * * Server announced the multi-user content changed: Debounce a refresh cycle.
 * The 'action' string can be checked to determine what kind, if any, is required.
 */
public refresh(p_action: string): void {
    //
    console.log('REFRESH', p_action);
    this._leoIntegration.refreshAll();
}

</t>
<t tx="fil.20210603195218.1">import * as vscode from "vscode";
import * as path from 'path';
import { LeoIntegration } from "../leoIntegration";
import * as utils from "../utils";

@language typescript
@tabwidth -4
@others
</t>
<t tx="fil.20210603195319.1">export class LeoSettingsProvider {

    private _panel: vscode.WebviewPanel | undefined;
    private readonly _extensionPath: string;
    private _html: string | undefined;
    private _waitingForUpdate: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._extensionPath = _context.extensionPath;
        vscode.workspace.onDidChangeConfiguration(p_event =&gt; this.changedConfiguration(p_event));
    }

    @others
}
</t>
<t tx="fil.20210603195319.2">public changedConfiguration(p_event?: vscode.ConfigurationChangeEvent): void {
    if (this._panel &amp;&amp; !this._waitingForUpdate) {
        this._panel.webview.postMessage({ command: 'newConfig', config: this._leoIntegration.config.getConfig() });
        this._panel.webview.postMessage({ command: 'newFontConfig', config: this._leoIntegration.config.getFontConfig() });
    }
}

</t>
<t tx="fil.20210603195319.3">public openWebview(): void {
    if (this._panel) {
        this._panel.reveal();
    } else {
        this._getBaseHtml().then(p_baseHtml =&gt; {
            this._panel = vscode.window.createWebviewPanel(
                'leoSettings', // Identifies the type of the webview. Used internally
                'Leo Integration Settings', // Title of the panel displayed to the user
                { viewColumn: vscode.ViewColumn.Beside, preserveFocus: false }, // Editor column to show the new webview panel in.
                {
                    retainContextWhenHidden: false,
                    enableFindWidget: true,
                    enableCommandUris: true,
                    enableScripts: true
                }
            );
            let w_baseUri = this._panel.webview.asWebviewUri(vscode.Uri.file(
                path.join(this._extensionPath)
            ));
            this._panel.iconPath = vscode.Uri.file(this._context.asAbsolutePath('resources/leoapp128px.png'));
            this._panel.webview.html = p_baseHtml.replace(
                /#{root}/g,
                w_baseUri.toString()
            ).replace(
                /#{endOfBody}/g,
                `&lt;script type="text/javascript" nonce="Z2l0bGV1cy1ib290c3RyYXA="&gt;window.leoConfig = ${JSON.stringify(
                    this._leoIntegration.config.getConfig()
                )};window.fontConfig = ${JSON.stringify(
                    this._leoIntegration.config.getFontConfig()
                )};&lt;/script&gt;`
            );
            this._panel.webview.onDidReceiveMessage(
                message =&gt; {
                    switch (message.command) {
                        case 'alert':
                            vscode.window.showErrorMessage(message.text);
                            break;
                        case 'chooseLeoEditorPath':
                            utils.chooseLeoFolderDialog().then(p_chosenPath =&gt; {
                                if (p_chosenPath &amp;&amp; p_chosenPath.length) {
                                    this._panel!.webview.postMessage(
                                        {
                                            command: 'newEditorPath',
                                            editorPath: p_chosenPath[0].fsPath
                                        }
                                    );
                                }
                            });
                            break;
                        case 'getNewConfig':
                            if (this._panel &amp;&amp; !this._waitingForUpdate) {
                                this._panel.webview.postMessage(
                                    {
                                        command: 'newConfig',
                                        config: this._leoIntegration.config.getConfig()
                                    }
                                );
                            }
                            break;
                        case 'config':
                            this._waitingForUpdate = true;
                            this._leoIntegration.config.setLeoIntegSettings(message.changes).then(() =&gt; {
                                this._panel!.webview.postMessage(
                                    {
                                        command: 'vscodeConfig',
                                        config: this._leoIntegration.config.getConfig()
                                    }
                                );
                                this._waitingForUpdate = false;
                            });
                            break;
                        case 'getNewFontConfig':
                            if (this._panel &amp;&amp; !this._waitingForUpdate) {
                                this._panel.webview.postMessage(
                                    {
                                        command: 'newFontConfig',
                                        config: this._leoIntegration.config.getFontConfig()
                                    }
                                );
                            }
                            break;
                        case 'fontConfig':
                            this._leoIntegration.config.setFontConfig(message.changes);
                            break;
                    }
                },
                null,
                this._context.subscriptions
            );
            this._panel.onDidDispose(() =&gt; {
                // console.log('disposed');
                this._panel = undefined;
            },
                null,
                this._context.subscriptions);
        });
    }
}

</t>
<t tx="fil.20210603195319.4">private async _getBaseHtml(): Promise&lt;string&gt; {
    if (this._html !== undefined) {
        return this._html;
    } else {
        const w_filename = this._context.asAbsolutePath(path.join('dist/webviews/', 'settings.html'));
        const w_doc = await vscode.workspace.openTextDocument(w_filename);

        this._html = w_doc.getText();

        return this._html;
    }
}
</t>
<t tx="fil.20210603195851.1">public resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken
) {
    this._view = webviewView;

    webviewView.webview.options = {
        // Allow scripts in the webview
        enableScripts: true,

        localResourceRoots: [this._extensionUri],
    };

    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    webviewView.webview.onDidReceiveMessage((data) =&gt; {
        switch (data.type) {
            case 'gotFocus': {
                utils.setContext("sideBarFocus", true);
                utils.setContext("focusedView", "leoFindPanel");
                break;
            }
            case 'leoFindNext': {
                vscode.commands.executeCommand(Constants.COMMANDS.FIND_NEXT);
                break;
            }
            case 'leoFindPrevious': {
                vscode.commands.executeCommand(Constants.COMMANDS.FIND_PREVIOUS);
                break;
            }
            case 'searchConfig': {
                this._leoIntegration.saveSearchSettings(data.value);
                break;
            }
            case 'replace': {
                this._leoIntegration.replace(true, false);
                break;
            }
            case 'replaceThenFind': {
                this._leoIntegration.replace(true, true);
                break;
            }
            case 'refreshSearchConfig': {
                // Leave a cycle before getting settings
                setTimeout(() =&gt; {
                    this._leoIntegration.loadSearchSettings();
                }, 0);
                break;
            }
        }
    });
    this._leoIntegration.setFindPanel(this._view);
}

</t>
<t tx="fil.20210603195902.1">private _getHtmlForWebview(webview: vscode.Webview) {
    // Get the local path to main script run in the webview, then convert it to a uri we can use in the webview.
    const scriptUri = webview.asWebviewUri(
        vscode.Uri.joinPath(this._extensionUri, 'find-panel', 'main.js')
    );
    // Do the same for the stylesheet.
    const styleResetUri = webview.asWebviewUri(
        vscode.Uri.joinPath(this._extensionUri, 'find-panel', 'reset.css')
    );
    const styleVSCodeUri = webview.asWebviewUri(
        vscode.Uri.joinPath(this._extensionUri, 'find-panel', 'vscode.css')
    );
    const styleMainUri = webview.asWebviewUri(
        vscode.Uri.joinPath(this._extensionUri, 'find-panel', 'main.css')
    );

    // Use a nonce to only allow a specific script to be run.
    const nonce = this.getNonce();

    return `&lt;!DOCTYPE html&gt;
        &lt;html lang="en" tabindex="-1"&gt;
        &lt;head&gt;
            &lt;meta charset="UTF-8"&gt;
            &lt;meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource}; script-src 'nonce-${nonce}';"&gt;
            &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
            &lt;link href="${styleResetUri}" rel="stylesheet"&gt;
            &lt;link href="${styleVSCodeUri}" rel="stylesheet"&gt;
            &lt;link href="${styleMainUri}" rel="stylesheet"&gt;

            &lt;title&gt;Leo Find Panel&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;label class="first" for="findText"&gt;Find:&lt;/label&gt;
            &lt;input type="text" id="findText" name="findText" placeholder="&lt;find pattern here&gt;" &gt;
            &lt;label for="replaceText"&gt;Replace:&lt;/label&gt;
            &lt;input type="text" id="replaceText" name="replaceText" &gt;
            &lt;div class="row"&gt;
                &lt;div class="col"&gt;
                    &lt;input type="checkbox" id="wholeWord" name="wholeWord" &gt;
                    &lt;label for="wholeWord"&gt;Whole &lt;u&gt;w&lt;/u&gt;ord&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="ignoreCase" name="ignoreCase" &gt;
                    &lt;label for="ignoreCase"&gt;&lt;u&gt;I&lt;/u&gt;gnore case&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="regExp" name="regExp" &gt;
                    &lt;label for="regExp"&gt;Rege&lt;u&gt;x&lt;/u&gt;p&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="markFinds" name="markFinds" &gt;
                    &lt;label for="markFinds"&gt;Mark &lt;u&gt;f&lt;/u&gt;inds&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="markChanges" name="markChanges" &gt;
                    &lt;label for="markChanges"&gt;Mark &lt;u&gt;c&lt;/u&gt;hanges&lt;/label&gt;
                &lt;/div&gt;
                &lt;div class="col"&gt;
                    &lt;input type="radio" id="entireOutline" name="searchScope" value="0"&gt;
                    &lt;label for="entireOutline"&gt;&lt;u&gt;E&lt;/u&gt;ntire outline&lt;/label&gt;&lt;br&gt;
                    &lt;input type="radio" id="subOutlineOnly" name="searchScope" value="1"&gt;
                    &lt;label for="subOutlineOnly"&gt;&lt;u&gt;S&lt;/u&gt;uboutline Only&lt;/label&gt;&lt;br&gt;
                    &lt;input type="radio" id="nodeOnly" name="searchScope" value="2"&gt;
                    &lt;label for="nodeOnly"&gt;&lt;u&gt;N&lt;/u&gt;ode only&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="searchHeadline" name="searchHeadline" &gt;
                    &lt;label for="searchHeadline"&gt;Search &lt;u&gt;h&lt;/u&gt;eadline&lt;/label&gt;&lt;br&gt;
                    &lt;input type="checkbox" id="searchBody" name="searchBody" &gt;
                    &lt;label for="searchBody"&gt;Search &lt;u&gt;b&lt;/u&gt;ody&lt;/label&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;script nonce="${nonce}" src="${scriptUri}"&gt;&lt;/script&gt;
        &lt;/body&gt;
        &lt;/html&gt;`;
}

</t>
<t tx="fil.20210603195909.1">private getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i &lt; 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}
</t>
<t tx="fil.20210603223013.1"></t>
<t tx="fil.20210603223013.10">checkboxIds.forEach((p_inputId) =&gt; {
                    //@ts-expect-error
    document.getElementById(p_inputId).checked = p_settings[p_inputId];
    searchSettings[p_inputId] = p_settings[p_inputId];
});
                //@ts-expect-error
document.getElementById(radioIds[p_settings['searchScope']]).checked = true;
searchSettings.searchScope = p_settings['searchScope'];
</t>
<t tx="fil.20210603223013.11">function sendSearchConfig() {
    dirty = false; // clear dirty flag
    vscode.postMessage({ type: 'searchConfig', value: searchSettings });
}

let timer; // for debouncing sending the settings from this webview to leointeg
let dirty = false;
</t>
<t tx="fil.20210603223013.12">function processChange() {
    clearTimeout(timer);
    dirty = true;
    timer = setTimeout(() =&gt; {
        sendSearchConfig();
    }, 300);
}

</t>
<t tx="fil.20210603223013.13"></t>
<t tx="fil.20210603223013.14">inputIds.forEach((p_inputId) =&gt; {
    @others
});
</t>
<t tx="fil.20210603223013.15">document.getElementById(p_inputId).onkeypress = function (p_event) {
                    //@ts-expect-error
    if (!p_event) p_event = window.event;
    var keyCode = p_event.code || p_event.key;
    if (keyCode == 'Enter') {
        if (timer) {
            clearTimeout(timer);
            sendSearchConfig();
        }
        vscode.postMessage({ type: 'leoFindNext' });
        return false;
    }
};
</t>
<t tx="fil.20210603223013.16">document.getElementById(p_inputId).addEventListener('input', function (p_event) {
                    //@ts-expect-error
    searchSettings[p_inputId] = this.value;
    processChange();
});
</t>
<t tx="fil.20210603223013.17">checkboxIds.forEach((p_inputId) =&gt; {
    document.getElementById(p_inputId).addEventListener('change', function (p_event) {
                //@ts-expect-error
        searchSettings[p_inputId] = this.checked;
        processChange();
    });
});
</t>
<t tx="fil.20210603223013.18"></t>
<t tx="fil.20210603223013.19">radioIds.forEach((p_inputId) =&gt; {
    document.getElementById(p_inputId).addEventListener('change', function (p_event) {
        searchSettings['searchScope'] = parseInt(
                    //@ts-expect-error
            document.querySelector('input[name="searchScope"]:checked').value
        );
        processChange();
    });
});

</t>
<t tx="fil.20210603223013.2">@language css
div.row {
  overflow-x: hidden;
  white-space: nowrap;
}

div.col {
  width: 50%;
  max-width: 9.5em;
  display: inline-block;
  text-overflow: ellipsis;
  overflow: hidden;
}
</t>
<t tx="fil.20210603223013.20"></t>
<t tx="fil.20210603223013.21">/**
 * @param {string} p_inputId
 */
function toggleCheckbox(p_inputId) {
    let w_checkbox = document.getElementById(p_inputId);
    let w_setTo = true;
            //@ts-expect-error
    if (w_checkbox.checked) {
        w_setTo = false;
    }
            //@ts-expect-error
    w_checkbox.checked = w_setTo;
    searchSettings[p_inputId] = w_setTo;
    if (timer) {
        clearTimeout(timer);
    }
    sendSearchConfig();
}

</t>
<t tx="fil.20210603223013.22">/**
 * @param {string} p_inputId
 */
function setRadio(p_inputId) {
            //@ts-expect-error
    document.getElementById(p_inputId).checked = true;
    searchSettings['searchScope'] = parseInt(
                //@ts-expect-error
        document.querySelector('input[name="searchScope"]:checked').value
    );
    if (timer) {
        clearTimeout(timer);
    }
    sendSearchConfig();
}

</t>
<t tx="fil.20210603223013.23">/**
 *
 * @param {KeyboardEvent} p_event
 */
function checkKeyDown(p_event) {
            //@ts-expect-error
    if (!p_event) p_event = window.event;
    var keyCode = p_event.code || p_event.key;

    if (keyCode === 'Tab') {
        var actEl = document.activeElement;
        if (p_event.shiftKey) {
            var firstEl = document.getElementById('findText');
            if (actEl === firstEl) {
                p_event.preventDefault();
                p_event.stopPropagation();
                p_event.stopImmediatePropagation();
                document.getElementById('searchBody').focus();
                return;
            }
        } else {
            var lastEl = document.getElementById('searchBody');
            if (actEl === lastEl) {
                p_event.preventDefault();
                p_event.stopPropagation();
                p_event.stopImmediatePropagation();
                focusOnField('findText');
                return;
            }
        }
    }
    // checkOtherKeys(p_event);
}

// TODO :  CAPTURE FOCUS IN OVERALL PANEL AND SET CONTEXT-VAR OF 'FOCUSED PANEL'

// TODO : ALSO CYCLE TABS !!
// TODO : ALSO CAPTURE CTRL+T TO FOCUS OUT OF HERE

// TODO : CHECK FOR ALT+CTRL+SHORTCUTS FOR TOGGLES AND RADIOS
// document.addEventListener ("keydown", function (zEvent) {
//     if (zEvent.ctrlKey  &amp;&amp;  zEvent.altKey  &amp;&amp;  zEvent.key === "e") {  // case sensitive
//         // DO YOUR STUFF HERE
//     }
// } );

document.onkeydown = checkKeyDown;

// ! Not Used Anymore ! now uses real vscode keybindings
/*
function checkOtherKeys(p_event) {
    var keyCode = p_event.code || p_event.key;
    if (keyCode === 'F2') {
        p_event.preventDefault();
        p_event.stopPropagation();
        p_event.stopImmediatePropagation();
        vscode.postMessage({ type: 'leoFindPrevious' });
        return;
    }
    if (keyCode === 'F3') {
        p_event.preventDefault();
        p_event.stopPropagation();
        p_event.stopImmediatePropagation();
        vscode.postMessage({ type: 'leoFindNext' });
        return;
    }
    if ((keyCode === 'f' || keyCode === 'KeyF') &amp;&amp; p_event.ctrlKey) {
        p_event.preventDefault();
        p_event.stopPropagation();
        p_event.stopImmediatePropagation();
        focusOnField('findText');
        return;
    }
    if ((keyCode === 't' || keyCode === 'KeyT') &amp;&amp; p_event.ctrlKey) {
        p_event.preventDefault();
        p_event.stopPropagation();
        p_event.stopImmediatePropagation();
        vscode.postMessage({ type: 'focusOnTree' });
        return;
    }
    if ((keyCode === '=' || keyCode === 'Equal') &amp;&amp; p_event.ctrlKey) {
        p_event.preventDefault();
        p_event.stopPropagation();
        p_event.stopImmediatePropagation();
        vscode.postMessage({ type: 'replace' });
        return;
    }
    if ((keyCode === '-' || keyCode === 'Minus') &amp;&amp; p_event.ctrlKey) {
        p_event.preventDefault();
        p_event.stopPropagation();
        p_event.stopImmediatePropagation();
        vscode.postMessage({ type: 'replaceThenFind' });
        return;
    }
    if (p_event.ctrlKey &amp;&amp; p_event.altKey) {
        switch (keyCode) {
            case 'w':
            case 'KeyW':
                toggleCheckbox('wholeWord');
                return;
            case 'i':
            case 'KeyI':
                toggleCheckbox('ignoreCase');
                return;
            case 'x':
            case 'KeyX':
                toggleCheckbox('regExp');
                return;
            case 'f':
            case 'KeyF':
                toggleCheckbox('markFinds');
                return;
            case 'c':
            case 'KeyC':
                toggleCheckbox('markChanges');
                return;
            case 'h':
            case 'KeyH':
                toggleCheckbox('searchHeadline');
                return;
            case 'b':
            case 'KeyB':
                toggleCheckbox('searchBody');
                return;
            case 'e':
            case 'KeyE':
                setRadio('entireOutline');
                return;
            case 's':
            case 'KeyS':
                setRadio('subOutlineOnly');
                return;
            case 'n':
            case 'KeyN':
                setRadio('nodeOnly');
                return;
            default:
                break;
        }
    }
}
*/

</t>
<t tx="fil.20210603223013.24">/**
 * @param {string} p_id
 */
function focusOnField(p_id) {
    const inputField = document.querySelector('#' + p_id);
            //@ts-expect-error
    inputField.select();
    // TODO : TEST IF NEEDED TO PREVENT FLICKER ON FIRST TRY?
    setTimeout(() =&gt; {
                //@ts-expect-error
        inputField.select();
    }, 0);
}

</t>
<t tx="fil.20210603223013.25"></t>
<t tx="fil.20210603223013.26">function getSettings() {
    // clear dirty, clear timer,
    if (dirty) {
        dirty = false;
        clearTimeout(timer);
        sendSearchConfig(); // just trigger send settings
    }
}

// FINISH STARTUP
vscode.postMessage({ type: 'refreshSearchConfig' });
</t>
<t tx="fil.20210603223013.4">//@ts-check

// This script will be run within the webview itself
// It cannot access the main VS Code APIs directly.
// Send message to leoInteg with vscode.postMessage({ keyNameEx1: someValue, ... });
// Receive messages from leoInteg with window.addEventListener('message', event =&gt; { ... });
@others
@language javascript
@tabwidth -4
</t>
<t tx="fil.20210603223013.5">(function () {
    //@ts-expect-error
    const vscode = acquireVsCodeApi();

    // * LeoSearchSettings Type
    let searchSettings = {
        findText: '',
        replaceText: '',
        wholeWord: false,
        ignoreCase: true,
        regExp: false,
        markFinds: false,
        markChanges: false,
        searchHeadline: true,
        searchBody: true,
        searchScope: 0, // 0 is entire outline (1: sub-outline, 2: node only)
    };

    document.addEventListener('focusin', (event) =&gt; {
        vscode.postMessage({ type: 'gotFocus' });
    });

    // Handle messages sent from the extension to the webview
    @others
})();
</t>
<t tx="fil.20210603223013.6">window.addEventListener('message', (event) =&gt; {
    const message = event.data; // The json data that the extension sent
    switch (message.type) {
        // Focus and select all text in 'find' field
        case 'selectFind': {
            focusOnField('findText');
            break;
        }
        // Focus and select all text in 'replace' field
        case 'selectReplace': {
            focusOnField('replaceText');
            break;
        }
        case 'getSettings': {
            getSettings();
            break;
        }
        case 'setSettings': {
            setSettings(message.value);
            break;
        }
        case 'setSearchSetting': {
            setSearchSetting(message.id);
            break;
        }
    }
});

let inputIds = ['findText', 'replaceText'];
let checkboxIds = [
    'wholeWord',
    'ignoreCase',
    'regExp',
    'markFinds',
    'markChanges',
    'searchHeadline',
    'searchBody',
];
let radioIds = ['entireOutline', 'subOutlineOnly', 'nodeOnly'];

</t>
<t tx="fil.20210603223013.7">/**
 * @param {string} p_id
 */
function setSearchSetting(p_id) {
    if (checkboxIds.includes(p_id)) {
        toggleCheckbox(p_id);
    } else if (radioIds.includes(p_id)) {
        setRadio(p_id);
    }
}

</t>
<t tx="fil.20210603223013.8">/**
 * @param {any} p_settings
 */
function setSettings(p_settings) {
    // When opening a Leo document, set default values of fields
    @others
}

</t>
<t tx="fil.20210603223013.9">inputIds.forEach((p_inputId) =&gt; {
                    //@ts-expect-error
    document.getElementById(p_inputId).value = p_settings[p_inputId];
    searchSettings[p_inputId] = p_settings[p_inputId];
});
</t>
<t tx="fil.20210603223014.2">@language css
html {
	box-sizing: border-box;
	font-size: 13px;
}

*,
*:before,
*:after {
	box-sizing: inherit;
}

body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
ol,
ul {
	margin: 0;
	padding: 0;
	font-weight: normal;
}

img {
	max-width: 100%;
	height: auto;
}
</t>
<t tx="fil.20210603223014.4">@language css
:root {
  --input-padding-vertical: 6px;
  --input-padding-horizontal: 4px;
  --input-margin-vertical: 4px;
  --input-margin-horizontal: 0;
  height: 100%;
  padding-right: 20px;
}

comment {
  --container-padding: 20px;
}

html:focus {
  outline: 1px solid;
  outline-width: 1px;
  outline-style: solid;
  outline-offset: -1px;
  outline-color: var(--vscode-focusBorder);
}

body {
  margin-left: 20px;
  background-color: transparent;
  padding: 0 var(--container-padding);
  color: var(--vscode-foreground);
  font-size: var(--vscode-font-size);
  font-weight: var(--vscode-font-weight);
  font-family: var(--vscode-font-family);
}

.first {
  margin-top: 8px;
  margin-bottom: 0;
  display: inline-block;
}

ol,
ul {
  padding-left: var(--container-padding);
}

body &gt; *,
form &gt; * {
  margin-block-start: var(--input-margin-vertical);
  margin-block-end: var(--input-margin-vertical);
}

*:focus {
  outline-color: var(--vscode-focusBorder);
}

a {
  color: var(--vscode-textLink-foreground);
}

a:hover,
a:active {
  color: var(--vscode-textLink-activeForeground);
}

code {
  font-size: var(--vscode-editor-font-size);
  font-family: var(--vscode-editor-font-family);
}

button {
  border: none;
  padding: var(--input-padding-vertical) var(--input-padding-horizontal);
  width: 100%;
  text-align: center;
  outline: 1px solid transparent;
  outline-offset: 2px !important;
  color: var(--vscode-button-foreground);
  background: var(--vscode-button-background);
}

button:hover {
  cursor: pointer;
  background: var(--vscode-button-hoverBackground);
}

button:focus {
  outline-color: var(--vscode-focusBorder);
}

button.secondary {
  color: var(--vscode-button-secondaryForeground);
  background: var(--vscode-button-secondaryBackground);
}

button.secondary:hover {
  background: var(--vscode-button-secondaryHoverBackground);
}

input:not([type="radio"]):not([type="checkbox"]),
textarea {
  display: block;
  margin-right: 20px;
  width: 100%;
  border: none;
  font-family: var(--vscode-font-family);
  padding: var(--input-padding-vertical) var(--input-padding-horizontal);
  color: var(--vscode-input-foreground);
  outline-color: var(--vscode-input-border);
  background-color: var(--vscode-input-background);
}

input[type="checkbox"]:focus + label {
  border: 1px solid var(--vscode-button-background);
}
input[type="radio"]:focus + label {
  border: 1px solid var(--vscode-button-background);
}

input::placeholder,
textarea::placeholder {
  color: var(--vscode-input-placeholderForeground);
}

u {
  color: var(--vscode-editor-foreground);
  text-decoration-color: var(--vscode-foreground);
  text-underline-offset: 0.04em;
}

body &gt; div &gt; div &gt; label:focus,
body &gt; div &gt; div &gt; label:active {
  outline-color: none !important;
  border: none !important;
}
</t>
<t tx="fil.20210603223933.1"></t>
<t tx="fil.20210603223933.10">&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
&lt;/head&gt;

&lt;body class="preload"&gt;
  &lt;div class="container"&gt;

    &lt;header&gt;
      &lt;a class="header__link"
         title="Learn more about Leo Integration"
         href="https://github.com/boltex/leointeg#literate-programming"&gt;
        &lt;div class="header__logo"&gt;
          &lt;img class="image__logo"
               src="#{root}/resources/leoapp128px.png" /&gt;
          &lt;div&gt;
            &lt;h1&gt;Leo&lt;span class="header__logo--highlight"&gt;Integ&lt;/span&gt;&lt;/h1&gt;
            &lt;p class="header__subtitle"&gt;Leo for VS Code&lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/a&gt;
      &lt;p class="header__blurb"&gt;
        Use &lt;b&gt;Leo&lt;/b&gt;, the Literate Editor with Outlines, to program with &lt;b&gt;directed acyclic graphs&lt;/b&gt;,
        along with section-references, '@others' and clones to generate (and read from) external files.
      &lt;/p&gt;
    &lt;/header&gt;

    &lt;div class="hero__area"&gt;
      &lt;p&gt;
        &lt;a class="bold"
           title="Learn more about LeoInteg"
           href="https://github.com/boltex/leointeg#-leo-editor-integration-with-visual-studio-code"&gt;LeoInteg&lt;/a&gt;
        is an open-source extension created by
        &lt;a class="bold"
           title="My github user page"
           href="https://boltex.github.io/"&gt;Félix&lt;/a&gt; that integrates &lt;a class="bold"
           title="Learn more about Leo"
           href="https://leoeditor.com/"&gt;Leo&lt;/a&gt; into Visual Studio
        Code.
      &lt;/p&gt;
      &lt;!-- &lt;div class="cta is-sidebar-hidden center"&gt;
        &lt;div class="cta--primary"&gt;
          &lt;a class="button button--flat-primary button--big" title="Support LeoInteg"
            href="https://github.com/boltex/leointeg"&gt;Support LeoInteg &amp;#x2764;&lt;/a&gt;
          &lt;p&gt;
            LeoInteg is built by the support of generous open source users and programmers like &lt;b&gt;you&lt;/b&gt;!
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt; --&gt;
    &lt;/div&gt;

    &lt;div class="content__area"&gt;
      &lt;section id="welcome"
               class="section--full mb-0"&gt;
        &lt;h2 class="section__title section__title--primary"&gt;
          Welcome to &lt;span class="highlight"&gt;LeoInteg 0.1.17&lt;/span&gt;
        &lt;/h2&gt;
        &lt;div class="center mt-1"&gt;
          &lt;a class="button button--flat"
             title="LeoInteg's Features"
             href="https://github.com/boltex/leointeg#features"&gt;
            See What's New in LeoInteg 0.1.17
          &lt;/a&gt;
        &lt;/div&gt;
        &lt;p class="blurb center ml-0 mr-0"&gt;
          LeoInteg is designed to &lt;b&gt;provide Leo's functionality&lt;/b&gt;
          and can be &lt;b&gt;customized&lt;/b&gt; to meet your needs.
        &lt;/p&gt;
        &lt;h2 class="section__title section__title--break"&gt;&lt;/h2&gt;
        &lt;p class="section__hint mt-0 center"&gt;
          Automate the &lt;a href="#leobridge-options"&gt;leoBridge startup&lt;/a&gt;,
          auto-refresh when &lt;a href="#external-files"&gt;external files change&lt;/a&gt;,
          or choose which &lt;a href="#node-commands"&gt;node icons&lt;/a&gt;
          are shown and more with the options below.
        &lt;/p&gt;
      &lt;/section&gt;

      &lt;section id="leobridge-options"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Leo Bridge Options
            &lt;/h2&gt;
          &lt;/div&gt;
          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="startServerAutomatically"
                       name="startServerAutomatically"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="startServerAutomatically"&gt;Start&amp;nbsp;Server&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Run the leobridgeserver.py server script at startup&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="connectToServerAutomatically"
                       name="connectToServerAutomatically"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="connectToServerAutomatically"&gt;Connect&amp;nbsp;to&amp;nbsp;Server&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Connects automatically to a LeoBridge server&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="leoEditorPath"&gt;Leo&amp;#8209;Editor&amp;nbsp;Path&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/label&gt;
                &lt;input id="leoEditorPath"
                       name="leoEditorPath"
                       type="text"
                       maxlength="256"
                       placeholder="C:/leo-editor"
                       data-setting /&gt;
                &lt;button type="button"
                        id="chooseLeoEditorPath"
                        name="chooseLeoEditorPath"
                        class="button btn button--flat button--flat-primary button--choose-path"&gt;
                  Browse For Folder...
                &lt;/button&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Location of your Leo-Editor installation&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="leoPythonCommand"&gt;Python&amp;nbsp;Command&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/label&gt;
                &lt;input id="leoPythonCommand"
                       name="leoPythonCommand"
                       type="text"
                       maxlength="256"
                       placeholder="Empty for default"
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Command for starting python (Defaults to 'py' on windows, or
                'python3' otherwise)&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="connectionAddress"&gt;Connection&amp;nbsp;Address&lt;/label&gt;
                &lt;input id="connectionAddress"
                       name="connectionAddress"
                       type="text"
                       maxlength="256"
                       placeholder="Host Name, IP Address or localhost"
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Connection host&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="connectionPort"&gt;Connection&amp;nbsp;Port&lt;/label&gt;
                &lt;input id="connectionPort"
                       name="connectionPort"
                       type="number"
                       min="0"
                       max="65535"
                       max-length="5"
                       placeholder="Port Number"
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Connection host port number&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="external-files"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              External Files Change Detection
            &lt;/h2&gt;
          &lt;/div&gt;
          &lt;div class="settings"&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="checkForChangeExternalFiles"&gt;Check changes to external files&lt;/label&gt;
                &lt;select id="checkForChangeExternalFiles"
                        name="checkForChangeExternalFiles"
                        data-setting&gt;
                  &lt;option value="none"&gt;Default from Leo's config&lt;/option&gt;
                  &lt;option value="force-check"&gt;Check for changes&lt;/option&gt;
                  &lt;option value="force-ignore"&gt;Ignore all changes&lt;/option&gt;
                &lt;/select&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Use Leo's defaults, or force either to check changes or not&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="defaultReloadIgnore"&gt;Force reload or ignore changes&lt;/label&gt;
                &lt;select id="defaultReloadIgnore"
                        name="defaultReloadIgnore"
                        data-setting&gt;
                  &lt;option value="none"&gt;Choose each time&lt;/option&gt;
                  &lt;option value="yes-all"&gt;Reload All&lt;/option&gt;
                  &lt;option value="no-all"&gt;Ignore All&lt;/option&gt;
                &lt;/select&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Choose yourself, or set default to reload or ignore changes&lt;/span&gt;
            &lt;/div&gt;

          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="interface-behavior"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Interface Behavior
            &lt;/h2&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="leoTreeBrowse"
                       name="leoTreeBrowse"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="leoTreeBrowse"&gt;Use Leo Tree Browsing&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Navigate Leo's outline with Leo's shortcuts and behavior instead of the
                default vscode
                method&lt;br&gt;(Arrow keys move selection instead of moving a cursor when focus is on Leo's outline)&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="treeKeepFocus"
                       name="treeKeepFocus"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="treeKeepFocus"&gt;Keep focus on Outline&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Keep focus in the outline when selecting a node - overridden by "&lt;strong&gt;Leo
                  Tree
                  Browsing"&lt;/strong&gt;&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="treeKeepFocusWhenAside"
                       name="treeKeepFocusWhenAside"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="treeKeepFocusWhenAside"&gt;Keep focus when opening on the side&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Keep focus in the outline when opening a body pane on the side&lt;/span&gt;
            &lt;/div&gt;

          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="tree-in-explorer"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;div class="setting__input setting__input--big"&gt;
              &lt;input id="treeInExplorer"
                     name="treeInExplorer"
                     type="checkbox"
                     data-setting /&gt;
              &lt;label for="treeInExplorer"&gt;Show&amp;nbsp;Leo&amp;nbsp;Outline&amp;nbsp;in&amp;nbsp;Explorer&lt;/label&gt;
            &lt;/div&gt;
            &lt;p class="section__header-hint"&gt;
              Adds an instance of the outline pane in the explorer view
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="section__preview"&gt;
          &lt;img class="image__preview"
               src="#{root}/resources/treeInExplorerDisabled.png" /&gt;
          &lt;img class="image__preview--overlay hidden"
               src="#{root}/resources/treeInExplorerEnabled.png"
               data-visibility="treeInExplorer" /&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="show-open-aside"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;div class="setting__input setting__input--big"&gt;
              &lt;input id="showOpenAside"
                     name="showOpenAside"
                     type="checkbox"
                     data-setting /&gt;
              &lt;label for="showOpenAside"&gt;Show&amp;nbsp;'Open&amp;nbsp;to&amp;nbsp;the&amp;nbsp;Side'&lt;/label&gt;
            &lt;/div&gt;
            &lt;p class="section__header-hint"&gt;
              Adds the command in the node's context menu
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="section__preview"&gt;
          &lt;img class="image__preview"
               src="#{root}/resources/showOpenAsideDisabled.png" /&gt;
          &lt;img class="image__preview--overlay hidden"
               src="#{root}/resources/showOpenAsideEnabled.png"
               data-visibility="showOpenAside" /&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="invert-contrast"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;div class="setting__input setting__input--big"&gt;
              &lt;input id="invertNodeContrast"
                     name="invertNodeContrast"
                     type="checkbox"
                     data-setting /&gt;
              &lt;label for="invertNodeContrast"&gt;Invert Node Contrast&lt;/label&gt;
            &lt;/div&gt;
            &lt;p class="section__header-hint"&gt;
              Inverts the dirty/clean border of tree nodes
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="section__preview"&gt;
          &lt;img class="image__preview"
               src="#{root}/resources/invertedDisabled.png" /&gt;
          &lt;img class="image__preview--overlay hidden"
               src="#{root}/resources/invertedEnabled.png"
               data-visibility="invertNodeContrast" /&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="node-commands"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Node Commands
            &lt;/h2&gt;
            &lt;p class="section__header-hint"&gt;
              Hovering tree nodes displays an edit icon - Choose more commands to display when hovering
            &lt;/p&gt;
          &lt;/div&gt;
          &lt;div class="section__preview"&gt;

            &lt;img class="image__preview"
                 src="#{root}/resources/allIconsDisabled.png" /&gt;

            &lt;div class="image__preview--float-container"&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/bookmark.png"
                   data-visibility="showMarkOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/copy.png"
                   data-visibility="showCopyOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/clone.png"
                   data-visibility="showCloneOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/arrows.png"
                   data-visibility="showArrowsOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/add.png"
                   data-visibility="showAddOnNodes" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/editHeadline.png"
                   data-visibility="showEditOnNodes" /&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showEditOnNodes"
                       name="showEditOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showEditOnNodes"&gt;Edit&amp;nbsp;Headline&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Edit Headline' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showMarkOnNodes"
                       name="showMarkOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showMarkOnNodes"&gt;Mark&amp;nbsp;/&amp;nbsp;Unmark&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Mark/Unmark' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showCopyOnNodes"
                       name="showCopyOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showCopyOnNodes"&gt;Copy&amp;nbsp;Node&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Copy' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showCloneOnNodes"
                       name="showCloneOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showCloneOnNodes"&gt;Clone&amp;nbsp;Node&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Clone' on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showArrowsOnNodes"
                       name="showArrowsOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showArrowsOnNodes"&gt;Move&amp;nbsp;arrow&amp;nbsp;commands&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Move' arrows on hover&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showAddOnNodes"
                       name="showAddOnNodes"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showAddOnNodes"&gt;Add&amp;nbsp;Node&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Shows 'Insert' on hover&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;

        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="editor-commands"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Body Editor Icons
            &lt;/h2&gt;
            &lt;p class="section__header-hint"&gt;
              Body Pane Command Icons - Choose which commands to display - &lt;em&gt;First leftmost 9 icons shown&lt;/em&gt;
            &lt;/p&gt;
          &lt;/div&gt;
          &lt;div class="section__preview"&gt;

            &lt;img class="image__preview__body"
                 src="#{root}/resources/body-menu.png" /&gt;

            &lt;div class="image__preview__body--float-container"&gt;

              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-refresh.png"
                   data-visibility="showRefreshOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-import.png"
                   data-visibility="showImportOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-sort.png"
                   data-visibility="showSortOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-mark.png"
                   data-visibility="showMarkOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-clipboard.png"
                   data-visibility="showClipboardOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-edition.png"
                   data-visibility="showEditionOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-extract.png"
                   data-visibility="showExtractOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-execute.png"
                   data-visibility="showExecuteOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-promote.png"
                   data-visibility="showPromoteOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-hoist.png"
                   data-visibility="showHoistOnBody" /&gt;
              &lt;img class="image__preview--float"
                   src="#{root}/resources/body-menu-prev-next.png" /&gt;

            &lt;/div&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;

            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showEditionOnBody"
                       name="showEditionOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showEditionOnBody"&gt;Outline&amp;nbsp;Edition&amp;nbsp;Commands&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Clone, Delete and Insert nodes&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showClipboardOnBody"
                       name="showClipboardOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showClipboardOnBody"&gt;Clipboard&amp;nbsp;Operations&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Cut, Copy and Paste nodes&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showPromoteOnBody"
                       name="showPromoteOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showPromoteOnBody"&gt;Promote&amp;nbsp;&amp;amp;&amp;nbsp;Demote&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Promote children, demote siblings&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showExecuteOnBody"
                       name="showExecuteOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showExecuteOnBody"&gt;Execute&amp;nbsp;Script&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Executes node or selected text&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showExtractOnBody"
                       name="showExtractOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showExtractOnBody"&gt;Extract&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Extract Text and Names&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showImportOnBody"
                       name="showImportOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showImportOnBody"&gt;Import&amp;nbsp;File&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Import any file into a node&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showRefreshOnBody"
                       name="showRefreshOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showRefreshOnBody"&gt;Refresh&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Refresh an external file from disk&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showHoistOnBody"
                       name="showHoistOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showHoistOnBody"&gt;Hoist&amp;nbsp;&amp;amp;&amp;nbsp;Dehoist&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Isolate part of the outline&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showMarkOnBody"
                       name="showMarkOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showMarkOnBody"&gt;Mark&amp;nbsp;&amp;amp;&amp;nbsp;Unmark&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Mark or unmark tree nodes&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;input id="showSortOnBody"
                       name="showSortOnBody"
                       type="checkbox"
                       data-setting /&gt;
                &lt;label for="showSortOnBody"&gt;Sort&amp;nbsp;Siblings&lt;/label&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Sort siblings of a node alphabetically&lt;/span&gt;
            &lt;/div&gt;

          &lt;/div&gt;

        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="font-sizes"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Outline and Body Font Sizes
            &lt;/h2&gt;
            &lt;p class="section__header-hint"&gt;
              &lt;em&gt;Start by adjusting the Outline pane&lt;/em&gt;, by changing the global &lt;em&gt;Zoom Level&lt;/em&gt;.&lt;br&gt;
              Then, resize the the &lt;em&gt;Body Pane font size&lt;/em&gt; by changing the &lt;em&gt;Editor Font Size&lt;/em&gt;.
            &lt;/p&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="zoomLevel"&gt;Zoom Level&lt;/label&gt;
                &lt;input id="zoomLevel"
                       name="zoomLevel"
                       type="number"
                       min="-12"
                       max="12"
                       maxlength="2"
                       placeholder="Number"
                       data-vscode /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;
                Adjust the zoom level&lt;br&gt;
                of the window.&lt;br&gt;
                (Original size is 0 and each&lt;br&gt;
                increment above 1 or below -1&lt;br&gt;
                represents zooming 20%.&lt;br&gt;
                You can also use decimals.)
              &lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="editorFontSize"&gt;Editor Font Size&lt;/label&gt;
                &lt;input id="editorFontSize"
                       name="editorFontSize"
                       type="number"
                       min="6"
                       max="30"
                       maxlength="2"
                       placeholder="Number"
                       data-vscode /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;
                Controls the Text-Editor&lt;br&gt;
                pane font size in pixels.&lt;br&gt;
                Set this after having set the&lt;br&gt;
                Zoom Level for the outline, as&lt;br&gt;
                it's affected by the Zoom Level.
              &lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      &lt;section id="statusbar-indicator"
               class="section--settings"&gt;
        &lt;div class="section__content"&gt;
          &lt;div class="section__header"&gt;
            &lt;h2&gt;
              Statusbar Indicator
            &lt;/h2&gt;
            &lt;p class="section__header-hint"&gt;
              Keyboard icon can also include a label and be displayed in a specific color
            &lt;/p&gt;
          &lt;/div&gt;

          &lt;div class="section__preview"&gt;
            &lt;img class="image__preview"
                 src="#{root}/resources/statusbar.png" /&gt;
          &lt;/div&gt;

          &lt;div class="settings"&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="statusBarString"&gt;Status Bar Keyboard indicator&lt;/label&gt;
                &lt;input id="statusBarString"
                       name="statusBarString"
                       type="text"
                       maxlength="8"
                       placeholder="Status bar indicator text "
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Keybindings 'on/off' indicator text message&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="setting"&gt;
              &lt;div class="setting__input"&gt;
                &lt;label for="statusBarColor"&gt;Status Bar Color&lt;/label&gt;
                &lt;input id="statusBarColor"
                       name="statusBarColor"
                       type="text"
                       maxlength="6"
                       placeholder="RrGgBb"
                       data-setting /&gt;
              &lt;/div&gt;
              &lt;span class="setting__hint"&gt;Keybindings 'on' indicator 6 hex digits color code&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;
    &lt;/div&gt;

    &lt;div class="sidebar"&gt;
      &lt;!-- &lt;div class="sidebar__group"&gt;
        &lt;a class="button button--flat-primary" title="Support LeoInteg"
          href="https://github.com/boltex/leointeg"&gt;Support
          LeoInteg &amp;#x2764;&lt;/a&gt;
        &lt;p&gt;
          LeoInteg is built by the support of generous open source users and programmers like &lt;b&gt;you&lt;/b&gt;!
        &lt;/p&gt;
      &lt;/div&gt; --&gt;

      &lt;div class="sidebar__group"&gt;
        &lt;h2&gt;Configuration&lt;/h2&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href="#leobridge-options"&gt;LeoBridge Options&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#external-files"&gt;External Files&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#interface-behavior"&gt;Interface Behavior&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#tree-in-explorer"&gt;Outline in Explorer&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#show-open-aside"&gt;Open to the Side&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#invert-contrast"&gt;Invert Contrast&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#node-commands"&gt;Node Hover Commands&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#editor-commands"&gt;Body Editor Icons&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#font-sizes"&gt;Font Sizes&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="#statusbar-indicator"&gt;Statusbar Indicator&lt;/a&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;

      &lt;!-- &lt;div class="sidebar__group"&gt;
        &lt;h2&gt;Help&lt;/h2&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href="https://github.com/boltex/leointeg#requirements"&gt;Documentation&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://github.com/boltex/leointeg/blob/master/CHANGELOG.md#change-log"&gt;Changelog&lt;/a&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt; --&gt;

      &lt;div class="sidebar__group"&gt;
        &lt;h2&gt;About Leo&lt;/h2&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;a href="https://leoeditor.com/"&gt;Home Page&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://leoeditor.com/leo_toc.html"&gt;Documentation&lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://groups.google.com/forum/#!forum/leo-editor"&gt;Forum&lt;/a&gt;
            &lt;small&gt; &amp;nbsp;&amp;nbsp;&amp;mdash;&amp;nbsp; #Google Group&lt;/small&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href="https://github.com/leo-editor/leo-editor"&gt;Source&lt;/a&gt;
            &lt;small&gt; &amp;nbsp;&amp;nbsp;&amp;mdash;&amp;nbsp; #GitHub&lt;/small&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;

  &lt;/div&gt;
  &lt;div id="dirty-config-toast"&gt;Saving...&lt;/div&gt;
  &lt;div id="saved-config-toast"&gt;Settings Saved&lt;/div&gt;
  #{endOfBody}
&lt;/body&gt;

&lt;/html&gt;
</t>
<t tx="fil.20210603223933.165">import { initializeAndWatchThemeColors } from './theme';
import { debounce } from "debounce";
import { ConfigSetting, IVsCodeApi } from '../../types';

declare function acquireVsCodeApi(): IVsCodeApi;

@others
@language typescript
@tabwidth -4
</t>
<t tx="fil.20210603223933.166">(function () {
    const vscode = acquireVsCodeApi();
    initializeAndWatchThemeColors();

    const toast = document.getElementById("saved-config-toast");
    const dirty = document.getElementById("dirty-config-toast");

    // * TEST
    const oldState = vscode.getState();
    let currentCount: number = (oldState &amp;&amp; oldState.count) || 0;
    if (currentCount) {
        // Already opened! Get fresh and recent config!
        vscode.postMessage({
            command: "getNewConfig"
        });
    }
    currentCount = currentCount + 1;
    vscode.setState({ count: currentCount });

    // * SETUP
    // Global variable config
    let frontConfig: { [key: string]: any } = {};
    let vscodeConfig: { [key: string]: any } = {};
    let vscodeFontConfig: { [key: string]: any } = {};
    let frontFontConfig: { [key: string]: any } = {};

    vscodeConfig = (window as any).leoConfig; // ! PRE SET BY leoSettingsWebview
    frontConfig = JSON.parse(JSON.stringify(vscodeConfig));
    vscodeFontConfig = (window as any).fontConfig; // ! PRE SET BY leoSettingsWebview
    frontFontConfig = JSON.parse(JSON.stringify(vscodeFontConfig));

    // Handle messages sent from the extension to the webview
    window.addEventListener("message", event =&gt; {
        const message = event.data; // The json data that the extension sent
        if (message.command) {
            switch (message.command) {
                case "test":
                    console.log("got test message");
                    break;
                case "newConfig":
                    vscodeConfig = message.config;
                    frontConfig = JSON.parse(JSON.stringify(message.config));
                    setControls();
                    break;
                case "vscodeConfig":
                    dirty!.className = dirty!.className.replace("show", "");
                    toast!.className = "show";
                    setTimeout(function () { toast!.className = toast!.className.replace("show", ""); }, 1500);
                    vscodeConfig = message.config; // next changes will be confronted to those settings
                    break;
                case "newFontConfig":
                    vscodeFontConfig = message.config;
                    frontFontConfig = JSON.parse(JSON.stringify(message.config));
                    setFontControls();
                    break;
                case "vscodeFontConfig":
                    vscodeFontConfig = message.config; // next changes will be confronted to those settings
                    break;
                case "newEditorPath":
                    const w_element: HTMLElement | null = document.getElementById("leoEditorPath");
                    if (w_element) {
                        (w_element as HTMLInputElement).value = message.editorPath;
                        onInputChanged(w_element as HTMLInputElement);
                    }
                    break;
                default:
                    console.log("got message: ", message.command);
                    break;
            }
        } else {
            console.log('got object without command:', message);
        }
    });

    @others

    var applyChanges = debounce(function () {
        var w_changes: ConfigSetting[] = [];
        if (frontConfig) {
            for (var prop in frontConfig) {
                if (Object.prototype.hasOwnProperty.call(frontConfig, prop)) {
                    // console.log(prop);
                    if (frontConfig[prop] !== vscodeConfig[prop]) {
                        w_changes.push({ code: prop, value: frontConfig[prop] });
                    }
                }
            }
        }
        if (w_changes.length) {
            // ok replace!
            vscodeConfig = frontConfig;
            frontConfig = JSON.parse(JSON.stringify(frontConfig));
            vscode.postMessage({
                command: "config",
                changes: w_changes
            });
        } else {
            // Still have to remove 'modified' popup
            dirty!.className = dirty!.className.replace("show", "");
        }
    }, 1500);

    var applyFontChanges = debounce(function () {
        vscode.postMessage({
            command: "fontConfig",
            changes: frontFontConfig
        });
    }, 800);


    // * START
    const w_button: HTMLElement | null = document.getElementById('chooseLeoEditorPath');
    if (w_button) {
        w_button.onclick = chooseLeoEditorPath;
    }
    setControls();
    setFontControls();
    setVisibility(frontConfig);
    onBind();

})();
</t>
<t tx="fil.20210603223933.2">const cssColorRegex = /^(?:(#?)([0-9a-f]{3}|[0-9a-f]{6})|((?:rgb|hsl)a?)\((-?\d+%?)[,\s]+(-?\d+%?)[,\s]+(-?\d+%?)[,\s]*(-?[\d.]+%?)?\))$/i;

@others
@language typescript
@tabwidth -4
</t>
<t tx="fil.20210603223933.3">function adjustLight(color: number, amount: number) {
    const cc = color + amount;
    const c = amount &lt; 0 ? (cc &lt; 0 ? 0 : cc) : cc &gt; 255 ? 255 : cc;

    return Math.round(c);
}

</t>
<t tx="fil.20210603223933.4">export function darken(color: string, percentage: number) {
    return lighten(color, -percentage);
}

</t>
<t tx="fil.20210603223933.5">export function lighten(color: string, percentage: number) {
    const rgba = toRgba(color);
    // tslint:disable-next-line: triple-equals
    if (rgba == null) { return color; }

    const [r, g, b, a] = rgba;
    const amount = (255 * percentage) / 100;
    return `rgba(${adjustLight(r, amount)}, ${adjustLight(g, amount)}, ${adjustLight(b, amount)}, ${a})`;
}

</t>
<t tx="fil.20210603223933.6">export function opacity(color: string, percentage: number) {
    const rgba = toRgba(color);
    // tslint:disable-next-line: triple-equals
    if (rgba == null) { return color; }

    const [r, g, b, a] = rgba;
    return `rgba(${r}, ${g}, ${b}, ${a * (percentage / 100)})`;
}

</t>
<t tx="fil.20210603223933.7">export function toRgba(color: string) {
    color = color.trim();

    const result = cssColorRegex.exec(color);
    // tslint:disable-next-line: triple-equals
    if (result == null) { return null; }

    if (result[1] === '#') {
        const hex = result[2];
        switch (hex.length) {
            case 3:
                return [parseInt(hex[0] + hex[0], 16), parseInt(hex[1] + hex[1], 16), parseInt(hex[2] + hex[2], 16), 1];
            case 6:
                return [
                    parseInt(hex.substring(0, 2), 16),
                    parseInt(hex.substring(2, 4), 16),
                    parseInt(hex.substring(4, 6), 16),
                    1
                ];
        }

        return null;
    }

    switch (result[3]) {
        case 'rgb':
            return [parseInt(result[4], 10), parseInt(result[5], 10), parseInt(result[6], 10), 1];
        case 'rgba':
            return [parseInt(result[4], 10), parseInt(result[5], 10), parseInt(result[6], 10), parseFloat(result[7])];
        default:
            return null;
    }
}
</t>
<t tx="fil.20210603223933.9">&lt;!DOCTYPE html&gt;
@others
@language xml
@tabwidth -2
</t>
<t tx="fil.20210603223934.1">function listenAll(selector: string, name: string, listener: EventListener) {
    const els = (document.querySelectorAll(selector) as unknown) as Element[];
    for (const el of els) {
        el.addEventListener(name, listener, false);
    }
}

</t>
<t tx="fil.20210603223934.10">function setVisibility(state: { [key: string]: string | boolean }) {
    for (const el of document.querySelectorAll&lt;HTMLElement&gt;('[data-visibility]')) {
        el.classList.toggle('hidden', !evaluateStateExpression(el.dataset.visibility!, state));
    }
}
</t>
<t tx="fil.20210603223934.11">function parseStateExpression(expression: string): [string, string, string | boolean | undefined] {
    const [lhs, op, rhs] = expression.trim().split(/([=+!])/);
    return [lhs.trim(), op !== undefined ? op.trim() : '=', rhs !== undefined ? rhs.trim() : rhs];
}

</t>
<t tx="fil.20210603223934.12">function evaluateStateExpression(expression: string, changes: { [key: string]: string | boolean }): boolean {
    let state = false;

    for (const expr of expression.trim().split('&amp;')) {
        const [lhs, op, rhs] = parseStateExpression(expr);

        switch (op) {
            case '=': {
                // Equals
                let value = changes[lhs];
                if (value === undefined) {
                    value = getSettingValue(lhs) || false;
                }
                state = rhs !== undefined ? rhs === String(value) : Boolean(value);
                break;
            }
            case '!': {
                // Not equals
                let value = changes[lhs];
                if (value === undefined) {
                    value = getSettingValue(lhs) || false;
                }
                state = rhs !== undefined ? rhs !== String(value) : !value;
                break;
            }
            case '+': {
                // Contains
                if (rhs !== undefined) {
                    const setting = getSettingValue(lhs);
                    state = setting !== undefined ? setting.includes(rhs.toString()) : false;
                }
                break;
            }
        }

        if (!state) { break; }
    }
    return state;
}

</t>
<t tx="fil.20210603223934.13">function getSettingValue(p_setting: string): any {
    return frontConfig[p_setting];
}
</t>
<t tx="fil.20210603223934.15">import { darken, lighten, opacity } from './colors';

@others
@language typescript
@tabwidth -4
</t>
<t tx="fil.20210603223934.16">export function initializeAndWatchThemeColors() {
    const onColorThemeChanged = () =&gt; {
        const body = document.body;
        const computedStyle = window.getComputedStyle(body);

        const bodyStyle = body.style;

        const font = computedStyle.getPropertyValue('--vscode-font-family').trim();
        if (font) {
            bodyStyle.setProperty('--font-family', font);
            bodyStyle.setProperty('--font-size', computedStyle.getPropertyValue('--vscode-font-size').trim());
            bodyStyle.setProperty('--font-weight', computedStyle.getPropertyValue('--vscode-font-weight').trim());
        } else {
            bodyStyle.setProperty(
                '--font-family',
                computedStyle.getPropertyValue('--vscode-editor-font-family').trim()
            );
            bodyStyle.setProperty('--font-size', computedStyle.getPropertyValue('--vscode-editor-font-size').trim());
            bodyStyle.setProperty(
                '--font-weight',
                computedStyle.getPropertyValue('--vscode-editor-font-weight').trim()
            );
        }

        let color = computedStyle.getPropertyValue('--vscode-editor-background').trim();
        bodyStyle.setProperty('--color-background', color);
        bodyStyle.setProperty('--color-background--lighten-05', lighten(color, 5));
        bodyStyle.setProperty('--color-background--darken-05', darken(color, 5));
        bodyStyle.setProperty('--color-background--lighten-075', lighten(color, 7.5));
        bodyStyle.setProperty('--color-background--darken-075', darken(color, 7.5));
        bodyStyle.setProperty('--color-background--lighten-15', lighten(color, 15));
        bodyStyle.setProperty('--color-background--darken-15', darken(color, 15));
        bodyStyle.setProperty('--color-background--lighten-30', lighten(color, 30));
        bodyStyle.setProperty('--color-background--darken-30', darken(color, 30));
        bodyStyle.setProperty('--color-background--lighten-50', lighten(color, 50));
        bodyStyle.setProperty('--color-background--darken-50', darken(color, 50));

        color = computedStyle.getPropertyValue('--vscode-button-background').trim();
        bodyStyle.setProperty('--color-button-background', color);
        bodyStyle.setProperty('--color-button-background--darken-30', darken(color, 30));

        color = computedStyle.getPropertyValue('--vscode-button-foreground').trim();
        bodyStyle.setProperty('--color-button-foreground', color);

        color = computedStyle.getPropertyValue('--vscode-editor-foreground').trim();
        if (!color) {
            color = computedStyle.getPropertyValue('--vscode-foreground').trim();
        }
        bodyStyle.setProperty('--color-foreground', color);
        bodyStyle.setProperty('--color-foreground--85', opacity(color, 85));
        bodyStyle.setProperty('--color-foreground--75', opacity(color, 75));
        bodyStyle.setProperty('--color-foreground--65', opacity(color, 65));
        bodyStyle.setProperty('--color-foreground--50', opacity(color, 50));

        color = computedStyle.getPropertyValue('--vscode-focusBorder').trim();
        bodyStyle.setProperty('--color-focus-border', color);

        color = computedStyle.getPropertyValue('--vscode-textLink-foreground').trim();
        bodyStyle.setProperty('--color-link-foreground', color);
        bodyStyle.setProperty('--color-link-foreground--darken-20', darken(color, 20));
        bodyStyle.setProperty('--color-link-foreground--lighten-20', lighten(color, 20));
    };

    const observer = new MutationObserver(onColorThemeChanged);
    observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });

    onColorThemeChanged();
    return observer;
}
</t>
<t tx="fil.20210603223934.2">function chooseLeoEditorPath() {
    vscode.postMessage({
        command: "chooseLeoEditorPath"
    });
}

</t>
<t tx="fil.20210603223934.3">function onBind() {
    listenAll('input[type=checkbox][data-setting]', 'change', function (this: HTMLInputElement) {
        return onInputChecked(this);
    });
    listenAll('input[type=text][data-setting], input:not([type])[data-setting]', 'blur', function (
        this: HTMLInputElement
    ) {
        return onInputBlurred(this);
    });
    listenAll('input[type=text][data-setting], input:not([type])[data-setting]', 'focus', function (
        this: HTMLInputElement
    ) {
        return onInputFocused(this);
    });
    listenAll('input[type=text][data-setting], input[type=number][data-setting]', 'input', function (
        this: HTMLInputElement
    ) {
        return onInputChanged(this);
    });
    listenAll('select[data-setting]', 'change', function (this: HTMLSelectElement) {
        return onDropdownChanged(this);
    });
    listenAll('input[type=number][data-vscode]', 'input', function (
        this: HTMLInputElement
    ) {
        return onVscodeInputChanged(this);
    });
}

</t>
<t tx="fil.20210603223934.4">function onDropdownChanged(element: HTMLSelectElement) {
    if (element) {
        const w_value = element.options[element.selectedIndex].value;
        frontConfig[element.id] = w_value;
    }
    dirty!.className = "show";
    applyChanges();
}

</t>
<t tx="fil.20210603223934.5">function onInputChecked(element: HTMLInputElement) {
    frontConfig[element.id] = element.checked;
    setVisibility(frontConfig);
    dirty!.className = "show";
    applyChanges();
}
</t>
<t tx="fil.20210603223934.6">function onInputBlurred(element: HTMLInputElement) {
    // console.log('onInputBlurred', element);
}
</t>
<t tx="fil.20210603223934.7">function onInputFocused(element: HTMLInputElement) {
    // console.log('onInputFocused', element);
}
</t>
<t tx="fil.20210603223934.8">function onInputChanged(element: HTMLInputElement) {
    if (element.type === 'number' &amp;&amp; Number(element.value) &lt; Number(element.max) &amp;&amp; Number(element.value) &gt; Number(element.min)) {
        frontConfig[element.id] = Number(element.value);
        element.classList.remove("is-invalid");
    } else if (element.type === 'number' &amp;&amp; (Number(element.value) &gt; Number(element.max) || Number(element.value) &lt; Number(element.min))) {
        // make red
        element.classList.add("is-invalid");
    } else if (element.type === 'text' &amp;&amp; element.value.length &lt;= element.maxLength) {
        frontConfig[element.id] = element.value;
    }
    dirty!.className = "show";
    applyChanges();
}

</t>
<t tx="fil.20210603223934.9">function setControls(): void {
    // 1- Set leointeg's own configuration settings
    for (const key in frontConfig) {
        if (frontConfig.hasOwnProperty(key)) {
            const w_element = document.getElementById(key);
            if (w_element &amp;&amp; w_element.getAttribute('type') === 'checkbox') {
                (w_element as HTMLInputElement).checked = frontConfig[key];
            } else if (w_element) {
                (w_element as HTMLInputElement).value = frontConfig[key];
            } else {
                console.log('ERROR : w_element', key, ' is ', w_element);
            }
        }
    }
}

</t>
<t tx="fil.20210603223956.2">@language css
html {
  height: 100%;
  font-size: 62.5%;
  box-sizing: border-box;
  scroll-behavior: smooth;
}

body {
  background-color: var(--color-background);
  color: var(--color-foreground);
  font-family: var(--font-family);
  height: 100%;
  line-height: 1.4;
  font-size: 100% !important;

  &amp;.vscode-light {
    background-color: var(--color-background--darken-075);
  }
}

a {
  border: 0;
  color: var(--color-link-foreground);
  font-weight: 400;
  outline: none;
  text-decoration: none;

  &amp;:not([href]):not([tabindex]):focus,
  &amp;:not([href]):not([tabindex]):hover {
    color: inherit;
    text-decoration: none;
  }

  &amp;:focus {
    outline-color: var(--color-focus-border);
  }
  &amp;:hover {
    color: var(--color-link-foreground--lighten-20);
  }
}

b {
  font-weight: 600;
}

code,
.shortcut-key {
  border-radius: 4px;
  color: var(--color-foreground);
  padding: 2px 6px 0 6px;
  vertical-align: baseline;

  .vscode-dark &amp; {
    background-color: var(--color-background--lighten-15);
    border-bottom: 2px solid var(--color-background--lighten-15);
  }

  .vscode-light &amp; {
    background-color: var(--color-background--darken-15);
    border-bottom: 2px solid var(--color-background--darken-15);
  }
}

h1 {
  border: none;
  font-size: 4rem;
  font-weight: 400;
  margin: 0;
  padding: 0;
  white-space: nowrap;
}

h2 {
  font-size: 2.2rem;
  font-weight: 200;
  line-height: normal;
  margin: 1em 0 0.3em 0;
  white-space: nowrap;
}

h3 {
  font-size: 1.8rem;
  font-weight: 200;
  line-height: normal;
  margin: 1em 0 0.3em 0;
  white-space: nowrap;
}

h4 {
  font-size: 1rem;
  font-weight: 200;
  line-height: normal;
  margin: 1em 0 0.3em 0;
  white-space: nowrap;
}

header {
  grid-area: header;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(265px, 1fr));
  grid-gap: 1em 3em;
  align-items: center;
  justify-items: center;
  margin: 0 3em;
}

input,
select,
button {
  font-family: var(--font-family);
  font-size: inherit;
  margin: 0;
}

input[type="checkbox"] {
  background: none;
  border: none;
  cursor: pointer;
  margin: 0;
  padding: 0 10px;

  &amp;:focus {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 5px;
    outline: none;
  }

  &amp;[disabled] {
    color: var(--color-foreground--75);
    cursor: default;
  }
}

input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  margin: 0;
}

input[type="number"],
input[type="text"],
input:not([type]) {
  background: none;
  color: var(--color-foreground);
  margin: 0 10px;
  max-width: 300px;
  padding: 4px;
  // width: 100%;

  .vscode-dark &amp; {
    border: 1px solid rgba(255, 255, 255, 0.3);
  }

  .vscode-light &amp; {
    border: 1px solid rgba(0, 0, 0, 0.3);
  }

  &amp;:focus {
    outline-color: var(--color-focus-border);

    .vscode-light &amp; {
      background-color: rgba(255, 255, 255, 0.4);
    }

    .vscode-dark &amp; {
      background-color: rgba(0, 0, 0, 0.2);
    }
  }

  &amp;.is-invalid {
    outline-color: red !important;
    border-color: red !important;
  }

  &amp;[disabled] {
    color: var(--color-foreground--75);
    cursor: default;
  }

  &amp;::placeholder {
    color: var(--vscode-input-placeholderForeground);
  }
}

label {
  cursor: pointer;
}

select {
  background: none;
  color: var(--color-foreground);
  cursor: pointer;
  margin: 0 0.75em;
  padding: 2px;
  min-width: 14em;

  .vscode-light &amp; {
    border: 1px solid rgba(0, 0, 0, 0.3);
  }

  .vscode-dark &amp; {
    border: 1px solid rgba(255, 255, 255, 0.3);
  }

  &amp;:focus {
    outline-color: var(--color-focus-border);
    .vscode-light &amp; {
      background-color: rgba(255, 255, 255, 0.4);
    }

    .vscode-dark &amp; {
      background-color: rgba(0, 0, 0, 0.2);
    }
  }

  &amp;[disabled] {
    color: var(--color-foreground--75);
    cursor: default;
  }
}

select option {
  .vscode-light &amp; {
    background-color: var(--color-background--darken-05);
  }

  .vscode-dark &amp; {
    background-color: var(--color-background--lighten-05);
  }

  &amp;:focus {
    outline-color: var(--color-focus-border);
    .vscode-light &amp; {
      background-color: rgba(255, 255, 255, 0.4);
    }

    .vscode-dark &amp; {
      background-color: rgba(0, 0, 0, 0.2);
    }
  }
}

ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

.button {
  background: none;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  display: inline-block;
  font-size: 1.1rem;
  letter-spacing: 0.25em;
  margin: 1em 0.5em;
  padding: 1em 1.75em;
  text-decoration: none;
  text-transform: uppercase;
  user-select: none;
  white-space: nowrap;

  &amp;:focus {
    outline: none;
  }
}

.button--big {
  font-size: 1.5rem;
}

.button--flat {
  .vscode-light &amp; {
    border: 1px solid rgba(0, 0, 0, 0.6);
    color: black;
  }
  .vscode-dark &amp; {
    border: 1px solid rgba(255, 255, 255, 0.6);
    color: white !important;
  }
  transition: background-color 250ms, border-color 250ms, color 250ms;

  &amp;:hover {
    .vscode-light &amp; {
      background-color: var(--color-button-background--darken-30);
      border-color: var(--color-button-background--darken-30);
      color: white !important;
    }
    .vscode-dark &amp; {
      background-color: white;
      border-color: white;
      color: black !important;
    }
  }

  .preload &amp; {
    transition-duration: 0s !important;
  }
}

.button--flat-inverse {
  background-color: white;
  border: 1px solid white;
  color: black !important;
  font-weight: 600;
  transition: background-color 250ms, border-color 250ms, color 250ms;

  &amp;:hover {
    background: rgba(0, 0, 0, 0.2);
    border-color: rgba(255, 255, 255, 0.6);
    color: white !important;
  }

  .preload &amp; {
    transition-duration: 0s !important;
  }
}

.button--flat-primary {
  background-color: var(--color-button-background);
  border: 1px solid var(--color-button-background);
  color: var(--color-button-foreground) !important;
  font-weight: 600;
  transition: background-color 250ms, border-color 250ms, color 250ms;

  &amp;:hover {
    .vscode-dark &amp; {
      background-color: white;
      border-color: white;
      color: black !important;
    }

    .vscode-light &amp; {
      background-color: var(--color-button-background--darken-30);
      border-color: var(--color-button-background--darken-30);
      color: white !important;
    }
  }

  .preload &amp; {
    transition-duration: 0s !important;
  }
}

.button--choose-path {
  padding: 0.6em 0.7em;
  margin-left: 0.2rem;
  margin-bottom: 0;
}

.blurb {
  font-size: 1.5rem;
  font-weight: 200;
  color: var(--color-foreground--65);
  margin: 1em;

  b {
    color: var(--color-foreground--85);
  }

  .vscode-light &amp; {
    color: var(--color-foreground--75);
  }
}

.command {
  font-weight: 600;
  padding: 1px 3px;
}

.container {
  display: grid;
  grid-template-areas: "header header" "hero hero" "content sidebar";
  grid-template-columns: repeat(1, 1fr min-content);
  margin: 1em auto;
  grid-gap: 1em 3em;
  max-width: 1200px;
  min-width: 450px;

  @media all and (max-width: 768px) {
    grid-gap: 1em 0;
  }
}

.content__area {
  grid-area: content;
  font-size: 1.4rem;
  // border-radius: 8x;

  .vscode-dark &amp; {
    background-color: var(--color-background--lighten-05);
  }

  .vscode-light &amp; {
    background-color: var(--color-background);
  }

  @media all and (max-width: 768px) {
    grid-column: span 1;
  }
}

.content__area--full-scroll {
  background-color: unset !important;
  margin-bottom: 90vh;

  .section--settings {
    margin: 0 0 1em 0;
  }
}

.cta {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  font-size: 1.3rem;
  margin: 0;

  &amp; p {
    margin-left: 10%;
    margin-right: 10%;
    margin-top: -0.5em;
    opacity: 0.6;
  }
}

.cta--primary {
  margin: 0 1em;
}

.cta--secondary {
  margin: 0 1em;
}

.header__blurb {
  color: var(--color-foreground--75);
  flex: 2 1 55%;
  font-size: 1.5rem;
  font-weight: 200;
  margin: 0;
  min-width: 345px;

  @media all and (max-width: 880px) {
    margin: 0 2em;
  }
}

.header__link {
  color: var(--color-foreground);
  outline: none;

  &amp;:hover,
  &amp;:active,
  &amp;:focus {
    color: var(--color-foreground);
    outline: none;
  }
}

.header__logo {
  display: flex;
  flex-wrap: nowrap;
}

.header__logo--highlight {
  color: #8d3d17;
}

.header__subtitle {
  color: var(--color-foreground--65);
  font-size: 2rem;
  font-weight: 100;
  margin: -0.2em 0 0 0;
  white-space: nowrap;
}

.hero__area {
  grid-area: hero;
  color: var(--color-foreground--75);
  font-size: 1.5rem;
  font-weight: 200;
  margin: 0 1em;

  b {
    color: var(--color-foreground--85);
  }
}

.hero__area--sticky {
  background: var(--color-background);
  margin: 0;
  padding: 1em 0;
  position: sticky;
  top: -1px;
  z-index: 1;
  grid-column: span 1;

  .vscode-light &amp; {
    background: var(--color-background--darken-075);
  }
}

.hero__row {
  display: flex;
  flex-wrap: nowrap;
  align-items: baseline;
  justify-content: space-between;
}

.hero__subtitle {
  color: var(--color-foreground--75);
  font-size: 1.4rem;
  margin: 0.25em 0 0 0;
}

.hero__title {
  font-size: 4rem;
  margin: 0;
}

.hero__title-actions {
  margin: 0 1em;
}

.hero__toolbar {
  flex: 1 1 auto;

  display: flex;
  justify-content: flex-end;
  white-space: nowrap;

  select,
  option {
    background-color: var(--color-background) !important;
    margin-right: 0;

    @media all and (max-width: 768px) {
      margin-right: unset;
    }
  }
}

.hero__toolbar-scope {
  flex: 0 0 auto;
}

.icon {
  background-color: var(--color-foreground);
  display: inline-block;
  height: 24px;
  margin-right: 3px;
  position: relative;
  width: 19px;
  top: 9px;

  h2 &amp; {
    top: 7px;
  }
}

// .icon__bulb {
//   -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path fill-rule="evenodd" d="M11.67 8.658c-.338.334-.598.705-.781 1.114-.178.407-.268.85-.268 1.329v1.6a1.304 1.304 0 0 1-.794 1.197c-.159.068-.329.102-.509.102H7.712a1.285 1.285 0 0 1-.922-.379 1.303 1.303 0 0 1-.38-.92v-1.6c0-.479-.092-.921-.274-1.329a3.556 3.556 0 0 0-.776-1.114 4.689 4.689 0 0 1-1.006-1.437A4.187 4.187 0 0 1 4 5.5a4.432 4.432 0 0 1 .616-2.27c.197-.336.432-.64.705-.914.274-.272.578-.506.911-.702.338-.196.7-.348 1.084-.454C7.7 1.053 8.1 1 8.516 1a4.476 4.476 0 0 1 2.276.614 4.475 4.475 0 0 1 1.622 1.616 4.438 4.438 0 0 1 .616 2.27c0 .617-.117 1.191-.353 1.721a4.69 4.69 0 0 1-1.006 1.437zM9.623 10.5H7.409v2.201c0 .081.028.15.09.212.062.061.131.09.213.09h1.606a.289.289 0 0 0 .213-.09.286.286 0 0 0 .09-.212V10.5z" clip-rule="evenodd"/&gt;&lt;/svg&gt;');
//   mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path fill-rule="evenodd" d="M11.67 8.658c-.338.334-.598.705-.781 1.114-.178.407-.268.85-.268 1.329v1.6a1.304 1.304 0 0 1-.794 1.197c-.159.068-.329.102-.509.102H7.712a1.285 1.285 0 0 1-.922-.379 1.303 1.303 0 0 1-.38-.92v-1.6c0-.479-.092-.921-.274-1.329a3.556 3.556 0 0 0-.776-1.114 4.689 4.689 0 0 1-1.006-1.437A4.187 4.187 0 0 1 4 5.5a4.432 4.432 0 0 1 .616-2.27c.197-.336.432-.64.705-.914.274-.272.578-.506.911-.702.338-.196.7-.348 1.084-.454C7.7 1.053 8.1 1 8.516 1a4.476 4.476 0 0 1 2.276.614 4.475 4.475 0 0 1 1.622 1.616 4.438 4.438 0 0 1 .616 2.27c0 .617-.117 1.191-.353 1.721a4.69 4.69 0 0 1-1.006 1.437zM9.623 10.5H7.409v2.201c0 .081.028.15.09.212.062.061.131.09.213.09h1.606a.289.289 0 0 0 .213-.09.286.286 0 0 0 .09-.212V10.5z" clip-rule="evenodd"/&gt;&lt;/svg&gt;');
//   -webkit-mask-repeat: no-repeat;
//   mask-repeat: no-repeat;
//   opacity: 0.8;
// }

// .icon__chevron-down {
//   -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path fill-rule="evenodd" clip-rule="evenodd" d="M7.97602 10.0719L12.3333 5.7146L12.952 6.33332L8.28538 11L7.66666 11L3 6.33332L3.61872 5.7146L7.97602 10.0719Z" /&gt;&lt;/svg&gt;');
//   mask-image: url('data:image/svg+xml;utf8,&lt;svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"&gt;&lt;path fill-rule="evenodd" clip-rule="evenodd" d="M7.97602 10.0719L12.3333 5.7146L12.952 6.33332L8.28538 11L7.66666 11L3 6.33332L3.61872 5.7146L7.97602 10.0719Z" /&gt;&lt;/svg&gt;');
//   -webkit-mask-repeat: no-repeat;
//   mask-repeat: no-repeat;
// }

// .icon__gear {
//   -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path d="M9.1 4.4L8.6 2H7.4l-.5 2.4-.7.3-2-1.3-.9.8 1.3 2-.2.7-2.4.5v1.2l2.4.5.3.8-1.3 2 .8.8 2-1.3.8.3.4 2.3h1.2l.5-2.4.8-.3 2 1.3.8-.8-1.3-2 .3-.8 2.3-.4V7.4l-2.4-.5-.3-.8 1.3-2-.8-.8-2 1.3-.7-.2zM9.4 1l.5 2.4L12 2.1l2 2-1.4 2.1 2.4.4v2.8l-2.4.5L14 12l-2 2-2.1-1.4-.5 2.4H6.6l-.5-2.4L4 13.9l-2-2 1.4-2.1L1 9.4V6.6l2.4-.5L2.1 4l2-2 2.1 1.4.4-2.4h2.8zm.6 7c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zM8 9c.6 0 1-.4 1-1s-.4-1-1-1-1 .4-1 1 .4 1 1 1z"/&gt;&lt;/svg&gt;');
//   mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path d="M9.1 4.4L8.6 2H7.4l-.5 2.4-.7.3-2-1.3-.9.8 1.3 2-.2.7-2.4.5v1.2l2.4.5.3.8-1.3 2 .8.8 2-1.3.8.3.4 2.3h1.2l.5-2.4.8-.3 2 1.3.8-.8-1.3-2 .3-.8 2.3-.4V7.4l-2.4-.5-.3-.8 1.3-2-.8-.8-2 1.3-.7-.2zM9.4 1l.5 2.4L12 2.1l2 2-1.4 2.1 2.4.4v2.8l-2.4.5L14 12l-2 2-2.1-1.4-.5 2.4H6.6l-.5-2.4L4 13.9l-2-2 1.4-2.1L1 9.4V6.6l2.4-.5L2.1 4l2-2 2.1 1.4.4-2.4h2.8zm.6 7c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zM8 9c.6 0 1-.4 1-1s-.4-1-1-1-1 .4-1 1 .4 1 1 1z"/&gt;&lt;/svg&gt;');
//   -webkit-mask-repeat: no-repeat;
//   mask-repeat: no-repeat;
// }

// .icon__info {
//   -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path fill-rule="evenodd" d="M8.568 1.031A6.8 6.8 0 0 1 12.76 3.05a7.06 7.06 0 0 1 .46 9.39 6.85 6.85 0 0 1-8.58 1.74 7 7 0 0 1-3.12-3.5 7.12 7.12 0 0 1-.23-4.71 7 7 0 0 1 2.77-3.79 6.8 6.8 0 0 1 4.508-1.149zM9.04 13.88a5.89 5.89 0 0 0 3.41-2.07 6.07 6.07 0 0 0-.4-8.06 5.82 5.82 0 0 0-7.43-.74 6.06 6.06 0 0 0 .5 10.29 5.81 5.81 0 0 0 3.92.58zM8.51 7h-1v4h1V7zm0-2h-1v1h1V5z" clip-rule="evenodd"/&gt;&lt;/svg&gt;');
//   mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"&gt;&lt;path fill-rule="evenodd" d="M8.568 1.031A6.8 6.8 0 0 1 12.76 3.05a7.06 7.06 0 0 1 .46 9.39 6.85 6.85 0 0 1-8.58 1.74 7 7 0 0 1-3.12-3.5 7.12 7.12 0 0 1-.23-4.71 7 7 0 0 1 2.77-3.79 6.8 6.8 0 0 1 4.508-1.149zM9.04 13.88a5.89 5.89 0 0 0 3.41-2.07 6.07 6.07 0 0 0-.4-8.06 5.82 5.82 0 0 0-7.43-.74 6.06 6.06 0 0 0 .5 10.29 5.81 5.81 0 0 0 3.92.58zM8.51 7h-1v4h1V7zm0-2h-1v1h1V5z" clip-rule="evenodd"/&gt;&lt;/svg&gt;');
//   -webkit-mask-repeat: no-repeat;
//   mask-repeat: no-repeat;
// }

.icon--md {
  height: 30px;
  width: 24px;
  top: 12px;
}

.icon--lg {
  height: 36px;
  width: 30px;
  top: 15px;
}

.image__logo {
  margin: 9px 1em 0 0;
  max-height: 64px;
  max-width: 64px;
}

.image__preview {
  display: block;
  border-radius: 8px;
  box-shadow: 0px 0px 1px 0px rgba(0, 0, 0, 0.8), 0px 0px 12px 1px rgba(0, 0, 0, 0.5);
  width: 600px;
}
.image__preview__body {
  display: block;
  border-radius: 8px;
  box-shadow: 0px 0px 1px 0px rgba(0, 0, 0, 0.8), 0px 0px 12px 1px rgba(0, 0, 0, 0.5);
  width: 680px;
}

.image__preview--overlay {
  left: 0;
  position: absolute;
  top: 0;
}

.image__preview--float-container {
  left: 0;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  padding-right: 17%;
}

.image__preview__body--float-container {
  left: 0;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  padding-right: 7px;
  padding-left: 7px;
  overflow: hidden;
}

.image__preview--float {
  float: right;
}

.link__configure,
.link__learn-more {
  margin-left: 10px;
}

.presets {
  align-items: baseline;
  justify-content: center;
  display: flex;
  width: 100%;
  flex-wrap: wrap;
}

section {
  display: flex;
  flex-wrap: wrap;

  margin-bottom: 1em;
  padding: 1em;

  h2 {
    flex: 1 0 auto;

    display: flex;
    margin-top: 0;
    margin-bottom: 1em;
  }
}

.section--full {
  flex-flow: column;
}

.section--settings {
  flex: 0 1 auto;

  display: flex;
  flex-wrap: wrap;

  border-radius: 8px;
  margin: 1em;
  padding: 1em;
  // box-shadow: 0px 0px 6px 1px rgba(0, 0, 0, 0.15);

  .vscode-dark &amp; {
    background: var(--color-background--lighten-075);
  }

  .vscode-light &amp; {
    background: var(--color-background--darken-05);
  }
}

.section--collapsible {
  .vscode-light &amp; {
    background: var(--color-background);
  }

  .section__header {
    cursor: pointer;
    flex: 1 0 100%;
    margin-right: 0;

    &amp;:after {
      background-color: var(--color-foreground--75);
      content: "";
      height: 40px;
      -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125"&gt;&lt;path d="M50 62a3 3 0 0 1-2-1L26 44a3 3 0 0 1 3-5l21 16 21-16a3 3 0 1 1 3 5L52 61a3 3 0 0 1-2 1z"/&gt;&lt;/svg&gt;');
      mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125"&gt;&lt;path d="M50 62a3 3 0 0 1-2-1L26 44a3 3 0 0 1 3-5l21 16 21-16a3 3 0 1 1 3 5L52 61a3 3 0 0 1-2 1z"/&gt;&lt;/svg&gt;');
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-size: 32px 40px;
      mask-size: 32px 40px;
      position: absolute;
      right: 0;
      top: 0;
      transition: transform 250ms ease-in-out;
      width: 32px;
    }
  }

  &amp;.collapsed {
    .section__header {
      margin-bottom: 0;

      &amp;:after {
        transform: translateY(-9px) rotate(-180deg);
      }

      h2 {
        margin-bottom: 0;
      }
    }

    .section__collapsible {
      display: none;
    }
  }
}

.section__collapsible {
  display: flex;
  flex-wrap: wrap;
}

.section__content {
  flex: 1 1 auto;

  display: flex;
  flex-flow: column wrap;
}

.section__group {
  flex: 1 0 100%;

  display: flex;
  flex-flow: wrap-reverse;

  &amp; + .section__group {
    margin-top: 1em;
  }
}

.section__header {
  display: flex;
  align-items: baseline;
  flex: 0 1 auto;
  flex-flow: column;
  margin-bottom: 1em;
  margin-right: 1em;
  position: relative;

  h2 {
    margin-bottom: 0;
  }

  .link__configure,
  .link__learn-more {
    visibility: hidden;
  }

  &amp;:hover {
    .link__configure,
    .link__learn-more {
      visibility: visible;
    }
  }
}

.section__header-hint {
  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0.25em 0;
}

.section__header-info {
  display: grid;
  grid-template-columns: auto auto;
  grid-gap: 1em;
  align-items: center;

  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0.25em 0.5em;

  p {
    margin: 0;
    line-height: 2rem;
  }

  .icon {
    top: 3px;
  }
}

.section__hint {
  flex: 0 0 auto;

  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0;
}

.section__preview {
  flex: 0 1 auto;
  position: relative;
  margin-left: auto;
  margin-right: auto;
  margin-bottom: 0.65rem;

  .section__collapsible &amp; {
    margin-bottom: 1em;
  }
}

.section__preview-hint {
  color: var(--color-foreground--75);
  font-weight: 200;
  margin: 0.5em 0.5em 0 0.5em;
  text-align: center;
}

// .section__preview-spacer {
// 	flex-grow: 10;
// 	flex-shrink: 10;
// }

.section__title {
  flex: 1 0 auto;
  margin: 0;
}

.section__title--primary {
  font-size: 3rem;
  margin: 0.3em 0;
  justify-content: center;
}

.section__title--break {
  margin: 0.3em 15% 0 15%;
  padding-top: 1em;
  justify-content: center;

  .vscode-dark &amp; {
    border-top: 1px solid var(--color-background--lighten-30);
  }

  .vscode-light &amp; {
    border-top: 1px solid var(--color-background--darken-30);
  }
}

.setting {
  flex: 0 1 auto;
  position: relative;
  margin-right: 1em;
  min-width: 15.5em;

  &amp; input[type="checkbox"] {
    flex: 0 0 16px;
    height: 16px;
    margin: 0 10px 0 0;
    position: relative;
    top: 3px;
    width: 16px;
  }

  &amp;[disabled] {
    label {
      color: var(--color-foreground--75);
      cursor: default;
    }
  }
}

#interface-behavior {
  .setting {
    min-width: 29em;
  }
}

// .setting--expandable {
//   .setting__expander {
//     background-color: var(--color-foreground--75);
//     cursor: pointer;
//     height: 16px;
//     -webkit-mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125"&gt;&lt;path d="M50 62a3 3 0 0 1-2-1L26 44a3 3 0 0 1 3-5l21 16 21-16a3 3 0 1 1 3 5L52 61a3 3 0 0 1-2 1z"/&gt;&lt;/svg&gt;');
//     mask-image: url('data:image/svg+xml;utf8,&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 125"&gt;&lt;path d="M50 62a3 3 0 0 1-2-1L26 44a3 3 0 0 1 3-5l21 16 21-16a3 3 0 1 1 3 5L52 61a3 3 0 0 1-2 1z"/&gt;&lt;/svg&gt;');
//     -webkit-mask-repeat: no-repeat;
//     mask-repeat: no-repeat;
//     -webkit-mask-size: 32px 28px;
//     mask-size: 32px 28px;
//     position: relative;
//     margin: 0;
//     transform: translate(-9px, 4px) rotate(-90deg);
//     transition: transform 250ms ease-in-out;
//     width: 32px;
//   }

//   &amp; + .settings {
//     display: none;
//   }

//   &amp;.expanded {
//     .setting__expander {
//       transform: translate(-4px, 0);
//     }

//     &amp; + .settings {
//       display: unset;
//     }
//   }
// }

.setting__input {
  display: inline-flex;
  flex-wrap: nowrap;
  align-items: baseline;
  line-height: normal;
  margin: 0.5em 0;

  input,
  select {
    flex-grow: 1;

    &amp; + .link__configure,
    &amp; + .link__learn-more {
      margin-left: 0;
    }
  }

  input[type="text"],
  input:not([type]) {
    min-width: 150px;
  }

  label {
    flex-grow: 0;

    &gt; select {
      margin-top: 0.25em;
    }
  }

  .link__learn-more,
  .link__configure {
    visibility: hidden;
    max-height: 15px;

    .icon {
      display: block;
      top: unset;
    }
  }

  &amp;:hover {
    .link__learn-more,
    .link__configure {
      visibility: visible;
    }
  }
}

.setting__input--big {
  font-size: 2.2rem;
  font-weight: 200;
  margin: 0;

  &amp; input[type="checkbox"] {
    flex: 0 0 1.5em;
    height: 1em;
    margin: 0;
    position: relative;
    top: 3px;
    left: -5px;
    width: 1em;
  }

  &amp; label {
    white-space: nowrap;
  }

  .link__learn-more,
  .link__configure {
    max-height: 17px;
  }
}

.setting__input--format {
  display: flex;

  input[type="text"],
  input:not([type]) {
    max-width: unset;
  }
}

.setting__hint {
  color: var(--color-foreground--75);
  display: block;
  font-weight: 200;
  font-size: 1.3rem;
  margin: 0 1em 0.5em 1em;
}

.settings {
  flex: 1 0 auto;

  display: flex;
  flex-wrap: wrap;
  // align-items: baseline;
  // justify-content: space-between;
}

.settings--fixed {
  display: block;
}

.sidebar {
  grid-area: sidebar;
  align-self: flex-start;
  font-size: 1.3rem;
  position: sticky;
  top: 0;
  z-index: 2;

  @media all and (max-width: 768px) {
    display: none;
  }

  li {
    white-space: nowrap;
  }

  .button {
    margin: 0;
  }
}

.sidebar__group {
  margin-top: 1em;

  h2 {
    font-size: 2rem;
  }

  p {
    font-weight: 400;
    opacity: 0.5;
    text-align: center;
  }
}

.sidebar__jump-link {
  &amp;.active {
    font-weight: 700;

    &amp;:before {
      content: " ";
      border-left: 4px solid var(--color-link-foreground--darken-20);
      position: absolute;
      left: -1em;
      height: 1em;
      padding-bottom: 4px;

      .vscode-light &amp; {
        border-left-color: var(--color-link-foreground--lighten-20);
      }
    }
  }
}

.sponsor__image {
  opacity: 0.8;
  transition: opacity 250ms;
  transform: scale(0.6);
  margin: -2.5em 0;

  &amp;:hover {
    opacity: 1;
  }
}

.sponsor__tag {
  font-size: 1.1rem;
  margin: -1em 0.5em 0 0.5em;
  opacity: 0.5;
  text-align: center;
}

.bold {
  font-weight: 600;
}

.center {
  text-align: center;
}

.hidden {
  display: none !important;
}

.highlight {
  background-color: #cc5d1a;
  border-bottom: 2px solid #cc5d1a;
  // background-color: #7e3919;
  // border-bottom: 2px solid #85422a;
  border-radius: 3px;
  color: #f2f2f2;
  margin: 0 0.25em;
  padding: 2px 10px;
  text-align: center;
  vertical-align: bottom;
}

.is-sidebar-hidden {
  display: none;

  @media all and (max-width: 768px) {
    display: initial;
  }
}

.mb-0 {
  margin-bottom: 0 !important;
}

.mb-05 {
  margin-bottom: 0.5em !important;
}

.mb-1 {
  margin-bottom: 1em !important;
}

.mb-2 {
  margin-bottom: 2em !important;
}

.ml-0 {
  margin-left: 0 !important;
}

.ml-1 {
  margin-left: 1em !important;
}

.ml-2 {
  margin-left: 2em !important;
}

.ml-3 {
  margin-left: 3em !important;
}

.ml-4 {
  margin-left: 4em !important;
}

.mr-0 {
  margin-right: 0 !important;
}

.mr-1 {
  margin-right: 1em !important;
}

.mr-2 {
  margin-right: 2em !important;
}

.mt-n1 {
  margin-top: -1em !important;
}

.mt-0 {
  margin-top: 0 !important;
}

.mt-05 {
  margin-top: 0.5em !important;
}

.mt-1 {
  margin-top: 1em !important;
}

.mt-2 {
  margin-top: 2em !important;
}

.non-interactive {
  cursor: default !important;
}

.nowrap {
  white-space: nowrap !important;
}

.light {
  .vscode-dark &amp; {
    display: none;
  }
}

.dark {
  .vscode-light &amp; {
    display: none;
  }
}

::-webkit-scrollbar-corner {
  background-color: transparent !important;
}

@import "popup";
</t>
<t tx="fil.20210603223956.4">@language css
#saved-config-toast {
  box-shadow: 0px 0px 28px 0 rgba(0, 0, 0, 0.5);
  // background-color: #000 !important;

  cursor: default;
  display: block;
  padding: 1em 0.5rem;
  position: fixed;
  text-align: center;
  width: 60%;
  // height: 200px;
  top: 50px;
  left: 50%;
  border-radius: 12px;
  // margin-top: -100px; /* Negative half of height. */
  margin-left: -30%; /* Negative half of width. */
  visibility: hidden;
  font-size: 2rem;
  z-index: 100;

  &amp;.show {
    visibility: visible; /* Show the snackbar */
    /* Add animation: Take 0.5 seconds to fade in and out the snackbar.
    However, delay the fade out process for 2.5 seconds */
    // -webkit-animation: fadein 0.3s, fadeout 0.3s 0.5s;
    // animation: fadein 0.3s, fadeout 0.3s 0.4s;
    animation: fadein 0.5s, fadeout 0.5s 1s;
  }

  &amp;:before {
    // background: transparent;
    // border: 12px solid transparent;
    // content: '';
    // left: 50%;
    // position: absolute;
    // pointer-events: none;
    // top: -24px;
    // z-index: 1001;

    .vscode-light &amp; {
      border-bottom-color: var(--color-background--darken-075);
    }

    .vscode-dark &amp; {
      border-bottom-color: var(--color-background--lighten-075);
    }
  }

  .vscode-light &amp; {
    background: var(--color-background--darken-075);
  }

  .vscode-dark &amp; {
    background: var(--color-background--lighten-075);
  }
}

#dirty-config-toast {
  box-shadow: 0px 0px 28px 0 rgba(0, 0, 0, 0.5);
  // background-color: #000 !important;

  cursor: default;
  display: block;
  padding: 1em 0.5rem;
  position: fixed;
  text-align: center;
  width: 60%;
  // height: 200px;
  top: 50px;
  left: 50%;
  border-radius: 12px;
  // margin-top: -100px; /* Negative half of height. */
  margin-left: -30%; /* Negative half of width. */
  visibility: hidden;
  font-size: 2rem;
  z-index: 100;

  &amp;.show {
    visibility: visible; /* Show the snackbar */
  }

  &amp;:before {
    // background: transparent;
    // border: 12px solid transparent;
    // content: '';
    // left: 50%;
    // position: absolute;
    // pointer-events: none;
    // top: -24px;
    // z-index: 1001;

    .vscode-light &amp; {
      border-bottom-color: var(--color-background--darken-075);
    }

    .vscode-dark &amp; {
      border-bottom-color: var(--color-background--lighten-075);
    }
  }
  .vscode-light &amp; {
    background-color: #cc5d1a;
    color: #f2f2f2;
  }

  .vscode-dark &amp; {
    background-color: #cc5d1a;
    color: #f2f2f2;
  }
}

/* Animations to fade the snackbar in and out */
@keyframes fadein {
  from {
    // top: 0;
    opacity: 0.8;
  }
  to {
    // top: 30px;
    opacity: 1;
  }
}

@keyframes fadeout {
  from {
    // top: 30px;
    opacity: 1;
  }
  to {
    // top: 0;
    opacity: 0;
  }
}

.token-popup__scroller {
  margin-right: -0.4em;
  max-height: 35vh;
  overflow-y: scroll;
  padding-right: 0.4em;
}

.token-popup__hint {
  color: var(--color-foreground--75);
  display: inline-block;
  font-weight: 200;
  margin: 1.25em 0.5em 0 0.25em;
}

.token-popup__title {
  color: var(--color-foreground);
  font-weight: 400;
  margin: 0.25em 0 1em 0;
  text-align: center;
}

.token-popup__table {
  border-collapse: collapse;
  color: var(--color-foreground--75);
  table-layout: fixed;

  &amp; tr:nth-child(even) {
    .vscode-light &amp; {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .vscode-dark &amp; {
      background-color: rgba(255, 255, 255, 0.04);
    }
  }

  &amp; td {
    padding: 6px;

    i {
      opacity: 0.6;
    }
  }

  &amp; td:first-child {
    padding: 6px 12px;
  }

  &amp; td:last-child {
    padding-right: 12px;
    text-align: end;
  }
}

.token {
  background: var(--color-link-foreground--darken-20);
  border-bottom: 2px solid var(--color-link-foreground--darken-20);
  border-radius: 3px;
  color: white;
  cursor: pointer;
  display: inline-block;
  padding: 1px 8px !important;

  &amp;:before {
    content: "${";
  }

  &amp;:after {
    content: "}";
  }

  .vscode-light &amp; {
    background: var(--color-link-foreground--lighten-20);
    border-bottom-color: var(--color-link-foreground--lighten-20);
  }
}
</t>
<t tx="fil.20210609233100.1">/**
 * * Clear leointeg's last-opened &amp; recently opened Leo files list
 */
public clearRecentLeoFiles(): void {
    this._context.workspaceState.update(Constants.LAST_FILES_KEY, undefined);
    this._context.workspaceState.update(Constants.RECENT_FILES_KEY, undefined);
    vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLEARED_RECENT);
}

</t>
</tnodes>
</leo_file>
