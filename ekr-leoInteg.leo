<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20200624091412.1"><vh>Startup</vh>
<v t="ekr.20200624091440.1"><vh>@settings</vh>
<v t="ekr.20200624091446.1"><vh>@data history-list</vh></v>
<v t="ekr.20200715162627.1"><vh>@button backup</vh></v>
<v t="ekr.20200716081515.1"><vh>@button mark-changed</vh>
<v t="ekr.20200716081737.1"><vh>mark_tree</vh></v>
<v t="ekr.20200716081901.1"><vh>mark_node</vh></v>
</v>
</v>
<v t="ekr.20200704142009.1"><vh>Recursive import script</vh></v>
</v>
<v t="ekr.20200713082426.1"><vh>To do</vh></v>
<v t="ekr.20200704142236.2"><vh>leointeg/src...</vh>
<v t="ekr.20200704142236.3"><vh>@clean commandStack.ts</vh>
<v t="ekr.20200704142236.4"><vh>class CommandStack</vh>
<v t="ekr.20200704142236.5"><vh>CommandStack.size</vh></v>
<v t="ekr.20200704142236.6"><vh>CommandStack.newSelection</vh></v>
<v t="ekr.20200704142236.7"><vh>CommandStack.add</vh></v>
<v t="ekr.20200704142236.8"><vh>CommandStack._tryStart</vh></v>
<v t="ekr.20200704142236.9"><vh>CommandStack._runStackCommand</vh></v>
<v t="ekr.20200704142236.10"><vh>CommandStack._resolveResult</vh></v>
</v>
</v>
<v t="ekr.20200704142236.11"><vh>@clean config.ts</vh>
<v t="ekr.20200704142236.12"><vh>class Config</vh>
<v t="ekr.20200704142236.13"><vh>Config.getConfig</vh></v>
<v t="ekr.20200704142236.14"><vh>Config.setLeoIntegSettings</vh></v>
<v t="ekr.20200704142236.15"><vh>Config.buildFromSavedSettings</vh></v>
</v>
</v>
<v t="ekr.20200704142236.16"><vh>@clean constants.ts</vh>
<v t="ekr.20200704142236.17"><vh>class Constants</vh></v>
</v>
<v t="ekr.20200704142236.18"><vh>@clean extension.ts</vh>
<v t="ekr.20200704142236.19"><vh>activate</vh></v>
<v t="ekr.20200704142236.21"><vh>deactivate</vh></v>
<v t="ekr.20200704142236.22"><vh>showWelcomeIfNewer</vh></v>
<v t="ekr.20200704142236.23"><vh>getDurationMilliseconds</vh></v>
</v>
<v t="ekr.20200704142236.24"><vh>@clean leoAsync.ts</vh>
<v t="ekr.20200704142236.25"><vh>class LeoAsync</vh>
<v t="ekr.20200704142236.26"><vh>LeoAsync.log</vh></v>
<v t="ekr.20200704142236.27"><vh>LeoAsync.showSaveAsDialog</vh></v>
<v t="ekr.20200704142236.28"><vh>LeoAsync.showAskModalDialog</vh></v>
<v t="ekr.20200704142236.29"><vh>LeoAsync.showWarnModalMessage</vh></v>
<v t="ekr.20200704142236.30"><vh>LeoAsync.showChangesDetectedInfoMessage</vh></v>
</v>
</v>
<v t="ekr.20200704142236.31"><vh>@clean leoBody.ts</vh>
<v t="ekr.20200704142236.32"><vh>class LeoBodyProvider</vh>
<v t="ekr.20200704142236.33"><vh>LeoBodyProvider.setBodyTime</vh></v>
<v t="ekr.20200704142236.34"><vh>LeoBodyProvider.setRenameTime</vh></v>
<v t="ekr.20200704142236.35"><vh>LeoBodyProvider.fireRefreshFile</vh></v>
<v t="ekr.20200704142236.36"><vh>LeoBodyProvider.refreshPossibleGnxList</vh></v>
<v t="ekr.20200704142236.37"><vh>LeoBodyProvider.getExpiredGnxList</vh></v>
<v t="ekr.20200704142236.38"><vh>LeoBodyProvider.watch</vh></v>
<v t="ekr.20200704142236.39"><vh>LeoBodyProvider.fireDeleteExpiredGnx</vh></v>
<v t="ekr.20200704142236.40"><vh>LeoBodyProvider.stat</vh></v>
<v t="ekr.20200704142236.41"><vh>LeoBodyProvider.readFile</vh></v>
<v t="ekr.20200704142236.42"><vh>LeoBodyProvider.readDirectory</vh></v>
<v t="ekr.20200704142236.43"><vh>LeoBodyProvider.createDirectory</vh></v>
<v t="ekr.20200704142236.44"><vh>LeoBodyProvider.writeFile</vh></v>
<v t="ekr.20200704142236.45"><vh>LeoBodyProvider.rename</vh></v>
<v t="ekr.20200704142236.46"><vh>LeoBodyProvider.delete</vh></v>
<v t="ekr.20200704142236.47"><vh>LeoBodyProvider.copy</vh></v>
<v t="ekr.20200704142236.48"><vh>LeoBodyProvider._fireSoon</vh></v>
</v>
</v>
<v t="ekr.20200704142236.49"><vh>@clean leoBridge.ts</vh>
<v t="ekr.20200704142236.50"><vh>class LeoBridge</vh>
<v t="ekr.20200704142236.51"><vh>LeoBridge.action</vh></v>
<v t="ekr.20200704142236.52"><vh>LeoBridge._asyncAction</vh></v>
<v t="ekr.20200704142236.53"><vh>LeoBridge._buildActionParameter</vh></v>
<v t="ekr.20200704142236.54"><vh>LeoBridge._resolveBridgeReady</vh></v>
<v t="ekr.20200704142236.55"><vh>LeoBridge._rejectAction</vh></v>
<v t="ekr.20200704142236.56"><vh>LeoBridge._callAction</vh></v>
<v t="ekr.20200704142236.57"><vh>LeoBridge._tryParseJSON</vh>
<v t="ekr.20200704142236.58"><vh>LeoBridge.catch</vh></v>
</v>
<v t="ekr.20200704142236.59"><vh>LeoBridge._processAnswer</vh></v>
<v t="ekr.20200704142236.60"><vh>LeoBridge.initLeoProcess</vh></v>
<v t="ekr.20200704142236.61"><vh>LeoBridge._send</vh></v>
</v>
</v>
<v t="ekr.20200712055600.63"><vh>@clean leoButtonNode.ts</vh>
<v t="ekr.20200712055600.64"><vh>class LeoButtonNode</vh></v>
</v>
<v t="ekr.20200712055600.65"><vh>@clean leoButtons.ts</vh>
<v t="ekr.20200712055600.66"><vh>class LeoButtonsProvider</vh>
<v t="ekr.20200712055600.67"><vh>LeoButtonsProvider.refreshTreeRoot</vh></v>
<v t="ekr.20200712055600.68"><vh>LeoButtonsProvider.getTreeItem</vh></v>
<v t="ekr.20200712055600.69"><vh>LeoButtonsProvider.getChildren</vh></v>
<v t="ekr.20200712055600.70"><vh>LeoButtonsProvider.getParent</vh></v>
</v>
</v>
<v t="ekr.20200704142236.62"><vh>@clean leoDocumentNode.ts</vh>
<v t="ekr.20200704142236.63"><vh>class LeoDocumentNode</vh></v>
</v>
<v t="ekr.20200704142236.64"><vh>@clean leoDocuments.ts</vh>
<v t="ekr.20200704142236.65"><vh>class LeoDocumentsProvider</vh>
<v t="ekr.20200704142236.66"><vh>LeoDocumentsProvider.refreshTreeRoot</vh></v>
<v t="ekr.20200704142236.67"><vh>LeoDocumentsProvider.getTreeItem</vh></v>
<v t="ekr.20200704142236.68"><vh>LeoDocumentsProvider.getChildren</vh></v>
<v t="ekr.20200704142236.69"><vh>LeoDocumentsProvider.getParent</vh></v>
</v>
</v>
<v t="ekr.20200704142236.70"><vh>@clean leoFileBrowser.ts</vh>
<v t="ekr.20200704142236.71"><vh>class LeoFilesBrowser</vh>
<v t="ekr.20200704142236.72"><vh>LeoFilesBrowser._getBestOpenFolderUri</vh></v>
<v t="ekr.20200704142236.73"><vh>LeoFilesBrowser.getLeoFileUrl</vh></v>
</v>
</v>
<v t="ekr.20200704142237.1"><vh>@clean leoIntegration.ts</vh>
<v t="ekr.20200704142237.2"><vh>class LeoIntegration</vh>
<v t="ekr.20200704142237.3"><vh>li.constructor</vh></v>
<v t="ekr.20200712165659.1"><vh>li.Comm...</vh>
<v t="ekr.20200704142237.4"><vh>li.sendAction</vh></v>
<v t="ekr.20200704142237.5"><vh>li.startNetworkServices</vh></v>
<v t="ekr.20200704142237.6"><vh>li.startServer</vh></v>
<v t="ekr.20200704142237.7"><vh>li.connect</vh></v>
<v t="ekr.20200704142237.8"><vh>li.cancelConnect</vh></v>
</v>
<v t="ekr.20200712165730.1"><vh>li.Log...</vh>
<v t="ekr.20200715163240.1"><vh>li.showTerminalPane</vh></v>
<v t="ekr.20200715163240.2"><vh>li.hideTerminalPane</vh></v>
<v t="ekr.20200715163240.3"><vh>li.addTerminalPaneEntry</vh></v>
<v t="ekr.20200715163240.4"><vh>li.showLogPane</vh></v>
<v t="ekr.20200715163240.5"><vh>li.hideLogPane</vh></v>
<v t="ekr.20200704142237.10"><vh>li.addLogPaneEntry</vh></v>
</v>
<v t="ekr.20200712165800.1"><vh>li.Other...</vh>
<v t="ekr.20200704142237.11"><vh>li.sendConfigToServer</vh></v>
<v t="ekr.20200704142237.12"><vh>li._triggerGetStates</vh></v>
<v t="ekr.20200704142237.13"><vh>li._isBusy</vh></v>
<v t="ekr.20200704142237.14"><vh>li._isCurrentFileNamed</vh></v>
<v t="ekr.20200704142237.15"><vh>li._setupNoOpenedLeoDocument</vh></v>
<v t="ekr.20200704142237.16"><vh>li._setupOpenedLeoDocument</vh></v>
<v t="ekr.20200704142237.17"><vh>li._onChangeConfiguration</vh></v>
<v t="ekr.20200704142237.18"><vh>li._onChangeCollapsedState</vh></v>
<v t="ekr.20200704142237.19"><vh>li._onTreeViewVisibilityChanged</vh></v>
<v t="ekr.20200704142237.20"><vh>li._onDocTreeViewVisibilityChanged</vh></v>
<v t="ekr.20200715163512.1"><vh>li._onButtonsTreeViewVisibilityChanged</vh></v>
<v t="ekr.20200704142237.21"><vh>li._onActiveEditorChanged</vh></v>
<v t="ekr.20200704142237.22"><vh>li._onChangeWindowState</vh></v>
<v t="ekr.20200704142237.23"><vh>li._onDocumentChanged</vh></v>
<v t="ekr.20200704142237.24"><vh>li.triggerBodySave</vh></v>
<v t="ekr.20200704142237.25"><vh>li._bodySaveDocument</vh></v>
<v t="ekr.20200715163630.1"><vh>li.setDocumentSelection</vh></v>
<v t="ekr.20200715163630.2"><vh>li.showOutline</vh></v>
<v t="ekr.20200715163630.3"><vh>li.configTreeRefresh</vh></v>
<v t="ekr.20200704142237.28"><vh>li._refreshOutline</vh></v>
<v t="ekr.20200704142237.29"><vh>li.apToLeoNode</vh></v>
<v t="ekr.20200704142237.30"><vh>li._apToLeoNodeConvertReveal</vh></v>
<v t="ekr.20200704142237.32"><vh>li.arrayToLeoNodesArray</vh></v>
<v t="ekr.20200704142237.33"><vh>li._revealTreeViewNode</vh></v>
<v t="ekr.20200704142237.34"><vh>li.launchRefresh</vh></v>
<v t="ekr.20200704142237.35"><vh>li._gotSelection</vh></v>
<v t="ekr.20200704142237.36"><vh>li.selectTreeNode</vh></v>
<v t="ekr.20200704142237.37"><vh>li._applyNodeSelectionToBody</vh></v>
<v t="ekr.20200704142237.38"><vh>li._showBodyIfRequired</vh></v>
<v t="ekr.20200704142237.39"><vh>li._switchBody</vh></v>
<v t="ekr.20200704142237.40"><vh>li._locateOpenedBody</vh></v>
<v t="ekr.20200704142237.41"><vh>li.closeBody</vh></v>
<v t="ekr.20200704142237.42"><vh>li.showBody</vh></v>
</v>
<v t="ekr.20200712165621.1"><vh>li.Node commands...</vh>
<v t="ekr.20200704142237.44"><vh>li.nodeCommand</vh></v>
<v t="ekr.20200704142237.45"><vh>li.executeScript</vh></v>
<v t="ekr.20200704142237.46"><vh>li.changeMark</vh></v>
<v t="ekr.20200704142237.47"><vh>li.editHeadline</vh></v>
<v t="ekr.20200704142237.48"><vh>li.insertNode</vh></v>
</v>
<v t="ekr.20200712165519.1"><vh>li.Files...</vh>
<v t="ekr.20200704142237.49"><vh>li.saveAsLeoFile</vh></v>
<v t="ekr.20200704142237.50"><vh>li.saveLeoFile</vh></v>
<v t="ekr.20200704142237.51"><vh>li.switchLeoFile</vh></v>
<v t="ekr.20200704142237.52"><vh>li.selectOpenedLeoDocument</vh></v>
<v t="ekr.20200715164553.1"><vh>li.clickButton</vh></v>
<v t="ekr.20200715164554.1"><vh>li.removeButton</vh></v>
<v t="ekr.20200704142237.53"><vh>li.closeLeoFile</vh></v>
<v t="ekr.20200704142237.54"><vh>li.newLeoFile</vh></v>
<v t="ekr.20200715164711.1"><vh>li.openLeoFile</vh></v>
<v t="ekr.20200715164711.2"><vh>li.setTreeViewTitle</vh></v>
<v t="ekr.20200715164711.3"><vh>li.showLeoCommands</vh></v>
<v t="ekr.20200715164711.4"><vh>li.statusBarOnClick</vh></v>
<v t="ekr.20200715164711.5"><vh>li.test</vh></v>
</v>
<v t="ekr.20200712083036.1"><vh>li.gitDiff (new)</vh></v>
</v>
</v>
<v t="ekr.20200704142237.60"><vh>@clean leoNode.ts</vh>
<v t="ekr.20200704142237.61"><vh>class LeoNode</vh>
<v t="ekr.20200704142237.62"><vh>LeoNode.copyProperties</vh></v>
<v t="ekr.20200704142237.63"><vh>LeoNode.setRoot</vh></v>
<v t="ekr.20200716084530.1"><vh>LeoNode._getNodeContextValue</vh></v>
<v t="ekr.20200704142237.64"><vh>LeoNode.getCursorSelection</vh></v>
<v t="ekr.20200704142237.65"><vh>LeoNode.setCursorSelection</vh></v>
</v>
</v>
<v t="ekr.20200704142237.66"><vh>@clean leoOutline.ts</vh>
<v t="ekr.20200704142237.67"><vh>class LeoOutlineProvider</vh>
<v t="ekr.20200704142237.68"><vh>LeoOutlineProvider.refreshTreeNode</vh></v>
<v t="ekr.20200704142237.69"><vh>LeoOutlineProvider.refreshTreeRoot</vh></v>
<v t="ekr.20200704142237.70"><vh>LeoOutlineProvider.getTreeItem</vh></v>
<v t="ekr.20200704142237.71"><vh>LeoOutlineProvider.getChildren</vh></v>
<v t="ekr.20200704142237.72"><vh>LeoOutlineProvider.getParent</vh></v>
</v>
</v>
<v t="ekr.20200704142237.73"><vh>@clean leoStatusBar.ts</vh>
<v t="ekr.20200704142237.74"><vh>class LeoStatusBar</vh>
<v t="ekr.20200704142237.75"><vh>LeoStatusBar.show</vh></v>
<v t="ekr.20200704142237.76"><vh>LeoStatusBar.hide</vh></v>
<v t="ekr.20200704142237.77"><vh>LeoStatusBar.setString</vh></v>
<v t="ekr.20200704142237.78"><vh>LeoStatusBar.update</vh></v>
<v t="ekr.20200704142237.79"><vh>LeoStatusBar._updateLeoObjectIndicatorDebounced</vh></v>
<v t="ekr.20200704142237.80"><vh>LeoStatusBar._updateLeoObjectIndicator</vh></v>
</v>
</v>
<v t="ekr.20200704142237.81"><vh>@clean serverManager.ts</vh>
<v t="ekr.20200704142237.82"><vh>class ServerService</vh>
<v t="ekr.20200704142237.83"><vh>ServerService.constructor</vh></v>
<v t="ekr.20200704142237.84"><vh>ServerService.startServer</vh></v>
</v>
</v>
<v t="ekr.20200704142237.85"><vh>@clean types.d.ts</vh>
<v t="ekr.20200704142237.86"><vh>ConfigMembers</vh></v>
<v t="ekr.20200704142237.87"><vh>RevealType</vh></v>
<v t="ekr.20200704142237.88"><vh>RefreshType</vh></v>
<v t="ekr.20200704142237.89"><vh>UserCommand</vh></v>
<v t="ekr.20200704142237.90"><vh>LeoAction</vh></v>
<v t="ekr.20200704142237.91"><vh>LeoLogEntry</vh></v>
<v t="ekr.20200704142237.92"><vh>ArchivedPosition</vh></v>
<v t="ekr.20200716084640.1"><vh>LeoPackageStates</vh></v>
<v t="ekr.20200704142237.93"><vh>LeoBridgePackage</vh></v>
<v t="ekr.20200716084817.1"><vh>LeoDocument</vh></v>
<v t="ekr.20200716084817.2"><vh>LeoButton</vh></v>
<v t="ekr.20200704142237.95"><vh>Icon</vh></v>
<v t="ekr.20200704142237.96"><vh>BodyTimeInfo</vh></v>
<v t="ekr.20200704142237.97"><vh>showSaveAsDialogParameters</vh></v>
<v t="ekr.20200704142237.98"><vh>runAskYesNoDialogParameters</vh></v>
<v t="ekr.20200704142237.99"><vh>runWarnMessageDialogParameters</vh></v>
<v t="ekr.20200704142237.100"><vh>runInfoMessageDialogParameters</vh></v>
<v t="ekr.20200704142237.101"><vh>AskMessageItem</vh></v>
<v t="ekr.20200704142237.102"><vh>ChooseDocumentItem</vh></v>
</v>
<v t="ekr.20200704142237.103"><vh>@clean utils.ts</vh>
<v t="ekr.20200704142237.104"><vh>padNumber2</vh></v>
<v t="ekr.20200704142237.105"><vh>buildNodeIconPaths</vh></v>
<v t="ekr.20200704142237.106"><vh>buildDocumentIconPaths</vh></v>
<v t="ekr.20200716085917.1"><vh>buildButtonsIconPaths</vh></v>
<v t="ekr.20200704142237.107"><vh>buildNodeAndTextJson</vh></v>
<v t="ekr.20200704142237.108"><vh>getFileFromPath</vh></v>
<v t="ekr.20200704142237.109"><vh>isIconChangedByEdit</vh></v>
<v t="ekr.20200704142237.110"><vh>isHexColor</vh></v>
<v t="ekr.20200704142237.111"><vh>strToLeoUri</vh></v>
<v t="ekr.20200704142237.112"><vh>leoUriToStr</vh></v>
<v t="ekr.20200704142237.113"><vh>setContext</vh></v>
</v>
</v>
<v t="felix.20191126232434.2"><vh>@clean leobridgeserver.py</vh>
<v t="felix.20191128002414.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="felix.20191128002417.1"><vh>&lt;&lt; constants &gt;&gt;</vh></v>
<v t="felix.20200302204251.1"><vh>class IdleTimeManager</vh>
<v t="felix.20200302204251.2"><vh>itm.add_callback</vh></v>
<v t="felix.20200302204251.3"><vh>itm.on_idle</vh></v>
<v t="felix.20200302204251.4"><vh>itm.start</vh></v>
</v>
<v t="felix.20200302205810.1"><vh>class ExternalFilesController</vh>
<v t="felix.20200302205810.2"><vh>efc.ctor</vh></v>
<v t="felix.20200302205810.7"><vh>efc.on_idle</vh></v>
<v t="felix.20200302205810.8"><vh>efc.idle_check_commander</vh></v>
<v t="felix.20200302205810.9"><vh>efc.idle_check_at_file_node</vh></v>
<v t="felix.20200304221925.1"><vh>efc.integResult</vh></v>
<v t="felix.20200302205810.21"><vh>efc.utilities</vh>
<v t="felix.20200302205810.22"><vh>efc.ask</vh></v>
<v t="felix.20200302205810.23"><vh>efc.checksum</vh></v>
<v t="felix.20200302205810.25"><vh>efc.get_mtime</vh></v>
<v t="felix.20200302205810.26"><vh>efc.get_time</vh></v>
<v t="felix.20200302205810.27"><vh>efc.has_changed</vh></v>
<v t="felix.20200302205810.28"><vh>efc.is_enabled</vh></v>
<v t="felix.20200302205810.29"><vh>efc.join</vh></v>
<v t="felix.20200302205810.30"><vh>efc.set_time</vh></v>
<v t="felix.20200302205810.31"><vh>efc.warn</vh></v>
</v>
<v t="felix.20200308145948.1"><vh>other called methods</vh>
<v t="felix.20200308150856.1"><vh>open_with</vh></v>
<v t="felix.20200308150848.1"><vh>check_overwrite</vh></v>
<v t="felix.20200308150821.1"><vh>shut_down</vh></v>
<v t="felix.20200308150842.1"><vh>destroy_frame</vh></v>
</v>
</v>
<v t="felix.20191126232434.4"><vh>class LeoBridgeIntegController</vh>
<v t="felix.20191126232434.5"><vh>bc.__init__</vh></v>
<v t="ekr.20200712071756.1"><vh>bc.Comm...</vh>
<v t="felix.20200303214235.1"><vh>bc._asyncIdleLoop</vh></v>
<v t="ekr.20200712063635.1"><vh>bc._returnNo</vh></v>
<v t="ekr.20200712063636.1"><vh>bc._returnYes</vh></v>
<v t="ekr.20200716085955.1"><vh>_idleTime</vh></v>
<v t="ekr.20200716085955.2"><vh>_getTotalOpened</vh></v>
<v t="ekr.20200716085955.3"><vh>_getFirstOpenedCommander</vh></v>
<v t="felix.20200304224909.1"><vh>bc.sendAsyncOutput</vh></v>
<v t="felix.20200304220844.1"><vh>bc.askResult</vh></v>
<v t="felix.20200312231358.1"><vh>bc.applyConfig</vh></v>
</v>
<v t="ekr.20200712164636.1"><vh>bc.Log...</vh>
<v t="felix.20200219224515.1"><vh>bc.logSignon</vh></v>
<v t="felix.20200219222712.1"><vh>bc.es</vh></v>
</v>
<v t="felix.20200211202929.1"><vh>bc.initConnection</vh></v>
<v t="ekr.20200712071738.1"><vh>bc.Files</vh>
<v t="ekr.20200712063843.1"><vh>bc.getOpenedFiles</vh></v>
<v t="ekr.20200712063845.1"><vh>bc.setOpenedFile</vh></v>
<v t="felix.20191126232434.13"><vh>bc.openFile</vh></v>
<v t="felix.20191126232434.14"><vh>bc.closeFile</vh></v>
<v t="felix.20200216160305.1"><vh>bc.saveFile</vh></v>
<v t="ekr.20200712063947.1"><vh>bc.getStates</vh></v>
</v>
<v t="ekr.20200712064119.1"><vh>bc.Buttons</vh>
<v t="ekr.20200712063947.2"><vh>bc.getButtons</vh></v>
<v t="ekr.20200712063947.3"><vh>bc.clickButton</vh></v>
<v t="ekr.20200712063948.1"><vh>bc.removeButton</vh></v>
</v>
<v t="felix.20191128003151.1"><vh>bc.JSON Output Functions</vh>
<v t="felix.20191128004456.1"><vh>bc.setActionId</vh></v>
<v t="felix.20200213195413.1"><vh>bc.asyncOutput</vh></v>
<v t="felix.20191126232434.7"><vh>bc.sendLeoBridgePackage</vh></v>
<v t="felix.20191126232434.8"><vh>bc.outputError</vh></v>
<v t="felix.20191126232434.9"><vh>bc.outputBodyData</vh></v>
<v t="felix.20191126232434.10"><vh>bc.outputPNode</vh></v>
<v t="felix.20191126232434.11"><vh>bc.outputPNodes</vh></v>
</v>
<v t="felix.20191128000818.1"><vh>bc.Outline Edition Commands</vh>
<v t="ekr.20200712064428.1"><vh>bc.pageUp</vh></v>
<v t="ekr.20200712064428.2"><vh>bc.pageDown</vh></v>
<v t="ekr.20200712064428.3"><vh>bc.gotoFirstVisible</vh></v>
<v t="ekr.20200712064428.4"><vh>bc.gotoLastVisible</vh></v>
<v t="ekr.20200712064428.5"><vh>bc.gotoLastSibling</vh></v>
<v t="ekr.20200712064428.6"><vh>bc.gotoNextVisible</vh></v>
<v t="ekr.20200712064428.7"><vh>bc.gotoPrevVisible</vh></v>
<v t="ekr.20200712064428.8"><vh>bc.gotoNextMarked</vh></v>
<v t="ekr.20200712064428.9"><vh>bc.gotoNextClone</vh></v>
<v t="ekr.20200712064428.10"><vh>bc.contractOrGoLeft</vh></v>
<v t="ekr.20200712064428.11"><vh>bc.expandAndGoRight</vh></v>
<v t="felix.20191127004621.1"><vh>bc.markPNode</vh></v>
<v t="felix.20191127235913.1"><vh>bc.unmarkPNode</vh></v>
<v t="felix.20191231203545.1"><vh>bc.clonePNode</vh></v>
<v t="felix.20191127004619.1"><vh>bc.copyPNode</vh></v>
<v t="felix.20191127004620.1"><vh>bc.cutPNode</vh></v>
<v t="felix.20191130211048.1"><vh>bc.pastePNode</vh></v>
<v t="felix.20191130211048.2"><vh>bc.pasteAsClonePNode</vh></v>
<v t="felix.20191127002548.1"><vh>bc.deletePNode</vh></v>
<v t="felix.20191127000344.1"><vh>bc.movePNodeDown</vh></v>
<v t="felix.20191127000419.1"><vh>bc.movePNodeLeft</vh></v>
<v t="felix.20191127000420.1"><vh>bc.movePNodeRight</vh></v>
<v t="felix.20191127000420.2"><vh>bc.movePNodeUp</vh></v>
<v t="felix.20191127001506.1"><vh>bc.insertPNode</vh></v>
<v t="felix.20200120224033.1"><vh>bc.insertNamedPNode</vh></v>
<v t="felix.20191127001506.2"><vh>bc.promotePNode</vh></v>
<v t="felix.20191127001506.3"><vh>bc.demotePNode</vh></v>
<v t="felix.20191231184412.1"><vh>bc.sortChildrenPNode</vh></v>
<v t="felix.20191231184412.2"><vh>bc.sortSiblingsPNode</vh></v>
<v t="felix.20191231201748.1"><vh>bc.hoistPNode</vh></v>
<v t="felix.20191231201749.1"><vh>bc.deHoist</vh></v>
</v>
<v t="ekr.20200712080426.1"><vh>bc.git-diff</vh></v>
<v t="felix.20191128001054.1"><vh>bc.Outline and Body Interaction</vh>
<v t="felix.20200105173826.1"><vh>bc.outlineCommand</vh></v>
<v t="felix.20191231203711.1"><vh>bc.undo</vh></v>
<v t="felix.20200103204811.1"><vh>bc.redo</vh></v>
<v t="felix.20200301235235.1"><vh>bc.refreshFromDiskPNode</vh></v>
<v t="felix.20191231214801.1"><vh>bc.executeScript</vh></v>
<v t="felix.20191126232434.15"><vh>bc.getPNode</vh></v>
<v t="felix.20191126232434.16"><vh>bc.getChildren</vh></v>
<v t="felix.20191126232434.17"><vh>bc.getParent</vh></v>
<v t="felix.20191126232434.18"><vh>bc.getSelectedNode</vh></v>
<v t="felix.20191201194046.1"><vh>bc.getAllGnx</vh></v>
<v t="felix.20191126232434.19"><vh>bc.getBody</vh></v>
<v t="felix.20191126232434.20"><vh>bc.getBodyLength</vh></v>
<v t="felix.20191126232434.21"><vh>bc.setNewBody</vh></v>
<v t="felix.20191126232434.22"><vh>bc.setBody</vh></v>
<v t="felix.20191126232434.23"><vh>bc.setNewHeadline</vh></v>
<v t="felix.20191126232434.24"><vh>bc.setSelectedNode</vh></v>
<v t="felix.20191126232434.25"><vh>bc.expandNode</vh></v>
<v t="felix.20191126232434.26"><vh>bc.collapseNode</vh></v>
<v t="felix.20200329000454.1"><vh>bc.contractAll</vh></v>
<v t="felix.20191126232434.29"><vh>bc.yieldAllRootChildren</vh></v>
<v t="felix.20191216195906.1"><vh>bc.findPNodeFromGnx</vh></v>
</v>
<v t="felix.20191128003648.1"><vh>bc.leoFlexx Conversion Functions</vh>
<v t="felix.20191126232434.27"><vh>bc.create_gnx_to_vnode</vh></v>
<v t="felix.20191126232434.28"><vh>bc.test_round_trip_positions</vh></v>
<v t="felix.20191126232434.30"><vh>bc.ap_to_p</vh></v>
<v t="felix.20191126232434.31"><vh>bc.p_to_ap</vh></v>
</v>
</v>
<v t="felix.20191126232435.1"><vh>main</vh></v>
</v>
<v t="felix.20191126232434.4"></v>
<v t="ekr.20200704142237.2"></v>
<v t="ekr.20200712083036.1"></v>
<v t="ekr.20200715170035.1"><vh>Found:nodeCommand</vh>
<v t="ekr.20200704142236.19"></v>
<v t="ekr.20200704142237.46"></v>
<v t="ekr.20200704142237.47"></v>
<v t="ekr.20200704142237.45"></v>
<v t="ekr.20200704142237.48"></v>
<v t="ekr.20200704142237.44"></v>
<v t="ekr.20200704142237.49"></v>
<v t="ekr.20200704142237.50"></v>
</v>
<v t="ekr.20200716081515.1"></v>
</vnodes>
<tnodes>
<t tx="ekr.20200624091412.1"></t>
<t tx="ekr.20200624091440.1"></t>
<t tx="ekr.20200624091446.1">move-lines-to-next-node
goto-next-marked</t>
<t tx="ekr.20200704142009.1">'''Recursively import all python files in a directory and clean the result.'''
@tabwidth -4 # For a better match.

if 1:
    dir_ = r'C:\leo.repo\leointeg\src'
    theTypes = ['.ts', ]
elif 1:
    dir_ = r'C:\leo.repo\mini_leo\rust\src'
    theTypes = ['.rs', ]
g.cls()
c.recursiveImport(
    add_context=True,  # Override setting only if True/False
    add_file_context=False,  # Override setting only if True/False
    dir_=dir_,
    kind = '@clean', # '@auto', '@clean', '@nosent','@file',
    add_path = True,
    recursive = False,
    safe_at_file = False,
    theTypes = theTypes # ['.py', '.ts', '.js','.vue',],
)
# c.expandAllSubheads()
</t>
<t tx="ekr.20200704142236.10">/**
 * * Handle the result from the command that has finished, and either launch the next one refresh accordingly
 * @param p_package is the json return 'package' that was just received back from Leo
 */
private _resolveResult(p_package: LeoBridgePackage): void {
    this._stack.shift();
    // If last is done then do refresh outline and focus on outline, or body
    // console.log('p_package :', p_package);

    // TODO : p_package members names should be made into constants

    this._receivedSelection = JSON.stringify(p_package.node); // ! Maybe set this._receivedSelection to the last one anyways ?
    if (!this.size()) {
        // Reset 'received' selected node so that lastSelectedNode is used instead
        // this._receivedSelection = ""; // ! Maybe not clear this here at this point!

        this._busy = false; // We're not busy anymore // ! maybe keep using _receivedSelection instead of clearing it?
        // console.log(`busy NOW FALSE :  ${this._busy}`);

        if (this._finalRefreshType) {
            // At least some type of refresh
            this._leoIntegration.launchRefresh(this._finalRefreshType, this._finalFromOutline);
        }
        // Reset refresh type and focus flag nonetheless
        this._finalRefreshType = RefreshType.NoRefresh;
        this._finalFromOutline = false;

    } else {
        // size &gt; 0, so call _runStackCommand again, keep _busy set to true
        // console.log('Next!');
        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}
</t>
<t tx="ekr.20200704142236.11">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import * as utils from "./utils";
import { ConfigMembers, RefreshType } from "./types";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142236.12">/**
 * * Configuration Settings Service
 */
export class Config implements ConfigMembers {
    // Some config settings are used in leobridgeserver.py such as defaultReloadIgnore and checkForChangeExternalFiles
    // TODO : Should use default values in a centralized way
    public checkForChangeExternalFiles: string = "none";  // Used in leoBridge script
    public defaultReloadIgnore: string = "none"; // Used in leoBridge script
    public leoTreeBrowse: boolean = true;
    public treeKeepFocus: boolean = true;
    public treeKeepFocusWhenAside: boolean = false;
    public treeInExplorer: boolean = true;
    public showOpenAside: boolean = true;
    public statusBarString: string = "";
    public statusBarColor: string = "";
    public showEditOnNodes: boolean = true;
    public showArrowsOnNodes: boolean = false;
    public showAddOnNodes: boolean = false;
    public showMarkOnNodes: boolean = false;
    public showCloneOnNodes: boolean = false;
    public showCopyOnNodes: boolean = false;
    public invertNodeContrast: boolean = false;
    public leoPythonCommand: string = "";
    public startServerAutomatically: boolean = false; // Now set this configuration option default to 'false' to showcase treeViews 'welcome content'
    public connectToServerAutomatically: boolean = false; // Now set this configuration option default to 'false'
    public connectionAddress: string = Constants.TCPIP_DEFAULT_ADDRESS;
    public connectionPort: number = Constants.TCPIP_DEFAULT_PORT;

    private _isSettingConfig: boolean = false;
    private _needsTreeRefresh: boolean = false;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="ekr.20200704142236.13">/**
 * * Get Leointeg Configuration
 * @returns An object with all 'live' config settings members such as treeKeepFocus, defaultReloadIgnore, etc.
 */
public getConfig(): ConfigMembers {
    return {
        checkForChangeExternalFiles: this.checkForChangeExternalFiles,  // Used in leoBridge script
        defaultReloadIgnore: this.defaultReloadIgnore,  // Used in leoBridge script

        leoTreeBrowse: this.leoTreeBrowse,
        treeKeepFocus: this.treeKeepFocus,
        treeKeepFocusWhenAside: this.treeKeepFocusWhenAside,
        treeInExplorer: this.treeInExplorer,
        showOpenAside: this.showOpenAside,
        statusBarString: this.statusBarString,
        statusBarColor: this.statusBarColor,
        showEditOnNodes: this.showEditOnNodes,
        showArrowsOnNodes: this.showArrowsOnNodes,
        showAddOnNodes: this.showAddOnNodes,
        showMarkOnNodes: this.showMarkOnNodes,
        showCloneOnNodes: this.showCloneOnNodes,
        showCopyOnNodes: this.showCopyOnNodes,
        invertNodeContrast: this.invertNodeContrast,
        leoPythonCommand: this.leoPythonCommand,
        startServerAutomatically: this.startServerAutomatically,
        connectToServerAutomatically: this.connectToServerAutomatically,
        connectionAddress: this.connectionAddress,
        connectionPort: this.connectionPort,
    };
}

</t>
<t tx="ekr.20200704142236.14">/**
 * * Make changes to the expansion config settings, the updated configuration values are persisted
 * @param p_changes an array of key/values to change in the expansion settings
 * @returns a promise in case additional procedures need to be run upon completion
 */
public setLeoIntegSettings(p_changes: { code: string, value: any }[]): Promise&lt;void&gt; {
    this._isSettingConfig = true;
    const w_promises: Thenable&lt;void&gt;[] = [];
    const w_vscodeConfig = vscode.workspace.getConfiguration(Constants.CONFIG_NAME);
    p_changes.forEach(i_change =&gt; {
        if (i_change &amp;&amp; i_change.code.includes(Constants.CONFIG_REFRESH_MATCH)) {
            // Check if tree refresh is required for hover-icons to be displayed or hidden accordingly
            this._needsTreeRefresh = true;
        }
        if (w_vscodeConfig.inspect(i_change.code)!.defaultValue === i_change.value) {
            // set as undefined - same as default
            w_promises.push(w_vscodeConfig.update(i_change.code, undefined, true));
            // console.log("clearing ", change.code, "to undefined");
        } else {
            // set as value which is not default
            w_promises.push(w_vscodeConfig.update(i_change.code, i_change.value, true));
            // console.log("setting ", change.code, "to ", change.value);
        }
    });
    return Promise.all(w_promises).then(() =&gt; {
        if (this._needsTreeRefresh) {
            this._needsTreeRefresh = false;
            setTimeout(() =&gt; {
                this._leoIntegration.configTreeRefresh();
            }, 200);
        }
        this._isSettingConfig = false;
        this.buildFromSavedSettings();
    });
}
</t>
<t tx="ekr.20200704142236.15">
/**
 * * Build config from settings from vscode's saved config settings
 */
public buildFromSavedSettings(): void {
    if (this._isSettingConfig) {
        // * Currently setting config, wait until its done all, and this will be called automatically
        return;
    } else {
        // * Graphic and theme settings
        this.invertNodeContrast = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.INVERT_NODES, false);
        this.statusBarString = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.STATUSBAR_STRING, Constants.GUI.STATUSBAR_DEFAULT_STRING);
        if (this.statusBarString.length &gt; 8) {
            this.statusBarString = Constants.GUI.STATUSBAR_DEFAULT_STRING;
        }
        this.statusBarColor = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.STATUSBAR_COLOR, Constants.GUI.STATUSBAR_DEFAULT_COLOR);
        if (!utils.isHexColor(this.statusBarColor)) {
            this.statusBarColor = Constants.GUI.STATUSBAR_DEFAULT_COLOR;
        }
        // * Interface elements visibility defaults
        // TODO : Should use default values in a centralized way
        this.checkForChangeExternalFiles = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.CHECK_FOR_CHANGE_EXTERNAL_FILES, "none");
        this.defaultReloadIgnore = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.DEFAULT_RELOAD_IGNORE, "none");
        this.treeInExplorer = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.TREE_IN_EXPLORER, true);
        this.showOpenAside = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_OPEN_ASIDE, true);
        this.showEditOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_EDIT, false);
        this.showArrowsOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_ARROWS, false);
        this.showAddOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_ADD, false);
        this.showMarkOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_MARK, false);
        this.showCloneOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_CLONE, false);
        this.showCopyOnNodes = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.SHOW_COPY, false);
        // * Interface settings
        this.leoTreeBrowse = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.LEO_TREE_BROWSE, true);
        this.treeKeepFocus = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.TREE_KEEP_FOCUS, true);
        this.treeKeepFocusWhenAside = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.TREE_KEEP_FOCUS_WHEN_ASIDE, false);
        // * Server and connection automation
        this.leoPythonCommand = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.LEO_PYTHON_COMMAND, "");
        this.startServerAutomatically = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.AUTO_START_SERVER, false);
        this.connectToServerAutomatically = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.AUTO_CONNECT, false);
        this.connectionAddress = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.IP_ADDRESS, Constants.TCPIP_DEFAULT_ADDRESS); // 'ws://'
        this.connectionPort = vscode.workspace.getConfiguration(Constants.CONFIG_NAME).get(Constants.CONFIG.IP_PORT, Constants.TCPIP_DEFAULT_PORT); // 32125
        // * Set context for tree items visibility that are based on config options
        this._leoIntegration.sendConfigToServer(this.getConfig());
        utils.setContext(Constants.CONTEXT_FLAGS.LEO_TREE_BROWSE, this.leoTreeBrowse);
        utils.setContext(Constants.CONTEXT_FLAGS.TREE_IN_EXPLORER, this.treeInExplorer);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_OPEN_ASIDE, this.showOpenAside);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_EDIT, this.showEditOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_ARROWS, this.showArrowsOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_ADD, this.showAddOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_MARK, this.showMarkOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_CLONE, this.showCloneOnNodes);
        utils.setContext(Constants.CONTEXT_FLAGS.SHOW_COPY, this.showCopyOnNodes);
    }
}
</t>
<t tx="ekr.20200704142236.16">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";

@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142236.17">/**
 * * Text and numeric constants used throughout leoInteg
 */
export class Constants {

    public static PUBLISHER: string = "boltex";
    public static NAME: string = "leointeg";
    public static CONFIG_NAME: string = "leoIntegration";
    public static CONFIG_REFRESH_MATCH: string = "OnNodes"; // substring to distinguish 'on-hover' icon commands

    public static TREEVIEW_ID: string = Constants.CONFIG_NAME;
    public static TREEVIEW_EXPLORER_ID: string = Constants.CONFIG_NAME + "Explorer";

    public static DOCUMENTS_ID: string = "leoDocuments";
    public static DOCUMENTS_EXPLORER_ID: string = "leoDocumentsExplorer";

    public static BUTTONS_ID: string = "leoButtons";
    public static BUTTONS_EXPLORER_ID: string = "leoButtonsExplorer";

    public static VERSION_STATE_KEY: string = "leoIntegVersion";

    public static FILE_EXTENSION: string = "leo";
    public static URI_SCHEME: string = "leo";
    public static URI_SCHEME_HEADER: string = "leo:/";
    public static FILE_OPEN_FILTER_MESSAGE: string = "Leo Files";
    public static UNTITLED_FILE_NAME: string = "untitled";

    public static DEFAULT_PYTHON: string = "python3.7";
    public static WIN32_PYTHON: string = "py";
    public static SERVER_PATH: string = "/leobridgeserver.py";
    public static SERVER_STARTED_TOKEN: string = "LeoBridge started";

    public static TCPIP_DEFAULT_PORT: number = 32125;
    public static TCPIP_DEFAULT_PROTOCOL: string = "ws://";
    public static TCPIP_DEFAULT_ADDRESS: string = "localhost";

    public static ERROR_PACKAGE_ID: number = 0;
    public static STARTING_PACKAGE_ID: number = 1;
    public static STATUSBAR_DEBOUNCE_DELAY: number = 50;
    public static STATES_DEBOUNCE_DELAY: number = 200; // a fifth of a second after command stack completion

    /**
     * * Strings used as language id (default is "leobody")
     * TODO : #56 @boltex Add more languages strings for when directives such as @language are used throughout body panes
     */
    public static BODY_LANGUAGES = {
        default: "leobody"
    };

    /**
     * * Strings used in the workbench interface panels (not for messages or dialogs)
     */
    public static GUI = {
        ICON_LIGHT_DOCUMENT: "resources/light/document.svg",
        ICON_DARK_DOCUMENT: "resources/dark/document.svg",
        ICON_LIGHT_DOCUMENT_DIRTY: "resources/light/document-dirty.svg",
        ICON_DARK_DOCUMENT_DIRTY: "resources/dark/document-dirty.svg",
        ICON_LIGHT_BUTTON: "resources/light/button.svg",
        ICON_DARK_BUTTON: "resources/dark/button.svg",
        ICON_LIGHT_BUTTON_ADD: "resources/light/button-add.svg",
        ICON_DARK_BUTTON_ADD: "resources/dark/button-add.svg",
        ICON_LIGHT_PATH: "resources/light/box",
        ICON_DARK_PATH: "resources/dark/box",
        ICON_FILE_EXT: ".svg",
        STATUSBAR_DEFAULT_COLOR: "fb7c47",
        STATUSBAR_DEFAULT_STRING: "", // Strings like "Literate", "Leo", UTF-8 also supported: ü¶Å
        STATUSBAR_INDICATOR: "$(keyboard) ",
        QUICK_OPEN_LEO_COMMANDS: "&gt;leo: ",
        EXPLORER_TREEVIEW_PREFIX: "LEO ",
        TREEVIEW_TITLE: "OUTLINE",
        TREEVIEW_TITLE_NOT_CONNECTED: "NOT CONNECTED",
        TREEVIEW_TITLE_CONNECTED: "CONNECTED",
        TREEVIEW_TITLE_INTEGRATION: "INTEGRATION",
        BODY_TITLE: "LEO BODY",
        LOG_PANE_TITLE: "Leo Log Window",
        TERMINAL_PANE_TITLE: "LeoBridge Server",
        THEME_STATUSBAR: "statusBar.foreground"
    };

    /**
     * * Basic user messages strings for messages and dialogs
     */
    public static USER_MESSAGES = {
        SCRIPT_BUTTON: "Creates a button from selected node's script",
        SCRIPT_BUTTON_TOOLTIP:
            "The 'Script Button' button creates a new button.\n" +
            "Its name will be the headline of the presently selected node\n" +
            "Hitting this newly created button executes the button's script.\n" +
            "\n" +
            "For example, to run a script on any part of an outline:\n" +
            "\n" +
            "1.  Select the node containing the script.\n" +
            "2.  Press 'Script Button'. This will create a new button.\n" +
            "3.  Select the node on which you want to run the script.\n" +
            "4.  Press the *new* button.",
        SAVE_CHANGES: "Save changes to",
        BEFORE_CLOSING: "before closing?",
        CANCEL: "Cancel",
        FILE_ALREADY_OPENED: "Leo file already opened",
        CHOOSE_OPENED_FILE: "Select an opened Leo File",
        FILE_NOT_OPENED: "No files opened.",
        STATUSBAR_TOOLTIP_ON: "Leo Key Bindings are in effect", // TODO : Add description of what happens if clicked
        STATUSBAR_TOOLTIP_OFF: "Leo Key Bindings off", // TODO : Add description of what happens if clicked
        PROMPT_EDIT_HEADLINE: "Edit Headline",
        PROMPT_INSERT_NODE: "Insert Node",
        DEFAULT_HEADLINE: "New Headline",
        START_SERVER_ERROR: "Error - Cannot start server: ",
        CONNECT_FAILED: "Leo Bridge Connection Failed",
        CONNECT_ERROR: "Leo Bridge Connection Error: Incorrect id",
        CONNECTED: "Connected",
        ALREADY_CONNECTED: "Already connected",
        DISCONNECTED: "Disconnected",
        CLOSE_ERROR: "Cannot close: No files opened.",
        YES: "Yes",
        NO: "No",
        YES_ALL: "Yes to all",
        NO_ALL: "No to all",
        CHANGES_DETECTED: "Changes to external files were detected.",
        REFRESHED: " Nodes were refreshed from file.", // with voluntary leading space
        IGNORED: " They were ignored.", // with voluntary leading space
        TOO_FAST: "leoInteg is busy! " // with voluntary trailing space
    };

    /**
     * * Choices offered when about to lose current changes to a Leo Document
     */
    public static ASK_SAVE_CHANGES_BUTTONS: vscode.MessageItem[] = [
        {
            title: Constants.USER_MESSAGES.YES,
            isCloseAffordance: false
        },
        {
            title: Constants.USER_MESSAGES.NO,
            isCloseAffordance: false
        },
        {
            title: Constants.USER_MESSAGES.CANCEL,
            isCloseAffordance: true
        }
    ];

    /**
     * * String for JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
     */
    public static CONFIG = {
        CHECK_FOR_CHANGE_EXTERNAL_FILES: "checkForChangeExternalFiles",
        DEFAULT_RELOAD_IGNORE: "defaultReloadIgnore",
        LEO_TREE_BROWSE: "leoTreeBrowse",
        TREE_KEEP_FOCUS: "treeKeepFocus",
        TREE_KEEP_FOCUS_WHEN_ASIDE: "treeKeepFocusWhenAside",
        STATUSBAR_STRING: "statusBarString",
        STATUSBAR_COLOR: "statusBarColor",
        TREE_IN_EXPLORER: "treeInExplorer",
        SHOW_OPEN_ASIDE: "showOpenAside",
        SHOW_EDIT: "showEditOnNodes",
        SHOW_ARROWS: "showArrowsOnNodes",
        SHOW_ADD: "showAddOnNodes",
        SHOW_MARK: "showMarkOnNodes",
        SHOW_CLONE: "showCloneOnNodes",
        SHOW_COPY: "showCopyOnNodes",
        INVERT_NODES: "invertNodeContrast",
        LEO_PYTHON_COMMAND: "leoPythonCommand",
        AUTO_START_SERVER: "startServerAutomatically",
        AUTO_CONNECT: "connectToServerAutomatically",
        IP_ADDRESS: "connectionAddress",
        IP_PORT: "connectionPort",
    };

    /**
     * * Used in 'when' clauses, set with vscode.commands.executeCommand("setContext",...)
     */
    public static CONTEXT_FLAGS = {
        // Main flags for connection and opened file
        BRIDGE_READY: "leoBridgeReady", // Connected to leoBridge
        TREE_OPENED: "leoTreeOpened", // At least one Leo file opened
        TREE_TITLED: "leoTreeTitled", // Tree is a Leo file and not a new untitled document
        SERVER_STARTED: "leoServerStarted", // Auto-start or manually started
        // 'states' flags for currently opened tree view
        LEO_CHANGED: "leoChanged",
        LEO_CAN_UNDO: "leoCanUndo",
        LEO_CAN_REDO: "leoCanRedo",
        LEO_CAN_DEMOTE: "leoCanDemote",
        LEO_CAN_PROMOTE: "leoCanPromote",
        LEO_CAN_DEHOIST: "leoCanDehoist",
        // 'states' flags about current selection, for visibility and commands availability
        SELECTED_MARKED: "leoMarked", // no need for unmarked here, use !leoMarked
        SELECTED_CLONE: "leoCloned",
        SELECTED_DIRTY: "leoDirty",
        SELECTED_EMPTY: "leoEmpty",
        SELECTED_CHILD: "leoChild", // Has children
        SELECTED_ATFILE: "LeoAtFile", // Can be refreshed
        SELECTED_ROOT: "leoRoot", // ! Not given by Leo: Computed by leoInteg/vscode instead
        // Statusbar Flag 'keybindings in effect'
        LEO_SELECTED: "leoObjectSelected", // keybindings "On": Outline or body has focus
        // Context Flags for 'when' clauses, used concatenated, for each outline node
        NODE_MARKED: "leoNodeMarked",  // Selected node is marked
        NODE_UNMARKED: "leoNodeUnmarked", // Selected node is unmarked (Needed for regexp)
        NODE_ATFILE: "leoNodeAtFile", // Selected node is an @file or @clean, etc...
        NODE_CLONED: "leoNodeCloned",
        NODE_ROOT: "leoNodeRoot",
        NODE_NOT_ROOT: "leoNodeNotRoot",
        // Flags for Leo documents tree view icons and hover node command buttons
        DOCUMENT_SELECTED_TITLED: "leoDocumentSelectedTitled",
        DOCUMENT_TITLED: "leoDocumentTitled",
        DOCUMENT_SELECTED_UNTITLED: "leoDocumentSelectedUntitled",
        DOCUMENT_UNTITLED: "leoDocumentUntitled",
        // Flags that match specific LeoInteg config settings
        LEO_TREE_BROWSE: Constants.CONFIG.LEO_TREE_BROWSE, // Leo outline also in the explorer view
        TREE_IN_EXPLORER: Constants.CONFIG.TREE_IN_EXPLORER, // Leo outline also in the explorer view
        SHOW_OPEN_ASIDE: Constants.CONFIG.SHOW_OPEN_ASIDE,   // Show 'open aside' in context menu
        SHOW_EDIT: Constants.CONFIG.SHOW_EDIT,              // Hover Icons on outline nodes
        SHOW_ARROWS: Constants.CONFIG.SHOW_ARROWS,           // Hover Icons on outline nodes
        SHOW_ADD: Constants.CONFIG.SHOW_ADD,                 // Hover Icons on outline nodes
        SHOW_MARK: Constants.CONFIG.SHOW_MARK,               // Hover Icons on outline nodes
        SHOW_CLONE: Constants.CONFIG.SHOW_CLONE,             // Hover Icons on outline nodes
        SHOW_COPY: Constants.CONFIG.SHOW_COPY,               // Hover Icons on outline nodes
        AUTO_START_SERVER: Constants.CONFIG.AUTO_START_SERVER,   // Used at startup
        AUTO_CONNECT: Constants.CONFIG.AUTO_CONNECT              // Used at startup
    };

    /**
     * * Actions that can be invoked by Leo through leobridge
     */
    public static ASYNC_ACTIONS = {
        ASYNC_LOG: "log",
        ASYNC_ASK: "ask",
        ASYNC_WARN: "warn",
        ASYNC_INFO: "info",
        ASYNC_INTERVAL: "interval"
    };

    /**
     * * When async action was ASYNC_INFO
     */
    public static ASYNC_INFO_MESSAGE_CODES = {
        ASYNC_REFRESHED: "refreshed",
        ASYNC_IGNORED: "ignored"
    };

    /**
     * * runAskYesNoDialog or runAskOkDialog result codes, used when async action requires a response
     */
    public static ASYNC_ASK_RETURN_CODES = {
        YES: "yes",
        NO: "no",
        YES_ALL: "yes-all",
        NO_ALL: "no-all",
        OK: '"ok"' // Quotes in string as a 'JSON parameter'
    };

    /**
     * * Commands for leobridgeserver.py
     */
    public static LEOBRIDGE = {
        APPLY_CONFIG: "applyConfig",
        ASK_RESULT: "askResult",
        GET_ALL_GNX: "getAllGnx",
        GET_BODY_LENGTH: "getBodyLength",
        GET_BODY: "getBody",
        GET_PNODE: "getPNode",
        GET_PARENT: "getParent",
        GET_CHILDREN: "getChildren",
        GET_SELECTED_NODE: "getSelectedNode",
        SET_SELECTED_NODE: "setSelectedNode",
        SET_BODY: "setBody",
        SET_HEADLINE: "setNewHeadline",
        EXPAND_NODE: "expandNode",
        COLLAPSE_NODE: "collapseNode",
        CONTRACT_ALL: "contractAll",
        GET_OPENED_FILES: "getOpenedFiles",
        SET_OPENED_FILE: "setOpenedFile", // Pass index ? name to validate / error check, only index when stable
        OPEN_FILE: "openFile",
        CLOSE_FILE: "closeFile",
        SAVE_FILE: "saveFile",
        SAVE_CLOSE_FILE: "saveCloseFile", // Save and close current document
        GET_BUTTONS: "getButtons",
        REMOVE_BUTTON: "removeButton",
        CLICK_BUTTON: "clickButton",
        // * Goto operations
        PAGE_UP: "pageUp",
        PAGE_DOWN: "pageDown",
        GOTO_FIRST_VISIBLE: "gotoFirstVisible",
        GOTO_LAST_VISIBLE: "gotoLastVisible",
        GOTO_LAST_SIBLING: "gotoLastSibling",
        GOTO_NEXT_VISIBLE: "gotoNextVisible",
        GOTO_PREV_VISIBLE: "gotoPrevVisible",
        GOTO_NEXT_MARKED: "gotoNextMarked",
        GOTO_NEXT_CLONE: "gotoNextClone",
        CONTRACT_OR_GO_LEFT: "contractOrGoLeft",
        EXPAND_AND_GO_RIGHT: "expandAndGoRight",
        // * Leo Operations
        MARK_PNODE: "markPNode",
        UNMARK_PNODE: "unmarkPNode",
        COPY_PNODE: "copyPNode",
        CUT_PNODE: "cutPNode",
        PASTE_PNODE: "pastePNode",
        PASTE_CLONE_PNODE: "pasteAsClonePNode",
        DELETE_PNODE: "deletePNode",
        MOVE_PNODE_DOWN: "movePNodeDown",
        MOVE_PNODE_LEFT: "movePNodeLeft",
        MOVE_PNODE_RIGHT: "movePNodeRight",
        MOVE_PNODE_UP: "movePNodeUp",
        INSERT_PNODE: "insertPNode",
        INSERT_NAMED_PNODE: "insertNamedPNode",
        CLONE_PNODE: "clonePNode",
        PROMOTE_PNODE: "promotePNode",
        DEMOTE_PNODE: "demotePNode",
        REFRESH_FROM_DISK_PNODE: "refreshFromDiskPNode",
        SORT_CHILDREN: "sortChildrenPNode",
        SORT_SIBLINGS: "sortSiblingsPNode",
        UNDO: "undo",
        REDO: "redo",
        EXECUTE_SCRIPT: "executeScript",
        GET_STATES: "getStates",
        HOIST_PNODE: "hoistPNode",
        DEHOIST: "deHoist",
        // TODO : @boltex More commands to implement #15, #23, #24
        CLONE_FIND_ALL: "cloneFindAll", // #24 @boltex
        CLONE_FIND_ALL_FLATTENED: "cloneFindAllFlattened", // #24 @boltex
        CLONE_FIND_MARKED: "cloneFindMarked", // #24 @boltex
        CLONE_FIND_FLATTENED_MARKED: "cloneFindFlattenedMarked", // #24 @boltex
        EXTRACT: "extract", // #15 @boltex
        EXTRACT_NAMES: "extractNames", // #15 @boltex
        COPY_MARKED: "copyMarked", // #23 @boltex
        DIFF_MARKED_NODES: "diffMarkedNodes", // #23 @boltex
        MARK_CHANGED_ITEMS: "markChangedItems", // #23 @boltex
        MARK_SUBHEADS: "markSubheads", // #23 @boltex
        UNMARK_ALL: "unmarkAll", // #23 @boltex
        CLONE_MARKED_NODES: "cloneMarkedNodes", // #23 @boltex
        DELETE_MARKED_NODES: "deleteMarkedNodes", // #23 @boltex
        MOVE_MARKED_NODES: "moveMarkedNodes" // #23 @boltex
    };

    /**
     * * Command strings to be used with vscode.commands.executeCommand
     */
    public static VSCODE_COMMANDS = {
        SET_CONTEXT: "setContext",
        CLOSE_ACTIVE_EDITOR: "workbench.action.closeActiveEditor",
        QUICK_OPEN: "workbench.action.quickOpen"
    };

    /**
     * * All commands this expansion exposes (in package.json, contributes &gt; commands)
     */
    public static COMMANDS = {
        SHOW_WELCOME: "showWelcomePage", // Always available: not in the commandPalette section of package.json
        SHOW_SETTINGS: "showSettingsPage", // Always available: not in the commandPalette section of package.json
        // * LeoBridge
        START_SERVER: "startServer",
        CONNECT: "connectToServer",
        SET_OPENED_FILE: "setOpenedFile",
        OPEN_FILE: "openLeoFile", // sets focus on BODY
        SWITCH_FILE: "switchLeoFile",
        NEW_FILE: "newLeoFile",
        SAVE_FILE: "saveLeoFile", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
        SAVE_FILE_FO: "saveLeoFileFromOutline", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
        SAVE_AS_FILE: "saveAsLeoFile",
        CLOSE_FILE: "closeLeoFile",
        CLICK_BUTTON: "clickButton",
        REMOVE_BUTTON: "removeButton",
        // * Outline selection
        SELECT_NODE: "selectTreeNode",
        OPEN_ASIDE: "openAside",
        // * Goto operations that always finish with focus in outline
        PAGE_UP: "pageUp",
        PAGE_DOWN: "pageDown",
        GOTO_FIRST_VISIBLE: "gotoFirstVisible",
        GOTO_LAST_VISIBLE: "gotoLastVisible",
        GOTO_LAST_SIBLING: "gotoLastSibling",
        GOTO_NEXT_VISIBLE: "gotoNextVisible",
        GOTO_PREV_VISIBLE: "gotoPrevVisible",
        GOTO_NEXT_MARKED: "gotoNextMarked",
        GOTO_NEXT_CLONE: "gotoNextClone",
        GOTO_NEXT_CLONE_SELECTION: "gotoNextCloneSelection",
        GOTO_NEXT_CLONE_SELECTION_FO: "gotoNextCloneSelectionFromOutline",
        CONTRACT_OR_GO_LEFT: "contractOrGoLeft",
        EXPAND_AND_GO_RIGHT: "expandAndGoRight",
        // * Leo Operations
        UNDO: "undo", // From command Palette
        UNDO_FO: "undoFromOutline", // from button, return focus on OUTLINE
        REDO: "redo", // From command Palette
        REDO_FO: "redoFromOutline", // from button, return focus on OUTLINE
        EXECUTE: "executeScriptSelection", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
        SHOW_BODY: "showBody",
        SHOW_OUTLINE: "showOutline",
        SHOW_LOG: "showLogPane",
        SORT_CHILDREN: "sortChildrenSelection", // TODO : add to #34 @boltex detect focused panel for command-palette to return focus where appropriate
        SORT_SIBLING: "sortSiblingsSelection",
        SORT_SIBLING_FO: "sortSiblingsSelectionFromOutline",
        CONTRACT_ALL: "contractAll", // From command Palette
        CONTRACT_ALL_FO: "contractAllFromOutline", // from button, return focus on OUTLINE
        // * Commands from tree panel buttons or context: focus on OUTLINE
        MARK: "mark",
        UNMARK: "unmark",
        COPY: "copyNode",
        CUT: "cutNode",
        PASTE: "pasteNode",
        PASTE_CLONE: "pasteNodeAsClone",
        DELETE: "delete",
        HEADLINE: "editHeadline",
        MOVE_DOWN: "moveOutlineDown",
        MOVE_LEFT: "moveOutlineLeft",
        MOVE_RIGHT: "moveOutlineRight",
        MOVE_UP: "moveOutlineUp",
        INSERT: "insertNode",
        CLONE: "cloneNode",
        PROMOTE: "promote",
        DEMOTE: "demote",
        REFRESH_FROM_DISK: "refreshFromDisk",
        // * Commands from keyboard, while focus on BODY (command-palette returns to BODY for now)
        MARK_SELECTION: "markSelection",
        UNMARK_SELECTION: "unmarkSelection",
        COPY_SELECTION: "copyNodeSelection", // Nothing to refresh/focus so no "FO" version
        CUT_SELECTION: "cutNodeSelection",
        PASTE_SELECTION: "pasteNodeAtSelection",
        PASTE_CLONE_SELECTION: "pasteNodeAsCloneAtSelection",
        DELETE_SELECTION: "deleteSelection",
        HEADLINE_SELECTION: "editSelectedHeadline",
        MOVE_DOWN_SELECTION: "moveOutlineDownSelection",
        MOVE_LEFT_SELECTION: "moveOutlineLeftSelection",
        MOVE_RIGHT_SELECTION: "moveOutlineRightSelection",
        MOVE_UP_SELECTION: "moveOutlineUpSelection",
        INSERT_SELECTION: "insertNodeSelection",
        INSERT_SELECTION_INTERRUPT: "insertNodeSelectionInterrupt", // Headline input box can be interrupted with another insert
        CLONE_SELECTION: "cloneNodeSelection",
        PROMOTE_SELECTION: "promoteSelection",
        DEMOTE_SELECTION: "demoteSelection",
        REFRESH_FROM_DISK_SELECTION: "refreshFromDiskSelection",
        // * Commands from keyboard, while focus on OUTLINE
        MARK_SELECTION_FO: "markSelectionFromOutline",
        UNMARK_SELECTION_FO: "unmarkSelectionFromOutline",
        // COPY_SELECTION Nothing to refresh/focus for "copy a node" so no entry here
        CUT_SELECTION_FO: "cutNodeSelectionFromOutline",
        PASTE_SELECTION_FO: "pasteNodeAtSelectionFromOutline",
        PASTE_CLONE_SELECTION_FO: "pasteNodeAsCloneAtSelectionFromOutline",
        DELETE_SELECTION_FO: "deleteSelectionFromOutline",
        HEADLINE_SELECTION_FO: "editSelectedHeadlineFromOutline",
        MOVE_DOWN_SELECTION_FO: "moveOutlineDownSelectionFromOutline",
        MOVE_LEFT_SELECTION_FO: "moveOutlineLeftSelectionFromOutline",
        MOVE_RIGHT_SELECTION_FO: "moveOutlineRightSelectionFromOutline",
        MOVE_UP_SELECTION_FO: "moveOutlineUpSelectionFromOutline",
        INSERT_SELECTION_FO: "insertNodeSelectionFromOutline",
        CLONE_SELECTION_FO: "cloneNodeSelectionFromOutline",
        PROMOTE_SELECTION_FO: "promoteSelectionFromOutline",
        DEMOTE_SELECTION_FO: "demoteSelectionFromOutline",
        REFRESH_FROM_DISK_SELECTION_FO: "refreshFromDiskSelectionFromOutline",
        // * - - - - - - - - - - - - - - - not implemented yet
        HOIST: "hoistNode",
        HOIST_SELECTION: "hoistSelection",
        HOIST_SELECTION_FO: "hoistSelectionFromOutline",
        DEHOIST: "deHoist",
        DEHOIST_FO: "deHoistFromOutline",
        CLONE_FIND_ALL: "cloneFindAll",
        CLONE_FIND_ALL_FLATTENED: "cloneFindAllFlattened",
        CLONE_FIND_MARKED: "cloneFindMarked",
        CLONE_FIND_FLATTENED_MARKED: "cloneFindFlattenedMarked",
        EXTRACT: "extract",
        EXTRACT_NAMES: "extractNames",
        COPY_MARKED: "copyMarked",
        DIFF_MARKED_NODES: "diffMarkedNodes",
        MARK_CHANGED_ITEMS: "markChangedItems",
        MARK_SUBHEADS: "markSubheads",
        UNMARK_ALL: "unmarkAll",
        CLONE_MARKED_NODES: "cloneMarkedNodes",
        DELETE_MARKED_NODES: "deleteMarkedNodes",
        MOVE_MARKED_NODES: "moveMarkedNodes"
    };
}
</t>
<t tx="ekr.20200704142236.18">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { RefreshType } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { LeoSettingsWebview } from "./webviews/leoSettingsWebview";
import { LeoButtonNode } from "./leoButtonNode";

@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142236.19">/**
 * * Called when extension is activated. It creates the leoIntegration and the 'welcome/Settings' webview instances
 */
export function activate(p_context: vscode.ExtensionContext) {

    const w_start = process.hrtime(); // For calculating total startup time duration

    const w_leoIntegExtension = vscode.extensions.getExtension(Constants.PUBLISHER + '.' + Constants.NAME)!;

    const w_leoIntegVersion = w_leoIntegExtension.packageJSON.version;

    const w_previousVersion = p_context.globalState.get&lt;string&gt;(Constants.VERSION_STATE_KEY);

    const w_leoIntegration: LeoIntegration = new LeoIntegration(p_context);
    const w_leoSettingsWebview: LeoSettingsWebview = new LeoSettingsWebview(p_context, w_leoIntegration);

    // * Reset Extension context flags (used in 'when' clauses in package.json)
    utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, false); // Connected to a leobridge server?
    utils.setContext(Constants.CONTEXT_FLAGS.TREE_OPENED, false); // Having a Leo file opened on that server?

    const w_cmdPrefix = Constants.NAME + ".";
    const w_commands: [string, (...args: any[]) =&gt; any][] = [

        // ! REMOVE TESTS ENTRIES FROM PACKAGE.JSON FOR MASTER BRANCH RELEASES !
        [w_cmdPrefix + "test", () =&gt; w_leoIntegration.test()], // * Test function useful when debugging
        [w_cmdPrefix + "testFromOutline", () =&gt; w_leoIntegration.test(true)], // * Test function useful when debugging

        [w_cmdPrefix + Constants.COMMANDS.SET_OPENED_FILE, (p_index: number) =&gt; w_leoIntegration.selectOpenedLeoDocument(p_index)], // Test for undeclared commands VERDICT IT WORKS!
        [w_cmdPrefix + Constants.COMMANDS.CLICK_BUTTON, (p_node: LeoButtonNode) =&gt; w_leoIntegration.clickButton(p_node)], // Test for undeclared commands VERDICT IT WORKS!
        [w_cmdPrefix + Constants.COMMANDS.REMOVE_BUTTON, (p_node: LeoButtonNode) =&gt; w_leoIntegration.removeButton(p_node)], // Cannot be undeclared because its referenced in package.json

        [w_cmdPrefix + Constants.COMMANDS.SHOW_WELCOME, () =&gt; w_leoSettingsWebview.openWebview()],
        [w_cmdPrefix + Constants.COMMANDS.SHOW_SETTINGS, () =&gt; w_leoSettingsWebview.openWebview()], // Same as 'show welcome screen'
        [w_cmdPrefix + Constants.COMMANDS.START_SERVER, () =&gt; w_leoIntegration.startServer()],
        [w_cmdPrefix + Constants.COMMANDS.CONNECT, () =&gt; w_leoIntegration.connect()],
        [w_cmdPrefix + Constants.COMMANDS.SHOW_LOG, () =&gt; w_leoIntegration.showLogPane()],
        [w_cmdPrefix + Constants.COMMANDS.SHOW_BODY, () =&gt; w_leoIntegration.showBody(false)], // Also focuses on body
        [w_cmdPrefix + Constants.COMMANDS.SHOW_OUTLINE, () =&gt; w_leoIntegration.showOutline(true)], // Also focuses on outline
        [w_cmdPrefix + Constants.COMMANDS.NEW_FILE, () =&gt; w_leoIntegration.newLeoFile()],
        [w_cmdPrefix + Constants.COMMANDS.SWITCH_FILE, () =&gt; w_leoIntegration.switchLeoFile()],

        [w_cmdPrefix + Constants.COMMANDS.OPEN_FILE, () =&gt; w_leoIntegration.openLeoFile()],
        [w_cmdPrefix + Constants.COMMANDS.SAVE_AS_FILE, () =&gt; w_leoIntegration.saveAsLeoFile()],
        [w_cmdPrefix + Constants.COMMANDS.SAVE_FILE, () =&gt; w_leoIntegration.saveLeoFile()],
        [w_cmdPrefix + Constants.COMMANDS.SAVE_FILE_FO, () =&gt; w_leoIntegration.saveLeoFile(true)],
        [w_cmdPrefix + Constants.COMMANDS.CLOSE_FILE, () =&gt; w_leoIntegration.closeLeoFile()],

        [w_cmdPrefix + Constants.COMMANDS.SELECT_NODE, (p_node: LeoNode) =&gt; w_leoIntegration.selectTreeNode(p_node, false, false)], // Called by nodes in tree when selected
        [w_cmdPrefix + Constants.COMMANDS.OPEN_ASIDE, (p_node: LeoNode) =&gt; w_leoIntegration.selectTreeNode(p_node, false, true)],

        [w_cmdPrefix + Constants.COMMANDS.CONTRACT_ALL, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.CONTRACT_ALL, undefined, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.CONTRACT_ALL_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.CONTRACT_ALL, undefined, RefreshType.RefreshTree, true)],

        [w_cmdPrefix + Constants.COMMANDS.MARK, (p_node: LeoNode) =&gt; w_leoIntegration.changeMark(true, p_node, false)],
        [w_cmdPrefix + Constants.COMMANDS.UNMARK, (p_node: LeoNode) =&gt; w_leoIntegration.changeMark(false, p_node, false)],
        [w_cmdPrefix + Constants.COMMANDS.MARK_SELECTION, () =&gt; w_leoIntegration.changeMark(true, undefined, false)],
        [w_cmdPrefix + Constants.COMMANDS.UNMARK_SELECTION, () =&gt; w_leoIntegration.changeMark(false, undefined, false)],
        [w_cmdPrefix + Constants.COMMANDS.MARK_SELECTION_FO, () =&gt; w_leoIntegration.changeMark(true, undefined, true)],
        [w_cmdPrefix + Constants.COMMANDS.UNMARK_SELECTION_FO, () =&gt; w_leoIntegration.changeMark(false, undefined, true)],

        [w_cmdPrefix + Constants.COMMANDS.COPY, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.COPY_PNODE, p_node, RefreshType.NoRefresh, false)], // No refresh/focus
        [w_cmdPrefix + Constants.COMMANDS.CUT, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.CUT_PNODE, p_node, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.PASTE, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.PASTE_PNODE, p_node, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.PASTE_CLONE, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.PASTE_CLONE_PNODE, p_node, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.DELETE, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.DELETE_PNODE, p_node, RefreshType.RefreshTree, false)],

        [w_cmdPrefix + Constants.COMMANDS.COPY_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.COPY_PNODE, undefined, RefreshType.NoRefresh, false)], // No refresh/focus
        [w_cmdPrefix + Constants.COMMANDS.CUT_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.CUT_PNODE, undefined, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.CUT_SELECTION_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.CUT_PNODE, undefined, RefreshType.RefreshTree, true)],
        [w_cmdPrefix + Constants.COMMANDS.PASTE_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.PASTE_PNODE, undefined, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.PASTE_SELECTION_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.PASTE_PNODE, undefined, RefreshType.RefreshTree, true)],
        [w_cmdPrefix + Constants.COMMANDS.PASTE_CLONE_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.PASTE_CLONE_PNODE, undefined, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.PASTE_CLONE_SELECTION_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.PASTE_CLONE_PNODE, undefined, RefreshType.RefreshTree, true)],
        [w_cmdPrefix + Constants.COMMANDS.DELETE_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.DELETE_PNODE, undefined, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.DELETE_SELECTION_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.DELETE_PNODE, undefined, RefreshType.RefreshTree, true)],

        [w_cmdPrefix + Constants.COMMANDS.HEADLINE, (p_node: LeoNode) =&gt; w_leoIntegration.editHeadline(p_node, false)],
        [w_cmdPrefix + Constants.COMMANDS.HEADLINE_SELECTION, () =&gt; w_leoIntegration.editHeadline(undefined, false)],
        [w_cmdPrefix + Constants.COMMANDS.HEADLINE_SELECTION_FO, () =&gt; w_leoIntegration.editHeadline(undefined, true)],

        [w_cmdPrefix + Constants.COMMANDS.MOVE_DOWN, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.MOVE_PNODE_DOWN, p_node, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.MOVE_LEFT, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.MOVE_PNODE_LEFT, p_node, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.MOVE_RIGHT, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.MOVE_PNODE_RIGHT, p_node, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.MOVE_UP, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.MOVE_PNODE_UP, p_node, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.INSERT, (p_node: LeoNode) =&gt; w_leoIntegration.insertNode(p_node, false)],
        [w_cmdPrefix + Constants.COMMANDS.CLONE, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.CLONE_PNODE, p_node, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.PROMOTE, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.PROMOTE_PNODE, p_node, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.DEMOTE, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.DEMOTE_PNODE, p_node, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.REFRESH_FROM_DISK, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.REFRESH_FROM_DISK_PNODE, p_node, RefreshType.RefreshTreeAndBody, false)],

        [w_cmdPrefix + Constants.COMMANDS.MOVE_DOWN_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.MOVE_PNODE_DOWN, undefined, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.MOVE_DOWN_SELECTION_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.MOVE_PNODE_DOWN, undefined, RefreshType.RefreshTree, true)],
        [w_cmdPrefix + Constants.COMMANDS.MOVE_LEFT_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.MOVE_PNODE_LEFT, undefined, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.MOVE_LEFT_SELECTION_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.MOVE_PNODE_LEFT, undefined, RefreshType.RefreshTree, true)],
        [w_cmdPrefix + Constants.COMMANDS.MOVE_RIGHT_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.MOVE_PNODE_RIGHT, undefined, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.MOVE_RIGHT_SELECTION_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.MOVE_PNODE_RIGHT, undefined, RefreshType.RefreshTree, true)],
        [w_cmdPrefix + Constants.COMMANDS.MOVE_UP_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.MOVE_PNODE_UP, undefined, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.MOVE_UP_SELECTION_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.MOVE_PNODE_UP, undefined, RefreshType.RefreshTree, true)],
        [w_cmdPrefix + Constants.COMMANDS.INSERT_SELECTION, () =&gt; w_leoIntegration.insertNode(undefined, false)],
        [w_cmdPrefix + Constants.COMMANDS.INSERT_SELECTION_FO, () =&gt; w_leoIntegration.insertNode(undefined, true)],

        // * Special command for when inserting rapidly more than one node without even specifying a headline label, such as spamming CTRL+I rapidly.
        [w_cmdPrefix + Constants.COMMANDS.INSERT_SELECTION_INTERRUPT, () =&gt; w_leoIntegration.insertNode(undefined, undefined, true)],

        [w_cmdPrefix + Constants.COMMANDS.CLONE_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.CLONE_PNODE, undefined, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.CLONE_SELECTION_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.CLONE_PNODE, undefined, RefreshType.RefreshTree, true)],
        [w_cmdPrefix + Constants.COMMANDS.PROMOTE_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.PROMOTE_PNODE, undefined, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.PROMOTE_SELECTION_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.PROMOTE_PNODE, undefined, RefreshType.RefreshTree, true)],
        [w_cmdPrefix + Constants.COMMANDS.DEMOTE_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.DEMOTE_PNODE, undefined, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.DEMOTE_SELECTION_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.DEMOTE_PNODE, undefined, RefreshType.RefreshTree, true)],

        [w_cmdPrefix + Constants.COMMANDS.REFRESH_FROM_DISK_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.REFRESH_FROM_DISK_PNODE, undefined, RefreshType.RefreshTreeAndBody, false)],
        [w_cmdPrefix + Constants.COMMANDS.REFRESH_FROM_DISK_SELECTION_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.REFRESH_FROM_DISK_PNODE, undefined, RefreshType.RefreshTreeAndBody, true)],

        [w_cmdPrefix + Constants.COMMANDS.SORT_CHILDREN, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.SORT_CHILDREN, undefined, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.SORT_SIBLING, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.SORT_SIBLINGS, undefined, RefreshType.RefreshTree, false)],
        [w_cmdPrefix + Constants.COMMANDS.SORT_SIBLING_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.SORT_SIBLINGS, undefined, RefreshType.RefreshTree, true)],

        [w_cmdPrefix + Constants.COMMANDS.PAGE_UP, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.PAGE_UP, undefined, RefreshType.RefreshTreeAndBody, true)],
        [w_cmdPrefix + Constants.COMMANDS.PAGE_DOWN, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.PAGE_DOWN, undefined, RefreshType.RefreshTreeAndBody, true)],
        [w_cmdPrefix + Constants.COMMANDS.GOTO_FIRST_VISIBLE, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.GOTO_FIRST_VISIBLE, undefined, RefreshType.RefreshTreeAndBody, true)],
        [w_cmdPrefix + Constants.COMMANDS.GOTO_LAST_VISIBLE, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.GOTO_LAST_VISIBLE, undefined, RefreshType.RefreshTreeAndBody, true)],
        [w_cmdPrefix + Constants.COMMANDS.GOTO_LAST_SIBLING, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.GOTO_LAST_SIBLING, undefined, RefreshType.RefreshTreeAndBody, true)],
        [w_cmdPrefix + Constants.COMMANDS.GOTO_NEXT_CLONE, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.GOTO_NEXT_CLONE, p_node, RefreshType.RefreshTreeAndBody, true)],
        [w_cmdPrefix + Constants.COMMANDS.GOTO_NEXT_CLONE_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.GOTO_NEXT_CLONE, undefined, RefreshType.RefreshTreeAndBody, false)],
        [w_cmdPrefix + Constants.COMMANDS.GOTO_NEXT_CLONE_SELECTION_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.GOTO_NEXT_CLONE, undefined, RefreshType.RefreshTreeAndBody, true)],

        [w_cmdPrefix + Constants.COMMANDS.GOTO_NEXT_VISIBLE, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.GOTO_NEXT_VISIBLE, undefined, RefreshType.RefreshTreeAndBody, true)],
        [w_cmdPrefix + Constants.COMMANDS.GOTO_PREV_VISIBLE, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.GOTO_PREV_VISIBLE, undefined, RefreshType.RefreshTreeAndBody, true)],
        [w_cmdPrefix + Constants.COMMANDS.GOTO_NEXT_MARKED, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.GOTO_NEXT_MARKED, undefined, RefreshType.RefreshTreeAndBody, true)],
        [w_cmdPrefix + Constants.COMMANDS.CONTRACT_OR_GO_LEFT, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.CONTRACT_OR_GO_LEFT, undefined, RefreshType.RefreshTreeAndBody, true)],
        [w_cmdPrefix + Constants.COMMANDS.EXPAND_AND_GO_RIGHT, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.EXPAND_AND_GO_RIGHT, undefined, RefreshType.RefreshTreeAndBody, true)],

        [w_cmdPrefix + Constants.COMMANDS.UNDO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.UNDO, undefined, RefreshType.RefreshTreeAndBody, false)],
        [w_cmdPrefix + Constants.COMMANDS.UNDO_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.UNDO, undefined, RefreshType.RefreshTreeAndBody, true)],
        [w_cmdPrefix + Constants.COMMANDS.REDO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.REDO, undefined, RefreshType.RefreshTreeAndBody, false)],
        [w_cmdPrefix + Constants.COMMANDS.REDO_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.REDO, undefined, RefreshType.RefreshTreeAndBody, true)],
        [w_cmdPrefix + Constants.COMMANDS.EXECUTE, () =&gt; w_leoIntegration.executeScript()],

        [w_cmdPrefix + Constants.COMMANDS.HOIST, (p_node: LeoNode) =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.HOIST_PNODE, p_node, RefreshType.RefreshTreeAndBody, true)],
        [w_cmdPrefix + Constants.COMMANDS.HOIST_SELECTION, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.HOIST_PNODE, undefined, RefreshType.RefreshTreeAndBody, false)],
        [w_cmdPrefix + Constants.COMMANDS.HOIST_SELECTION_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.HOIST_PNODE, undefined, RefreshType.RefreshTreeAndBody, true)],
        [w_cmdPrefix + Constants.COMMANDS.DEHOIST, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.DEHOIST, undefined, RefreshType.RefreshTreeAndBody, false)],
        [w_cmdPrefix + Constants.COMMANDS.DEHOIST_FO, () =&gt; w_leoIntegration.nodeCommand(Constants.LEOBRIDGE.DEHOIST, undefined, RefreshType.RefreshTreeAndBody, true)],

        // TODO : @boltex More commands to implement #15, #23, #24
        [w_cmdPrefix + Constants.COMMANDS.CLONE_FIND_ALL, () =&gt; vscode.window.showInformationMessage("TODO: cloneFindAll command")],
        [w_cmdPrefix + Constants.COMMANDS.CLONE_FIND_ALL_FLATTENED, () =&gt; vscode.window.showInformationMessage("TODO: cloneFindAllFlattened command")],
        [w_cmdPrefix + Constants.COMMANDS.CLONE_FIND_MARKED, () =&gt; vscode.window.showInformationMessage("TODO: cloneFindMarked command")],
        [w_cmdPrefix + Constants.COMMANDS.CLONE_FIND_FLATTENED_MARKED, () =&gt; vscode.window.showInformationMessage("TODO: cloneFindFlattenedMarked command")],
        [w_cmdPrefix + Constants.COMMANDS.EXTRACT, () =&gt; vscode.window.showInformationMessage("TODO: extract command")],
        [w_cmdPrefix + Constants.COMMANDS.EXTRACT_NAMES, () =&gt; vscode.window.showInformationMessage("TODO: extractNames command")],
        [w_cmdPrefix + Constants.COMMANDS.COPY_MARKED, () =&gt; vscode.window.showInformationMessage("TODO: copyMarked command")],
        [w_cmdPrefix + Constants.COMMANDS.DIFF_MARKED_NODES, () =&gt; vscode.window.showInformationMessage("TODO: diffMarkedNodes command")],
        [w_cmdPrefix + Constants.COMMANDS.MARK_CHANGED_ITEMS, () =&gt; vscode.window.showInformationMessage("TODO: markChangedItems command")],
        [w_cmdPrefix + Constants.COMMANDS.MARK_SUBHEADS, () =&gt; vscode.window.showInformationMessage("TODO: markSubheads command")],
        [w_cmdPrefix + Constants.COMMANDS.UNMARK_ALL, () =&gt; vscode.window.showInformationMessage("TODO: unmarkAll command")],
        [w_cmdPrefix + Constants.COMMANDS.CLONE_MARKED_NODES, () =&gt; vscode.window.showInformationMessage("TODO: cloneMarkedNodes command")],
        [w_cmdPrefix + Constants.COMMANDS.DELETE_MARKED_NODES, () =&gt; vscode.window.showInformationMessage("TODO: deleteMarkedNodes command")],
        [w_cmdPrefix + Constants.COMMANDS.MOVE_MARKED_NODES, () =&gt; vscode.window.showInformationMessage("TODO: moveMarkedNode command")]
    ];

    w_commands.map(function (p_command) { p_context.subscriptions.push(vscode.commands.registerCommand(...p_command)); });

    // * Show Welcome / settings screen if the version is newer than last time, then start automatic server and connection
    showWelcomeIfNewer(w_leoIntegVersion, w_previousVersion).then(() =&gt; {
        // * Start server and / or connect to it (as specified in settings)
        w_leoIntegration.startNetworkServices();
        p_context.globalState.update(Constants.VERSION_STATE_KEY, w_leoIntegVersion);
        console.log('leoInteg startup launched in ', getDurationMilliseconds(w_start), 'ms');
    });
}

</t>
<t tx="ekr.20200704142236.2"></t>
<t tx="ekr.20200704142236.21">/**
 * * Called when extension is deactivated
 */
export function deactivate() {
    console.log('deactivate called for extension "leointeg"');
}

</t>
<t tx="ekr.20200704142236.22">/**
 * * Show welcome screen if needed, based on last version executed
 * @param p_version Current version, as a string, from packageJSON.version
 * @param p_previousVersion Previous version, as a string, from context.globalState.get service
 * @returns a promise that triggers when command to show the welcome screen is finished, or immediately if not needed
 */
async function showWelcomeIfNewer(p_version: string, p_previousVersion: string | undefined): Promise&lt;unknown&gt; {
    let w_showWelcomeScreen: boolean = false;
    if (p_previousVersion === undefined) {
        console.log('leoInteg first-time install');
        w_showWelcomeScreen = true;
    } else {
        if (p_previousVersion !== p_version) {
            console.log(`leoInteg upgraded from v${p_previousVersion} to v${p_version}`);
        }
        const [w_major, w_minor] = p_version.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        const [w_prevMajor, w_prevMinor] = p_previousVersion.split('.').map(p_stringVal =&gt; parseInt(p_stringVal, 10));
        if (
            (w_major === w_prevMajor &amp;&amp; w_minor === w_prevMinor) ||
            // Don't notify on downgrades
            (w_major &lt; w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &lt; w_prevMinor))
        ) {
            w_showWelcomeScreen = false;
        } else if (w_major !== w_prevMajor || (w_major === w_prevMajor &amp;&amp; w_minor &gt; w_prevMinor)) {
            // Will show on major or minor upgrade (Formatted as 'Major.Minor.Revision' eg. 1.2.3)
            w_showWelcomeScreen = true;
        }
    }
    if (w_showWelcomeScreen) {
        return vscode.commands.executeCommand(Constants.NAME + "." + Constants.COMMANDS.SHOW_WELCOME);
    } else {
        return Promise.resolve();
    }
}

</t>
<t tx="ekr.20200704142236.23">/**
 * * Returns the milliseconds between a given starting process.hrtime tuple and the current call to process.hrtime
 * @param p_start starting process.hrtime to subtract from current immediate time
 * @returns number of milliseconds passed since the given start hrtime
 */
function getDurationMilliseconds(p_start: [number, number]): number {
    const [secs, nanosecs] = process.hrtime(p_start);
    return secs * 1000 + Math.floor(nanosecs / 1000000);
}
</t>
<t tx="ekr.20200704142236.24">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import { Constants } from "./constants";
import { AskMessageItem, RefreshType, runAskYesNoDialogParameters, runWarnMessageDialogParameters, runInfoMessageDialogParameters, showSaveAsDialogParameters } from "./types";
import { LeoIntegration } from "./leoIntegration";

/*
    TODO : Should Reproduce those interactive controls that may be asked by Leo and redo a true UI bridge

def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    return self.simulateDialog("aboutLeoDialog", None)

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog", None)

def runAskOkDialog(self, c, title, message=None, text="Ok"):
    return self.simulateDialog("okDialog", "Ok")

def runAskOkCancelNumberDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
):
    return self.simulateDialog("numberDialog", -1)

def runAskOkCancelStringDialog(self, c, title, message,
    cancelButtonText=None,
    okButtonText=None,
    default="",
    wide=False,
):
    return self.simulateDialog("stringDialog", '')

def runCompareDialog(self, c):
    return self.simulateDialog("compareDialog", '')

def runOpenFileDialog(self, c, title, filetypes, defaultextension,
    multiple=False,
    startpath=None,
):
    return self.simulateDialog("openFileDialog", None)

def runSaveFileDialog(self, c, initialfile, title, filetypes, defaultextension):
    return self.simulateDialog("saveFileDialog", None)

def runAskYesNoDialog(self, c, title,
    message=None,
    yes_all=False,
    no_all=False,
):
    return self.simulateDialog("yesNoDialog", "no")

def runAskYesNoCancelDialog(self, c, title,
    message=None,
    yesMessage="Yes",
    noMessage="No",
    yesToAllMessage=None,
    defaultButton="Yes",
    cancelMessage=None,
):
    return self.simulateDialog("yesNoCancelDialog", "cancel")

def simulateDialog(self, key, defaultVal):
    return defaultVal

*/
@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142236.25">
/**
 * * Handles the functions called by Leo through leoBridge such as adding a log pane entry, runAskYesNoDialog for file changes, etc.
 * * Some config settings affect this behavior, such as defaultReloadIgnore and checkForChangeExternalFiles
 */
export class LeoAsync {

    private _askResult: string = "";

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) { }

    @others
}
</t>
<t tx="ekr.20200704142236.26">/**
 * * Adds message string to leoInteg's log pane, used when leoBridge gets an async 'log' command
 */
public log(p_message: string): void {
    this._leoIntegration.addLogPaneEntry(p_message);
}

</t>
<t tx="ekr.20200704142236.27">/**
 * * Equivalent to runSaveFileDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * @param p_saveAsArg
 */
public showSaveAsDialog(p_saveAsArg: showSaveAsDialogParameters): void {
    console.log('TODO: SHOW SAVE AS DIALOG!');

}

</t>
<t tx="ekr.20200704142236.28">/**
 * * Equivalent to runAskYesNoDialog from Leo's qt_gui.py, used when leoBridge gets an async 'ask' command
 * * Opens a modal dialog to return one of 'yes', 'yes-all', 'no' or 'no-all' to be sent back with the leoBridge 'ASK_RESULT' action
 * @param p_askArg an async package object {"ask": title, "message": message, "yes_all": yes_all, "no_all": no_all}
 */
public showAskModalDialog(p_askArg: runAskYesNoDialogParameters): void {
    this._askResult = "no"; // defaults to not doing anything, matches isCloseAffordance just to be safe
    // Note: "last line" could be eventually used in the message
    // const w_lastLine = p_askArg.message.substr(p_askArg.message.lastIndexOf("\n") + 1);
    const w_items: AskMessageItem[] = [
        {
            title: Constants.USER_MESSAGES.YES,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES,
            isCloseAffordance: false
        },
        {
            title: Constants.USER_MESSAGES.NO,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO,
            isCloseAffordance: true
        }
    ];
    if (p_askArg.yes_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.YES_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.YES_ALL,
            isCloseAffordance: false
        });
    }
    if (p_askArg.no_all) {
        w_items.push({
            title: Constants.USER_MESSAGES.NO_ALL,
            value: Constants.ASYNC_ASK_RETURN_CODES.NO_ALL,
            isCloseAffordance: false
        });
    }
    const w_askRefreshInfoMessage: Thenable&lt;AskMessageItem | undefined&gt; = vscode.window.showInformationMessage(
        p_askArg.message,
        { modal: true },
        ...w_items
    );
    w_askRefreshInfoMessage.then((p_result: AskMessageItem | undefined) =&gt; {
        if (p_result) {
            this._askResult = p_result.value;
        }
        const w_sendResultPromise = this._leoIntegration.sendAction(Constants.LEOBRIDGE.ASK_RESULT, '"' + this._askResult + '"'); // Quotes in string as a 'JSON parameter'
        if (this._askResult.includes(Constants.ASYNC_ASK_RETURN_CODES.YES)) {
            w_sendResultPromise.then(() =&gt; {
                // Might have answered 'yes/yesAll' and refreshed and changed the body text
                this._leoIntegration.launchRefresh(RefreshType.RefreshTreeAndBody, false); // TODO : #34 @boltex Deal with focus placement
            });
        }
    });
}

</t>
<t tx="ekr.20200704142236.29">/**
 * * Equivalent to runAskOkDialog from Leo's qt_gui.py, used when leoBridge gets an async 'warn' command
 * @param p_waitArg an async package object {"warn": "", "message": ""}
 */
public showWarnModalMessage(p_waitArg: runWarnMessageDialogParameters): void {
    vscode.window.showInformationMessage(
        p_waitArg.message,
        { modal: true }
    ).then(() =&gt; {
        this._leoIntegration.sendAction(Constants.LEOBRIDGE.ASK_RESULT, Constants.ASYNC_ASK_RETURN_CODES.OK); // Quotes in string as a 'JSON parameter'
    });
}

</t>
<t tx="ekr.20200704142236.3">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import * as utils from "./utils";
import { UserCommand, RefreshType, LeoBridgePackage } from "./types";
import { LeoIntegration } from "./leoIntegration";

@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142236.30">/**
 * * Show non-blocking info message about detected file changes, used when leoBridge gets an async 'info' command
 * @param p_infoArg an async package object { "message": string; }
 */
public showChangesDetectedInfoMessage(p_infoArg: runInfoMessageDialogParameters): void {
    let w_message = Constants.USER_MESSAGES.CHANGES_DETECTED;
    switch (p_infoArg.message) {
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_REFRESHED:
            w_message += Constants.USER_MESSAGES.REFRESHED;
            this._leoIntegration.launchRefresh(RefreshType.RefreshTreeAndBody, false); // TODO : #34 @boltex Deal with focus placement
            break;
        case Constants.ASYNC_INFO_MESSAGE_CODES.ASYNC_IGNORED:
            w_message += Constants.USER_MESSAGES.IGNORED;
            break;
        default:
            break;
    }
    vscode.window.showInformationMessage(w_message);
}
</t>
<t tx="ekr.20200704142236.31">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import * as utils from "./utils";
import * as path from 'path';
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { BodyTimeInfo } from "./types";

/**
 * * Body panes implementation as a file system using "leo" as a scheme identifier
 * * Saving and renaming prevents flickering and prevents undos to 'traverse through' different gnx
 */
@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142236.32">export class LeoBodyProvider implements vscode.FileSystemProvider {

    // * Simple structure to keep mtime of selected and renamed body virtual files
    private _selectedBody: BodyTimeInfo = { gnx: "", ctime: 0, mtime: 0 };
    private _renameBody: BodyTimeInfo = { gnx: "", ctime: 0, mtime: 0 };

    // * Last file read data with the readFile method
    private _lastGnx: string = ""; // gnx of last file read
    private _lastBodyData: string = ""; // body content of last file read
    private _lastGnxBodyLength: number = 0; // length of last file read

    // * List of currently opened body panes gnx (from 'watch' &amp; 'dispose' methods)
    private _openedBodiesGnx: string[] = [];

    // * List of all possible vNodes gnx in the currently opened leo file (since last refresh/tree operation)
    private _possibleGnxList: string[] = [];

    // * An event to signal that a resource has been changed
    // * It should fire for resources that are being [watched](#FileSystemProvider.watch) by clients of this provider
    private _onDidChangeFileEmitter = new vscode.EventEmitter&lt;vscode.FileChangeEvent[]&gt;();
    readonly onDidChangeFile: vscode.Event&lt;vscode.FileChangeEvent[]&gt; = this._onDidChangeFileEmitter.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    /**
     * * Sets selected node body's modified time for this gnx virtual file
     * @param p_uri URI of file for which to set made-up modified time
     */
    @others
}
</t>
<t tx="ekr.20200704142236.33">public setBodyTime(p_uri: vscode.Uri): void {
    const w_gnx = utils.leoUriToStr(p_uri);
    this._selectedBody = {
        gnx: w_gnx,
        ctime: 0,
        mtime: (w_gnx === this._renameBody.gnx &amp;&amp; this._selectedBody.gnx === this._renameBody.gnx) ? this._renameBody.mtime : Date.now(),
    };
}

/**
 * * Sets renamed file modified time for this gnx, used for 'rename' hack to prevent text undos between gnx
 * @param p_uri URI of file for which to set made-up modified time
 */
</t>
<t tx="ekr.20200704142236.34">public setRenameTime(p_gnx: string): void {
    this._renameBody = {
        gnx: p_gnx,
        ctime: 0,
        mtime: Date.now(),
    };
}

/**
 * * Refresh the body pane for a particular gnx by telling vscode that the file from the Leo file provider has changed
 * @param p_gnx Gnx of body associated with this virtual file, mostly Leo's selected node
 */
</t>
<t tx="ekr.20200704142236.35">public fireRefreshFile(p_gnx: string): void {
    this._selectedBody = {
        gnx: p_gnx,
        ctime: 0,
        mtime: Date.now(),
    };
    this._onDidChangeFileEmitter.fire([{
        type: vscode.FileChangeType.Changed,
        uri: utils.strToLeoUri(p_gnx)
    } as vscode.FileChangeEvent]);
}

/**
 * * Refreshes the '_possibleGnxList' list of all unique gnx from Leo
 * @returns a promise that resolves to the fresh gnx string array
 */
</t>
<t tx="ekr.20200704142236.36">public refreshPossibleGnxList(): Thenable&lt;string[]&gt; {
    // * Get updated list of possible gnx
    return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_ALL_GNX).then((p_result) =&gt; {
        if (p_result.allGnx) {
            this._possibleGnxList = p_result.allGnx;
        } else {
            this._possibleGnxList = [];
        }
        return Promise.resolve(this._possibleGnxList);
    });
}

/**
 * * Get list of bodies that should be closed: gnx from openedBodiesGnx that are not in possibleGnxList
 * @returns Promise that resolves in a string array
 */
</t>
<t tx="ekr.20200704142236.37">public getExpiredGnxList(): Thenable&lt;string[]&gt; {
    return this.refreshPossibleGnxList()
        .then(p_possibleGnxList =&gt; {
            const w_gnxToClose: string[] = [];
            this._openedBodiesGnx.forEach(p_openedGnx =&gt; {
                if (!p_possibleGnxList.includes(p_openedGnx)) {
                    w_gnxToClose.push(p_openedGnx);
                }
            });
            this.fireDeleteExpiredGnx(w_gnxToClose);
            return Promise.resolve(w_gnxToClose);
        });
}

</t>
<t tx="ekr.20200704142236.38">public watch(p_resource: vscode.Uri): vscode.Disposable {
    const w_gnx = utils.leoUriToStr(p_resource);
    if (!this._openedBodiesGnx.includes(w_gnx)) {
        this._openedBodiesGnx.push(w_gnx); // add gnx
    }
    return new vscode.Disposable(() =&gt; {
        const w_position = this._openedBodiesGnx.indexOf(w_gnx); // find and remove it
        if (w_position &gt; -1) {
            this._openedBodiesGnx.splice(w_position, 1);
        }
    });
}

</t>
<t tx="ekr.20200704142236.39">public fireDeleteExpiredGnx(p_gnxList: string[]): void {
    p_gnxList.forEach(p_gnx =&gt; {
        const w_uri: vscode.Uri = utils.strToLeoUri(p_gnx);
        this._fireSoon({ uri: w_uri, type: vscode.FileChangeType.Deleted });
    });
}

</t>
<t tx="ekr.20200704142236.4">/**
 * * Front-facing, user command stack of actions. Actions can also be added once started resolving.
 */
export class CommandStack {

    private _stack: UserCommand[] = [];
    private _busy: boolean = false;

    private _finalRefreshType: RefreshType = RefreshType.NoRefresh; // Refresh type after last command is done. (Keep only if higher)
    private _finalFromOutline: boolean = false; // Set focus on outline instead of body? (Keep from last one pushed)

    // * Received selection from the last command that finished.
    // * Note: JSON string representation of a node, will be re-sent as node to leo instead of lastSelectedNode
    private _receivedSelection: string = ""; // Selected node that was received from last command from a running stack. Empty string is used as 'false'.

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._busy = false;
    }

    @others
}
</t>
<t tx="ekr.20200704142236.40">public stat(p_uri: vscode.Uri): vscode.FileStat | Thenable&lt;vscode.FileStat&gt; {
    // TODO : Fix extraneous stat(...) call(s)
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            // console.log('called stat on root');
            return { type: vscode.FileType.Directory, ctime: 0, mtime: 0, size: 0 };
        } else if (utils.leoUriToStr(p_uri) === this._lastGnx) {
            // If same as last checked, sending back time at absolute past
            return {
                type: vscode.FileType.File,
                ctime: 0,
                mtime: 0, // this._selectedBody.mtime, // IF this._selectedBody.mtime we get file changed on disk error!!
                size: this._lastGnxBodyLength
            };
        } else {
            const w_gnx = utils.leoUriToStr(p_uri);
            if (false &amp;&amp; this._selectedBody.gnx !== w_gnx &amp;&amp; this._renameBody.gnx !== w_gnx) {
                // ! TEST IF NEEDED !
                console.log('ERROR File not in list selected: ' + this._selectedBody.gnx +
                    " renamed: " + this._renameBody.gnx +
                    " stat asked on w_gnx: " + w_gnx);
                throw vscode.FileSystemError.FileNotFound();
            } else {
                return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BODY_LENGTH, '"' + w_gnx + '"')
                    .then((p_result) =&gt; {
                        let w_mtime: number = 0;
                        if (this._renameBody.gnx === w_gnx) {
                            w_mtime = this._renameBody.mtime;
                        } else {
                            w_mtime = this._selectedBody.mtime;
                        }
                        return Promise.resolve(
                            {
                                type: vscode.FileType.File,
                                ctime: 0,
                                mtime: w_mtime,
                                size: p_result.bodyLength ? p_result.bodyLength : 0
                            }
                        );
                    });
            }
        }
    } else {
        throw vscode.FileSystemError.FileNotFound(); // console.log("not ready");
    }
}

</t>
<t tx="ekr.20200704142236.41">public readFile(p_uri: vscode.Uri): Thenable&lt;Uint8Array&gt; {
    if (this._leoIntegration.leoStates.fileOpenedReady) {
        if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
            throw vscode.FileSystemError.FileIsADirectory();
        } else {
            const w_gnx = utils.leoUriToStr(p_uri);
            // if (!this._possibleGnxList.includes(w_gnx)) {
            if (this._selectedBody.gnx !== w_gnx &amp;&amp; this._renameBody.gnx !== w_gnx) {
                console.error("readFile: ERROR File not in list! readFile missing refreshes?");
                throw vscode.FileSystemError.FileNotFound();
            } else {
                return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BODY, '"' + w_gnx + '"')
                    .then((p_result) =&gt; {
                        if (p_result.bodyData) {
                            this._lastGnx = w_gnx;
                            this._lastBodyData = p_result.bodyData;
                            this._lastGnxBodyLength = p_result.bodyData.length;
                            return Promise.resolve(Buffer.from(p_result.bodyData));
                        } else if (p_result.bodyData === "") {
                            this._lastGnx = w_gnx;
                            this._lastGnxBodyLength = 0;
                            this._lastBodyData = "";
                            return Promise.resolve(Buffer.from(""));
                        } else {
                            if (this._lastGnx === w_gnx) {
                                // was last gnx of closed file about to be switched to new document selected
                                console.log('Passed in not found: ' + w_gnx);

                                return Promise.resolve(Buffer.from(this._lastBodyData));
                            }
                            console.error("ERROR =&gt; readFile of unknown GNX"); // is possibleGnxList updated correctly?
                            return Promise.resolve(Buffer.from(""));
                            //  throw vscode.FileSystemError.FileNotFound();
                        }
                    });
            }
        }
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="ekr.20200704142236.42">public readDirectory(p_uri: vscode.Uri): Thenable&lt;[string, vscode.FileType][]&gt; {
    if (p_uri.fsPath.length === 1) { // p_uri.fsPath === '/' || p_uri.fsPath === '\\'
        const w_directory: [string, vscode.FileType][] = [];
        w_directory.push([this._selectedBody.gnx, vscode.FileType.File]);
        return Promise.resolve(w_directory);
    } else {
        throw vscode.FileSystemError.FileNotFound();
    }
}

</t>
<t tx="ekr.20200704142236.43">public createDirectory(p_uri: vscode.Uri): void {
    console.warn('Called createDirectory with ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

</t>
<t tx="ekr.20200704142236.44">public writeFile(p_uri: vscode.Uri, p_content: Uint8Array, p_options: { create: boolean, overwrite: boolean }): void {
    this._leoIntegration.triggerBodySave(true);
    const w_gnx = utils.leoUriToStr(p_uri);
    const w_now = Date.now();
    if (this._selectedBody.gnx === w_gnx) {
        this._selectedBody.mtime = w_now;
    }
    if (this._renameBody.gnx === w_gnx) {
        this._renameBody.mtime = w_now;
    }
    this._fireSoon({ type: vscode.FileChangeType.Changed, uri: p_uri });
}

</t>
<t tx="ekr.20200704142236.45">public rename(p_oldUri: vscode.Uri, p_newUri: vscode.Uri, p_options: { overwrite: boolean }): void {
    const w_gnx = utils.leoUriToStr(p_newUri);
    if (this._selectedBody.gnx === w_gnx) {
        this._selectedBody.mtime = Date.now();
    }
    if (this._renameBody.gnx === w_gnx) {
        this._renameBody.mtime = Date.now();
    }
    this._fireSoon(
        { type: vscode.FileChangeType.Deleted, uri: p_oldUri },
        { type: vscode.FileChangeType.Created, uri: p_newUri }
    );
}

</t>
<t tx="ekr.20200704142236.46">public delete(uri: vscode.Uri): void {
    let w_dirname = uri.with({ path: path.posix.dirname(uri.path) }); // dirname is just a slash "/"
    this._fireSoon({ type: vscode.FileChangeType.Changed, uri: w_dirname }, { uri, type: vscode.FileChangeType.Deleted });
}

</t>
<t tx="ekr.20200704142236.47">public copy(p_uri: vscode.Uri): void {
    console.warn('Called copy on ', p_uri.fsPath); // should not happen
    throw vscode.FileSystemError.NoPermissions();
}

private _emitter = new vscode.EventEmitter&lt;vscode.FileChangeEvent[]&gt;();
private _bufferedEvents: vscode.FileChangeEvent[] = [];
private _fireSoonHandle?: NodeJS.Timer;

</t>
<t tx="ekr.20200704142236.48">private _fireSoon(...p_events: vscode.FileChangeEvent[]): void {
    this._bufferedEvents.push(...p_events);
    if (this._fireSoonHandle) {
        clearTimeout(this._fireSoonHandle);
    }
    this._fireSoonHandle = setTimeout(() =&gt; {
        this._emitter.fire(this._bufferedEvents);
        this._bufferedEvents.length = 0; // clearing events array
    }, 5);
}
</t>
<t tx="ekr.20200704142236.49">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import * as WebSocket from 'ws';
import { Constants } from "./constants";
import { LeoBridgePackage, LeoAction } from "./types";
import { LeoIntegration } from "./leoIntegration";
import { LeoAsync } from "./leoAsync";

/**
 * * Handles communication with the leobridgeserver.py python script via websockets
 */
@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142236.5">/**
 * * Get command stack size
 * @returns the number of actions on the command stack
 */
public size(): number {
    return this._stack.length;
}

</t>
<t tx="ekr.20200704142236.50">export class LeoBridge {

    private _actionBusy: boolean = false; // A busy state meaning an action was started from the bottom but has yet to resolve

    private _leoBridgeSerialId: number = 0; // TODO : When doing error checking, see if this should be Constants.STARTING_PACKAGE_ID or 0 or 2... ?
    private _callStack: LeoAction[] = [];
    private _readyPromise: Promise&lt;LeoBridgePackage&gt; | undefined;

    // private _hasbin = require('hasbin'); // TODO : #10 @boltex See if this can help with anaconda/miniconda issues
    private _websocket: WebSocket | null = null;
    private _leoAsync: LeoAsync;

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._leoAsync = new LeoAsync(_context, _leoIntegration);
    }

    /**
     * * Places an action on top of a stack, to be resolved from the bottom
     * @param p_action Command string to be performed by Leo via leobridgeserver.py
     * @param p_jsonParam Optional JSON parameter for the specified action
     * @param p_deferredPayload Used to build this._readyPromise that resolves itself at startup
     * @param p_preventCall Flag for special action used to build this._readyPromise that resolves itself at startup
     * @returns a Promise that will contain the JSON package answered back by leobridgeserver.py
     */
    @others
}
</t>
<t tx="ekr.20200704142236.51">public action(p_action: string, p_jsonParam = "null", p_deferredPayload?: LeoBridgePackage, p_preventCall?: boolean): Promise&lt;LeoBridgePackage&gt; {
    return new Promise((resolve, reject) =&gt; {
        const w_action: LeoAction = {
            parameter: this._buildActionParameter(p_action, p_jsonParam),
            deferredPayload: p_deferredPayload ? p_deferredPayload : undefined,
            resolveFn: resolve,
            rejectFn: reject
        };

        this._callStack.push(w_action);
        if (!p_preventCall) {
            this._callAction();
        }
    });
}

/**
 * * Actions invoked by Leo that can be called asynchronously at any time
 * @param w_parsedData Object that contains an 'async' string member that was parsed from a _websocket.onmessage JSON package
 */
</t>
<t tx="ekr.20200704142236.52">private _asyncAction(w_parsedData: any): void {
    if (w_parsedData &amp;&amp; w_parsedData.async &amp;&amp; (typeof w_parsedData.async === "string")) {
        switch (w_parsedData.async) {
            case Constants.ASYNC_ACTIONS.ASYNC_LOG: {
                this._leoAsync.log(w_parsedData.log);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_ASK: {
                this._leoAsync.showAskModalDialog(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_WARN: {
                this._leoAsync.showWarnModalMessage(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_INFO: {
                this._leoAsync.showChangesDetectedInfoMessage(w_parsedData);
                break;
            }
            case Constants.ASYNC_ACTIONS.ASYNC_INTERVAL: {
                console.log("interval ", w_parsedData); // 'ping' interval for debugging
                break;
            }
            default: {
                console.error("[leoIntegration] Unknown async action ", w_parsedData);
                break;
            }
        }
    } else {
        console.error("[leoIntegration] Unknown async command from leoBridge");
    }
}

/**
 * * Build JSON string for action parameter to the leoBridge
 * @param p_action Action string to be invoked as command by Leo in the leobridgeserver.py script
 * @param p_jsonParam Optional JSON string to be added as a 'param' to the action sent to Leo
 */
</t>
<t tx="ekr.20200704142236.53">private _buildActionParameter(p_action: string, p_jsonParam?: string): string {
    return "{\"id\":" + (++this._leoBridgeSerialId) + // no quotes, serial id is a number, pre incremented
        ", \"action\": \"" + p_action +  // action is string so surround with quotes
        "\", \"param\":" + p_jsonParam +  // param is already json, no need for added quotes
        "}";
}

/**
 * * Resolves promises with the answers from an action that was finished
 * @param p_object Parsed data that was given as the answer by the Leo command that finished
 */
</t>
<t tx="ekr.20200704142236.54">private _resolveBridgeReady(p_object: string) {
    let w_bottomAction = this._callStack.shift();
    if (w_bottomAction) {
        if (w_bottomAction.deferredPayload) {
            // Used when the action already has a return value ready but is also waiting for python's side
            w_bottomAction.resolveFn(w_bottomAction.deferredPayload); // given back 'as is'
        } else {
            w_bottomAction.resolveFn(p_object);
        }
        this._actionBusy = false;
    } else {
        console.error("[leoBridge] Error stack empty");
    }
}

/**
 * * Rejects an action from the bottom of the stack
 * @param p_reason Given rejection 'reason'
 */
</t>
<t tx="ekr.20200704142236.55">private _rejectAction(p_reason: string): void {
    const w_bottomAction = this._callStack.shift();
    if (w_bottomAction) {
        w_bottomAction.rejectFn(p_reason);
    }
}

/**
 * * Sends an action from the bottom of the stack
 */
</t>
<t tx="ekr.20200704142236.56">private _callAction(): void {
    if (this._callStack.length &amp;&amp; !this._actionBusy) {
        this._actionBusy = true; // launch / resolve bottom one
        const w_action = this._callStack[0];
        this._send(w_action.parameter + "\n");
    }
}

/**
 * * JSON.parse encased in a Try/Catch block
 * @param p_jsonStr The JSON string to be parsed
 * @returns The resulting object or 'false' if unsuccessful
 */
</t>
<t tx="ekr.20200704142236.57">private _tryParseJSON(p_jsonStr: string): boolean | any {
    try {
        var w_object = JSON.parse(p_jsonStr);
        // JSON.parse(null) returns null, and typeof null === "object", null is falsy, so this suffices:
        if (w_object &amp;&amp; typeof w_object === "object") {
            return w_object;
        }
    }
    @others
}

/**
 * * Process data that came from the Leo process
 * @param p_data given JSON data
 */
</t>
<t tx="ekr.20200704142236.58">catch (e) {
    console.error('[leoBridge] JSON was invalid: ' + p_jsonStr);
}
return false;
</t>
<t tx="ekr.20200704142236.59">private _processAnswer(p_data: string): void {
    const w_parsedData = this._tryParseJSON(p_data);
    if (w_parsedData &amp;&amp; w_parsedData.id) {
        this._resolveBridgeReady(w_parsedData);
        this._callAction();
    } else if (w_parsedData &amp;&amp; w_parsedData.async) {
        // * Check for async messages such as log pane entries or other
        this._asyncAction(w_parsedData);
    } else {
        // unprocessed/unknown python output
        console.error("[leoBridge] Unprocessed or unknown JSON received: ", p_data);
    }
}

/**
 * * Spawn a websocket
 * @returns A promise for a LeoBridgePackage object containing only an 'id' member of 1 that will resolve when the 'leoBridge' is established
 */
</t>
<t tx="ekr.20200704142236.6">/**
 * * Signal to the command stack that a new selected node was received in case it needed to know when to clear its own '_receivedSelection'
 */
public newSelection(): void {
    if (!this._busy) {
        this._receivedSelection = "";
    }
}

</t>
<t tx="ekr.20200704142236.60">public initLeoProcess(): Promise&lt;LeoBridgePackage&gt; {
    this._websocket = new WebSocket(Constants.TCPIP_DEFAULT_PROTOCOL +
        this._leoIntegration.config.connectionAddress +
        ":" + this._leoIntegration.config.connectionPort);
    // * Capture the python process output
    this._websocket.onmessage = (p_event) =&gt; {
        if (p_event.data) {
            this._processAnswer(p_event.data.toString());
        }
    };
    this._websocket.onerror = (p_event: WebSocket.ErrorEvent) =&gt; {
        console.error(`Websocket error: ${p_event.message}`);
    };
    this._websocket.onclose = (p_event: WebSocket.CloseEvent) =&gt; {
        // * Disconnected from server
        console.log(`Websocket closed, code: ${p_event.code}`);
        this._rejectAction(`Websocket closed, code: ${p_event.code}`);
        // TODO : Implement a better connection error handling
        if (this._leoIntegration.leoStates.leoBridgeReady) {
            this._leoIntegration.cancelConnect(`Websocket closed, code: ${p_event.code}`);
        }
    };
    // * Start first with 'preventCall' set to true: no need to call anything for the first 'ready'
    this._readyPromise = this.action("", "", { id: Constants.STARTING_PACKAGE_ID }, true);
    return this._readyPromise; // This promise will resolve when the started python process starts
}

/**
 * * Send into the python process input
 * @param p_data JSON Message string to be sent to leobridgeserver.py
 */
</t>
<t tx="ekr.20200704142236.61">private _send(p_data: string): any {
    if (this._readyPromise) {
        this._readyPromise.then(() =&gt; { // using '.then' that was surely resolved already: to be buffered in case process isn't ready.
            if (this._websocket &amp;&amp; this._websocket.OPEN) {
                this._websocket.send(p_data); // p_message should be json
            }
        });
    }
}
</t>
<t tx="ekr.20200704142236.62">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoDocument, Icon } from "./types";
import * as utils from "./utils";
import { LeoIntegration } from "./leoIntegration";

/**
 * * Opened Leo documents tree view node item implementation for usage in a TreeDataProvider
 */
@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142236.63">export class LeoDocumentNode extends vscode.TreeItem {

    public contextValue: string; // * Context string is checked in package.json with 'when' clauses

    constructor(
        public documentEntry: LeoDocument,
        private _leoIntegration: LeoIntegration
    ) {
        super(documentEntry.name);
        // * Setup this instance
        const w_isNamed: boolean = !!this.documentEntry.name;
        this.label = w_isNamed ? utils.getFileFromPath(this.documentEntry.name) : Constants.UNTITLED_FILE_NAME;
        this.tooltip = w_isNamed ? this.documentEntry.name : Constants.UNTITLED_FILE_NAME;
        this.command = {
            command: Constants.NAME + "." + Constants.COMMANDS.SET_OPENED_FILE,
            title: '',
            arguments: [this.documentEntry.index]
        };
        // If this was created as a selected node, make sure it's selected as we may have opened/closed document
        if (this.documentEntry.selected) {
            this._leoIntegration.setDocumentSelection(this);
            this.contextValue = w_isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_SELECTED_UNTITLED;
        } else {
            this.contextValue = w_isNamed ? Constants.CONTEXT_FLAGS.DOCUMENT_TITLED : Constants.CONTEXT_FLAGS.DOCUMENT_UNTITLED;
        }
    }

    public get iconPath(): Icon {
        return this._leoIntegration.documentIcons[this.documentEntry.changed ? 1 : 0];
    }

    public get id(): string {
        // Add prefix and suffix salt to numeric index prevent accidental duplicates
        return "p" + this.documentEntry.index + "s" + this.documentEntry.name;
    }
}
</t>
<t tx="ekr.20200704142236.64">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoDocumentNode } from "./leoDocumentNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoDocument } from "./types";

/**
 * * Opened Leo documents shown as a list with this TreeDataProvider implementation
 */
@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142236.65">export class LeoDocumentsProvider implements vscode.TreeDataProvider&lt;LeoDocumentNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoDocumentNode | undefined&gt; = new vscode.EventEmitter&lt;LeoDocumentNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoDocumentNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    /**
     * * Refresh the whole outline
     */
    @others
}
</t>
<t tx="ekr.20200704142236.66">public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="ekr.20200704142236.67">public getTreeItem(element: LeoDocumentNode): Thenable&lt;LeoDocumentNode&gt; | LeoDocumentNode {
    return element;
}

</t>
<t tx="ekr.20200704142236.68">public getChildren(element?: LeoDocumentNode): Thenable&lt;LeoDocumentNode[]&gt; {

    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

        // call action to get get list, and convert to LeoDocumentNode(s) array
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_OPENED_FILES).then(p_package =&gt; {
            if (p_package &amp;&amp; p_package) {
                const w_list: LeoDocumentNode[] = [];
                const w_files: LeoDocument[] = p_package.openedFiles!.files;

                let w_index: number = 0;

                if (w_files &amp;&amp; w_files.length) {
                    w_files.forEach((i_file: LeoDocument) =&gt; {
                        w_list.push(new LeoDocumentNode(i_file, this._leoIntegration));
                        w_index++;
                    });
                }

                return Promise.resolve(w_list);
            } else {
                return Promise.resolve([]);
            }
        });
    } else {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
}

</t>
<t tx="ekr.20200704142236.69">public getParent(element: LeoDocumentNode): ProviderResult&lt;LeoDocumentNode&gt; | null {
    return null; // A list, as such, entries are always child of root, so return null
}
</t>
<t tx="ekr.20200704142236.7">/**
 * * Adds on top and try to execute the bottom command if not already running
 * @param p_command a userCommand object about the action, the node if any, refresh type and fromOutline flag
 * @returns true if added, false if it could not due to stack 'rules': Targeted command (specified node) can only be added on an empty stack
 */
public add(p_command: UserCommand): boolean {
    if (this.size() &amp;&amp; p_command.node) {
        // If already started we only if if action requires generic selected node as param
        return false;
    } else {
        this._stack.push(p_command);
        // This flag is set on command entered, not when finally executed because a rapid type in editor can override focus
        this._finalFromOutline = p_command.fromOutline; // use the last _finalFromOutline regardless of previous so change now
        this._tryStart();
        return true;
    }
}

</t>
<t tx="ekr.20200704142236.70">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import { Constants } from "./constants";
import * as path from "path"; // TODO : Use this library to have reliable support for window-vs-linux file-paths

/**
 * * Handles opening of file browser when choosing which Leo file to open
 */
@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142236.71">export class LeoFilesBrowser {

    private _fileBrowserActive: boolean = false;

    constructor(private _context: vscode.ExtensionContext) { }

    /**
     * * Find a folder to propose when opening the browse-for-leo-file chooser
     * @returns An Uri for path to a folder for initial opening
     */
    @others
}
</t>
<t tx="ekr.20200704142236.72">private _getBestOpenFolderUri(): vscode.Uri {
    let w_openedFileEnvUri: vscode.Uri | boolean = false;
    let w_activeUri: vscode.Uri | undefined = undefined;

    if (vscode.workspace.workspaceFolders &amp;&amp; vscode.workspace.workspaceFolders[0]) {
        w_activeUri = vscode.workspace.workspaceFolders[0].uri;
    }

    if (w_activeUri) {
        const w_defaultFolder = vscode.workspace.getWorkspaceFolder(w_activeUri);
        if (w_defaultFolder) {
            w_openedFileEnvUri = w_defaultFolder.uri; // Set as current opened document-path's folder
        }
    }
    if (!w_openedFileEnvUri) {
        w_openedFileEnvUri = vscode.Uri.file("~"); // TODO : set as home folder properly, this doesn't work
        // ! EXAMPLE WITH os : const homedir = require('os').homedir();
    }
    return w_openedFileEnvUri;
}

/**
 * * Open a file browser and let the user choose a Leo file or cancel the operation
 * @param p_saveAsFlag Optional, a flag that will ask for a 'save' path+filename.
 * @returns a promise resolving to a chosen path string, or rejected with an empty string if cancelled
 */
</t>
<t tx="ekr.20200704142236.73">public getLeoFileUrl(p_saveAsFlag?: boolean): Promise&lt;string&gt; {
    if (this._fileBrowserActive) {
        return Promise.resolve("");
    }
    this._fileBrowserActive = true;
    return new Promise((resolve, reject) =&gt; {
        const w_filters: { [name: string]: string[] } = {};
        w_filters[Constants.FILE_OPEN_FILTER_MESSAGE] = [Constants.FILE_EXTENSION];

        if (p_saveAsFlag) {
            // Choose file
            vscode.window.showSaveDialog({
                saveLabel: "Save Leo File",
                defaultUri: this._getBestOpenFolderUri(),
                filters: { 'Leo File': ['leo'] }
            })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // single string
                        resolve(p_chosenLeoFile.fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                    } else {
                        reject("");
                    }
                });
        } else {
            vscode.window
                .showOpenDialog({
                    canSelectMany: false,
                    defaultUri: this._getBestOpenFolderUri(),
                    filters: w_filters
                })
                .then(p_chosenLeoFile =&gt; {
                    this._fileBrowserActive = false;
                    if (p_chosenLeoFile) {
                        // array instead of single string
                        resolve(p_chosenLeoFile[0].fsPath.replace(/\\/g, "/")); // Replace backslashes for windows support
                    } else {
                        reject("");
                    }
                });
        }
    });
}
</t>
<t tx="ekr.20200704142236.8">/**
 * * Try to launch commands that were added on the stack if any
 */
private _tryStart(): void {
    if (this.size() &amp;&amp; !this._busy) {

        // actions have beed added and command stack instance is not busy, so set the busy flag and start from the bottom
        this._busy = true; // Cleared when the last command has returned (and the stack is empty)

        this._runStackCommand().then((p_package: LeoBridgePackage) =&gt; {
            this._resolveResult(p_package);
        });
    }
}

</t>
<t tx="ekr.20200704142236.9">/**
 * * Run the command at the index 0, the bottom of the stack
 */
private _runStackCommand(): Promise&lt;LeoBridgePackage&gt; {
    // console.log('Running from a stack of', this._stack.length);

    const w_command = this._stack[0]; // Reference from bottom of stack, don't remove yet

    // Build parameter's json here - use providedHeadline if needed
    let w_nodeJson: string = ""; // ap json used in building w_jsonParam
    let w_jsonParam: string = ""; // Finished parameter that is sent

    // First one uses given node or last selected node, other subsequent on stack will use _receivedSelection
    // (Commands such as 'collapse all' will just ignore passed on node parameter)
    const w_providedHeadline = w_command.providedHeadline; // Can be undefined
    if (w_command.node) {
        // console.log('USING SPECIFIC Node');

        w_nodeJson = w_command.node.apJson; // Was node specific, so we are starting from a new stack of commands
    } else {
        // Use received "selected node" unless first, then use last selected node
        // console.log(`NOT SPECIFIC node, busy is ${this._busy}`);

        if (this._receivedSelection) {
            // console.log('USING LAST _receivedSelection, SHOULD SEE NEXT ABOVE!');

            w_nodeJson = this._receivedSelection;
        } else {
            // console.log('USING LAST lastSelectedNode');

            w_nodeJson = this._leoIntegration.lastSelectedNode!.apJson;
        }
        if (!w_nodeJson) {
            console.log('ERROR NO ARCHIVED POSITION JSON');
        }
    }
    if (w_providedHeadline) {
        w_jsonParam = utils.buildNodeAndTextJson(w_nodeJson, w_providedHeadline); // 'Insert Named Node' or 'Edit Headline'
    } else {
        w_jsonParam = w_nodeJson; // 'Insert Unnamed Node' or regular command
    }

    // Setup _finalRefreshType, if higher than the one setup so far
    this._finalRefreshType = w_command.refreshType &gt; this._finalRefreshType ? w_command.refreshType : this._finalRefreshType;

    // Submit this action to Leo and return a promise of its packaged answer
    return this._leoIntegration.sendAction(w_command.action, w_jsonParam);
}

</t>
<t tx="ekr.20200704142237.1">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import { debounce } from "debounce";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoBridgePackage, RevealType, ArchivedPosition, Icon, ConfigMembers, RefreshType, ChooseDocumentItem, LeoDocument } from "./types";
import { Config } from "./config";
import { LeoFilesBrowser } from "./leoFileBrowser";
import { LeoNode } from "./leoNode";
import { LeoOutlineProvider } from "./leoOutline";
import { LeoBodyProvider } from "./leoBody";
import { LeoBridge } from "./leoBridge";
import { ServerService } from "./serverManager";
import { LeoStatusBar } from "./leoStatusBar";
import { CommandStack } from "./commandStack";
import { LeoDocumentsProvider } from "./leoDocuments";
import { LeoDocumentNode } from "./leoDocumentNode";
import { LeoStates } from "./leoStates";
import { LeoButtonsProvider } from "./leoButtons";
import { LeoButtonNode } from "./leoButtonNode";

/**
 * * Orchestrates Leo integration into vscode with treeview and file system providers
 */
@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142237.10">/**
 * * Adds a message string to leoInteg's log pane. Used when leoBridge receives an async 'log' command.
 * @param p_message The string to be added in the log
 */
public addLogPaneEntry(p_message: string): void {
    this._leoLogPane.appendLine(p_message);
}

</t>
<t tx="ekr.20200704142237.100">/**
 * * Parameter structure for non-blocking info message about detected file changes
 */
export interface runInfoMessageDialogParameters {
    "message": string;
}

</t>
<t tx="ekr.20200704142237.101">/**
 * * Used in showAskModalDialog to get answer from user interaction
 */
export interface AskMessageItem extends vscode.MessageItem {
    value: string;
}

</t>
<t tx="ekr.20200704142237.102">/**
 * * Used in switch Leo document to get answer from user interaction
 */
export interface ChooseDocumentItem extends vscode.QuickPickItem {
    value: number;
}
</t>
<t tx="ekr.20200704142237.103">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import { Constants } from "./constants";
import { Icon } from "./types";
import { LeoNode } from "./leoNode";

// * String and other types/structures helper functions, along with common vscode API calls

/**
 * * Build a string for representing a number that's 2 digits wide, padding with a zero if needed
 * @param p_number Between 0 and 99
 * @returns a 2 digit wide string representation of the number, left padded with zeros as needed.
 */
@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142237.104">export function padNumber2(p_number: number): string {
    return ("0" + p_number).slice(-2);
}

/**
 * * Build all possible strings for node icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array of the 16 vscode node icons used in this vscode expansion
 */
</t>
<t tx="ekr.20200704142237.105">export function buildNodeIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return Array(16).fill("").map((p_val, p_index) =&gt; {
        return {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_PATH + padNumber2(p_index) + Constants.GUI.ICON_FILE_EXT)
        };
    });
}

/**
 * * Build all possible strings for documents icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
</t>
<t tx="ekr.20200704142237.106">export function buildDocumentIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_DOCUMENT),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_DOCUMENT)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_DOCUMENT_DIRTY),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_DOCUMENT_DIRTY)
        }
    ];
}

</t>
<t tx="ekr.20200704142237.107">/**
 * * Builds and returns a JSON string with 'node' and 'text' members
 * @param p_nodeJson Targeted tree node in the proper JSON format
 * @param p_text Desired text sent along with node in the parameters of the action to be 'called'
 * @returns JSON string suitable for being a parameter of a leoBridge action
 */
export function buildNodeAndTextJson(p_nodeJson: string, p_text: string): string {
    return "{\"node\":" + p_nodeJson +
        ", \"text\": " + JSON.stringify(p_text) +
        "}";
}

</t>
<t tx="ekr.20200704142237.108">/**
 * * Extracts the file name from a full path, such as "foo.bar" from "/abc/def/foo.bar"
 * @param p_path Full path such as "/var/drop/foo/boo/moo.js" or "C:\Documents and Settings\img\recycled log.jpg"
 * @returns file name string such as "moo.js" or "recycled log.jpg""
 */
export function getFileFromPath(p_path: string): string {
    return p_path.replace(/^.*[\\\/]/, '');
}

</t>
<t tx="ekr.20200704142237.109">/**
 * * Checks if a node would become dirty if it were to now have body content at all
 * @param p_node LeoNode from vscode's outline
 * @param p_newHasBody Flag to signify presence of body content, to be compared with its current state
 * @returns True if it would change the icon with actual body content, false otherwise
 */
export function isIconChangedByEdit(p_node: LeoNode, p_newHasBody: boolean): boolean {
    if (!p_node.dirty || (p_node.hasBody === !p_newHasBody)) {
        return true;
    }
    return false;
}

</t>
<t tx="ekr.20200704142237.11">/**
 * * Send configuration through leoBridge to the server script, mostly used when checking if refreshing derived files is optional.
 * @param p_config A config object containing all the configuration settings
 */
public sendConfigToServer(p_config: ConfigMembers): void {
    if (this.leoStates.fileOpenedReady) {
        this.sendAction(Constants.LEOBRIDGE.APPLY_CONFIG, JSON.stringify(p_config)).then(p_package =&gt; {
            // Back from applying configuration to leobridgeserver.py
        });
    }
}

</t>
<t tx="ekr.20200704142237.110">/**
 * * Checks if a string is formatted as a valid rrggbb color code.
 * @param p_hexString hexadecimal 6 digits string, without leading '0x'
 * @returns True if the string is a valid representation of an hexadecimal 6 digit number
 */
export function isHexColor(p_hexString: string): boolean {
    return typeof p_hexString === 'string'
        &amp;&amp; p_hexString.length === 6
        &amp;&amp; !isNaN(Number('0x' + p_hexString));
}

</t>
<t tx="ekr.20200704142237.111">/**
 * * Builds a 'Leo Scheme' vscode.Uri from a gnx (or strings like 'LEO BODY' or empty strings to decorate breadcrumbs)
 * @param p_str leo node gnx strings are used to build Uri
 * @returns A vscode 'Uri' object
 */
export function strToLeoUri(p_str: string): vscode.Uri {
    return vscode.Uri.parse(Constants.URI_SCHEME_HEADER + p_str);
}

</t>
<t tx="ekr.20200704142237.112">/**
 * * Gets the gnx, (or another string like 'LEO BODY' or other), from a vscode.Uri object
 * @param p_uri Source uri to extract from
 * @returns The string source that was used to build this Uri
 */
export function leoUriToStr(p_uri: vscode.Uri): string {
    // TODO : Use length of a constant or something other than 'fsPath'
    // For now, just remove the '/' (or backslash on Windows) before the path string
    return p_uri.fsPath.substr(1);
}

</t>
<t tx="ekr.20200704142237.113">/**
 * * Sets a vscode context variable with the 'vscode.commands.executeCommand' and 'setContext' method
 * @param p_key Key string name such as constants 'bridgeReady' or 'treeOpened', etc.
 * @param p_value Value to be assigned to the p_key 'key'
 * @returns A Thenable that was returned by the executeCommand call to set the context
 */
export function setContext(p_key: string, p_value: any): Thenable&lt;unknown&gt; {
    return vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.SET_CONTEXT, p_key, p_value);
}
</t>
<t tx="ekr.20200704142237.12">/**
 * * 'getStates' action for use in debounced method call
 */
private _triggerGetStates(): void {
    // Debounced timer has triggered so perform getStates action
    this._leoDocumentsProvider.refreshTreeRoot();
    this._leoButtonsProvider.refreshTreeRoot();
    this.sendAction(Constants.LEOBRIDGE.GET_STATES).then((p_package: LeoBridgePackage) =&gt; {
        if (p_package.states) {
            this.leoStates.leoStateFlags(p_package.states);
        }
    });
}

</t>
<t tx="ekr.20200704142237.13">/**
 * * Returns the 'busy' state flag of the command stack, while showing a message if it is.
 * Needed by special unstackable commands such as new, open,...
 */
private _isBusy(): boolean {
    if (this._commandStack.size()) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.TOO_FAST);
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="ekr.20200704142237.14">/**
 * * Returns true if the current opened Leo document's filename has some content. (not a new unnamed file)
 */
private _isCurrentFileNamed(): boolean {
    return !!this.leoStates.leoOpenedFileName.length; // checks if it's an empty string
}

</t>
<t tx="ekr.20200704142237.15">/**
 * * Setup leoInteg's UI for having no opened Leo documents
 */
private _setupNoOpenedLeoDocument(): void {
    this.leoStates.fileOpenedReady = false;
    this._bodyTextDocument = undefined;
    this.lastSelectedNode = undefined;
    this._refreshOutline(RevealType.RevealSelectFocus);
    this.closeBody();
}

</t>
<t tx="ekr.20200704142237.16">/**
 * * A Leo file was opened: setup leoInteg's UI accordingly.
 */
private _setupOpenedLeoDocument(p_openFileResult: any): Thenable&lt;vscode.TextEditor&gt; {
    const w_selectedLeoNode = this.apToLeoNode(p_openFileResult.node, false); // Just to get gnx for the body's fist appearance
    this.leoStates.leoOpenedFileName = p_openFileResult.filename;

    // * Could be already opened, so perform 'rename hack' as if another node was selected
    if (this._bodyTextDocument &amp;&amp; this.bodyUri) {
        this._switchBody(w_selectedLeoNode.gnx);
    } else {
        this.bodyUri = utils.strToLeoUri(w_selectedLeoNode.gnx);
    }

    // * Start body pane system
    if (!this._bodyFileSystemStarted) {
        this._context.subscriptions.push(
            vscode.workspace.registerFileSystemProvider(Constants.URI_SCHEME, this._leoFileSystem, { isCaseSensitive: true })
        );
        this._bodyFileSystemStarted = true;
    }
    // * Startup flag
    this.leoStates.fileOpenedReady = true;
    // * Maybe first valid redraw of tree along with the selected node and its body
    this._refreshOutline(RevealType.RevealSelectFocus); // p_revealSelection flag set
    // this.setTreeViewTitle(Constants.GUI.TREEVIEW_TITLE); // ? Maybe unused when used with welcome content
    // * Maybe first StatusBar appearance
    this._leoStatusBar.update(true, 0, true);
    this._leoStatusBar.show(); // Just selected a node
    // * Show leo log pane
    this.showLogPane();
    // * Send config to python's side (for settings such as defaultReloadIgnore and checkForChangeExternalFiles)
    this.sendConfigToServer(this.config.getConfig());
    // * Refresh Opened tree views
    this._leoDocumentsProvider.refreshTreeRoot();
    this._leoButtonsProvider.refreshTreeRoot();
    // * Maybe first Body appearance
    return this.showBody(false);
}

</t>
<t tx="ekr.20200704142237.17">/**
 * * Handles the change of vscode config: a onDidChangeConfiguration event triggered
 * @param p_event The configuration-change event passed by vscode
 */
private _onChangeConfiguration(p_event: vscode.ConfigurationChangeEvent): void {
    if (p_event.affectsConfiguration(Constants.CONFIG_NAME)) {
        this.config.buildFromSavedSettings();
    }
}

</t>
<t tx="ekr.20200704142237.18">/**
 * * Handles the node expanding and collapsing interactions by the user in the treeview
 * @param p_event The event passed by vscode
 * @param p_expand True if it was an expand, false if it was a collapse event
 * @param p_treeView Pointer to the treeview itself, either the standalone treeview or the one under the explorer
 */
private _onChangeCollapsedState(p_event: vscode.TreeViewExpansionEvent&lt;LeoNode&gt;, p_expand: boolean, p_treeView: vscode.TreeView&lt;LeoNode&gt;): void {
    // * Expanding or collapsing via the treeview interface selects the node to mimic Leo
    this.triggerBodySave(true);
    if (p_treeView.selection[0] &amp;&amp; p_treeView.selection[0] === p_event.element) {
        // * This happens if the tree selection is the same as the expanded/collapsed node: Just have Leo do the same
        this.sendAction(p_expand ? Constants.LEOBRIDGE.EXPAND_NODE : Constants.LEOBRIDGE.COLLAPSE_NODE, p_event.element.apJson);
    } else {
        // * This part only happens if the user clicked on the arrow without trying to select the node
        this._revealTreeViewNode(p_event.element, { select: true, focus: false }); // No force focus : it breaks collapse/expand when direct parent
        this.selectTreeNode(p_event.element, true);  // not waiting for a .then(...) so not to add any lag
        this.sendAction(p_expand ? Constants.LEOBRIDGE.EXPAND_NODE : Constants.LEOBRIDGE.COLLAPSE_NODE, p_event.element.apJson);
    }
}

</t>
<t tx="ekr.20200704142237.19">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flag to signify that the treeview who triggered this event is the one in the explorer view
 */
private _onTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_event.visible) {
        this._lastVisibleTreeView = p_explorerView ? this._leoTreeExplorerView : this._leoTreeStandaloneView;
        this.setTreeViewTitle();
        this._needLastSelectedRefresh = true; // Its a new node in a new tree so refresh lastSelectedNode too
        this._refreshOutline(RevealType.RevealSelect);
    }
}

</t>
<t tx="ekr.20200704142237.2">@language typescript
export class LeoIntegration {

    // * Status Flags
    private _leoIsConnecting: boolean = false; // Used in connect method to prevent other attempts while trying
    private _leoBridgeReadyPromise: Promise&lt;LeoBridgePackage&gt; | undefined; // Set when leoBridge has a leo controller ready
    private _currentOutlineTitle: string = Constants.GUI.TREEVIEW_TITLE_INTEGRATION; // Title has to be kept because it might need to be set (again) when either tree is first shown when switching visibility

    // * State flags
    public leoStates: LeoStates;

    // * Frontend command stack
    private _commandStack: CommandStack;

    // * Configuration Settings Service
    public config: Config; // Public configuration service singleton, used in leoSettingsWebview, leoBridge, and leoNode for inverted contrast

    // * Icon Paths
    public nodeIcons: Icon[] = []; // Singleton static array of all icon paths used in leoNodes for rendering in treeview
    public documentIcons: Icon[] = [];
    public buttonIcons: Icon[] = [];

    // * File Browser
    private _leoFilesBrowser: LeoFilesBrowser; // Browsing dialog service singleton used in the openLeoFile and save-as methods

    // * LeoBridge
    private _leoBridge: LeoBridge; // Singleton service to access leobridgeserver

    // * Outline Pane
    private _leoTreeDataProvider: LeoOutlineProvider; // TreeDataProvider single instance
    private _leoTreeStandaloneView: vscode.TreeView&lt;LeoNode&gt;; // Outline tree view added to the Tree View Container with an Activity Bar icon
    private _leoTreeExplorerView: vscode.TreeView&lt;LeoNode&gt;; // Outline tree view added to the Explorer Sidebar
    private _lastVisibleTreeView: vscode.TreeView&lt;LeoNode&gt;; // Outline tree view added to the Explorer Sidebar
    private _nextNodeId: number = Constants.STARTING_PACKAGE_ID; // Used to generate id's for new treeNodes: The id is used to preserve or set the selection and expansion states

    private _lastSelectedNode: LeoNode | undefined; // Last selected node we got a hold of; leoTreeView.selection maybe newer and unprocessed
    get lastSelectedNode(): LeoNode | undefined { // TODO : REMOVE NEED FOR UNDEFINED SUB TYPE WITH _needLastSelectedRefresh
        return this._lastSelectedNode;
    }
    set lastSelectedNode(p_leoNode: LeoNode | undefined) {  // TODO : REMOVE NEED FOR UNDEFINED SUB TYPE WITH _needLastSelectedRefresh
        // console.log(`Setting Last Selected Node:${p_leoNode!.label}, with id: ${p_leoNode!.id}`);
        this._lastSelectedNode = p_leoNode;
        if (p_leoNode) {
            utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_leoNode.marked); // Global context to 'flag' the selected node's marked state
        }
    }

    // * Outline Pane redraw/refresh flags. Also set when calling refreshTreeRoot
    // If there's no reveal and its the selected node, the old id will be re-used for the node. (see _id property in LeoNode)
    private _revealType: RevealType = RevealType.NoReveal; // to be read/cleared in arrayToLeoNodesArray, to check if any should self-select
    private _preventShowBody = false; // Used when refreshing treeview from config: It requires not to open the body pane when refreshing.

    // * Documents Pane
    private _leoDocumentsProvider: LeoDocumentsProvider;
    private _leoDocuments: vscode.TreeView&lt;LeoDocumentNode&gt;;
    private _leoDocumentsExplorer: vscode.TreeView&lt;LeoDocumentNode&gt;;
    private _currentDocumentChanged: boolean = false; // if clean and an edit is done: refresh opened documents view

    // * Commands stack finishing resolving "refresh flags", for type of refresh after finishing stack
    private _needRefreshBody: boolean = false; // Flag for commands that might change current body
    private _fromOutline: boolean = false; // Last command issued had focus on outline, as opposed to the body
    private _focusInterrupt: boolean = false; // Flag for preventing setting focus when interrupting (canceling) an 'insert node' text input dialog with another one

    // * Body Pane
    private _bodyFileSystemStarted: boolean = false;
    private _leoFileSystem: LeoBodyProvider; // as per https://code.visualstudio.com/api/extension-guides/virtual-documents#file-system-api
    private _bodyTextDocument: vscode.TextDocument | undefined; // Set when selected in tree by user, or opening a Leo file in showBody. and by _locateOpenedBody.
    private _bodyMainSelectionColumn: vscode.ViewColumn | undefined; // Column of last body 'textEditor' found, set to 1

    private _bodyUri: vscode.Uri = utils.strToLeoUri("");
    get bodyUri(): vscode.Uri {
        return this._bodyUri;
    }
    set bodyUri(p_uri: vscode.Uri) {
        this._leoFileSystem.setBodyTime(p_uri);
        this._bodyUri = p_uri;
    }

    // * '@button' pane
    private _leoButtonsProvider: LeoButtonsProvider;
    private _leoButtons: vscode.TreeView&lt;LeoButtonNode&gt;;
    private _leoButtonsExplorer: vscode.TreeView&lt;LeoButtonNode&gt;;

    // * Log Pane
    private _leoLogPane: vscode.OutputChannel = vscode.window.createOutputChannel(Constants.GUI.LOG_PANE_TITLE);

    // * Terminal Pane
    private _leoTerminalPane: vscode.OutputChannel | undefined;

    // * Status Bar
    private _leoStatusBar: LeoStatusBar;

    // * Edit/Insert Headline Input Box options instance, setup so clicking outside cancels the headline change
    private _headlineInputOptions: vscode.InputBoxOptions = { ignoreFocusOut: false, value: "", valueSelection: undefined, prompt: "" };

    // * Automatic leobridgeserver startup management service
    private _serverService: ServerService;

    // * Timing
    private _needLastSelectedRefresh = false;
    private _bodyLastChangedDocument: vscode.TextDocument | undefined; // Only set in _onDocumentChanged

    // * Debounced method used to get states for UI display flags (commands such as undo, redo, save, ...)
    public getStates: (() =&gt; void) &amp; {
        clear(): void;
    } &amp; {
        flush(): void;
    };

    @others
}
</t>
<t tx="ekr.20200704142237.20">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flag to signify that the treeview who triggered this event is the one in the explorer view
 */
private _onDocTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_explorerView) {
        // (Facultative/unused) Do something different if explorer view is used, instead of the standalone outline pane
    }
    if (p_event.visible) {
        this._leoDocumentsProvider.refreshTreeRoot();
    }
}

</t>
<t tx="ekr.20200704142237.21">/**
 * * Handles detection of the active editor having changed from one to another, or closed
 * TODO : Make sure the selection in tree if highlighted when a body pane is selected
 * @param p_event The editor itself that is now active
 * @param p_internalCall Flag used to signify the it was called voluntarily by leoInteg itself
 */
private _onActiveEditorChanged(p_event: vscode.TextEditor | undefined, p_internalCall?: boolean): void {
    if (!p_internalCall) {
        this.triggerBodySave(true);// Save in case edits were pending
    }
    // * Status flag check
    if (!p_event &amp;&amp; this._leoStatusBar.statusBarFlag) {
        return;
    }
    // * Status flag check
    if (vscode.window.activeTextEditor) {
        this._leoStatusBar.update(vscode.window.activeTextEditor.document.uri.scheme === Constants.URI_SCHEME);
    }
}

</t>
<t tx="ekr.20200704142237.22">/**
 * * Triggers when a vscode window have gained or lost focus
 * @param p_event WindowState (focussed or not) event passed by vscode
 */
private _onChangeWindowState(p_event: vscode.WindowState): void {
    this.triggerBodySave(); // In case user is about to modify a derived file, we want to send possible edited body text to Leo
}

</t>
<t tx="ekr.20200704142237.23">/**
 * * Handle typing that was detected in a document
 * @param p_event Text changed event passed by vscode
 */
private _onDocumentChanged(p_event: vscode.TextDocumentChangeEvent): void {
    // ".length" check necessary, see https://github.com/microsoft/vscode/issues/50344
    if (p_event.contentChanges.length &amp;&amp; (p_event.document.uri.scheme === Constants.URI_SCHEME)) {

        // * There was an actual change on a Leo Body by the user
        this._bodyLastChangedDocument = p_event.document;
        this._fromOutline = false; // Focus is on body pane

        // * If icon should change then do it now (if there's no document edit pending)
        if (this.lastSelectedNode &amp;&amp; (!this._currentDocumentChanged || utils.leoUriToStr(p_event.document.uri) === this.lastSelectedNode.gnx)) {
            const w_hasBody = !!(p_event.document.getText().length);
            if (utils.isIconChangedByEdit(this.lastSelectedNode, w_hasBody)) {
                this._bodySaveDocument(p_event.document)
                    .then(() =&gt; {
                        this.lastSelectedNode!.dirty = true;
                        this.lastSelectedNode!.hasBody = w_hasBody;
                        this._refreshOutline(RevealType.NoReveal); // NoReveal for keeping the same id and selection
                    });
                return; // * Don't continue
            }
        }
    }
}

</t>
<t tx="ekr.20200704142237.24">/**
 * * Save body to Leo if its dirty. That is, only if a change has been made to the body 'document' so far
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 */
public triggerBodySave(p_forcedVsCodeSave?: boolean): Thenable&lt;boolean&gt; {
    // * Save body to Leo if a change has been made to the body 'document' so far
    if (this._bodyLastChangedDocument &amp;&amp; this._bodyLastChangedDocument.isDirty) {
        const w_document = this._bodyLastChangedDocument; // backup for bodySaveDocument before reset
        this._bodyLastChangedDocument = undefined; // reset to make falsy
        return this._bodySaveDocument(w_document, p_forcedVsCodeSave);
    } else {
        this._bodyLastChangedDocument = undefined;
        return Promise.resolve(true);
    }
}

</t>
<t tx="ekr.20200704142237.25">/**
 * * Sets new body text on leo's side, and may optionally save vsCode's body editor (which will trim spaces)
 * @param p_document Vscode's text document which content will be used to be the new node's body text in Leo
 * @param p_forcedVsCodeSave Flag to also have vscode 'save' the content of this editor through the filesystem
 */
private _bodySaveDocument(p_document: vscode.TextDocument, p_forcedVsCodeSave?: boolean): Thenable&lt;boolean&gt; {
    if (p_document) {
        // * Fetch gnx and document's body text first, to be reused more than once in this method
        const w_param = {
            gnx: utils.leoUriToStr(p_document.uri),
            body: p_document.getText()
        };
        return this.sendAction(Constants.LEOBRIDGE.SET_BODY, JSON.stringify(w_param)).then(() =&gt; {
            this.getStates();
            if (p_forcedVsCodeSave) {
                return p_document.save(); // ! USED INTENTIONALLY: This trims trailing spaces
            }
            return Promise.resolve(p_document.isDirty);
        });
    } else {
        return Promise.resolve(false);
    }
}

</t>
<t tx="ekr.20200704142237.28">/**
 * * Refreshes the outline. A reveal type can be passed along to specify the reveal type for the selected node
 * @param p_revealType Facultative reveal type to specify type of reveal when the 'selected node' is encountered
 */
private _refreshOutline(p_revealType?: RevealType): void {
    if (p_revealType !== undefined) { // To check if selected node should self-select while redrawing whole tree
        this._revealType = p_revealType; // To be read/cleared (in arrayToLeoNodesArray instead of directly by nodes)
    }
    // Force showing last used Leo outline first
    if (this._lastSelectedNode &amp;&amp; !(this._leoTreeExplorerView.visible || this._leoTreeStandaloneView.visible)) {
        this._lastVisibleTreeView.reveal(this._lastSelectedNode).then(() =&gt; {
            this._leoTreeDataProvider.refreshTreeRoot();
        });
    } else {
        this._leoTreeDataProvider.refreshTreeRoot();
    }
}

</t>
<t tx="ekr.20200704142237.29">/**
 * * Converts an archived position object to a LeoNode instance
 * @param p_ap The archived position to convert
 * @param p_revealSelected Flag that will trigger the node to reveal, select, and focus if its selected node in Leo
 * @param p_specificNode Other specific LeoNode to be used to override when revealing the the selected node is encountered
 */
public apToLeoNode(p_ap: ArchivedPosition, p_revealSelected?: boolean, p_specificNode?: LeoNode): LeoNode {
    // TODO : (CODE CLEANUP) p_revealSelected flag should be inverted, its rarely used by far
    let w_collapse: vscode.TreeItemCollapsibleState = vscode.TreeItemCollapsibleState.None;
    if (p_ap.hasChildren) {
        w_collapse = p_ap.expanded ? vscode.TreeItemCollapsibleState.Expanded : vscode.TreeItemCollapsibleState.Collapsed;
    }
    // * Unknown attributes are one-way read-only data, don't carry this in for string key for leo/python side of things
    let w_u = false;
    if (p_ap.u) {
        w_u = p_ap.u;
        delete p_ap.u;
    }
    const w_leoNode = new LeoNode(
        p_ap.headline,          // label-headline
        p_ap.gnx,               // gnx
        w_collapse,             // collapsibleState
        JSON.stringify(p_ap),   // string key for leo/python side of things
        p_ap.childIndex,        // childIndex
        !!p_ap.cloned,          // cloned
        !!p_ap.dirty,           // dirty
        !!p_ap.marked,          // marked
        !!p_ap.atFile,          // atFile
        !!p_ap.hasBody,         // hasBody
        w_u,                    // unknownAttributes
        this,                   // _leoIntegration pointer
        // If there's no reveal and its the selected node re-use the old id
        (!this._revealType &amp;&amp; p_ap.selected &amp;&amp; this.lastSelectedNode) ? this.lastSelectedNode.id : (++this._nextNodeId).toString()
    );
    if (p_revealSelected &amp;&amp; this._revealType &amp;&amp; p_ap.selected) {
        this._apToLeoNodeConvertReveal(p_specificNode ? p_specificNode : w_leoNode);
    }
    return w_leoNode;
}

</t>
<t tx="ekr.20200704142237.3">constructor(private _context: vscode.ExtensionContext) {
    // * Setup States
    this.leoStates = new LeoStates(_context, this);

    // * Get configuration settings
    this.config = new Config(_context, this);
    this.config.buildFromSavedSettings();

    // * Build Icon filename paths
    this.nodeIcons = utils.buildNodeIconPaths(_context);
    this.documentIcons = utils.buildDocumentIconPaths(_context);
    this.buttonIcons = utils.buildButtonsIconPaths(_context);

    // * File Browser
    this._leoFilesBrowser = new LeoFilesBrowser(_context);

    // * Setup leoBridge
    this._leoBridge = new LeoBridge(_context, this);

    // * Setup frontend command stack
    this._commandStack = new CommandStack(_context, this);

    // * Same data provider for both outline trees, Leo view and Explorer view
    this._leoTreeDataProvider = new LeoOutlineProvider(this);

    // * Leo view and Explorer view outline panes - Uses 'select node' command, so 'onDidChangeSelection' is not used
    this._leoTreeStandaloneView = vscode.window.createTreeView(Constants.TREEVIEW_ID, { showCollapseAll: false, treeDataProvider: this._leoTreeDataProvider });
    this._leoTreeStandaloneView.onDidExpandElement((p_event =&gt; this._onChangeCollapsedState(p_event, true, this._leoTreeStandaloneView)));
    this._leoTreeStandaloneView.onDidCollapseElement((p_event =&gt; this._onChangeCollapsedState(p_event, false, this._leoTreeStandaloneView)));
    this._leoTreeStandaloneView.onDidChangeVisibility((p_event =&gt; this._onTreeViewVisibilityChanged(p_event, false))); // * Trigger 'show tree in Leo's view'
    this._leoTreeExplorerView = vscode.window.createTreeView(Constants.TREEVIEW_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoTreeDataProvider });
    this._leoTreeExplorerView.onDidExpandElement((p_event =&gt; this._onChangeCollapsedState(p_event, true, this._leoTreeExplorerView)));
    this._leoTreeExplorerView.onDidCollapseElement((p_event =&gt; this._onChangeCollapsedState(p_event, false, this._leoTreeExplorerView)));
    this._leoTreeExplorerView.onDidChangeVisibility((p_event =&gt; this._onTreeViewVisibilityChanged(p_event, true))); // * Trigger 'show tree in explorer view'
    this._lastVisibleTreeView = this.config.treeInExplorer ? this._leoTreeExplorerView : this._leoTreeStandaloneView;

    // * Leo Opened Documents Treeview Providers and tree views
    this._leoDocumentsProvider = new LeoDocumentsProvider(this);
    this._leoDocuments = vscode.window.createTreeView(Constants.DOCUMENTS_ID, { showCollapseAll: false, treeDataProvider: this._leoDocumentsProvider });
    this._leoDocuments.onDidChangeVisibility((p_event =&gt; this._onDocTreeViewVisibilityChanged(p_event, false)));
    this._leoDocumentsExplorer = vscode.window.createTreeView(Constants.DOCUMENTS_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoDocumentsProvider });
    this._leoDocumentsExplorer.onDidChangeVisibility((p_event =&gt; this._onDocTreeViewVisibilityChanged(p_event, true)));

    // * '@buttons' Treeview Providers and tree views
    this._leoButtonsProvider = new LeoButtonsProvider(this);
    this._leoButtons = vscode.window.createTreeView(Constants.BUTTONS_ID, { showCollapseAll: false, treeDataProvider: this._leoButtonsProvider });
    this._leoButtons.onDidChangeVisibility((p_event =&gt; this._onButtonsTreeViewVisibilityChanged(p_event, false)));
    this._leoButtonsExplorer = vscode.window.createTreeView(Constants.BUTTONS_EXPLORER_ID, { showCollapseAll: false, treeDataProvider: this._leoButtonsProvider });
    this._leoButtonsExplorer.onDidChangeVisibility((p_event =&gt; this._onButtonsTreeViewVisibilityChanged(p_event, true)));

    // * Body Pane
    this._leoFileSystem = new LeoBodyProvider(this);
    this._bodyMainSelectionColumn = 1;

    // * Status bar: Show keyboard-Shortcut-Flag to signify Leo keyboard shortcuts are active
    this._leoStatusBar = new LeoStatusBar(_context, this);

    // * Automatic server start service
    this._serverService = new ServerService(_context, this);

    // * React to change in active panel/text editor (window.activeTextEditor) - also fires when the active editor becomes undefined
    vscode.window.onDidChangeActiveTextEditor(p_event =&gt; this._onActiveEditorChanged(p_event));

    // * The selection in an output panel or any other editor has changed
    // vscode.window.onDidChangeTextEditorSelection(p_event =&gt; this._onChangeEditorSelection(p_event)); // ! Not used for now

    // * The view column of an editor has changed (when shifting editors through closing/inserting editors or closing columns)
    // No effect when dragging editor tabs: it just closes and reopens in other column, see '_onChangeVisibleEditors'
    vscode.window.onDidChangeTextEditorViewColumn(() =&gt; this.triggerBodySave());

    // * Triggers when a different text editor in any column, either tab or body, is focused
    // This is also what triggers after drag and drop, see '_onChangeEditorViewColumn'
    vscode.window.onDidChangeVisibleTextEditors(() =&gt; this.triggerBodySave());

    // * Triggers when a vscode window have gained or lost focus
    vscode.window.onDidChangeWindowState(() =&gt; this.triggerBodySave());

    // * Edited and saved the document, does it on any document in editor
    // vscode.workspace.onDidSaveTextDocument(p_event =&gt; this._onDocumentSaved(p_event)); // ! Not used for now

    // * React when typing and changing body pane
    vscode.workspace.onDidChangeTextDocument(p_event =&gt; this._onDocumentChanged(p_event)); // * Detect when user types in body pane here

    // * React to configuration settings events
    vscode.workspace.onDidChangeConfiguration(p_event =&gt; this._onChangeConfiguration(p_event));

    // * Debounced refresh flags and UI parts, other than the tree and body, when operation(s) are done executing
    this.getStates = debounce(this._triggerGetStates, Constants.STATES_DEBOUNCE_DELAY);
}

</t>
<t tx="ekr.20200704142237.30">/**
 * * Reveals the node that was detected as being the selected one while converting from archived positions
 * Also select it, or focus on it too depending on global this._revealType variable
 * @param p_leoNode The node that was detected as the selected node in Leo
 */
private _apToLeoNodeConvertReveal(p_leoNode: LeoNode): void {
    this.leoStates.selectedNodeFlags(p_leoNode);
    // First setup flags for selecting and focusing based on the current reveal type needed
    const w_selectFlag = this._revealType &gt;= RevealType.RevealSelect; // at least RevealSelect
    let w_focusFlag = this._revealType &gt;= RevealType.RevealSelectFocus;  // at least RevealSelectFocus
    // Flags are setup so now reveal, select and / or focus as needed
    this._revealType = RevealType.NoReveal; // ok reset
    // If first time, or when treeview switched, lastSelectedNode will be undefined
    if (!this.lastSelectedNode || this._needLastSelectedRefresh) {
        this._needLastSelectedRefresh = false;
        this.lastSelectedNode = p_leoNode; // special case only: lastSelectedNode should be set in selectTreeNode
    }
    setTimeout(() =&gt; {
        // TODO : MAKE SURE TIMEOUT IS REALLY REQUIRED
        this._revealTreeViewNode(p_leoNode, { select: w_selectFlag, focus: w_focusFlag })
            .then(() =&gt; {
                // console.log('did this ask for parent?', p_leoNode.id, p_leoNode.label); // ! debug
                if (w_selectFlag) {
                    this._gotSelection(p_leoNode);
                }
            });
    });
}

</t>
<t tx="ekr.20200704142237.32">/**
 * * Converts an array of 'ap' to an array of leoNodes.  This is used in 'getChildren' of leoOutline.ts
 * @param p_array Array of archived positions to be converted to leoNodes for the vscode treeview
 */
public arrayToLeoNodesArray(p_array: ArchivedPosition[]): LeoNode[] {
    const w_leoNodesArray: LeoNode[] = [];
    for (let w_apData of p_array) {
        const w_leoNode = this.apToLeoNode(w_apData, true);
        w_leoNodesArray.push(w_leoNode);
    }
    return w_leoNodesArray;
}

</t>
<t tx="ekr.20200704142237.33">/**
 * * 'TreeView.reveal' for any opened leo outline that is currently visible
 * @param p_leoNode The node to be revealed
 * @param p_options Options object for the revealed node to either also select it, focus it, and expand it
 */
private _revealTreeViewNode(p_leoNode: LeoNode, p_options?: { select?: boolean, focus?: boolean, expand?: boolean | number }): Thenable&lt;void&gt; {
    if (this._leoTreeStandaloneView.visible) {
        return this._leoTreeStandaloneView.reveal(p_leoNode, p_options);
    }
    if (this._leoTreeExplorerView.visible &amp;&amp; this.config.treeInExplorer) {
        return this._leoTreeExplorerView.reveal(p_leoNode, p_options);
    }
    return Promise.resolve(); // Defaults to resolving even if both are hidden
}

</t>
<t tx="ekr.20200704142237.34">/**
 * * Launch the tree root, and optionally body, refresh processes, leading to _gotSelection upon reaching the selected node
 * @param p_refreshType choose to refresh the outline, or the outline and body pane along with it
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 */
public launchRefresh(p_refreshType: RefreshType, p_fromOutline: boolean): void {
    // * Rules not specified with ternary operator(s) for clarity
    // Set w_revealType, it will ultimately set this._revealType. Used when finding the OUTLINE's selected node and setting or preventing focus into it
    // Set this._fromOutline. Used when finding the selected node and showing the BODY to set or prevent focus in it
    let w_revealType: RevealType = RevealType.NoReveal;
    if (p_fromOutline) {
        this._fromOutline = true;
        w_revealType = RevealType.RevealSelectFocus;
    } else {
        this._fromOutline = false;
        w_revealType = RevealType.RevealSelect;
    }
    // Set this._needRefreshBody. Used when finding the selected node and showing the BODY to trigger a 'fireRefreshFile'
    if (p_refreshType === RefreshType.RefreshTreeAndBody) {
        this._needRefreshBody = true;
        // When this refresh is launched with 'refresh body' requested, we need to lose any pending edits and save on vscode's side.
        if (this._bodyLastChangedDocument &amp;&amp; this._bodyLastChangedDocument.isDirty) {
            this._bodyLastChangedDocument.save(); // ! Voluntarily save to 'clean' any pending body (lose trailing whitespace)
        }
    } else {
        this._needRefreshBody = false;
    }
    // * _focusInterrupt Override
    if (this._focusInterrupt) {
        // this._focusInterrupt = false; // TODO : Test if reverting this in _gotSelection is 'ok'
        w_revealType = RevealType.RevealSelect;
    }
    // * Launch Outline's Root Refresh Cycle
    this._refreshOutline(w_revealType);
    this.getStates();
}

</t>
<t tx="ekr.20200704142237.35">/**
 * * Handle the selected node that was reached while converting received ap_nodes to LeoNodes
 * @param p_node The selected node that was reached while receiving 'children' from tree view api implementing Leo's outline
 */
private _gotSelection(p_node: LeoNode): Thenable&lt;vscode.TextEditor&gt; {
    // * Use the 'from outline' concept to decide if focus should be on body or outline after editing a headline
    let w_showBodyKeepFocus: boolean = this._fromOutline; // Will preserve focus where it is without forcing into the body pane if true
    if (this._focusInterrupt) {
        this._focusInterrupt = false; // TODO : Test if reverting this in _gotSelection is 'ok'
        w_showBodyKeepFocus = true;
    }
    return this._applyNodeSelectionToBody(p_node, false, w_showBodyKeepFocus);
}

</t>
<t tx="ekr.20200704142237.36">/**
 * * User has selected a node via mouse click or via 'enter' keypress in the outline, otherwise flag p_internalCall if used internally
 * @param p_node Node that was just selected
 * @param p_internalCall Flag used to indicate the selection is forced, and NOT originating from user interaction
 * @param p_aside Flag to force opening the body "Aside", i.e. when the selection was made from choosing "Open Aside"
 */
public selectTreeNode(p_node: LeoNode, p_internalCall?: boolean, p_aside?: boolean): Thenable&lt;vscode.TextEditor&gt; {
    // * check if used via context menu's "open-aside" on an unselected node: check if p_node is currently selected, if not select it
    if (p_aside &amp;&amp; p_node !== this.lastSelectedNode) {
        this._revealTreeViewNode(p_node, { select: true, focus: false }); // no need to set focus: tree selection is set to right-click position
    }
    this.leoStates.selectedNodeFlags(p_node);
    // TODO : #39 @boltex Save and restore selection, along with cursor position, from selection state saved in each node (or gnx array)
    this._leoStatusBar.update(true); // Just selected a node directly, or via expand/collapse
    const w_showBodyKeepFocus = p_aside ? this.config.treeKeepFocusWhenAside : this.config.treeKeepFocus;
    // * Check if having already this exact node position selected : Just show the body and exit!
    if (p_node === this.lastSelectedNode) {
        this._locateOpenedBody(p_node.gnx);
        return this.showBody(!!p_aside, w_showBodyKeepFocus); // voluntary exit
    }
    // * Set selected node in Leo via leoBridge
    this.sendAction(Constants.LEOBRIDGE.SET_SELECTED_NODE, p_node.apJson);
    return this._applyNodeSelectionToBody(p_node, !!p_aside, w_showBodyKeepFocus, true);
}

</t>
<t tx="ekr.20200704142237.37">/**
 * * Makes sure the body now reflects the selected node. This is called after 'selectTreeNode', or after '_gotSelection' when refreshing.
 * @param p_node Node that was just selected
 * @param p_aside Flag to indicate opening 'Aside' was required
 * @param p_showBodyKeepFocus Flag used to keep focus where it was instead of forcing in body
 * @param p_force_open Flag to force opening the body pane editor
 */
private _applyNodeSelectionToBody(p_node: LeoNode, p_aside: boolean, p_showBodyKeepFocus: boolean, p_force_open?: boolean): Thenable&lt;vscode.TextEditor&gt; {
    // Check first if body needs refresh: if so we will voluntarily throw out any pending edits on body
    this.triggerBodySave(); // Send body to Leo because we're about to (re)show a body of possibly different gnx
    this.lastSelectedNode = p_node; // Set the 'lastSelectedNode'  this will also set the 'marked' node context
    this._commandStack.newSelection();
    // * Is the last opened body still opened? If not the new gnx then make the body pane switch and show itself if needed,
    if (this._bodyTextDocument &amp;&amp; !this._bodyTextDocument.isClosed) {
        // * Check if already opened and visible, _locateOpenedBody also sets bodyTextDocumentSameUri, bodyMainSelectionColumn, bodyTextDocument
        if (this._locateOpenedBody(p_node.gnx)) {
            // * Here we really tested _bodyTextDocumentSameUri set from _locateOpenedBody, (means we found the same already opened) so just show it
            this.bodyUri = utils.strToLeoUri(p_node.gnx);
            return this._showBodyIfRequired(p_aside, p_showBodyKeepFocus, p_force_open); // already opened in a column so just tell vscode to show it
        } else {
            // * So far, _bodyTextDocument is still opened and different from new selection: so "save &amp; rename" to block undo/redos
            return this._switchBody(p_node.gnx)
                .then(() =&gt; {
                    return this._showBodyIfRequired(p_aside, p_showBodyKeepFocus, p_force_open); // Also finish by showing it if not already visible
                });
        }
    } else {
        // * Is the last opened body is closed so just open the newly selected one
        this.bodyUri = utils.strToLeoUri(p_node.gnx);
        return this._showBodyIfRequired(p_aside, p_showBodyKeepFocus, p_force_open);
    }
}

</t>
<t tx="ekr.20200704142237.38">/**
 * * This function tries to prevent opening the body editor unnecessarily when hiding and re(showing) the outline pane
 * TODO : Find Better Conditions! Always true for now...
 * @param p_aside Flag for opening the editor beside any currently opened and focused editor
 * @param p_showBodyKeepFocus flag that when true will stop the editor from taking focus once opened
 * @param p_force_open Forces opening the body pane editor
 */
private _showBodyIfRequired(p_aside: boolean, p_showBodyKeepFocus: boolean, p_force_open?: boolean): Thenable&lt;vscode.TextEditor&gt; {
    if (this._preventShowBody) {
        this._preventShowBody = false;
        return Promise.resolve(vscode.window.activeTextEditor!);
    }
    if (true || p_force_open || this._leoTreeStandaloneView.visible) {
        return this.showBody(p_aside, p_showBodyKeepFocus); // ! Always true for now to stabilize refreshes after derived files refreshes and others.
    } else {
        return Promise.resolve(vscode.window.activeTextEditor!);
    }
}

</t>
<t tx="ekr.20200704142237.39">/**
 * * Save and rename from this.bodyUri to p_newGnx: This changes the body content &amp; blocks 'undos' from crossing over
 * @param p_newGnx New gnx body id to switch to
 */
private _switchBody(p_newGnx: string): Thenable&lt;boolean&gt; {
    if (this._bodyTextDocument) {
        return this._bodyTextDocument.save().then((p_result) =&gt; {
            const w_edit = new vscode.WorkspaceEdit();
            this._leoFileSystem.setRenameTime(p_newGnx);
            w_edit.renameFile(
                this.bodyUri, // Old URI from last node
                utils.strToLeoUri(p_newGnx), // New URI from selected node
                { overwrite: true, ignoreIfExists: true }
            );
            return vscode.workspace.applyEdit(w_edit).then(p_result =&gt; {
                this.bodyUri = utils.strToLeoUri(p_newGnx); // Old is now set to new to finish
                return Promise.resolve(p_result); // Also finish by showing it if not already visible
            });
        });
    } else {
        return Promise.resolve(false);
    }
}

</t>
<t tx="ekr.20200704142237.4">/**
 * *  Sends an action for leobridgeserver.py to run with Leo. This is used mostly by LeoAsync, leoOutline and leoBody.
 * @param p_action is the action string constant, from Constants.LEOBRIDGE
 * @param p_jsonParam (optional, defaults to "null", which translates to None in python) a JSON string to be given to the python side, often built with JSON.stringify(object)
 * @param p_deferredPayload (optional) a pre-made package that will be given back as the response, instead of package coming back from python
 * @param p_preventCall (optional) Flag for special case, only used at startup
 * @returns a Promise that will contain the JSON package answered back by leobridgeserver.py
 */
public sendAction(p_action: string, p_jsonParam = "null", p_deferredPayload?: LeoBridgePackage, p_preventCall?: boolean): Promise&lt;LeoBridgePackage&gt; {
    return this._leoBridge.action(p_action, p_jsonParam, p_deferredPayload, p_preventCall);
}

</t>
<t tx="ekr.20200704142237.40">/**
 * * Sets globals if the current body is found opened in an editor panel for a particular gnx
 * @param p_gnx gnx to match
 */
private _locateOpenedBody(p_gnx: string): boolean {
    let w_found = false;
    // * Only gets to visible editors, not every tab per editor
    vscode.window.visibleTextEditors.forEach(p_textEditor =&gt; {
        if (utils.leoUriToStr(p_textEditor.document.uri) === p_gnx) {
            w_found = true;
            this._bodyTextDocument = p_textEditor.document;
            this._bodyMainSelectionColumn = p_textEditor.viewColumn;
        }
    });
    return w_found;
}

</t>
<t tx="ekr.20200704142237.41">/**
 * * Closes any body pane opened in this vscode window instance
 */
public closeBody(): void {
    // TODO : Try to close body pane(s)
    vscode.window.visibleTextEditors.forEach(p_textEditor =&gt; {
        if (p_textEditor.document.uri.scheme === Constants.URI_SCHEME) {
            if (p_textEditor.hide) {
                p_textEditor.hide();
            }
        }
    });
}

</t>
<t tx="ekr.20200704142237.42">/**
 * * Opens an an editor for the currently selected node: "this.bodyUri". If already opened, this just 'reveals' it
 * @param p_aside Flag for opening the editor beside any currently opened and focused editor
 * @param p_preserveFocus flag that when true will stop the editor from taking focus once opened
 */
public showBody(p_aside: boolean, p_preserveFocus?: boolean): Thenable&lt;vscode.TextEditor&gt; {
    // first setup timeout asking for gnx file refresh in case we were resolving a refresh of type 'RefreshTreeAndBody'
    if (this._needRefreshBody) {
        this._needRefreshBody = false; // Flag has triggered a body refresh so we clear it
        // TODO : CHECK IF TIMEOUT NECESSARY!
        setTimeout(() =&gt; {
            this._leoFileSystem.fireRefreshFile(utils.leoUriToStr(this.bodyUri));
        }, 0);
    }
    return vscode.workspace.openTextDocument(this.bodyUri).then(p_document =&gt; {

        this._bodyTextDocument = p_document;

        // TODO : Should get original @language effective value for specific 'top of document' body that is shown
        if (this._bodyTextDocument.languageId !== Constants.BODY_LANGUAGES.default) {
            vscode.languages.setTextDocumentLanguage(this._bodyTextDocument, Constants.BODY_LANGUAGES.default);
        }

        vscode.window.visibleTextEditors.forEach(p_textEditor =&gt; {
            if (p_textEditor.document.uri.fsPath === p_document.uri.fsPath) {
                this._bodyMainSelectionColumn = p_textEditor.viewColumn;
                this._bodyTextDocument = p_textEditor.document;
            }
        });
        // Setup options for the preview state of the opened editor, and to choose which column it should appear
        const w_showOptions: vscode.TextDocumentShowOptions = p_aside ?
            {
                viewColumn: vscode.ViewColumn.Beside,
                preserveFocus: p_preserveFocus, // an optional flag that when true will stop the editor from taking focus
                preview: true // should text document be in preview only? set false for fully opened
                // selection: new Range( new Position(0,0), new Position(0,0) ) // TODO : Set scroll position of node if known / or top otherwise
            } : {
                viewColumn: this._bodyMainSelectionColumn ? this._bodyMainSelectionColumn : 1, // view column in which the editor should be shown
                preserveFocus: p_preserveFocus, // an optional flag that when true will stop the editor from taking focus
                preview: false // should text document be in preview only? set false for fully opened
                // selection: new Range( new Position(0,0), new Position(0,0) ) // TODO : Set scroll position of node if known / or top otherwise
            };

        // NOTE: textEditor.show() is deprecated ‚Äî Use window.showTextDocument instead.
        return vscode.window.showTextDocument(this._bodyTextDocument, w_showOptions).then(w_bodyEditor =&gt; {
            // w_bodyEditor.options.lineNumbers = OFFSET ; // TODO : if position is in an derived file node show relative position
            // other possible interactions: revealRange / setDecorations / visibleRanges / options.cursorStyle / options.lineNumbers
            return Promise.resolve(w_bodyEditor);
        });
    });
}

</t>
<t tx="ekr.20200704142237.44">/**
 * * Adds a command to the stack to be resolved, returns true if possible (based on stack state and rules), false otherwise
 * @param p_action A string code constant member from Constants.LEOBRIDGE, which are commands for leobridgeserver.py
 * @param p_node Specific node to pass as parameter, or the selected node if omitted
 * @param p_refreshType Specifies to either refresh nothing, the tree or both body and tree when finished resolving
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_providedHeadline Specific string to pass along as parameter with the action, similar to p_node parameter
 * @returns True if added successfully (see command stack 'rules' in commandStack.ts), false otherwise
 */
public nodeCommand(p_action: string, p_node?: LeoNode, p_refreshType?: RefreshType, p_fromOutline?: boolean, p_providedHeadline?: string): boolean {
    this.triggerBodySave(); // No forced vscode save
    if (this._commandStack.add({
        action: p_action,
        node: p_node,  // Will return false for sure if already started and this is not undefined
        providedHeadline: p_providedHeadline ? p_providedHeadline : undefined,
        refreshType: p_refreshType ? p_refreshType : RefreshType.NoRefresh,
        fromOutline: !!p_fromOutline, // force boolean
    })) {
        return true;
    } else {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.TOO_FAST + p_action); // TODO : Use cleanup message string CONSTANT instead
        return false;
    }
}

</t>
<t tx="ekr.20200704142237.45">/**
 * * Launches the 'Execute Script' Leo command with the selected text, if any, otherwise the selected node itself is used
 * @returns True if the selection, or node, was started as a script
 */
public executeScript(): boolean {
    // * Check if selected string in the focused leo body
    if (vscode.window.activeTextEditor &amp;&amp; vscode.window.activeTextEditor.document.uri.scheme === Constants.URI_SCHEME) {
        // was active text editor leoBody, check if selection length
        if (vscode.window.activeTextEditor.selections.length === 1 &amp;&amp; !vscode.window.activeTextEditor.selection.isEmpty) {
            // Exactly one selection range, and is not empty, so try "executing" only the selected content.
            let w_selection = vscode.window.activeTextEditor.selection;
            let w_script = vscode.window.activeTextEditor.document.getText(w_selection);
            if (w_script.length) {
                return this.nodeCommand(Constants.LEOBRIDGE.EXECUTE_SCRIPT, undefined, RefreshType.RefreshTreeAndBody, false, w_script);
            }
        }

    }
    // * Catch all call: execute selected node outline with a single space as script
    return this.nodeCommand(Constants.LEOBRIDGE.EXECUTE_SCRIPT, undefined, RefreshType.RefreshTreeAndBody, false, " ");
}

</t>
<t tx="ekr.20200704142237.46">/**
 * Changes the marked state of a specified, or currently selected node
 * @param p_isMark Set 'True' to mark, otherwise unmarks the node
 * @param p_node Specifies which node use, or leave undefined to mark or unmark the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 */
public changeMark(p_isMark: boolean, p_node?: LeoNode, p_fromOutline?: boolean): void {
    if (this.nodeCommand(p_isMark ? Constants.LEOBRIDGE.MARK_PNODE : Constants.LEOBRIDGE.UNMARK_PNODE, p_node, RefreshType.RefreshTree, p_fromOutline)) {
        if (!p_node || p_node === this.lastSelectedNode) {
            utils.setContext(Constants.CONTEXT_FLAGS.SELECTED_MARKED, p_isMark);
        }
    }
}

</t>
<t tx="ekr.20200704142237.47">/**
 * * Asks for a new headline label, and replaces the current label with this new one one the specified, or currently selected node
 * @param p_node Specifies which node to rename, or leave undefined to rename the currently selected node
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 */
public editHeadline(p_node?: LeoNode, p_fromOutline?: boolean): void {
    // * Only if no commands are waiting to finish because we need the exact label to show in the edit control for now, see TODO below
    if (this._isBusy()) { return; } // Warn user to wait for end of busy state
    this.triggerBodySave(true);
    if (!p_node &amp;&amp; this.lastSelectedNode) {
        p_node = this.lastSelectedNode; // Gets last selected node if called via keyboard shortcut or command palette (not set in command stack class)
    }
    if (p_node) {
        this._headlineInputOptions.prompt = Constants.USER_MESSAGES.PROMPT_EDIT_HEADLINE;
        this._headlineInputOptions.value = p_node.label; // preset input pop up
        vscode.window.showInputBox(this._headlineInputOptions)
            .then(p_newHeadline =&gt; {
                if (p_newHeadline) {
                    p_node!.label = p_newHeadline; // ! When labels change, ids will change and its selection and expansion states cannot be kept stable anymore.
                    this.nodeCommand(Constants.LEOBRIDGE.SET_HEADLINE, p_node, RefreshType.RefreshTree, p_fromOutline, p_newHeadline);
                } else {
                    // TODO : Make sure focus is set back properly to either outline or body if this is canceled (Maybe unnecessary?)
                }
            });
    }
}

</t>
<t tx="ekr.20200704142237.48">/**
 * * Asks for a headline label to be entered and creates (inserts) a new node under the current, or specified, node
 * @param p_node specified under which node to insert, or leave undefined to use whichever is currently selected
 * @param p_fromOutline Signifies that the focus was, and should be brought back to, the outline
 * @param p_interrupt Signifies the insert action is actually interrupting itself (e.g. rapid CTRL+I actions by the user)
 */
public insertNode(p_node?: LeoNode, p_fromOutline?: boolean, p_interrupt?: boolean): void {
    let w_fromOutline: boolean = !!p_fromOutline; // Use w_fromOutline for where we intend to leave focus when done with the insert
    if (p_interrupt) {
        this._focusInterrupt = true;
        w_fromOutline = this._fromOutline; // Going to use last state // TODO : MAKE SURE ITS STILL AVAILABLE AND VALID
    }
    if (!p_node || !this._isBusy()) {
        // * Only if no parameters or no stack at all
        this.triggerBodySave(true);
        this._headlineInputOptions.prompt = Constants.USER_MESSAGES.PROMPT_INSERT_NODE;
        this._headlineInputOptions.value = Constants.USER_MESSAGES.DEFAULT_HEADLINE;
        vscode.window.showInputBox(this._headlineInputOptions)
            .then(p_newHeadline =&gt; {
                const w_action = p_newHeadline ? Constants.LEOBRIDGE.INSERT_NAMED_PNODE : Constants.LEOBRIDGE.INSERT_PNODE;
                this.nodeCommand(w_action, p_node, RefreshType.RefreshTree, w_fromOutline, p_newHeadline); // p_node and p_newHeadline can be undefined
            });
    }
}

</t>
<t tx="ekr.20200704142237.49">/**
 * * Asks for file name and path, then saves the Leo file
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 */
public saveAsLeoFile(p_fromOutline?: boolean): void {
    if (!this.leoStates.fileOpenedReady || this._isBusy()) { return; } // Warn user to wait for end of busy state
    // TODO : Implement &amp; support multiple simultaneous files
    if (this.leoStates.fileOpenedReady) {
        if (this.lastSelectedNode) {
            this.triggerBodySave(true)
                .then(() =&gt; {
                    return this._leoFilesBrowser.getLeoFileUrl(true);
                })
                .then(p_chosenLeoFile =&gt; {
                    if (p_chosenLeoFile.trim()) {
                        this.nodeCommand(Constants.LEOBRIDGE.SAVE_FILE, undefined, RefreshType.RefreshTree, p_fromOutline, p_chosenLeoFile); // p_node and p_newHeadline can be undefined
                    }
                });
        }
    } else {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    }
}

</t>
<t tx="ekr.20200704142237.5">/**
 * * leoInteg starting entry point: Start a leoBridge server, and/or establish a connection to a server, based on config settings.
 */
public startNetworkServices(): void {
    // * Check settings and start a server accordingly
    if (this.config.startServerAutomatically) {
        this.startServer();
    } else {
        // * (via settings) Connect to Leo Bridge server automatically without starting one first
        if (this.config.connectToServerAutomatically) {
            this.connect();
        }
    }
}

</t>
<t tx="ekr.20200704142237.50">/**
 * * Invokes the self.commander.save() Leo command
 * @param p_fromOutlineSignifies that the focus was, and should be brought back to, the outline
 */
public saveLeoFile(p_fromOutline?: boolean): void {
    if (!this.leoStates.fileOpenedReady || this._isBusy()) { return; } // Warn user to wait for end of busy state

    // TODO : Specify which file when supporting multiple simultaneous opened Leo files
    if (this.leoStates.fileOpenedReady) {
        if (this.lastSelectedNode &amp;&amp; this._isCurrentFileNamed()) {
            this.triggerBodySave(true)
                .then(() =&gt; {
                    this.nodeCommand(Constants.LEOBRIDGE.SAVE_FILE, undefined, RefreshType.RefreshTree, p_fromOutline, ""); // p_node and p_newHeadline can be undefined
                });
        } else {
            this.saveAsLeoFile(p_fromOutline); // Override this command call if file is unnamed!
        }
    } else {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.FILE_NOT_OPENED);
    }
}

</t>
<t tx="ekr.20200704142237.51">/**
 * * Show switch document 'QuickPick' dialog and switch file if selection is made, or just return if no files are opened.
 */
public switchLeoFile(): void {
    if (!this.leoStates.fileOpenedReady || this._isBusy()) { return; } // Warn user to wait for end of busy state
    // get list and show dialog to user, even if there's only one...but at least one!
    // TODO : p_package members names should be made into constants
    // TODO : Fix / Cleanup opened body panes close before reopening when switching
    this.triggerBodySave(true)
        .then(() =&gt; {
            return this._leoBridge.action(Constants.LEOBRIDGE.GET_OPENED_FILES);
        })
        .then(p_package =&gt; {
            const w_entries: ChooseDocumentItem[] = []; // Entries to offer as choices.
            const w_files: LeoDocument[] = p_package.openedFiles!.files;
            const w_selectedIndex: number = p_package.openedFiles!.index;
            let w_index: number = 0;
            let w_currentlySelected = "";  // ? not used elsewhere ?
            if (w_files &amp;&amp; w_files.length) {
                w_files.forEach(function (p_filePath: LeoDocument) {
                    if (w_index === w_selectedIndex) {
                        w_currentlySelected = p_filePath.name; // ? not used elsewhere ?
                    }
                    w_entries.push({
                        label: w_index.toString(),
                        description: p_filePath.name ? p_filePath.name : Constants.UNTITLED_FILE_NAME,
                        value: w_index,
                        alwaysShow: true
                    });
                    w_index++;
                });
                const w_pickOptions: vscode.QuickPickOptions = {
                    matchOnDescription: true,
                    placeHolder: Constants.USER_MESSAGES.CHOOSE_OPENED_FILE
                };
                vscode.window.showQuickPick(w_entries, w_pickOptions).then((p_chosenDocument) =&gt; {
                    if (p_chosenDocument) {
                        this.selectOpenedLeoDocument(p_chosenDocument.value);
                    } // else : cancelled so no action taken
                });
            }
        });
}

</t>
<t tx="ekr.20200704142237.52">/**
 * * Switches Leo document directly by index number. Used by document treeview and switchLeoFile command.
 */
public selectOpenedLeoDocument(p_index: number): void {
    if (this._isBusy()) { return; } // Warn user to wait for end of busy state
    this._leoBridge.action(Constants.LEOBRIDGE.SET_OPENED_FILE, JSON.stringify({ "index": p_index }))
        .then((p_openFileResult: LeoBridgePackage) =&gt; {
            // Like we just opened or made a new file
            if (p_openFileResult.setOpened) {
                this._setupOpenedLeoDocument(p_openFileResult.setOpened);
            } else {
                console.log('Select Opened Leo File Error');
            }
        });
}

</t>
<t tx="ekr.20200704142237.53">/**
 * * Close an opened Leo file
 */
public closeLeoFile(): void {
    if (this._isBusy()) { return; } // Warn user to wait for end of busy state
    if (this.leoStates.fileOpenedReady) {
        this.triggerBodySave(true)
            .then(() =&gt; {
                return this.sendAction(Constants.LEOBRIDGE.CLOSE_FILE, JSON.stringify({ forced: false }));
            })
            .then((p_package =&gt; {
                // TODO : p_package members names should be made into constants
                if (p_package.closed) {
                    this._leoDocumentsProvider.refreshTreeRoot();
                    this._leoButtonsProvider.refreshTreeRoot();
                    if (p_package.closed.total === 0) {
                        this._setupNoOpenedLeoDocument();
                    } else {
                        this.launchRefresh(RefreshType.RefreshTreeAndBody, false);
                    }
                } else if (p_package.closed === false) {
                    // Explicitly false and not just undefined
                    const w_askArg = Constants.USER_MESSAGES.SAVE_CHANGES + ' ' +
                        this.leoStates.leoOpenedFileName + ' ' +
                        // this._openedLeoDocuments[this._leoOpenedFilesIndex] + ' ' +
                        Constants.USER_MESSAGES.BEFORE_CLOSING;

                    const w_askSaveChangesInfoMessage: Thenable&lt;vscode.MessageItem | undefined&gt; = vscode.window.showInformationMessage(
                        w_askArg,
                        { modal: true },
                        ...Constants.ASK_SAVE_CHANGES_BUTTONS
                    );
                    w_askSaveChangesInfoMessage.then((p_result: vscode.MessageItem | undefined) =&gt; {
                        if (p_result) {
                            if (p_result.title === Constants.USER_MESSAGES.YES) {
                                // save and close
                                let w_savePromise: Promise&lt;LeoBridgePackage&gt;;
                                if (this._isCurrentFileNamed()) {
                                    w_savePromise = this.sendAction(Constants.LEOBRIDGE.SAVE_FILE, JSON.stringify({ text: "" }));
                                } else {
                                    w_savePromise = this._leoFilesBrowser.getLeoFileUrl(true).then((p_chosenLeoFile) =&gt; {
                                        if (p_chosenLeoFile.trim()) {
                                            return this.sendAction(Constants.LEOBRIDGE.SAVE_FILE, JSON.stringify({ text: p_chosenLeoFile.trim() }));
                                        } else {
                                            return Promise.reject();
                                        }
                                    });
                                }
                                return w_savePromise.then(() =&gt; {
                                    return this.sendAction(Constants.LEOBRIDGE.CLOSE_FILE, JSON.stringify({ forced: true }));
                                }, () =&gt; {
                                    // canceled
                                    return Promise.reject();
                                });
                            } else if (p_result.title === Constants.USER_MESSAGES.NO) {
                                return this.sendAction(Constants.LEOBRIDGE.CLOSE_FILE, JSON.stringify({ forced: true }));
                            }
                        } else {
                            return Promise.reject(); // cancelled ask
                        }
                    }).then((p_package: LeoBridgePackage | undefined) =&gt; {
                        // * back from CLOSE_FILE action, the last that can be performed (after saving if dirty or not)
                        this._leoDocumentsProvider.refreshTreeRoot();
                        this._leoButtonsProvider.refreshTreeRoot();
                        if (p_package &amp;&amp; p_package.closed &amp;&amp; p_package.closed.total === 0) {
                            this._setupNoOpenedLeoDocument();
                        } else {
                            this.launchRefresh(RefreshType.RefreshTreeAndBody, false);
                        }
                    });
                }
                // else don't do anything
            }));
    } else {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.CLOSE_ERROR);
    }
}

</t>
<t tx="ekr.20200704142237.54">/**
 * * Creates a new untitled Leo document
 * * If not shown already, it also shows the outline, body and log panes along with leaving focus in the outline
 */
public newLeoFile(): void {
    if (this._isBusy()) { return; } // Warn user to wait for end of busy state
    this.triggerBodySave(true)
        .then(() =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.OPEN_FILE, '""');
        })
        .then((p_openFileResult: LeoBridgePackage) =&gt; {
            if (p_openFileResult.opened) {
                return this._setupOpenedLeoDocument(p_openFileResult.opened);
            } else {
                console.log('New Leo File Error');
            }
        });
}

</t>
<t tx="ekr.20200704142237.6">/**
 * * Starts an instance of a leoBridge server, and may connect to it afterwards, based on configuration flags.
 */
public startServer(): void {
    if (!this._leoTerminalPane) {
        this._leoTerminalPane = vscode.window.createOutputChannel(Constants.GUI.TERMINAL_PANE_TITLE);
    }
    this._serverService.startServer(this.config.leoPythonCommand)
        .then((p_message) =&gt; {
            utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, true); // server started
            if (this.config.connectToServerAutomatically) {
                this.connect();
            }
        }, (p_reason) =&gt; {
            vscode.window.showErrorMessage(Constants.USER_MESSAGES.START_SERVER_ERROR + p_reason);
        });
}

</t>
<t tx="ekr.20200704142237.60">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";
import { ArchivedPosition, Icon } from "./types"; // * TO HELP DEBUG

/**
 * * Implementation of tree nodes for usage in a TreeDataProvider
 */
@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142237.61">export class LeoNode extends vscode.TreeItem {

    public cursorSelection: any; // TODO : #39 @boltex Keep body's cursor and selection position from vscode to get it back
    public contextValue: string; // * Context string is checked in package.json with 'when' clauses

    public isRoot: boolean = false; // * for hoist/dehoist context flags purposes

    constructor(
        public label: string, // Node headline
        public gnx: string,
        public collapsibleState: vscode.TreeItemCollapsibleState, // Computed in receiver/creator
        public apJson: string, // Key for leo/python side of things
        public childIndex: number, // For debugging purposes
        public cloned: boolean,
        public dirty: boolean,
        public marked: boolean,
        public atFile: boolean,
        public hasBody: boolean,
        public u: any,
        private _leoIntegration: LeoIntegration,
        private _id: string
    ) {
        super(label, collapsibleState);
        this.contextValue = this._getNodeContextValue();
        this.command = {
            command: Constants.NAME + "." + Constants.COMMANDS.SELECT_NODE,
            title: '',
            arguments: [this]
        };
    }

    // * TO HELP DEBUG

    // get description(): string {
    //     // * some smaller grayed-out text accompanying the main label
    //     const w_ap: ArchivedPosition = JSON.parse(this.apJson);
    //     return "child:" + w_ap.childIndex + " lvl:" + w_ap.level + " gnx:" + w_ap.gnx;
    // }

    // get description(): string {
    //     // * some smaller grayed-out text accompanying the main label
    //     return "id:" + this.id;
    // }

    /**
     * * Sets this node properties (dirty, marked, etc.) by copying from a given node.
     * * This is needed by the outline provider when refreshing a single node.
     * @param p_node Node to copy properties from.
     * @returns Node itself with the new properties applied
     */
    @others
}
</t>
<t tx="ekr.20200704142237.62">public copyProperties(p_node: LeoNode): LeoNode {
    this.label = p_node.label;
    this.gnx = p_node.gnx;
    this.collapsibleState = p_node.collapsibleState;
    this.apJson = p_node.apJson;
    this.childIndex = p_node.childIndex;
    this.cloned = p_node.cloned;
    this.dirty = p_node.dirty;
    this.marked = p_node.marked;
    this.atFile = p_node.atFile;
    this.hasBody = p_node.hasBody;
    this.isRoot = p_node.isRoot;
    this.contextValue = this._getNodeContextValue();
    return this;
}

</t>
<t tx="ekr.20200704142237.63">/**
 * * Set this node as the root for hoist/dehoist context flags purposes
 */
public setRoot(): void {
    this.isRoot = true;
    this._leoIntegration.leoStates.leoRoot = true; // Set this special global 'selected node' flag
    this.contextValue = this._getNodeContextValue();
}

</t>
<t tx="ekr.20200704142237.64">public getCursorSelection(): any {
    return this.cursorSelection;
}

</t>
<t tx="ekr.20200704142237.65">public setCursorSelection(p_cursorSelection: any): void {
    this.cursorSelection = p_cursorSelection;
}

public get iconPath(): Icon {
    // From Leo's leoNodes.py computeIcon function
    // 1=has Body, 2=marked, 4=cloned, 8=dirty
    let w_dirty: boolean = this._leoIntegration.config.invertNodeContrast ? !this.dirty : this.dirty;
    let w_icon: number =
        (+w_dirty &lt;&lt; 3) |
        (+this.cloned &lt;&lt; 2) |
        (+this.marked &lt;&lt; 1) |
        +this.hasBody;
    return this._leoIntegration.nodeIcons[w_icon];
}

// Optional id for the tree item that has to be unique across tree.
// The id is used to preserve the selection and expansion state of the tree item.
// If not provided, an id is generated using the tree item's label.
// Note that when labels change, ids will change and that selection and expansion state cannot be kept stable anymore.
public get id(): string { return this._id; }

public get description(): string {
    // * some smaller grayed-out text accompanying the main label
    if (this.u) {
        return "üìé (" + Object.keys(this.u).length + ")";
    } else {
        return ""; // Falsy will not be shown
    }
}

public get tooltip(): string {
    if (this.u) {
        //  "\ntotal keys is :" + Object.keys(this.u).length
        return this.label + "\n" +
            JSON.stringify(this.u, undefined, 2);
    } else {
        return this.label; // * Whole headline as tooltip
    }
}
</t>
<t tx="ekr.20200704142237.66">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoNode } from "./leoNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoBridgePackage } from "./types";

/**
 * * Leo outline implemented as a tree view with this TreeDataProvider implementation
 */
@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142237.67">export class LeoOutlineProvider implements vscode.TreeDataProvider&lt;LeoNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoNode | undefined&gt; = new vscode.EventEmitter&lt;LeoNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoNode | undefined&gt; = this._onDidChangeTreeData.event;

    private _refreshSingleNodeFlag: boolean = false; // used in leoOutline.ts to check if getTreeItem(element: LeoNode) should fetch from Leo, or return as-is

    constructor(private _leoIntegration: LeoIntegration) { }

    /**
     * * Refresh a single node
     * @param p_node The outline's node itself as a LeoNode instance
     */
    @others
}
</t>
<t tx="ekr.20200704142237.68">public refreshTreeNode(p_node: LeoNode): void {
    this._refreshSingleNodeFlag = true; // We want to do a real refresh, not just giving back the same we've got as input in getTreeItem
    this._onDidChangeTreeData.fire(p_node);
}

/**
 * * Refresh the whole outline
 */
</t>
<t tx="ekr.20200704142237.69">public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="ekr.20200704142237.7">/**
 * * Initiate a connection to the leoBridge server, then show view title, log pane, and set 'bridge ready' flags.
 */
public connect(): void {
    if (this.leoStates.leoBridgeReady || this._leoIsConnecting) {
        vscode.window.showInformationMessage(Constants.USER_MESSAGES.ALREADY_CONNECTED);
        return;
    }
    this._leoIsConnecting = true;
    this._leoBridgeReadyPromise = this._leoBridge.initLeoProcess();
    this._leoBridgeReadyPromise.then(
        (p_package) =&gt; {
            this._leoIsConnecting = false;
            if (p_package.id !== 1) {
                this.cancelConnect(Constants.USER_MESSAGES.CONNECT_ERROR);
            } else {
                this.leoStates.leoBridgeReady = true;
                utils.setContext(Constants.CONTEXT_FLAGS.BRIDGE_READY, true);
                this.showLogPane();
                if (!this.config.connectToServerAutomatically) {
                    vscode.window.showInformationMessage(Constants.USER_MESSAGES.CONNECTED);
                }
            }

            // TODO : Finish Closing and possibly SAME FOR OPENING AND CONNECTING
            // TODO : #14 @boltex COULD BE SOME FILES ALREADY OPENED OR NONE!

        },
        (p_reason) =&gt; {
            this._leoIsConnecting = false;
            this.cancelConnect(Constants.USER_MESSAGES.CONNECT_FAILED + p_reason);
        });
}

</t>
<t tx="ekr.20200704142237.70">public getTreeItem(element: LeoNode): Thenable&lt;LeoNode&gt; | LeoNode {
    if (this._refreshSingleNodeFlag) {
        this._refreshSingleNodeFlag = false;
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_PNODE, element.apJson)
            .then((p_package: LeoBridgePackage) =&gt; {
                const w_node = this._leoIntegration.apToLeoNode(p_package.node!, true, element);
                return element.copyProperties(w_node);
            });
    } else {
        return element;
    }
}

</t>
<t tx="ekr.20200704142237.71">public getChildren(element?: LeoNode): Thenable&lt;LeoNode[]&gt; {
    if (!this._leoIntegration.leoStates.fileOpenedReady) {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
    if (element) {
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_CHILDREN, element.apJson)
            .then((p_package: LeoBridgePackage) =&gt; {
                return this._leoIntegration.arrayToLeoNodesArray(p_package.nodes!);
            });
    } else {
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_CHILDREN, "null")
            .then((p_package: LeoBridgePackage) =&gt; {
                const w_nodes = this._leoIntegration.arrayToLeoNodesArray(p_package.nodes!);
                if (w_nodes &amp;&amp; w_nodes.length === 1) {
                    w_nodes[0].setRoot();
                }
                return w_nodes;
            });
    }
}

</t>
<t tx="ekr.20200704142237.72">public getParent(element: LeoNode): ProviderResult&lt;LeoNode&gt; | null {
    // * This method should be implemented in order to access reveal API.
    // ! But it should NOT have to be called because we will only try to 'select' already revealed nodes

    // ! Might be called if nodes are revealed while in vscode's refresh process
    // ! Parent asked for this way will go up till root and effectively refresh whole tree.
    // console.log('ERROR! GET PARENT CALLED! on: ', element.label);

    if (this._leoIntegration.leoStates.fileOpenedReady) {
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_PARENT, element ? element.apJson : "null")
            .then((p_package: LeoBridgePackage) =&gt; {
                if (p_package.node === null) {
                    return null;
                } else {
                    return this._leoIntegration.apToLeoNode(p_package.node!);
                }
            });
    } else {
        return null; // Default gives no parent
    }
}
</t>
<t tx="ekr.20200704142237.73">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from "./leoIntegration";

/**
 * * Statusbar indicator controller object
 */
@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142237.74">export class LeoStatusBar {

    private _leoStatusBarItem: vscode.StatusBarItem;
    private _statusbarNormalColor = new vscode.ThemeColor(Constants.GUI.THEME_STATUSBAR);  // "statusBar.foreground"
    private _updateStatusBarTimeout: NodeJS.Timeout | undefined;
    private _string: string = ""; // Use this string with indicator, using this will replace the default from config

    // * Represents having focus on a leo tree, body or document panel to enable leo keybindings
    private _statusBarFlag: boolean = false;
    set statusBarFlag(p_value: boolean) {
        this._statusBarFlag = p_value;
    }
    get statusBarFlag(): boolean {
        return this._statusBarFlag;
    }

    constructor(
        private _context: vscode.ExtensionContext,
        private _leoIntegration: LeoIntegration
    ) {
        this._leoStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
        this._leoStatusBarItem.color = this._leoIntegration.config.statusBarColor;

        // this._leoStatusBarItem.command = Constants.COMMANDS.SWITCH_FILE;
        this._leoStatusBarItem.command = "leointeg.test"; // just call test function for now to help debugging
        this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR + this._leoIntegration.config.statusBarString;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;
        _context.subscriptions.push(this._leoStatusBarItem);
        this._leoStatusBarItem.hide();
    }

    /**
     * * Makes the statusbar indicator visible
     */
    @others
}
</t>
<t tx="ekr.20200704142237.75">public show(): void {
    this._leoStatusBarItem.show();
}

/**
 * * Hides the statusbar indicator
 */
</t>
<t tx="ekr.20200704142237.76">public hide(): void {
    this._leoStatusBarItem.hide();
}

/**
 * * Sets string to replace default from config &amp; refresh it
 */
</t>
<t tx="ekr.20200704142237.77">public setString(p_string: string): void {
    this._string = p_string;
    this._updateLeoObjectIndicator();
}

/**
 * * Updates the status bar visual indicator visual indicator with optional debouncing delay
 * @param p_state True/False flag for On or Off status
 * @param p_debounceDelay Optional, in milliseconds
 */
</t>
<t tx="ekr.20200704142237.78">public update(p_state: boolean, p_debounceDelay?: number, p_forced?: boolean): void {
    if (p_forced || (p_state !== this.statusBarFlag)) {
        this.statusBarFlag = p_state;
        if (p_debounceDelay) {
            this._updateLeoObjectIndicatorDebounced(p_debounceDelay);
        } else {
            this._updateLeoObjectIndicator();
        }
    }
}

/**
 * * Updates the status bar visual indicator flag in a debounced manner
 * @param p_delay number of milliseconds
 */
</t>
<t tx="ekr.20200704142237.79">private _updateLeoObjectIndicatorDebounced(p_delay: number): void {
    if (this._updateStatusBarTimeout) {
        clearTimeout(this._updateStatusBarTimeout);
    }
    this._updateStatusBarTimeout = setTimeout(() =&gt; {
        this._updateLeoObjectIndicator();
    }, p_delay);
}

/**
 * * Updates the status bar visual indicator flag directly
 */
</t>
<t tx="ekr.20200704142237.8">/**
 * * Cancels websocket connection and reverts context flags. Called from leoBridge.ts when its websocket reports disconnection.
 * @param p_message
 */
public cancelConnect(p_message?: string): void {
    // 'disconnect error' versus 'failed to connect'
    if (this.leoStates.leoBridgeReady) {
        vscode.window.showErrorMessage(p_message ? p_message : Constants.USER_MESSAGES.DISCONNECTED);
    } else {
        vscode.window.showInformationMessage(p_message ? p_message : Constants.USER_MESSAGES.DISCONNECTED);
    }
    this.leoStates.fileOpenedReady = false;
    this.leoStates.leoBridgeReady = false;
    this._leoBridgeReadyPromise = undefined;
    this._leoStatusBar.update(false);
    this._refreshOutline(RevealType.RevealSelect);
}

</t>
<t tx="ekr.20200704142237.80">private _updateLeoObjectIndicator(): void {
    if (this._updateStatusBarTimeout) { // Can be called directly, so clear timer if any
        clearTimeout(this._updateStatusBarTimeout);
    }
    utils.setContext(Constants.CONTEXT_FLAGS.LEO_SELECTED, !!this.statusBarFlag);
    this._leoStatusBarItem.text = Constants.GUI.STATUSBAR_INDICATOR +
        (this._string ? this._string : this._leoIntegration.config.statusBarString) + " " +
        (this._leoIntegration.leoStates.leoOpenedFileName ? utils.getFileFromPath(this._leoIntegration.leoStates.leoOpenedFileName) : Constants.UNTITLED_FILE_NAME);
    if (this.statusBarFlag &amp;&amp; this._leoIntegration.leoStates.fileOpenedReady) { // * Also check in constructor for statusBar properties (the createStatusBarItem call itself)
        this._leoStatusBarItem.color = "#" + this._leoIntegration.config.statusBarColor;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_ON;
    } else {
        this._leoStatusBarItem.color = this._statusbarNormalColor;
        this._leoStatusBarItem.tooltip = Constants.USER_MESSAGES.STATUSBAR_TOOLTIP_OFF;
    }
}
</t>
<t tx="ekr.20200704142237.81">@path C:/leo.repo/leointeg/src/
import * as os from 'os';
import * as child from 'child_process';
import * as path from "path"; // TODO : Use this library to have reliable support for window-vs-linux file-paths
import * as vscode from "vscode";
import * as utils from "./utils";
import { Constants } from "./constants";
import { LeoIntegration } from './leoIntegration';

@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142237.82">/**
 * * Provides simple automatic leo bridge server startup
 */
export class ServerService {
    // TODO : See #10 @boltex Problem starting the leo-bridge server automatically with anaconda/miniconda on windows
    // See https://github.com/yhirose/vscode-filtertext/blob/master/src/extension.ts#L196

    private _platform: string;
    private _isWin32: boolean;

    /**
     * * Leo Bridge Server Process
     */
    private _serverProcess: child.ChildProcess | undefined;

    @others
}
</t>
<t tx="ekr.20200704142237.83">private _resolvePromise: ((value?: unknown) =&gt; void) | undefined;
private _rejectPromise: ((reason?: any) =&gt; void) | undefined;

private _isStarted: boolean = false;

constructor(
    private _context: vscode.ExtensionContext,
    private _leoIntegration: LeoIntegration
) {
    this._platform = os.platform();
    this._isWin32 = this._platform === "win32";
}

/**
 * * Splits the received data into lines and parses output to detect server start event
 * * Otherwise just outputs lines to the terminal Output
 * @param p_data Data object (not pure string)
 */
private _gotTerminalData(p_data: string): void {
    p_data.toString().split("\n").forEach(p_line =&gt; {
        p_line = p_line.trim();
        if (p_line) { // * std out process line by line: json shouldn't have line breaks
            if (p_line.startsWith(Constants.SERVER_STARTED_TOKEN)) {
                if (this._resolvePromise &amp;&amp; !this._isStarted) {
                    this._isStarted = true;
                    this._resolvePromise(p_line); // * Server confirmed started
                }
            }
            this._leoIntegration.addTerminalPaneEntry(p_line); // Output message anyways
        }
    });
}

</t>
<t tx="ekr.20200704142237.84">/**
 * * Get command from settings or best command for the current OS
 * @param p_leoPythonCommand String command to start python on this computer
 * @returns A promise that resolves when the server is started, or that is rejected in case of problem while starting
 */
public startServer(p_leoPythonCommand: string): Promise&lt;any&gt; {
    let w_pythonPath = "";
    this._leoIntegration.showTerminalPane();
    const w_serverScriptPath = this._context.extensionPath + Constants.SERVER_PATH;
    if (p_leoPythonCommand &amp;&amp; p_leoPythonCommand.length) {
        // Start by running command (see executeCommand for multiple useful snippets)
        w_pythonPath = p_leoPythonCommand; // Set path
        this._leoIntegration.addTerminalPaneEntry('Starting server with command: ' + p_leoPythonCommand);
    } else {
        w_pythonPath = Constants.DEFAULT_PYTHON;
        if (this._isWin32) {
            w_pythonPath = Constants.WIN32_PYTHON;
        }
        this._leoIntegration.addTerminalPaneEntry('Starting server with command : ' +
            w_pythonPath + ((this._isWin32 &amp;&amp; w_pythonPath === "py") ? " -3 " : "") +
            " " + w_serverScriptPath);
    }

    const w_serverStartPromise = new Promise((p_resolve, w_reject) =&gt; {
        // * Spawn a python child process for a leoBridge server
        this._resolvePromise = p_resolve;
        this._rejectPromise = w_reject;
    });

    let w_args: string[] = []; //  "\"" + w_serverScriptPath + "\"" // For on windows ??

    if (this._isWin32 &amp;&amp; w_pythonPath === "py") {
        w_args.push("-3");
    }
    w_args.push(w_serverScriptPath);
    this._serverProcess = child.spawn(w_pythonPath, w_args);

    if (this._serverProcess &amp;&amp; this._serverProcess.stdout) {
        // * Capture the python process output
        this._serverProcess.stdout.on("data", (p_data: string) =&gt; {
            this._gotTerminalData(p_data);
        });
    } else {
        console.error("No stdout");
    }
    if (this._serverProcess &amp;&amp; this._serverProcess.stderr) {
        // * Capture other python process outputs
        this._serverProcess.stderr.on("data", (p_data: string) =&gt; {
            console.log(`stderr: ${p_data}`);
            this._isStarted = false;
            utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);
            this._serverProcess = undefined;
            if (this._rejectPromise) {
                this._rejectPromise(`stderr: ${p_data}`);
            }
        });
    } else {
        console.error("No stderr");
    }
    if (this._serverProcess) {
        this._serverProcess!.on("close", (p_code: any) =&gt; {
            console.log(`leoBridge exited with code ${p_code}`);
            this._isStarted = false;
            utils.setContext(Constants.CONTEXT_FLAGS.SERVER_STARTED, false);
            this._serverProcess = undefined;
            if (this._rejectPromise) {
                this._rejectPromise(`leoBridge exited with code ${p_code}`);
            }
        });
    }

    return w_serverStartPromise;
}
</t>
<t tx="ekr.20200704142237.85">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import { LeoNode } from "./leoNode";

/**
 * * Types of the various JSON configuration keys such as treeKeepFocus, defaultReloadIgnore, etc.
 */
@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200704142237.86">export interface ConfigMembers {
    checkForChangeExternalFiles: string;
    defaultReloadIgnore: string;
    leoTreeBrowse: boolean;
    treeKeepFocus: boolean;
    treeKeepFocusWhenAside: boolean;
    statusBarString: string;
    statusBarColor: string;
    treeInExplorer: boolean;
    showOpenAside: boolean;
    showEditOnNodes: boolean;
    showArrowsOnNodes: boolean;
    showAddOnNodes: boolean;
    showMarkOnNodes: boolean;
    showCloneOnNodes: boolean;
    showCopyOnNodes: boolean;
    invertNodeContrast: boolean;
    leoPythonCommand: string;
    startServerAutomatically: boolean;
    connectToServerAutomatically: boolean;
    connectionAddress: string;
    connectionPort: number;
}

/**
 * * When refreshing the outline and getting to Leo's selected node
 */
</t>
<t tx="ekr.20200704142237.87">export const enum RevealType {
    NoReveal = 0, // In apToLeoNode conversion, If if the global revealType is "NoReveal" and its the selected node, re-use the old id
    Reveal,
    RevealSelect,
    RevealSelectFocus
}

/**
 * * User command's refresh-type for when coming back from executing the command
 */
</t>
<t tx="ekr.20200704142237.88">export const enum RefreshType {
    NoRefresh = 0, // only for 'copy-node' so far
    RefreshTree,   // Refresh tree and show body pane if not already opened, but no need to refresh it
    RefreshTreeAndBody // undo, redo, execute and others can also modify the current body, so refresh the filesystem gnx too
}

/**
 * * Command parameter for when 'stacking' front end commands
 */
</t>
<t tx="ekr.20200704142237.89">export interface UserCommand {
    action: string;
    node?: LeoNode | undefined;  // We can START a stack with a targeted command
    providedHeadline?: string | undefined;
    refreshType: RefreshType;
    fromOutline: boolean;
}

/**
 * * Actions to be performed by Leo, pushed and resolved as a stack
 */
</t>
<t tx="ekr.20200704142237.90">export interface LeoAction {
    parameter: string; // to pass along with action to python's side
    deferredPayload?: any | undefined; // Used when the action already has a return value ready but is also waiting for python's side
    resolveFn: (result: any) =&gt; void; // call that with an answer from python's (or other) side
    rejectFn: (reason: any) =&gt; void; // call if problem is encountered
}

/**
 * * Simple 'string log entry' package format
 */
</t>
<t tx="ekr.20200704142237.91">export interface LeoLogEntry {
    log: string;
}

/**
 * * ArchivedPosition format package from Leo's leoflexx.py
 */
</t>
<t tx="ekr.20200704142237.92">export interface ArchivedPosition {
    hasBody: boolean;       // bool(p.b),
    hasChildren: boolean;   // p.hasChildren()
    childIndex: number;     // p._childIndex
    cloned: boolean;        // p.isCloned()
    dirty: boolean;         // p.isDirty()
    expanded: boolean;      // p.isExpanded()
    gnx: string;            // p.v.gnx
    level: number;          // p.level()
    headline: string;       // p.h
    marked: boolean;        // p.isMarked()
    atFile: boolean         // p.isAnyAtFileNode():
    selected: boolean;      // p == commander.p
    u?: any;               // User Attributes
    stack: {
        gnx: string;        // stack_v.gnx
        childIndex: number; // stack_childIndex
        headline: string;   // stack_v.h
    }[];                    // for (stack_v, stack_childIndex) in p.stack]
}

</t>
<t tx="ekr.20200704142237.93">/**
 * * Main JSON information package format used between leointeg and Leo
 */
export interface LeoBridgePackage {
    id: number; // TODO : Could be used for error checking
    // * Each of those top level member is an answer from a Constants.LEOBRIDGE command
    allGnx?: string[];
    bodyLength?: number;
    bodyData?: string;
    node?: ArchivedPosition;
    nodes?: ArchivedPosition[];
    states?: LeoPackageStates;
    closed?: {
        total: number;
        filename?: string;
        node?: ArchivedPosition;
    },
    opened?: {
        total: number;
        filename: string;
        node: ArchivedPosition;
    },
    setOpened?: {
        total: number;
        filename: string;
        node: ArchivedPosition
    },
    openedFiles?: {
        index: number;
        files: LeoDocument[]
    }
    buttons?: LeoButton[]
}

</t>
<t tx="ekr.20200704142237.95">/**
 * * Icon path names used in leoNodes for rendering in treeview
 */
export interface Icon {
    light: string;
    dark: string;
}

</t>
<t tx="ekr.20200704142237.96">/**
 * * LeoBody virtual file time information object
 */
export interface BodyTimeInfo {
    gnx: string;
    ctime: number;
    mtime: number;
}

</t>
<t tx="ekr.20200704142237.97">/**
 * * Parameter structure used in the 'runSaveFileDialog' equivalent when asking user input
 */
export interface showSaveAsDialogParameters {
    // See TODO in leoAsync.ts
    "initialFile": string;
    "title": string;
    "message": string;
    "filetypes": string[];
    "defaultExtension": string;
}

</t>
<t tx="ekr.20200704142237.98">/**
 * * Parameter structure used in the 'runAskYesNoDialog' equivalent when asking user input
 */
export interface runAskYesNoDialogParameters {
    "ask": string;
    "message": string;
    "yes_all": boolean;
    "no_all": boolean;
}

</t>
<t tx="ekr.20200704142237.99">/**
 * * Parameter structure used in the 'runAskOkDialog' equivalent when showing a warning
 */
export interface runWarnMessageDialogParameters {
    "warn": string;
    "message": string;
}

</t>
<t tx="ekr.20200712055600.63">@path C:/leo.repo/leointeg/src/

// @button node implementation for usage with the leoButtons.ts treeview provider
import * as vscode from "vscode";
import { Constants } from "./constants";
import { LeoButton, Icon } from "./types";
import { LeoIntegration } from "./leoIntegration";

/**
 * * Leo @buttons tree view node item implementation for usage in a TreeDataProvider
 */
@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200712055600.64">export class LeoButtonNode extends vscode.TreeItem {

    public contextValue: string; // * Context string is checked in package.json with 'when' clauses
    private _isAdd: boolean;

    constructor(
        public button: LeoButton,
        private _leoIntegration: LeoIntegration
    ) {
        super(button.name);
        // * Setup this instance
        this.command = {
            command: Constants.NAME + "." + Constants.COMMANDS.CLICK_BUTTON,
            title: '',
            arguments: [this]
        };
        this._isAdd = (this.button.index === "nullButtonWidget 1" &amp;&amp; this.button.name === "script-button");
        this.contextValue = "leoButtonNode";
    }

    public get iconPath(): Icon {
        return this._leoIntegration.buttonIcons[this._isAdd ? 1 : 0];
    }

    public get id(): string {
        // Add prefix and suffix salt to index prevent accidental duplicates
        return "p" + this.button.index + "s" + this.button.name;
    }

    public get tooltip(): string {
        if (this._isAdd) {
            return Constants.USER_MESSAGES.SCRIPT_BUTTON_TOOLTIP;
        } else {
            return this.button.name;
        }
    }

    public get description(): string | boolean {
        if (this._isAdd) {
            return Constants.USER_MESSAGES.SCRIPT_BUTTON;
        } else {
            return false;
        }
    }

}
</t>
<t tx="ekr.20200712055600.65">@path C:/leo.repo/leointeg/src/
import * as vscode from "vscode";
import { LeoIntegration } from "./leoIntegration";
import { LeoButtonNode } from "./leoButtonNode";
import { ProviderResult } from "vscode";
import { Constants } from "./constants";
import { LeoButton } from "./types";

/**
 * * '@buttons' shown as a list with this TreeDataProvider implementation
 */
@others
@language typescript
@tabwidth -4
</t>
<t tx="ekr.20200712055600.66">export class LeoButtonsProvider implements vscode.TreeDataProvider&lt;LeoButtonNode&gt; {

    private _onDidChangeTreeData: vscode.EventEmitter&lt;LeoButtonNode | undefined&gt; = new vscode.EventEmitter&lt;LeoButtonNode | undefined&gt;();

    readonly onDidChangeTreeData: vscode.Event&lt;LeoButtonNode | undefined&gt; = this._onDidChangeTreeData.event;

    constructor(private _leoIntegration: LeoIntegration) { }

    /**
     * * Refresh the whole outline
     */
    @others
}
</t>
<t tx="ekr.20200712055600.67">public refreshTreeRoot(): void {
    this._onDidChangeTreeData.fire(undefined);
}

</t>
<t tx="ekr.20200712055600.68">public getTreeItem(element: LeoButtonNode): Thenable&lt;LeoButtonNode&gt; | LeoButtonNode {
    return element;
}

</t>
<t tx="ekr.20200712055600.69">public getChildren(element?: LeoButtonNode): Thenable&lt;LeoButtonNode[]&gt; {

    // if called with element, or not ready, give back empty array as there won't be any children
    if (this._leoIntegration.leoStates.fileOpenedReady &amp;&amp; !element) {

        // call action to get get list, and convert to LeoButtonNode(s) array
        return this._leoIntegration.sendAction(Constants.LEOBRIDGE.GET_BUTTONS).then(p_package =&gt; {
            if (p_package &amp;&amp; p_package) {
                const w_list: LeoButtonNode[] = [];
                const w_buttons: LeoButton[] = p_package.buttons!;
                if (w_buttons &amp;&amp; w_buttons.length) {
                    w_buttons.forEach((i_button: LeoButton) =&gt; {
                        w_list.push(new LeoButtonNode(i_button, this._leoIntegration));
                    });
                }
                return Promise.resolve(w_list);
            } else {
                return Promise.resolve([]);
            }
        });
    } else {
        return Promise.resolve([]); // Defaults to an empty list of children
    }
}

</t>
<t tx="ekr.20200712055600.70">public getParent(element: LeoButtonNode): ProviderResult&lt;LeoButtonNode&gt; | null {
    return null; // A list, as such, entries are always child of root, so return null
}

</t>
<t tx="ekr.20200712063635.1">def _returnNo(self, *arguments):
    '''Used to override g.app.gui.ask[XXX] dialogs answers'''
    return "no"

</t>
<t tx="ekr.20200712063636.1">def _returnYes(self, *arguments):
    '''Used to override g.app.gui.ask[XXX] dialogs answers'''
    return "yes"

</t>
<t tx="ekr.20200712063843.1">def getOpenedFiles(self, p_package):
    '''Return array of opened file path/names to be used as openFile parameters to switch files'''
    w_files = []
    w_index = 0
    w_indexFound = 0
    for w_commander in self.g.app.commanders():
        if w_commander.closed == False:
            w_isSelected = False
            w_isChanged = w_commander.changed
            if self.commander == w_commander:
                w_indexFound = w_index
                w_isSelected = True
            w_entry = {"name": w_commander.mFileName, "index": w_index,
                       "changed": w_isChanged, "selected": w_isSelected}
            w_files.append(w_entry)
            w_index = w_index + 1

    w_openedFiles = {"files": w_files, "index": w_indexFound}

    return self.sendLeoBridgePackage("openedFiles", w_openedFiles)

</t>
<t tx="ekr.20200712063845.1">def setOpenedFile(self, p_package):
    '''Choose the new active commander from array of opened file path/names by numeric index'''
    w_openedCommanders = []

    for w_commander in self.g.app.commanders():
        if w_commander.closed == False:
            w_openedCommanders.append(w_commander)

    w_index = p_package['index']

    if w_openedCommanders[w_index]:
        self.commander = w_openedCommanders[w_index]

    if self.commander:
        self.commander.closed = False
        self.create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self.p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage("setOpened", w_result)
    else:
        return self.outputError('Error in setOpenedFile')

</t>
<t tx="ekr.20200712063947.1">def getStates(self, p_package):
    """
    Gets the currently opened file's general states for UI enabled/disabled states
    such as undo available, file changed/unchanged
    """
    w_states = {}
    if self.commander:
        try:
            w_states["changed"] = self.commander.changed   # 'dirty/changed' member
            w_states["canUndo"] = self.commander.canUndo()
            w_states["canRedo"] = self.commander.canRedo()
            w_states["canDemote"] = self.commander.canDemote()
            w_states["canPromote"] = self.commander.canPromote()
            w_states["canDehoist"] = self.commander.canDehoist()

        except Exception as e:
            self.g.trace('Error while getting states')
            print("Error while getting states")
            print(str(e))
    else:
        w_states["changed"] = False
        w_states["canUndo"] = False
        w_states["canRedo"] = False
        w_states["canDemote"] = False
        w_states["canPromote"] = False
        w_states["canDehoist"] = False

    return self.sendLeoBridgePackage("states", w_states)

</t>
<t tx="ekr.20200712063947.2">def getButtons(self, p_package):
    '''Gets the currently opened file's @buttons list'''
    w_buttons = []
    if self.commander.theScriptingController and self.commander.theScriptingController.buttonsDict:
        w_dict = self.commander.theScriptingController.buttonsDict
        for w_key in w_dict:
            w_entry = {"name": w_dict[w_key], "index": str(w_key)}
            w_buttons.append(w_entry)
    return self.sendLeoBridgePackage("buttons", w_buttons)

</t>
<t tx="ekr.20200712063947.3">def clickButton(self, p_package):
    '''Handles buttons clicked in vscode from the '@button' panel'''
    w_index = p_package['index']
    w_dict = self.commander.theScriptingController.buttonsDict
    w_button = None
    for i_key in w_dict:
        if(str(i_key) == w_index):
            w_button = i_key
    if w_button:
        w_button.command()  # run clicked button command
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="ekr.20200712063948.1">def removeButton(self, p_package):
    '''Removes an entry from the buttonsDict by index string'''
    w_index = p_package['index']
    w_dict = self.commander.theScriptingController.buttonsDict
    w_key = None
    for i_key in w_dict:
        if(str(i_key) == w_index):
            w_key = i_key
    if w_key:
        del(w_dict[w_key])  # delete object member
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="ekr.20200712064119.1"></t>
<t tx="ekr.20200712064428.1">def pageUp(self, p_ap):
    """Selects a node a couple of steps up in the tree to simulate page up"""
    self.commander.selectVisBack()
    self.commander.selectVisBack()
    self.commander.selectVisBack()
    return self.outputPNode(self.commander.p)

</t>
<t tx="ekr.20200712064428.10">def contractOrGoLeft(self, p_ap):
    """Simulate the left Arrow Key in folder of Windows Explorer."""
    return self.outlineCommand("contractNodeOrGoToParent", p_ap)

</t>
<t tx="ekr.20200712064428.11">def expandAndGoRight(self, p_ap):
    """If a node has children, expand it if needed and go to the first child."""
    return self.outlineCommand("expandNodeAndGoToFirstChild", p_ap)

</t>
<t tx="ekr.20200712064428.2">def pageDown(self, p_ap):
    """Selects a node a couple of steps down in the tree to simulate page down"""
    self.commander.selectVisNext()
    self.commander.selectVisNext()
    self.commander.selectVisNext()
    return self.outputPNode(self.commander.p)

</t>
<t tx="ekr.20200712064428.3">def gotoFirstVisible(self, p_ap):
    """Select the first visible node of the selected chapter or hoist."""
    return self.outlineCommand("goToFirstVisibleNode", p_ap)

</t>
<t tx="ekr.20200712064428.4">def gotoLastVisible(self, p_ap):
    """Select the last visible node of selected chapter or hoist."""
    return self.outlineCommand("goToLastVisibleNode", p_ap)

</t>
<t tx="ekr.20200712064428.5">def gotoLastSibling(self, p_ap):
    """Select the last sibling of the selected node."""
    return self.outlineCommand("goToLastSibling", p_ap)

</t>
<t tx="ekr.20200712064428.6">def gotoNextVisible(self, p_ap):
    """Select the visible node following the presently selected node."""
    return self.outlineCommand("selectVisNext", p_ap)

</t>
<t tx="ekr.20200712064428.7">def gotoPrevVisible(self, p_ap):
    """Select the visible node preceding the presently selected node."""
    return self.outlineCommand("selectVisBack", p_ap)

</t>
<t tx="ekr.20200712064428.8">def gotoNextMarked(self, p_ap):
    """Select the next marked node."""
    return self.outlineCommand("goToNextMarkedHeadline", p_ap)

</t>
<t tx="ekr.20200712064428.9">def gotoNextClone(self, p_ap):
    """
    Select the next node that is a clone of the selected node.
    If the selected node is not a clone, do find-next-clone.
    """
    return self.outlineCommand("goToNextClone", p_ap)

</t>
<t tx="ekr.20200712071738.1"></t>
<t tx="ekr.20200712071756.1"></t>
<t tx="ekr.20200712080426.1"></t>
<t tx="ekr.20200712083036.1">@language typescript
</t>
<t tx="ekr.20200712164636.1"></t>
<t tx="ekr.20200712165519.1"></t>
<t tx="ekr.20200712165621.1"></t>
<t tx="ekr.20200712165659.1"></t>
<t tx="ekr.20200712165730.1"></t>
<t tx="ekr.20200712165800.1"></t>
<t tx="ekr.20200713082426.1">To do:

- Remember recent .leo files.
- git-diff command
</t>
<t tx="ekr.20200715162627.1">c.backup_helper(sub_dir='leoInteg')
</t>
<t tx="ekr.20200715163240.1">/**
 * * Reveals the leoBridge server terminal output if not already visible
 */
public showTerminalPane(): void {
    if (this._leoTerminalPane) {
        this._leoTerminalPane.show(true);
    }
}

</t>
<t tx="ekr.20200715163240.2">/**
 * * Hides the leoBridge server terminal output
 */
public hideTerminalPane(): void {
    if (this._leoTerminalPane) {
        this._leoTerminalPane.hide();
    }
}

</t>
<t tx="ekr.20200715163240.3">/**
 * * Adds a message string to leoInteg's leoBridge server terminal output.
 * @param p_message The string to be added in the log
 */
public addTerminalPaneEntry(p_message: string): void {
    if (this._leoTerminalPane) {
        this._leoTerminalPane.appendLine(p_message);
    }
}

</t>
<t tx="ekr.20200715163240.4">/**
 * * Reveals the log pane if not already visible
 */
public showLogPane(): void {
    this._leoLogPane.show(true);
}

</t>
<t tx="ekr.20200715163240.5">/**
 * * Hides the log pane
 */
public hideLogPane(): void {
    this._leoLogPane.hide();
}

</t>
<t tx="ekr.20200715163512.1">/**
 * * Handle the change of visibility of either outline treeview and refresh it if its visible
 * @param p_event The treeview-visibility-changed event passed by vscode
 * @param p_explorerView Flag to signify that the treeview who triggered this event is the one in the explorer view
 */
private _onButtonsTreeViewVisibilityChanged(p_event: vscode.TreeViewVisibilityChangeEvent, p_explorerView: boolean): void {
    if (p_explorerView) {
        // (Facultative/unused) Do something different if explorer view is used, instead of the standalone outline pane
    }
    if (p_event.visible) {
        this._leoButtonsProvider.refreshTreeRoot();
    }
}

</t>
<t tx="ekr.20200715163630.1">/**
 * * Places selection on the required node in a 'timeout'. Used after refreshing the opened Leo documents view.
 * @param p_documentNode Document node instance in the Leo document view to be the 'selected' one.
 */
public setDocumentSelection(p_documentNode: LeoDocumentNode): void {
    this._currentDocumentChanged = p_documentNode.documentEntry.changed;
    this.leoStates.leoOpenedFileName = p_documentNode.documentEntry.name;
    @others
    setTimeout(() =&gt; {
        if (!this._leoDocuments.visible &amp;&amp; !this._leoDocumentsExplorer.visible) {
            return;
        }
        let w_trigger = false;
        let w_docView: vscode.TreeView&lt;LeoDocumentNode&gt;;
        if (this._leoDocuments.visible) {
            w_docView = this._leoDocuments;
        } else {
            w_docView = this._leoDocumentsExplorer;
        }
        if (w_docView.selection.length &amp;&amp; w_docView.selection[0] === p_documentNode) {
            // console.log('already selected!');
        } else {
            w_trigger = true;
        }
        if (w_trigger) {
            w_docView.reveal(p_documentNode, { select: true, focus: false });
        }
    });
}

</t>
<t tx="ekr.20200715163630.2">/**
 * * Show the outline, with Leo's selected node also selected, and optionally focussed
 * @param p_focusOutline Flag for focus to be placed in outline
 */
public showOutline(p_focusOutline: boolean): void {
    if (this._lastSelectedNode) {
        this._lastVisibleTreeView.reveal(this._lastSelectedNode, {
            select: true,
            focus: p_focusOutline
        }).then(() =&gt; {
            // console.log('done showing/revealing outline');
        });
    }
}

</t>
<t tx="ekr.20200715163630.3">/**
 * * Refresh tree for node hover icons refresh only
 */
public configTreeRefresh(): void {
    if (this.leoStates.fileOpenedReady &amp;&amp; this.lastSelectedNode) {
        this._revealType = RevealType.RevealSelect;
        this._preventShowBody = true;
        this._leoTreeDataProvider.refreshTreeRoot();
    }
}

</t>
<t tx="ekr.20200715164553.1">/**
 * * Invoke an '@button' click directly by index string. Used by '@buttons' treeview.
 */
public clickButton(p_node: LeoButtonNode): void {
    if (this._isBusy()) { return; } // Warn user to wait for end of busy state
    this._leoBridge.action(Constants.LEOBRIDGE.CLICK_BUTTON, JSON.stringify({ "index": p_node.button.index }))
        .then((p_clickButtonResult: LeoBridgePackage) =&gt; {
            // console.log('Back from clickButton, package is: ', p_clickButtonResult);
            this.launchRefresh(RefreshType.RefreshTreeAndBody, false);
        });
}

</t>
<t tx="ekr.20200715164554.1">/**
 * * Removes an '@button' from Leo's button dict, directly by index string. Used by '@buttons' treeview.
 */
public removeButton(p_node: LeoButtonNode): void {
    if (this._isBusy()) { return; } // Warn user to wait for end of busy state
    this._leoBridge.action(Constants.LEOBRIDGE.REMOVE_BUTTON, JSON.stringify({ "index": p_node.button.index }))
        .then((p_removeButtonResult: LeoBridgePackage) =&gt; {
            // console.log('Back from removeButton, package is: ', p_removeButtonResult);
            this.launchRefresh(RefreshType.RefreshTreeAndBody, false);
        });
}

</t>
<t tx="ekr.20200715164711.1">/**
 * * Shows an 'Open Leo File' dialog window and opens the chosen file
 * * If not shown already, it also shows the outline, body and log panes along with leaving focus in the outline
 */
public openLeoFile(): void {
    if (this._isBusy()) { return; } // Warn user to wait for end of busy state
    this._leoFilesBrowser.getLeoFileUrl()
        .then(p_chosenLeoFile =&gt; {
            return this.sendAction(Constants.LEOBRIDGE.OPEN_FILE, '"' + p_chosenLeoFile + '"');
        }, p_errorGetFile =&gt; {
            return Promise.reject(p_errorGetFile);
        })
        .then((p_openFileResult: LeoBridgePackage) =&gt; {
            return this._setupOpenedLeoDocument(p_openFileResult.opened);
        }, p_errorOpen =&gt; {
            console.log('in .then not opened or already opened');
            return Promise.reject(p_errorOpen);
        });
}

</t>
<t tx="ekr.20200715164711.2">/**
 * * Set the outline pane top bar string message
 * @param p_title new string to replace the current title
 */
public setTreeViewTitle(p_title?: string): void {
    if (p_title) {
        this._currentOutlineTitle = p_title;
    }
    // * Set/Change outline pane title e.g. "INTEGRATION", "OUTLINE"
    if (this._leoTreeStandaloneView) {
        this._leoTreeStandaloneView.title = this._currentOutlineTitle;
    }
    if (this._leoTreeExplorerView) {
        this._leoTreeExplorerView.title = Constants.GUI.EXPLORER_TREEVIEW_PREFIX + this._currentOutlineTitle;
    }
}

</t>
<t tx="ekr.20200715164711.3">/**
 * * Offer all leo commands in the command palette (This opens the palette with string '&gt;leo:' already typed)
 */
public showLeoCommands(): void {
    vscode.commands.executeCommand(Constants.VSCODE_COMMANDS.QUICK_OPEN, Constants.GUI.QUICK_OPEN_LEO_COMMANDS);
}

</t>
<t tx="ekr.20200715164711.4">/**
 * * StatusBar click handler
 */
public statusBarOnClick(): void {
    if (this.leoStates.fileOpenedReady) {
        this.switchLeoFile();
    } else {
        this.showLeoCommands();
    }
}

</t>
<t tx="ekr.20200715164711.5">public test(p_fromOutline?: boolean): void {
    this.statusBarOnClick(); // placeholder / test
}
</t>
<t tx="ekr.20200715170035.1">@nosearch

# flattened, word, ignore-case, head, body

# found 8 nodes

@language typescript</t>
<t tx="ekr.20200716081515.1">"""Remove unused non-organizer nodes. Split nodes with parse-body"""

@others

for p in c.all_positions():
    if p.isAtCleanNode():
        mark_tree(p)
c.redraw()
c.selectPosition(c.rootPosition())
c.goToNextMarkedHeadline()
</t>
<t tx="ekr.20200716081737.1">def mark_tree(root):
    """Mark all nodes of an @clean tree that probably should change."""
    for p in root.subtree():
        mark_node(p)
    # Make sure we don't actually change any files.
    root.clearDirty()
</t>
<t tx="ekr.20200716081901.1">def mark_node(p):
    """Mark node p if it should be deleted or split."""
    if not p.hasChildren() and not p.b.strip():
        p.setMarked()
        g.trace('  Delete:', p.h)
        return
    if p.hasChildren():
        return
    # Similar to ic.parse_body.
    ic = c.importCommands
    language = g.scanForAtLanguage(c, p)
    ext = '.' + g.app.language_extension_dict.get(language)
    parser = ic.body_parser_for_ext(ext)
    if not parser:
        return
    s = p.b
    p.b = ''  # Required.
    try:
        parser(p, s)
        n = p.numberOfChildren()
        n_s = 'child' if n == 1 else 'children'
        if n &gt; 1:
            p.setMarked()
            g.trace(f"  Split: {p.h}, {n} {n_s}")
    except Exception:
        g.es_exception()
        raise
    finally:
        p.b = s
        p.deleteAllChildren()</t>
<t tx="ekr.20200716084530.1">private _getNodeContextValue(): string {
    let w_contextValue = Constants.CONTEXT_FLAGS.NODE_UNMARKED; // * Start it with 'leoNodeMarked' or 'leoNodeUnmarked'
    if (this.marked) {
        w_contextValue = Constants.CONTEXT_FLAGS.NODE_MARKED;
    }
    if (this.atFile) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ATFILE; // * then append 'leoNodeAtFile' to existing if needed
    }
    if (this.cloned) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_CLONED; // * then append 'leoNodeCloned' to existing if needed
    }
    if (this.isRoot) {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_ROOT;
    } else {
        w_contextValue += Constants.CONTEXT_FLAGS.NODE_NOT_ROOT;
    }
    return w_contextValue;
}

</t>
<t tx="ekr.20200716084640.1">export interface LeoPackageStates {
    changed: boolean;
    canUndo: boolean;
    canRedo: boolean;
    canDemote: boolean;
    canPromote: boolean;
    canDehoist: boolean;
}

</t>
<t tx="ekr.20200716084817.1">/**
 * * Leo document structure used in the 'Opened Leo Documents' tree view provider sent back by the server
 */
export interface LeoDocument {
    name: string;
    index: number;
    changed: boolean;
    selected: boolean;
}

</t>
<t tx="ekr.20200716084817.2">/**
 * * Leo '@button' structure used in the '@buttons' tree view provider sent back by the server
 */
export interface LeoButton {
    name: string;
    index: string; // STRING KEY
}

</t>
<t tx="ekr.20200716085917.1">/**
 * * Build all possible strings for buttons icons graphic file paths
 * @param p_context Needed to get to absolute paths on the system
 * @returns An array containing icons for the documents tree view
 */
export function buildButtonsIconPaths(p_context: vscode.ExtensionContext): Icon[] {
    return [
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON)
        },
        {
            light: p_context.asAbsolutePath(Constants.GUI.ICON_LIGHT_BUTTON_ADD),
            dark: p_context.asAbsolutePath(Constants.GUI.ICON_DARK_BUTTON_ADD)
        }
    ];
}

</t>
<t tx="ekr.20200716085955.1">def _idleTime(self, fn, delay, tag):
    # TODO : REVISE/REPLACE WITH OWN SYSTEM
    asyncio.get_event_loop().create_task(self._asyncIdleLoop(delay/1000, fn))

</t>
<t tx="ekr.20200716085955.2">def _getTotalOpened(self):
    '''Get total of opened commander (who have closed == false)'''
    w_total = 0
    for w_commander in self.g.app.commanders():
        if w_commander.closed == False:
            w_total = w_total + 1
    return w_total

</t>
<t tx="ekr.20200716085955.3">def _getFirstOpenedCommander(self):
    '''Get first opened commander, or False if there are none.'''
    for w_commander in self.g.app.commanders():
        if w_commander.closed == False:
            return w_commander
    return False

</t>
<t tx="felix.20191126232434.10">def outputPNode(self, p_node=False):
    if p_node:
        return self.sendLeoBridgePackage("node", self.p_to_ap(p_node))  # Single node, singular
    else:
        return self.sendLeoBridgePackage("node", None)

</t>
<t tx="felix.20191126232434.11">def outputPNodes(self, p_pList):
    w_apList = []
    for p in p_pList:
        w_apList.append(self.p_to_ap(p))
    return self.sendLeoBridgePackage("nodes", w_apList)  # Multiple nodes, plural

</t>
<t tx="felix.20191126232434.13">def openFile(self, p_file):
    """
    Open a leo file via leoBridge controller, or create a new document if empty string.
    Returns an object that contains a 'opened' member.
    """
    w_found = False

    # If not empty string (asking for New file) then check if already opened
    if p_file:
        for w_commander in self.g.app.commanders():
            if w_commander.fileName() == p_file:
                w_found = True
                self.commander = w_commander

    if not w_found:
        self.commander = self.bridge.openLeoFile(p_file)  # create self.commander

    # Leo at this point has done this too: g.app.windowList.append(c.frame)
    # and so this now app.commanders() yields this: return [f.c for f in g.app.windowList]

    # did this add to existing array of g.app.commanders() ?
    # print(*self.g.app.commanders(), sep='\n')

    if self.commander:
        self.commander.closed = False
        self.create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self.p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage("opened", w_result)
    else:
        return self.outputError('Error in openFile')

</t>
<t tx="felix.20191126232434.14">def closeFile(self, p_package):
    """
    Closes a leo file. A file can then be opened with "openFile"
    Returns an object that contains a 'closed' member
    """
    # TODO : Specify which file to support multiple opened files
    if self.commander:
        if p_package["forced"] and self.commander.changed:
            # return "no" g.app.gui.runAskYesNoDialog  and g.app.gui.runAskYesNoCancelDialog
            self.commander.revert()
        if p_package["forced"] or not self.commander.changed:
            self.commander.closed = True
            self.commander.close()
        else:
            return self.sendLeoBridgePackage('closed', False)  # Cannot close, ask to save, ignore or cancel

    # Switch commanders to first available
    w_total = self._getTotalOpened()
    if w_total:
        self.commander = self._getFirstOpenedCommander()
    else:
        self.commander = None

    if self.commander:
        self.create_gnx_to_vnode()
        w_result = {"total": self._getTotalOpened(), "filename": self.commander.fileName(),
                    "node": self.p_to_ap(self.commander.p)}
        return self.sendLeoBridgePackage("closed", w_result)
    else:
        w_result = {"total": 0}
        return self.sendLeoBridgePackage("closed", w_result)

</t>
<t tx="felix.20191126232434.15">def getPNode(self, p_ap):
    '''EMIT OUT a node, don't select it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            return self.outputPNode(w_p)
        else:
            return self.outputError("Error in getPNode no w_p node found")
    else:
        return self.outputError("Error in getPNode no param p_ap")

</t>
<t tx="felix.20191126232434.16">def getChildren(self, p_ap):
    '''EMIT OUT list of children of a node'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p and w_p.hasChildren():
            return self.outputPNodes(w_p.children())
        else:
            return self.outputPNodes([])  # default empty array
    else:
        if self.commander.hoistStack:
            return self.outputPNodes([self.commander.hoistStack[-1].p])
        else:
            return self.outputPNodes(self.yieldAllRootChildren())  # this outputs all Root Children

</t>
<t tx="felix.20191126232434.17">def getParent(self, p_ap):
    '''EMIT OUT the parent of a node, as an array, even if unique or empty'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p and w_p.hasParent():
            return self.outputPNode(w_p.getParent())
        else:
            return self.outputPNode()  # default empty for root
    else:
        return self.outputPNode()

</t>
<t tx="felix.20191126232434.18">def getSelectedNode(self, p_paramUnused):
    '''EMIT OUT Selected Position as an array, even if unique'''
    if self.commander.p:
        return self.outputPNode(self.commander.p)
    else:
        return self.outputPNode()

</t>
<t tx="felix.20191126232434.19">def getBody(self, p_gnx):
    '''EMIT OUT body of a node'''
    if p_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(p_gnx)  # vitalije
        if w_v:
            if w_v.b:
                return self.outputBodyData(w_v.b)
            else:
                return self.outputBodyData()  # default "" empty string
        else:
            return self.sendLeoBridgePackage()  # empty as inexistent
    else:
        return self.sendLeoBridgePackage()  # empty as inexistent

</t>
<t tx="felix.20191126232434.2">@path C:/leo.repo/leointeg/
#! python3
@language python
@tabwidth -4
&lt;&lt; imports &gt;&gt;
&lt;&lt; constants &gt;&gt;
@others
if __name__ == '__main__':
    # Startup
    try:
        main()
    except KeyboardInterrupt:
        print("\nKeyboard Interupt: Stopping leobridge server", flush=True)
        sys.exit()
</t>
<t tx="felix.20191126232434.20">def getBodyLength(self, p_gnx):
    '''EMIT OUT body string length of a node'''
    if p_gnx:
        w_v = self.commander.fileCommands.gnxDict.get(p_gnx)  # vitalije
        if w_v and len(w_v.b):
            return self.sendLeoBridgePackage("bodyLength", len(w_v.b))
        else:
            return self.sendLeoBridgePackage("bodyLength", 0)
    else:
        # TODO : May need to signal inexistent by self.sendLeoBridgePackage()  # empty as inexistent
        return self.sendLeoBridgePackage("bodyLength", 0)

</t>
<t tx="felix.20191126232434.21">def setNewBody(self, p_body):
    '''Change Body of selected node'''
    # TODO : This method is unused for now? Remove if unnecessary.
    # TODO : Does this support 'Undo'?
    if self.commander.p:
        self.commander.p.b = p_body['body']
        return self.outputPNode(self.commander.p)
    else:
        return self.outputError("Error in setNewBody")

</t>
<t tx="felix.20191126232434.22">def setBody(self, p_package):
    '''Change Body text of a node'''
    for w_p in self.commander.all_positions():
        if w_p.v.gnx == p_package['gnx']:  # found
            # TODO : Before setting undo and trying to set body, first check if different than existing body
            w_bunch = self.commander.undoer.beforeChangeNodeContents(w_p)  # setup undoable operation
            w_p.v.setBodyString(p_package['body'])
            self.commander.undoer.afterChangeNodeContents(w_p, "Body Text", w_bunch)
            if not self.commander.isChanged():
                self.commander.setChanged()
            if not w_p.v.isDirty():
                w_p.setDirty()
            break
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.23">def setNewHeadline(self, p_package):
    '''Change Headline of a node'''
    w_newHeadline = p_package['text']
    w_ap = p_package['node']
    if w_ap:
        w_p = self.ap_to_p(w_ap)
        if w_p:
            # set this node's new headline
            w_bunch = self.commander.undoer.beforeChangeNodeContents(w_p)
            w_p.h = w_newHeadline
            self.commander.undoer.afterChangeNodeContents(w_p, 'Change Headline', w_bunch)
            return self.outputPNode(w_p)
    else:
        return self.outputError("Error in setNewHeadline")

</t>
<t tx="felix.20191126232434.24">def setSelectedNode(self, p_ap):
    '''Select a node, or the first one found with its GNX'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            if self.commander.positionExists(w_p):
                # set this node as selection
                self.commander.selectPosition(w_p)
            else:
                w_foundPNode = self.findPNodeFromGnx(p_ap['gnx'])
                if w_foundPNode:
                    self.commander.selectPosition(w_foundPNode)
                else:
                    print("Set Selection node does not exist! ap was:" + json.dumps(p_ap))
    # * return the finally selected node
    if self.commander.p:
        return self.outputPNode(self.commander.p)
    else:
        return self.outputPNode()

</t>
<t tx="felix.20191126232434.25">def expandNode(self, p_ap):
    '''Expand a node'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_p.expand()
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.26">def collapseNode(self, p_ap):
    '''Collapse a node'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_p.contract()
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20191126232434.27">def create_gnx_to_vnode(self):
    '''Make the first gnx_to_vnode array with all unique nodes'''
    t1 = time.process_time()
    self.gnx_to_vnode = {v.gnx: v for v in self.commander.all_unique_nodes()}
    # This is likely the only data that ever will be needed.
    if 0:
        print('app.create_all_data: %5.3f sec. %s entries' % (
            (time.process_time()-t1), len(list(self.gnx_to_vnode.keys()))))
    self.test_round_trip_positions()

</t>
<t tx="felix.20191126232434.28">def test_round_trip_positions(self):
    '''(From Leo plugin leoflexx.py) Test the round tripping of p_to_ap and ap_to_p.'''
    # Bug fix: p_to_ap updates app.gnx_to_vnode. Save and restore it.
    old_d = self.gnx_to_vnode.copy()
    old_len = len(list(self.gnx_to_vnode.keys()))
    t1 = time.process_time()
    qtyAllPositions = 0
    for p in self.commander.all_positions():
        qtyAllPositions += 1
        ap = self.p_to_ap(p)
        p2 = self.ap_to_p(ap)
        assert p == p2, (repr(p), repr(p2), repr(ap))
    gnx_to_vnode = old_d
    new_len = len(list(gnx_to_vnode.keys()))
    assert old_len == new_len, (old_len, new_len)
    print('Leo file opened. Its outline contains ' + str(qtyAllPositions) + " nodes positions.")
    print(('Testing app.test_round_trip_positions for all nodes: Total time: %5.3f sec.' % (time.process_time()-t1)))

</t>
<t tx="felix.20191126232434.29">def yieldAllRootChildren(self):
    '''Return all root children P nodes'''
    p = self.commander.rootPosition()
    while p:
        yield p
        p.moveToNext()

</t>
<t tx="felix.20191126232434.30">def ap_to_p(self, ap):
    '''(From Leo plugin leoflexx.py) Convert an archived position to a true Leo position.'''
    childIndex = ap['childIndex']
    v = self.gnx_to_vnode[ap['gnx']]
    stack = [
        (self.gnx_to_vnode[d['gnx']], d['childIndex'])
        for d in ap['stack']
    ]
    return leoNodes.position(v, childIndex, stack)

</t>
<t tx="felix.20191126232434.31">def p_to_ap(self, p):
    '''(From Leo plugin leoflexx.py) Converts Leo position to a serializable archived position.'''
    if not p.v:
        print('app.p_to_ap: no p.v: %r %s' % (p))
        assert False
    p_gnx = p.v.gnx
    if p_gnx not in self.gnx_to_vnode:
        self.gnx_to_vnode[p_gnx] = p.v
    # * necessary properties for outline
    w_ap = {
        'childIndex': p._childIndex,
        'gnx': p.v.gnx,
        'level': p.level(),
        'headline': p.h,
        'stack': [{
            'gnx': stack_v.gnx,
            'childIndex': stack_childIndex,
            'headline': stack_v.h,
        } for (stack_v, stack_childIndex) in p.stack],
    }
    # TODO : Convert all those booleans into an 8 bit integer 'status' flag
    if p.v.u:
        w_ap['u'] = p.v.u
    if bool(p.b):
        w_ap['hasBody'] = True
    if p.hasChildren():
        w_ap['hasChildren'] = True
    if p.isCloned():
        w_ap['cloned'] = True
    if p.isDirty():
        w_ap['dirty'] = True
    if p.isExpanded():
        w_ap['expanded'] = True
    if p.isMarked():
        w_ap['marked'] = True
    if p.isAnyAtFileNode():
        w_ap['atFile'] = True
    if p == self.commander.p:
        w_ap['selected'] = True
    return w_ap


</t>
<t tx="felix.20191126232434.4">class LeoBridgeIntegController:
    '''Leo Bridge Controller'''

    @others
</t>
<t tx="felix.20191126232434.5">def __init__(self):
    # TODO : @boltex #74 need gnx_to_vnode for each opened file/commander
    self.gnx_to_vnode = []  # utility array - see leoflexx.py in leoPluginsRef.leo
    self.bridge = leoBridge.controller(gui='nullGui',
                                       loadPlugins=True,  # True: attempt to load plugins.
                                       readSettings=True,  # True: read standard settings files.
                                       silent=True,      # True: don't print signon messages.
                                       verbose=False)     # True: prints messages that would be sent to the log pane.
    self.g = self.bridge.globals()

    # * Trace outputs to pythons stdout, also prints the function call stack
    # self.g.trace('test trace')

    # * Intercept Log Pane output: Sends to vsCode's log pane
    self.g.es = self.es  # pointer - not a function call

    # print(dir(self.g))
    self.currentActionId = 1  # Id of action being processed, STARTS AT 1 = Initial 'ready'

    # * Currently Selected Commander (opened from leo.core.leoBridge or chosen via the g.app.windowList frame list)
    self.commander = None

    self.leoIntegConfig = None
    self.webSocket = None
    self.loop = None

    # * Replacement instances to Leo's codebase : IdleTime, idleTimeManager and externalFilesController
    self.g.IdleTime = self._idleTime
    self.g.app.idleTimeManager = IdleTimeManager(self.g)
    # attach instance to g.app for calls to set_time, etc.
    self.g.app.externalFilesController = ExternalFilesController(self)
    # TODO : Maybe use those yes/no replacement right before actual usage instead of in init. (to allow re-use/switching)
    self.g.app.gui.runAskYesNoDialog = self._returnYes  # override for "revert to file" operation

    # * setup leoBackground to get messages from leo
    try:
        self.g.app.idleTimeManager.start()  # To catch derived file changes
    except:
        print('ERROR with idleTimeManager')

</t>
<t tx="felix.20191126232434.7">def sendLeoBridgePackage(self, p_key=False, p_any=None):
    w_package = {"id": self.currentActionId}
    if p_key:
        w_package[p_key] = p_any  # add [key]?:any
    return(json.dumps(w_package, separators=(',', ':')))  # send as json
    # await self.webSocket.send(json.dumps(w_package, separators=(',', ':')))  # send as json

</t>
<t tx="felix.20191126232434.8">def outputError(self, p_message="Unknown Error"):
    print("ERROR: " + p_message)  # Output to this server's running console
    w_package = {"id": self.currentActionId}
    w_package["error"] = p_message
    return p_message

</t>
<t tx="felix.20191126232434.9">def outputBodyData(self, p_bodyText=""):
    return self.sendLeoBridgePackage("bodyData", p_bodyText)

</t>
<t tx="felix.20191126232435.1">def main():
    '''python script for leo integration via leoBridge'''
    global wsHost, wsPort
    print("Starting LeoBridge... (Launch with -h for help)", flush=True)
    # replace default host address and port if provided as arguments

    try:
        opts, args = getopt.getopt(sys.argv[1:], "ha:p:", ["help", "address=", "port="])
    except getopt.GetoptError:
        print('leobridgeserver.py -a &lt;address&gt; -p &lt;port&gt;')
        print('defaults to localhost on port 32125', flush=True)
        if args:
            print("unused args: " + str(args), flush=True)
        sys.exit(2)
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            print('leobridgeserver.py -a &lt;address&gt; -p &lt;port&gt;')
            print('defaults to localhost on port 32125', flush=True)
            sys.exit()
        elif opt in ("-a", "--address"):
            wsHost = arg
        elif opt in ("-p", "--port"):
            wsPort = arg

    # * start Server
    integController = LeoBridgeIntegController()

    # * This is a basic example loop
    # async def asyncInterval(timeout):
    #     dummyCounter = 0
    #     strTimeout = str(timeout) + ' sec interval'
    #     while True:
    #         await asyncio.sleep(timeout)
    #         dummyCounter = dummyCounter+1
    #         await integController.asyncOutput("{\"interval\":" + str(timeout+dummyCounter) + "}")  # as number
    #         print(strTimeout)

    async def leoBridgeServer(websocket, path):
        try:
            integController.initConnection(websocket)
            await websocket.send(integController.sendLeoBridgePackage())  # * Start by sending empty as 'ok'
            integController.logSignon()
            async for w_message in websocket:
                w_param = json.loads(w_message)
                if w_param and w_param['action']:
                    # print("action:" + w_param['action'])
                    # * Storing id of action in global var instead of passing as parameter
                    integController.setActionId(w_param['id'])
                    # ! functions called this way need to accept at least a parameter other than 'self'
                    # ! See : getSelectedNode and getAllGnx
                    # TODO : Block attempts to call functions starting with underscore or reserved
                    answer = getattr(integController, w_param['action'])(w_param['param'])  # Crux
                else:
                    answer = "Error in processCommand"
                    print(answer, flush=True)
                await websocket.send(answer)
        except:
            print("Caught Websocket Disconnect Event", flush=True)
        finally:
            asyncio.get_event_loop().stop()

    localLoop = asyncio.get_event_loop()
    start_server = websockets.serve(leoBridgeServer, wsHost, wsPort)
    # localLoop.create_task(asyncInterval(5)) # Starts a test loop of async communication
    localLoop.run_until_complete(start_server)
    print("LeoBridge started at " + wsHost + " on port: " + str(wsPort) + " [ctrl+c] to break", flush=True)
    localLoop.run_forever()
    print("Stopping leobridge server", flush=True)


</t>
<t tx="felix.20191127000344.1">def movePNodeDown(self, p_ap):
    '''Move a node DOWN, don't select it if possible'''
    return self.outlineCommand("moveOutlineDown", p_ap, True)

</t>
<t tx="felix.20191127000419.1">def movePNodeLeft(self, p_ap):
    '''Move a node LEFT, don't select it if possible'''
    return self.outlineCommand("moveOutlineLeft", p_ap, True)

</t>
<t tx="felix.20191127000420.1">def movePNodeRight(self, p_ap):
    '''Move a node RIGHT, don't select it if possible'''
    return self.outlineCommand("moveOutlineRight", p_ap, True)

</t>
<t tx="felix.20191127000420.2">def movePNodeUp(self, p_ap):
    '''Move a node UP, don't select it if possible'''
    return self.outlineCommand("moveOutlineUp", p_ap, True)

</t>
<t tx="felix.20191127001506.1">def insertPNode(self, p_ap):
    '''Insert a node at given node, then select it once created, and finally return it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_bunch = self.commander.undoer.beforeInsertNode(w_p)
            w_newNode = w_p.insertAfter()
            w_newNode.setDirty()
            self.commander.undoer.afterInsertNode(w_newNode, 'Insert Node', w_bunch)
            self.commander.selectPosition(w_newNode)
            return self.outputPNode(self.commander.p)  # in both cases, return selected node
        else:
            return self.outputError("Error in insertPNode no w_p node found")  # default empty
    else:
        return self.outputError("Error in insertPNode no param p_ap")

</t>
<t tx="felix.20191127001506.2">def promotePNode(self, p_ap):
    '''Promote a node, don't select it if possible'''
    return self.outlineCommand("promote", p_ap, True)

</t>
<t tx="felix.20191127001506.3">def demotePNode(self, p_ap):
    '''Demote a node, don't select it if possible'''
    return self.outlineCommand("demote", p_ap, True)

</t>
<t tx="felix.20191127002548.1">def deletePNode(self, p_ap):
    '''Delete a node, don't select it. Try to keep selection, then return the selected node that remains'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            if w_p == self.commander.p:
                self.commander.deleteOutline()  # already on this node, so delete it
            else:
                oldPosition = self.commander.p  # not same node, save position to possibly return to
                self.commander.selectPosition(w_p)
                self.commander.deleteOutline()
                if self.commander.positionExists(oldPosition):
                    self.commander.selectPosition(oldPosition)  # select if old position still valid
                else:
                    oldPosition._childIndex = oldPosition._childIndex-1
                    # Try again with childIndex
                    if self.commander.positionExists(oldPosition):
                        self.commander.selectPosition(oldPosition)  # additional try with lowered childIndex
            return self.outputPNode(self.commander.p)  # in both cases, return selected node
        else:
            return self.outputError("Error in deletePNode no w_p node found")  # default empty
    else:
        return self.outputError("Error in deletePNode no param p_ap")

</t>
<t tx="felix.20191127004619.1">def copyPNode(self, p_ap):
    '''Copy a node, don't select it'''
    return self.outlineCommand("copyOutline", p_ap, True)

</t>
<t tx="felix.20191127004620.1">def cutPNode(self, p_ap):
    '''Cut a node, don't select it'''
    return self.outlineCommand("cutOutline", p_ap, True)

</t>
<t tx="felix.20191127004621.1">def markPNode(self, p_ap):
    '''Mark a node, don't select it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_p.setMarked()
            return self.outputPNode(self.commander.p)  # return selected node when done (not w_p)
        else:
            return self.outputError("Error in markPNode no w_p node found")
    else:
        return self.outputError("Error in markPNode no param p_ap")

</t>
<t tx="felix.20191127235913.1">def unmarkPNode(self, p_ap):
    '''Unmark a node, don't select it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_p.clearMarked()
            return self.outputPNode(self.commander.p)  # return selected node when done (not w_p)
        else:
            return self.outputError("Error in unmarkPNode no w_p node found")
    else:
        return self.outputError("Error in unmarkPNode no param p_ap")

</t>
<t tx="felix.20191128000818.1"></t>
<t tx="felix.20191128001054.1"></t>
<t tx="felix.20191128002414.1">import leo.core.leoBridge as leoBridge
import leo.core.leoNodes as leoNodes
import asyncio
import websockets
import sys
import getopt
import time
import json

</t>
<t tx="felix.20191128002417.1"># server defaults
wsHost = "localhost"
wsPort = 32125


</t>
<t tx="felix.20191128003151.1"></t>
<t tx="felix.20191128003648.1"></t>
<t tx="felix.20191128004456.1">def setActionId(self, p_id):
    self.currentActionId = p_id

</t>
<t tx="felix.20191130211048.1">def pastePNode(self, p_ap):
    '''Paste a node, don't select it if possible'''
    return self.outlineCommand("pasteOutline", p_ap, True)

</t>
<t tx="felix.20191130211048.2">def pasteAsClonePNode(self, p_ap):
    '''Paste as clone, don't select it if possible'''
    return self.outlineCommand("pasteOutlineRetainingClones", p_ap, True)

</t>
<t tx="felix.20191201194046.1">def getAllGnx(self, p_paramUnused):
    '''Get gnx array from all unique nodes'''
    w_all_gnx = [p.v.gnx for p in self.commander.all_unique_positions(copy=False)]
    return self.sendLeoBridgePackage("allGnx", w_all_gnx)

</t>
<t tx="felix.20191216195906.1">def findPNodeFromGnx(self, p_gnx):
    '''Return first p node with this gnx or false'''
    for p in self.commander.all_unique_positions():
        if p.v.gnx == p_gnx:
            return p
    return False

</t>
<t tx="felix.20191231184412.1">def sortChildrenPNode(self, p_ap):
    '''Sort children of a node, don't select it if possible'''
    return self.outlineCommand("sortChildren", p_ap, True)

</t>
<t tx="felix.20191231184412.2">def sortSiblingsPNode(self, p_ap):
    '''Sort siblings of a node, don't select it if possible'''
    return self.outlineCommand("sortSiblings", p_ap, True)

</t>
<t tx="felix.20191231201748.1">def hoistPNode(self, p_ap):
    '''Select and Hoist a node'''
    return self.outlineCommand("hoist", p_ap)  # Don't try to re-select node

</t>
<t tx="felix.20191231201749.1">def deHoist(self, p_paramUnused):
    '''De-Hoist'''
    self.commander.dehoist()
    return self.outputPNode(self.commander.p)  # in any case, return selected node

</t>
<t tx="felix.20191231203545.1">def clonePNode(self, p_ap):
    '''Clone a node, return it if it was also the current selection, otherwise try not to select it'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            if w_p == self.commander.p:
                return self.outlineCommand("clone", p_ap, False)
            else:
                return self.outlineCommand("clone", p_ap, True)
        else:
            return self.outputError("Error in clonePNode function, no w_p node found")  # default empty
    else:
        return self.outputError("Error in clonePNode function, no param p_ap")

</t>
<t tx="felix.20191231203711.1">def undo(self, p_paramUnused):
    '''Undo last un-doable operation'''
    if self.commander.undoer.canUndo():
        self.commander.undoer.undo()
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="felix.20191231214801.1">def executeScript(self, p_package):
    '''Select a node and run its script'''
    if 'node' in p_package:
        w_ap = p_package['node']
        w_p = self.ap_to_p(w_ap)
        if w_p:
            self.commander.selectPosition(w_p)
            w_script = ""
            if 'text' in p_package:
                w_script = str(p_package['text'])
            if w_script and not w_script.isspace():
                # * Mimic getScript !!
                try:
                    # Remove extra leading whitespace so the user may execute indented code.
                    w_script = self.g.removeExtraLws(w_script, self.commander.tab_width)
                    w_script = self.g.extractExecutableString(self.commander, w_p, w_script)
                    w_validScript = self.g.composeScript(self.commander, w_p, w_script,
                                                         forcePythonSentinels=True,
                                                         useSentinels=True)
                    self.commander.executeScript(script=w_validScript)
                except Exception as e:
                    self.g.trace('Error while executing script')
                    print('Error while executing script')
                    print(str(e))
            else:
                self.commander.executeScript()
            return self.outputPNode(self.commander.p)  # in both cases, return selected node
        else:
            return self.outputError("Error in run no w_p node found")  # default empty
    else:
        return self.outputError("Error in run no param p_ap")

</t>
<t tx="felix.20200103204811.1">def redo(self, p_paramUnused):
    '''Undo last un-doable operation'''
    if self.commander.undoer.canRedo():
        self.commander.undoer.redo()
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
<t tx="felix.20200105173826.1">def outlineCommand(self, p_command, p_ap, p_keepSelection=False):
    '''Generic call to an outline operation (p_command) for specific p-node (p_ap), with possibility of trying to preserve the current selection (p_keepSelection)'''
    if p_ap:
        w_p = self.ap_to_p(p_ap)
        if w_p:
            w_func = getattr(self.commander, p_command)
            if w_p == self.commander.p:
                w_func()
            else:
                oldPosition = self.commander.p  # not same node, save position to possibly return to
                self.commander.selectPosition(w_p)
                w_func()
                if p_keepSelection and self.commander.positionExists(oldPosition):
                    self.commander.selectPosition(oldPosition)  # select if old position still valid
            return self.outputPNode(self.commander.p)  # in both cases, return selected node
        else:
            return self.outputError("Error in " + p_command + " no w_p node found")  # default empty
    else:
        return self.outputError("Error in " + p_command + " no param p_ap")

</t>
<t tx="felix.20200120224033.1">def insertNamedPNode(self, p_package):
    '''Insert a node at given node, set its headline, select it and finally return it'''
    w_newHeadline = p_package['text']
    w_ap = p_package['node']
    if w_ap:
        w_p = self.ap_to_p(w_ap)
        if w_p:
            w_u = self.commander.undoer.beforeInsertNode(w_p)
            w_newNode = w_p.insertAfter()
            # set this node's new headline
            w_newNode.h = w_newHeadline
            w_newNode.setDirty()
            self.commander.undoer.afterInsertNode(w_newNode, 'Insert Node', w_u)
            self.commander.selectPosition(w_newNode)
            return self.outputPNode(self.commander.p)  # in any case, return selected node
        else:
            return self.outputError("Error in insertNamedPNode no w_p node found")  # default empty
    else:
        return self.outputError("Error in insertNamedPNode no param w_ap")

</t>
<t tx="felix.20200211202929.1">def initConnection(self, p_webSocket):
    self.webSocket = p_webSocket
    self.loop = asyncio.get_event_loop()

</t>
<t tx="felix.20200213195413.1">async def asyncOutput(self, p_json):
    '''Output json string to the websocket'''
    if self.webSocket:
        await self.webSocket.send(p_json)
    else:
        print("websocket not ready yet")

</t>
<t tx="felix.20200216160305.1">def saveFile(self, p_package):
    '''Saves the leo file. New or dirty derived files are rewritten'''
    if self.commander:
        try:
            if "text" in p_package:
                self.commander.save(fileName=p_package['text'])
            else:
                self.commander.save()
        except Exception as e:
            self.g.trace('Error while saving')
            print("Error while saving")
            print(str(e))

    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200219222712.1">def es(self, * args, **keys):
    '''Output to the Log Pane'''
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
        'nodeLink': None,
    }
    d = self.g.doKeywordArgs(keys, d)
    s = self.g.translateArgs(args, d)
    w_package = {"async": "log", "log": s}
    self.sendAsyncOutput(w_package)

</t>
<t tx="felix.20200219224515.1">def logSignon(self):
    '''Simulate the Initial Leo Log Entry'''
    if self.loop:
        self.g.app.computeSignon()
        self.g.es(str(self.g.app.signon))
        self.g.es(str(self.g.app.signon1))
    else:
        print('no loop in logSignon')

</t>
<t tx="felix.20200301235235.1">def refreshFromDiskPNode(self, p_ap):
    '''Refresh from Disk, don't select it if possible'''
    return self.outlineCommand("refreshFromDisk", p_ap, True)

</t>
<t tx="felix.20200302204251.1">class IdleTimeManager:
    """
    A singleton class to manage idle-time handling. This class handles all
    details of running code at idle time, including running 'idle' hooks.

    Any code can call g.app.idleTimeManager.add_callback(callback) to cause
    the callback to be called at idle time forever.
    """
    # TODO : REVISE/REPLACE WITH OWN SYSTEM

    def __init__(self, g):
        """Ctor for IdleTimeManager class."""
        self.g = g
        self.callback_list = []
        self.timer = None
        self.on_idle_count = 0

    @others

</t>
<t tx="felix.20200302204251.2">def add_callback(self, callback):
    """Add a callback to be called at every idle time."""
    self.callback_list.append(callback)

</t>
<t tx="felix.20200302204251.3">def on_idle(self, timer):
    """IdleTimeManager: Run all idle-time callbacks."""
    if not self.g.app:
        return
    if self.g.app.killed:
        return
    if not self.g.app.pluginsController:
        self.g.trace('No g.app.pluginsController', self.g.callers())
        timer.stop()
        return  # For debugger.
    self.on_idle_count += 1
    # Handle the registered callbacks.
    # print("list length : ", len(self.callback_list))
    for callback in self.callback_list:
        try:
            callback()
        except Exception:
            self.g.es_exception()
            self.g.es_print(f"removing callback: {callback}")
            self.callback_list.remove(callback)
    # Handle idle-time hooks.
    self.g.app.pluginsController.on_idle()

</t>
<t tx="felix.20200302204251.4">def start(self):
    """Start the idle-time timer."""
    self.timer = self.g.IdleTime(
        self.on_idle,
        delay=500,  # Milliseconds
        tag='IdleTimeManager.on_idle')
    if self.timer:
        self.timer.start()

</t>
<t tx="felix.20200302205810.1">class ExternalFilesController:
    '''EFC Modified from Leo's sources'''

    @others

</t>
<t tx="felix.20200302205810.2">def __init__(self, integController):
    '''Ctor for ExternalFiles class.'''
    self.on_idle_count = 0
    self.integController = integController
    self.checksum_d = {}
    # Keys are full paths, values are file checksums.
    self.enabled_d = {}
    # For efc.on_idle.
    # Keys are commanders.
    # Values are cached @bool check-for-changed-external-file settings.
    self.has_changed_d = {}
    # Keys are commanders. Values are boolean.
    # Used only to limit traces.
    self.unchecked_commanders = []
    # Copy of g.app.commanders()
    self.unchecked_files = []
    # Copy of self file. Only one files is checked at idle time.
    self._time_d = {}
    # Keys are full paths, values are modification times.
    # DO NOT alter directly, use set_time(path) and
    # get_time(path), see set_time() for notes.
    self.yesno_all_time = 0  # previous yes/no to all answer, time of answer
    self.yesno_all_answer = None  # answer, 'yes-all', or 'no-all'

    self.infoMessage = None  # if yesAll/noAll forced, then just show info message after idle_check_commander
    # False or "detected", "refreshed" or "ignored"

    self.integController.g.app.idleTimeManager.add_callback(self.on_idle)

    self.waitingForAnswer = False
    self.lastPNode = None  # last p node that was asked for if not set to "AllYes\AllNo"
    self.lastCommander = None

</t>
<t tx="felix.20200302205810.21"></t>
<t tx="felix.20200302205810.22">def ask(self, c, path, p=None):
    '''
    Ask user whether to overwrite an @&lt;file&gt; tree.
    Return True if the user agrees.
    '''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["defaultReloadIgnore"].lower()
        if not bool('none' in w_check_config):
            if bool('yes' in w_check_config):
                self.infoMessage = "refreshed"
                return True
            else:
                self.infoMessage = "ignored"
                return False
    # let original function resolve

    if self.yesno_all_time + 3 &gt;= time.time() and self.yesno_all_answer:
        self.yesno_all_time = time.time()  # Still reloading?  Extend time.
        # if yesAll/noAll forced, then just show info message
        w_yesno_all_bool = bool('yes' in self.yesno_all_answer.lower())

        return w_yesno_all_bool
    if not p:
        where = 'the outline node'
    else:
        where = p.h

    _is_leo = path.endswith(('.leo', '.db'))

    if _is_leo:
        s = '\n'.join([
            f'{self.integController.g.splitLongFileName(path)} has changed outside Leo.',
            'Overwrite it?'
        ])
    else:
        s = '\n'.join([
            f'{self.integController.g.splitLongFileName(path)} has changed outside Leo.',
            f"Reload {where} in Leo?",
        ])

    w_package = {"async": "ask", "ask": 'Overwrite the version in Leo?',
                 "message": s, "yes_all": not _is_leo, "no_all": not _is_leo}

    self.integController.sendAsyncOutput(w_package)
    self.waitingForAnswer = True
    return False
    # result = self.integController.g.app.gui.runAskYesNoDialog(c, 'Overwrite the version in Leo?', s,
    # yes_all=not _is_leo, no_all=not _is_leo)

    # if result and "-all" in result.lower():
    # self.yesno_all_time = time.time()
    # self.yesno_all_answer = result.lower()

    # return bool(result and 'yes' in result.lower())

</t>
<t tx="felix.20200302205810.23">def checksum(self, path):
    '''Return the checksum of the file at the given path.'''
    import hashlib
    return hashlib.md5(open(path, 'rb').read()).hexdigest()

</t>
<t tx="felix.20200302205810.25">def get_mtime(self, path):
    '''Return the modification time for the path.'''
    return self.integController.g.os_path_getmtime(self.integController.g.os_path_realpath(path))

</t>
<t tx="felix.20200302205810.26">def get_time(self, path):
    '''
    return timestamp for path

    see set_time() for notes
    '''
    return self._time_d.get(self.integController.g.os_path_realpath(path))

</t>
<t tx="felix.20200302205810.27">def has_changed(self, c, path):
    '''Return True if p's external file has changed outside of Leo.'''
    if not self.integController.g.os_path_exists(path):
        return False
    if self.integController.g.os_path_isdir(path):
        return False
    #
    # First, check the modification times.
    old_time = self.get_time(path)
    new_time = self.get_mtime(path)
    if not old_time:
        # Initialize.
        self.set_time(path, new_time)
        self.checksum_d[path] = self.checksum(path)
        return False
    if old_time == new_time:
        return False
    #
    # Check the checksums *only* if the mod times don't match.
    old_sum = self.checksum_d.get(path)
    new_sum = self.checksum(path)
    if new_sum == old_sum:
        # The modtime changed, but it's contents didn't.
        # Update the time, so we don't keep checking the checksums.
        # Return False so we don't prompt the user for an update.
        self.set_time(path, new_time)
        return False
    # The file has really changed.
    assert old_time, path
    # #208: external change overwrite protection only works once.
    # If the Leo version is changed (dirtied) again,
    # overwrite will occur without warning.
    # self.set_time(path, new_time)
    # self.checksum_d[path] = new_sum
    return True

</t>
<t tx="felix.20200302205810.28">def is_enabled(self, c):
    '''Return the cached @bool check_for_changed_external_file setting.'''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["checkForChangeExternalFiles"].lower()
        if bool('check' in w_check_config):
            return True
        if bool('ignore' in w_check_config):
            return False
    # let original function resolve
    d = self.enabled_d
    val = d.get(c)
    if val is None:
        val = c.config.getBool('check-for-changed-external-files', default=False)
        d[c] = val
    return val

</t>
<t tx="felix.20200302205810.29">def join(self, s1, s2):
    '''Return s1 + ' ' + s2'''
    return f"{s1} {s2}"

</t>
<t tx="felix.20200302205810.30">def set_time(self, path, new_time=None):
    '''
    Implements c.setTimeStamp.

    Update the timestamp for path.

    NOTE: file paths with symbolic links occur with and without those links
    resolved depending on the code call path.  This inconsistency is
    probably not Leo's fault but an underlying Python issue.
    Hence the need to call realpath() here.
    '''

    # print("called set_time for " + str(path))

    t = new_time or self.get_mtime(path)
    self._time_d[self.integController.g.os_path_realpath(path)] = t

</t>
<t tx="felix.20200302205810.31">def warn(self, c, path, p):
    '''
    Warn that an @asis or @nosent node has been changed externally.

    There is *no way* to update the tree automatically.
    '''
    # check with leoInteg's config first
    if self.integController.leoIntegConfig:
        w_check_config = self.integController.leoIntegConfig["defaultReloadIgnore"].lower()

        if w_check_config != "none":
            # if not 'none' then do not warn, just infoMessage 'warn' at most
            if not self.infoMessage:
                self.infoMessage = "warn"
            return

    # let original function resolve
    if self.integController.g.unitTesting or c not in self.integController.g.app.commanders():
        return
    if not p:
        self.integController.g.trace('NO P')
        return

    s = '\n'.join([
        '%s has changed outside Leo.\n' % self.integController.g.splitLongFileName(path),
        'Leo can not update this file automatically.\n',
        'This file was created from %s.\n' % p.h,
        'Warning: refresh-from-disk will destroy all children.'
    ])

    w_package = {"async": "warn", "warn": 'External file changed', "message": s}

    self.integController.sendAsyncOutput(w_package)
    self.waitingForAnswer = True

</t>
<t tx="felix.20200302205810.7">def on_idle(self):
    '''
    Check for changed open-with files and all external files in commanders
    for which @bool check_for_changed_external_file is True.
    '''
    # Fix for flushing the terminal console to traverse
    # python through node.js when using start server in leoInteg
    sys.stdout.flush()

    if not self.integController.g.app or self.integController.g.app.killed:
        return
    if self.waitingForAnswer:
        return

    self.on_idle_count += 1

    if self.unchecked_commanders:
        # Check the next commander for which
        # @bool check_for_changed_external_file is True.
        c = self.unchecked_commanders.pop()
        self.lastCommander = c
        self.idle_check_commander(c)
    else:
        # Add all commanders for which
        # @bool check_for_changed_external_file is True.
        self.unchecked_commanders = [
            z for z in self.integController.g.app.commanders() if self.is_enabled(z)
        ]

</t>
<t tx="felix.20200302205810.8">def idle_check_commander(self, c):
    '''
    Check all external files corresponding to @&lt;file&gt; nodes in c for
    changes.
    '''
    # #1100: always scan the entire file for @&lt;file&gt; nodes.
    # #1134: Nested @&lt;file&gt; nodes are no longer valid, but this will do no harm.

    self.infoMessage = None  # reset infoMessage
    # False or "detected", "refreshed" or "ignored"

    for p in c.all_unique_positions():
        if self.waitingForAnswer:
            break
        if p.isAnyAtFileNode():
            self.idle_check_at_file_node(c, p)

    # if yesAll/noAll forced, then just show info message
    if self.infoMessage:
        w_package = {"async": "info", "message": self.infoMessage}
        self.integController.sendAsyncOutput(w_package)

</t>
<t tx="felix.20200302205810.9">def idle_check_at_file_node(self, c, p):
    '''Check the @&lt;file&gt; node at p for external changes.'''
    trace = False
    # Matt, set this to True, but only for the file that interests you.\
    # trace = p.h == '@file unregister-leo.leox'
    path = self.integController.g.fullPath(c, p)
    has_changed = self.has_changed(c, path)
    if trace:
        self.integController.g.trace('changed', has_changed, p.h)
    if has_changed:
        self.lastPNode = p  # can be set here because its the same process for ask/warn
        if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
            # Fix #1081: issue a warning.
            self.warn(c, path, p=p)
        elif self.ask(c, path, p=p):
            self.lastCommander.selectPosition(self.lastPNode)
            c.refreshFromDisk()

        # Always update the path &amp; time to prevent future warnings.
        self.set_time(path)
        self.checksum_d[path] = self.checksum(path)

</t>
<t tx="felix.20200303214235.1">async def _asyncIdleLoop(self, p_seconds, p_fn):
    while True:
        await asyncio.sleep(p_seconds)
        p_fn(self)

</t>
<t tx="felix.20200304220844.1">def askResult(self, p_result):
    '''Got the result to an asked question/warning from vscode'''
    self.g.app.externalFilesController.integResult(p_result)
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200304221925.1">def integResult(self, p_result):
    '''Received result from vsCode'''
    # Got the result to an asked question/warning from vscode
    if not self.waitingForAnswer:
        print("ERROR: Received Result but no Asked Dialog")
        return
    # check if p_resultwas from a warn (ok) or an ask ('yes','yes-all','no','no-all')
    # act accordingly

    path = self.integController.g.fullPath(self.lastCommander, self.lastPNode)

    # 1- if ok, unblock 'warn'
    # 2- if no, unblock 'ask'
    # ------------------------------------------ Nothing special to do

    # 3- if noAll, set noAll, and unblock 'ask'
    if p_result and "-all" in p_result.lower():
        self.yesno_all_time = time.time()
        self.yesno_all_answer = p_result.lower()
    # ------------------------------------------ Also covers setting yesAll in #5

    # 4- if yes, REFRESH self.lastPNode, and unblock 'ask'
    # 5- if yesAll,REFRESH self.lastPNode, set yesAll, and unblock 'ask'
    if bool(p_result and 'yes' in p_result.lower()):
        self.lastCommander.selectPosition(self.lastPNode)
        self.lastCommander.refreshFromDisk()

    # Always update the path &amp; time to prevent future warnings for this PNode.
    self.set_time(path)
    self.checksum_d[path] = self.checksum(path)

    self.waitingForAnswer = False  # unblock
    self.idle_check_commander(self.lastCommander)  # unblock: run the loop as if timer had hit

</t>
<t tx="felix.20200304224909.1">def sendAsyncOutput(self, p_package):
    if "async" not in p_package:
        print('[sendAsyncOutput] Error async member missing in package parameter' + json.dumps(p_package, separators=(',', ':')))
        return
    if self.loop:
        self.loop.create_task(self.asyncOutput(json.dumps(p_package, separators=(',', ':'))))
    else:
        print('[sendAsyncOutput] Error loop not ready' + json.dumps(p_package, separators=(',', ':')))

</t>
<t tx="felix.20200308145948.1"># Some methods are called in the usual (non-leoBridge without 'efc') save process.
# Those may called by the 'save' function, like check_overwrite,
# or by any other functions from the instance of leo.core.leoBridge that's running.

</t>
<t tx="felix.20200308150821.1">def shut_down(self):
    return

</t>
<t tx="felix.20200308150842.1">def destroy_frame(self, f):
    return

</t>
<t tx="felix.20200308150848.1">def check_overwrite(self, c, fn):
    # print("check_overwrite!! ")
    return True

</t>
<t tx="felix.20200308150856.1">def open_with(self, c, d):
    return

</t>
<t tx="felix.20200312231358.1">def applyConfig(self, p_config):
    '''Got leoInteg's config from vscode'''
    self.leoIntegConfig = p_config
    return self.sendLeoBridgePackage()  # Just send empty as 'ok'

</t>
<t tx="felix.20200329000454.1">def contractAll(self, p_paramUnused):
    '''(Collapse) Contract All'''
    self.commander.contractAllHeadlines()
    return self.outputPNode(self.commander.p)  # return selected node when done

</t>
</tnodes>
</leo_file>
